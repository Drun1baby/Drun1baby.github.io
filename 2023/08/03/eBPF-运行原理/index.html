<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Drunkbaby">
    
    <title>
        
            eBPF 运行原理 |
        
        Drunkbaby&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="https://raw.githubusercontent.com/Drun1baby/CVE_Pentest/main/%E5%8F%8B%E9%93%BEimages/favicon.png">
    
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/regular.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/solid.min.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/font/css/brands.min.css">
    
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"drun1baby.github.io","root":"/","language":"zh-CN","path":"search.xml"}
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":true},"style":{"primary_color":"#0066cc","logo":"https://raw.githubusercontent.com/Drun1baby/CVE_Pentest/main/%E5%8F%8B%E9%93%BEimages/logo.png","favicon":"https://raw.githubusercontent.com/Drun1baby/CVE_Pentest/main/%E5%8F%8B%E9%93%BEimages/favicon.png","avatar":"https://raw.githubusercontent.com/Drun1baby/CVE_Pentest/main/%E5%8F%8B%E9%93%BEimages/favicon.png","font_size":"15px","font_family":null,"hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"header_transparent":true,"background_img":"/images/bg.svg","description":"且将新火试新茶，诗酒趁年华","font_color":null,"hitokoto":false},"scroll":{"progress_bar":true,"percent":false}},"local_search":{"enable":true,"preload":true},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"default"},"side_tools":{},"pjax":{"enable":true},"lazyload":{"enable":false},"comment":{"enable":true,"use":"valine","valine":{"enable":true,"appid":"9Ky0YY6Ij33nFC4KZ2VcGh9k-MdYXbMMI","appkey":"qqN77H4k2Hxhg7ZJ88Lf0xxM","placeholder":"just go go","server_urls":"https://9Ky0YY6I.api.lncldglobal.com","background":"/images/comment_bg.png","count":true},"gitalk":{"github_id":"Drun1baby","github_admins":null,"repository":"gitalk-restore","client_id":"e5b5e5c0ba918eb3d3c4","client_secret":"a0ac0e6f2078095bce9291f42acd13b67e059dff","proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"post":{"author_label":{"enable":true,"auto":true,"custom_label_list":["Trainee","Engineer","Architect"]},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"version":"3.7.3"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Drunkbaby's Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>


<main class="page-container border-box">

    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="https://raw.githubusercontent.com/Drun1baby/CVE_Pentest/main/%E5%8F%8B%E9%93%BEimages/logo.png">
                </a>
            
            <a class="site-name border-box" href="/">
               Drunkbaby&#39;s Blog
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">

                

                    <div class="fade-in-down-animation">
    <div class="post-page-container border-box">

        <div class="article-content-container border-box">

            <div class="article-title">
                <span class="title-hover-animation">eBPF 运行原理</span>
            </div>

            
                <div class="article-header border-box">
                    
                        <div class="avatar-box border-box">
                            <img src="https://raw.githubusercontent.com/Drun1baby/CVE_Pentest/main/%E5%8F%8B%E9%93%BEimages/favicon.png">
                        </div>
                    
                    <div class="info-box">
                        <div class="author">
                            <span class="name">Drunkbaby</span>
                            
                                <span class="author-label">Lv6</span>
                            
                        </div>
                        <div class="meta-info border-box">
                            

<div class="article-meta-info-container border-box post">
    <div class="article-meta-info border-box">
        


        
            <span class="meta-info-item article-create-date">
                <i class="icon fa-solid fa-calendar-check"></i>&nbsp;
                <span class="pc">2023-08-03 22:48:30</span>
                <span class="mobile">2023-08-03 22:48</span>
            </span>

            <span class="meta-info-item article-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="pc">2023-08-06 14:03:01</span>
            </span>
        

        
            <span class="meta-info-item article-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul>
                    
                            <li class="category-item">
                                
                                <a href="/categories/eBPF/">eBPF</a>
                            </li>
                        
                    
                </ul>
            </span>
        

        
            <span class="article-tag meta-info-item border-box">
                <i class="icon fas fa-tags"></i>&nbsp;
                <ul>
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/eBPF/">eBPF</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item article-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>6.5k 字</span>
            </span>
        
        
            <span class="meta-info-item article-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>25 分钟</span>
            </span>
        
        
            <span class="meta-info-item article-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content keep-markdown-body">
                

                <p>eBPF 运行原理，eBPF 学习（二）</p>
<span id="more"></span>

<h1 id="eBPF-运行原理篇"><a href="#eBPF-运行原理篇" class="headerlink" title="eBPF 运行原理篇"></a>eBPF 运行原理篇</h1><h2 id="eBPF-虚拟机是如何工作的"><a href="#eBPF-虚拟机是如何工作的" class="headerlink" title="eBPF 虚拟机是如何工作的"></a>eBPF 虚拟机是如何工作的</h2><h3 id="eBPF-的五个模块"><a href="#eBPF-的五个模块" class="headerlink" title="eBPF 的五个模块"></a>eBPF 的五个模块</h3><p>eBPF 是一个运行在内核中的虚拟机，很多人在初次接触它时，会把它跟系统虚拟化（比如 kvm）中的虚拟机弄混。其实，虽然都被称为“虚拟机”，系统虚拟化和 eBPF 虚拟机还是有着本质不同的。</p>
<p>系统虚拟化基于 x86 或 arm64 等通用指令集，这些指令集足以完成完整计算机的所有功能。而为了确保在内核中安全地执行，eBPF 只提供了非常有限的指令集。这些指令集可用于完成一部分内核的功能，但却远不足以模拟完整的计算机。为了更高效地与内核进行交互，eBPF 指令还有意采用了 C 调用约定，其提供的辅助函数可以在 C 语言中直接调用，极大地方便了 eBPF 程序的开发。</p>
<p>如下图（图片来自 BPF Internals）所示，eBPF 在内核中的运行时主要由 5 个模块组成：</p>
<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/RunningeBPF.png" class>

<ul>
<li>第一个模块是  <strong>eBPF 辅助函数</strong>。它提供了一系列用于 eBPF 程序与内核其他模块进行交互的函数。这些函数并不是任意一个 eBPF 程序都可以调用的，具体可用的函数集由 BPF 程序类型决定。</li>
<li>第二个模块是  <strong>eBPF 验证器</strong>。它用于确保 eBPF 程序的安全。验证器会将待执行的指令创建为一个有向无环图（DAG），确保程序中不包含不可达指令；接着再模拟指令的执行过程，确保不会执行无效指令。</li>
<li>第三个模块是由  <strong>11 个 64 位寄存器、一个程序计数器和一个 512 字节的栈组成的存储模块</strong>。这个模块用于控制 eBPF 程序的执行。其中，R0 寄存器用于存储函数调用和 eBPF 程序的返回值，这意味着函数调用最多只能有一个返回值；R1-R5 寄存器用于函数调用的参数，因此函数调用的参数最多不能超过 5 个；而 R10 则是一个只读寄存器，用于从栈中读取数据。</li>
<li>第四个模块是即时编译器，它将 eBPF 字节码编译成本地机器指令，以便更高效地在内核中执行。</li>
<li>第五个模块是  BPF 映射（map），它用于提供大块的存储。这些存储可被用户空间程序用来进行访问，进而控制 eBPF 程序的运行状态。</li>
</ul>
<p>关于 BPF 辅助函数和 BPF 映射的具体内容我会放在后续的文章里面详细编写，现在我们先来看看 BPF 指令的具体格式，以及它是如何加载到内核中，又是何时运行的。</p>
<h3 id="BPF-指令是什么样的"><a href="#BPF-指令是什么样的" class="headerlink" title="BPF 指令是什么样的"></a>BPF 指令是什么样的</h3><p>用上一讲的 Hello World 作为例子，一起看下 BPF 指令到底是什么样子的。</p>
<p>它的逻辑其实很简单，先调用    bpf_trace_printk  输出一个 “Hello, World!” 字符串，然后就返回成功了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">  bpf_trace_printk(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们通过 BCC 的 Python 库，加载并运行了这个 eBPF 程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># This is a Hello World example of BPF.</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># load BPF program</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;hello.c&quot;</span>)</span><br><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world&quot;</span>)</span><br><span class="line">b.trace_print()</span><br></pre></td></tr></table></figure>

<p>在终端中运行下面的命令，就可以启动这个 eBPF 程序（注意， BCC 帮你完成了编译和加载的过程）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 hello.py</span><br></pre></td></tr></table></figure>

<p>接下来我们使用一个新的工具 bpftool，用它可以查看 eBPF 程序的运行状态。</p>
<p>首先，打开一个新的终端，执行下面的命令，查询系统中正在运行的 eBPF 程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftool prog list</span><br><span class="line"></span><br><span class="line">579: kprobe  name hello_world  tag 38dd440716c4900f  gpl</span><br><span class="line">        loaded_at 2023-08-06T09:01:22+0800  uid 0</span><br><span class="line">        xlated 104B  jited 70B  memlock 4096B</span><br><span class="line">        btf_id 8</span><br></pre></td></tr></table></figure>

<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/bpftoolList.png" class>

<p>输出中，579 是这个 eBPF 程序的编号，kprobe 是程序的类型，而 hello_world 是程序的名字。</p>
<p>有了 eBPF 程序编号之后，执行下面的命令就可以导出这个 eBPF 程序的指令（注意把 579 替换成你查询到的编号）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftool prog dump xlated <span class="built_in">id</span> 579</span><br></pre></td></tr></table></figure>

<p>这里有个小坑，需要自己手动编译 libelf-dev 的源码，具体见 <a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/Withdraw_end/article/details/132127777">https://blog.csdn.net/Withdraw_end/article/details/132127777<i class="fas fa-external-link-alt"></i></a> </p>
<p>输出结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> * ctx)</span>:</span><br><span class="line">; <span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">   0: <span class="params">(b7)</span> r1 = <span class="number">33</span></span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">   <span class="number">1</span>: (<span class="number">6b</span>) *(u16 *)(r10 <span class="number">-4</span>) = r1</span><br><span class="line">   <span class="number">2</span>: (b7) r1 = <span class="number">1684828783</span></span><br><span class="line">   <span class="number">3</span>: (<span class="number">63</span>) *(u32 *)(r10 <span class="number">-8</span>) = r1</span><br><span class="line">   <span class="number">4</span>: (<span class="number">18</span>) r1 = <span class="number">0x57202c6f6c6c6548</span></span><br><span class="line">   <span class="number">6</span>: (<span class="number">7b</span>) *(u64 *)(r10 <span class="number">-16</span>) = r1</span><br><span class="line">   <span class="number">7</span>: (bf) r1 = r10</span><br><span class="line">; </span><br><span class="line">   <span class="number">8</span>: (<span class="number">07</span>) r1 += <span class="number">-16</span></span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">   <span class="number">9</span>: (b7) r2 = <span class="number">14</span></span><br><span class="line">  <span class="number">10</span>: (<span class="number">85</span>) call bpf_trace_printk#<span class="number">-58800</span></span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="number">11</span>: (b7) r0 = <span class="number">0</span></span><br><span class="line">  <span class="number">12</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/outputOrder580.png" class>

<p>其中，分号开头的部分，正是我们前面写的 C 代码，而其他行则是具体的 BPF 指令。具体每一行的 BPF 指令又分为三部分：</p>
<ul>
<li>第一部分，冒号前面的数字 0-12 ，代表 BPF 指令行数；</li>
<li>第二部分，括号中的 16 进制数值，表示 BPF 指令码。它的具体含义你可以参考 IOVisor BPF 文档，比如第 0 行的 0xb7 表示为 64 位寄存器赋值。</li>
<li>第三部分，括号后面的部分，就是 BPF 指令的伪代码。</li>
</ul>
<p>结合前面讲述的各个寄存器的作用，不难理解这些 BPF 指令的含义：</p>
<ul>
<li>第 0-8 行，借助 R10 寄存器从栈中把字符串 “Hello, World!” 读出来，并放入 R1 寄存器中；</li>
<li>第 9 行，向 R2 寄存器写入字符串的长度 14（即代码注释里面的  <code>sizeof(_fmt)</code> ）；</li>
<li>第 10 行，调用 BPF 辅助函数  <code>bpf_trace_printk</code>  输出字符串；</li>
<li>第 11 行，向 R0 寄存器写入 0，表示程序的返回值是 0；</li>
<li>最后一行，程序执行成功退出。</li>
</ul>
<p>总结起来，<strong>这些指令先通过 R1 和 R2 寄存器设置了 <code>bpf_trace_printk</code> 的参数，然后调用 <code>bpf_trace_printk</code> 函数输出字符串，最后再通过 R0 寄存器返回成功</strong>。</p>
<p>实际上我们也可以通过类似的 BPF 指令来开发 eBPF 程序，不过相对于一开始的 C 程序相比，BPF 指令的可读性和维护性明显差得多。所以还是建议使用 C 语言开发 eBPF 程序，而只把 BPF 指令作为排查 eBPF 程序疑难杂症时的参考。</p>
<p>这里，来简单看看  BPF 指令加载后是如何运行的。当这些 BPF 指令加载到内核后， BPF 即时编译器会将其编译成本地机器指令，最后才会执行编译后的机器指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># bpftool prog dump jited id 580</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> * ctx)</span>:</span><br><span class="line">bpf_prog_38dd440716c4900f_hello_world:</span><br><span class="line">; <span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">   0:  nopl   0<span class="title function_">x0</span><span class="params">(%rax,%rax,<span class="number">1</span>)</span></span><br><span class="line">   5:  xchg   %ax,%ax</span><br><span class="line">   7:  push   %rbp</span><br><span class="line">   8:  mov    %rsp,%rbp</span><br><span class="line">   b:  sub    $0x10,%rsp</span><br><span class="line">  12:  mov    $0x21,%edi</span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">  <span class="number">17</span>:  mov    %di,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">1b</span>:  mov    $<span class="number">0x646c726f</span>,%edi</span><br><span class="line">  <span class="number">20</span>:  mov    %edi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">23</span>:  movabs $<span class="number">0x57202c6f6c6c6548</span>,%rdi</span><br><span class="line">  <span class="number">2</span>d:  mov    %rdi,<span class="number">-0x10</span>(%rbp)</span><br><span class="line">  <span class="number">31</span>:  mov    %rbp,%rdi</span><br><span class="line">;</span><br><span class="line">  <span class="number">34</span>:  add    $<span class="number">0xfffffffffffffff0</span>,%rdi</span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">  <span class="number">38</span>:  mov    $<span class="number">0xe</span>,%esi</span><br><span class="line">  <span class="number">3</span>d:  call   <span class="number">0xffffffffd8c7e834</span></span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="number">42</span>:  xor    %eax,%eax</span><br><span class="line">  <span class="number">44</span>:  leave</span><br><span class="line">  <span class="number">45</span>:  ret</span><br></pre></td></tr></table></figure>

<p>这些机器指令的含义跟前面的 BPF 指令是类似的，但具体的指令和寄存器都换成了 x86 的格式。你不需要掌握这些机器指令的具体含义，只要知道查询的具体方法就足够了。这是因为，就像你曾接触过的其他高级语言一样，在实际的 eBPF 使用过程中，并不需要直接使用机器指令，而是 eBPF 虚拟机帮你自动完成了转换。</p>
<h3 id="eBPF-程序是什么时候执行的"><a href="#eBPF-程序是什么时候执行的" class="headerlink" title="eBPF 程序是什么时候执行的"></a>eBPF 程序是什么时候执行的</h3><p>到这里，我想你已经理解了 BPF 指令的具体格式，以及它与  C 源代码之间的对应关系。不过，这个 eBPF 程序到底是什么时候执行的呢？接下来，我们再一起看看 BPF 指令的加载和执行过程。</p>
<p>在上一讲中我提到，BCC 负责了 eBPF 程序的编译和加载过程。因而，要了解 BPF 指令的加载过程，就可以从 BCC 执行 eBPF 程序的过程入手。</p>
<p>那么，怎么才能查看到 BCC 的执行过程呢？那就是跟踪它的系统调用过程。首先，我们打开一个终端，执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -ebpf表示只跟踪bpf系统调用</span></span><br><span class="line">sudo strace -v -f -ebpf python3 ./hello.py</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">bpf(BPF_BTF_LOAD, &#123;</span><br><span class="line">		btf = <span class="string">&quot;\237\353\1\0\30\0\0\0\0\0\0\0\230\2\0\0\230\2\0\0\340\10\0\0\0\0\0\0\0\0\0\2&quot;</span>...,</span><br><span class="line">		btf_log_buf = <span class="literal">NULL</span>,</span><br><span class="line">		btf_size = <span class="number">2960</span>,</span><br><span class="line">		btf_log_size = <span class="number">0</span>,</span><br><span class="line">		btf_log_level = <span class="number">0</span></span><br><span class="line">	&#125;, <span class="number">120</span>) = <span class="number">3</span></span><br><span class="line">	bpf(BPF_PROG_LOAD, &#123;</span><br><span class="line">		prog_type = BPF_PROG_TYPE_KPROBE,</span><br><span class="line">		insn_cnt = <span class="number">13</span>,</span><br><span class="line">		insns = [&#123;</span><br><span class="line">			code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">			dst_reg = BPF_REG_1,</span><br><span class="line">			src_reg = BPF_REG_0,</span><br><span class="line">			off = <span class="number">0</span>,</span><br><span class="line">			imm = <span class="number">0x21</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_STX | BPF_H | BPF_MEM,</span><br><span class="line">			dst_reg = BPF_REG_10,</span><br><span class="line">			src_reg = BPF_REG_1,</span><br><span class="line">			off = <span class="number">-4</span>,</span><br><span class="line">			imm = <span class="number">0</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">			dst_reg = BPF_REG_1,</span><br><span class="line">			src_reg = BPF_REG_0,</span><br><span class="line">			off = <span class="number">0</span>,</span><br><span class="line">			imm = <span class="number">0x646c726f</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_STX | BPF_W | BPF_MEM,</span><br><span class="line">			dst_reg = BPF_REG_10,</span><br><span class="line">			src_reg = BPF_REG_1,</span><br><span class="line">			off = <span class="number">-8</span>,</span><br><span class="line">			imm = <span class="number">0</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_LD | BPF_DW | BPF_IMM,</span><br><span class="line">			dst_reg = BPF_REG_1,</span><br><span class="line">			src_reg = BPF_REG_0,</span><br><span class="line">			off = <span class="number">0</span>,</span><br><span class="line">			imm = <span class="number">0x6c6c6548</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_LD | BPF_W | BPF_IMM,</span><br><span class="line">			dst_reg = BPF_REG_0,</span><br><span class="line">			src_reg = BPF_REG_0,</span><br><span class="line">			off = <span class="number">0</span>,</span><br><span class="line">			imm = <span class="number">0x57202c6f</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_STX | BPF_DW | BPF_MEM,</span><br><span class="line">			dst_reg = BPF_REG_10,</span><br><span class="line">			src_reg = BPF_REG_1,</span><br><span class="line">			off = <span class="number">-16</span>,</span><br><span class="line">			imm = <span class="number">0</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_ALU64 | BPF_X | BPF_MOV,</span><br><span class="line">			dst_reg = BPF_REG_1,</span><br><span class="line">			src_reg = BPF_REG_10,</span><br><span class="line">			off = <span class="number">0</span>,</span><br><span class="line">			imm = <span class="number">0</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_ALU64 | BPF_K | BPF_ADD,</span><br><span class="line">			dst_reg = BPF_REG_1,</span><br><span class="line">			src_reg = BPF_REG_0,</span><br><span class="line">			off = <span class="number">0</span>,</span><br><span class="line">			imm = <span class="number">0xfffffff0</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">			dst_reg = BPF_REG_2,</span><br><span class="line">			src_reg = BPF_REG_0,</span><br><span class="line">			off = <span class="number">0</span>,</span><br><span class="line">			imm = <span class="number">0xe</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_JMP | BPF_K | BPF_CALL,</span><br><span class="line">			dst_reg = BPF_REG_0,</span><br><span class="line">			src_reg = BPF_REG_0,</span><br><span class="line">			off = <span class="number">0</span>,</span><br><span class="line">			imm = <span class="number">0x6</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">			dst_reg = BPF_REG_0,</span><br><span class="line">			src_reg = BPF_REG_0,</span><br><span class="line">			off = <span class="number">0</span>,</span><br><span class="line">			imm = <span class="number">0</span></span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			code = BPF_JMP | BPF_K | BPF_EXIT,</span><br><span class="line">			dst_reg = BPF_REG_0,</span><br><span class="line">			src_reg = BPF_REG_0,</span><br><span class="line">			off = <span class="number">0</span>,</span><br><span class="line">			imm = <span class="number">0</span></span><br><span class="line">		&#125;],</span><br><span class="line">		license = <span class="string">&quot;GPL&quot;</span>,</span><br><span class="line">		log_level = <span class="number">0</span>,</span><br><span class="line">		log_size = <span class="number">0</span>,</span><br><span class="line">		log_buf = <span class="literal">NULL</span>,</span><br><span class="line">		kern_version = KERNEL_VERSION(<span class="number">5</span>, <span class="number">10</span>, <span class="number">70</span>),</span><br><span class="line">		prog_flags = <span class="number">0</span>,</span><br><span class="line">		prog_name = <span class="string">&quot;hello_world&quot;</span>,</span><br><span class="line">		prog_ifindex = <span class="number">0</span>,</span><br><span class="line">		expected_attach_type = BPF_CGROUP_INET_INGRESS,</span><br><span class="line">		prog_btf_fd = <span class="number">3</span>,</span><br><span class="line">		func_info_rec_size = <span class="number">8</span>,</span><br><span class="line">		func_info = <span class="number">0x1ad3af0</span>,</span><br><span class="line">		func_info_cnt = <span class="number">1</span>,</span><br><span class="line">		line_info_rec_size = <span class="number">16</span>,</span><br><span class="line">		line_info = <span class="number">0x1ac4690</span>,</span><br><span class="line">		line_info_cnt = <span class="number">5</span>,</span><br><span class="line">		attach_btf_id = <span class="number">0</span>,</span><br><span class="line">		attach_prog_fd = <span class="number">0</span></span><br><span class="line">	&#125;, <span class="number">120</span>) = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/straceHelloPY.png" class>

<p>这些参数看起来很复杂，但实际上，如果你查询 bpf 系统调用的格式（执行 man bpf 命令），就可以发现，它实际上只需要三个参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bpf(int cmd, union bpf_attr *attr, unsigned int size);</span><br></pre></td></tr></table></figure>

<p>对应前面的 strace 输出结果，这三个参数的具体含义如下。</p>
<ul>
<li>第一个参数是 BPF_PROG_LOAD ， 表示加载 BPF 程序。</li>
<li>第二个参数是 bpf_attr 类型的结构体，表示 BPF 程序的属性。其中，有几个需要你留意的参数，比如：<ul>
<li><code>prog_type</code> 表示 BPF 程序的类型，这儿是 <code>BPF_PROG_TYPE_KPROBE</code> ，跟我们 Python 代码中的 <code>attach_kprobe</code> 一致；</li>
<li><code>insn_cnt (instructions count)</code> 表示指令条数；insns (instructions) 包含了具体的每一条指令，这儿的 13 条指令跟我们前面 <code>bpftool prog dump</code> 的结果是一致的（具体的指令格式，你可以参考内核中 bpf_insn 的定义）；</li>
<li><code>prog_name</code> 则表示 BPF 程序的名字，即 <code>hello_world</code> 。</li>
</ul>
</li>
<li>第三个参数 120 表示属性的大小。</li>
</ul>
<p>到这里，我们已经了解了 bpf 系统调用的基本格式。对于  bpf  系统调用在内核中的实现原理，你并不需要详细了解。我们只要知道它的具体功能，就可以掌握 eBPF 的核心原理了。当然，如果你对它的实现方法有兴趣的话，可以参考内核源码 <code>kernel/bpf/syscall.c</code> 中<code> SYSCALL_DEFINE3</code> 的实现。</p>
<p>BPF 程序加载到内核后，并不会立刻执行，而是基于它的基本原理来的</p>
<blockquote>
<p>eBPF 程序并不像常规的线程那样，启动后就一直运行在那里，它需要事件触发后才会执行。这些事件包括系统调用、内核跟踪点、内核函数和用户态函数的调用退出、网络事件，等等。</p>
</blockquote>
<p>对于我们的 Hello World 来说，由于调用了 <code>attach_kprobe</code> 函数，很明显，这是一个内核跟踪事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>所以，除了把 eBPF 程序加载到内核之外，还需要把加载后的程序跟具体的内核函数调用事件进行绑定。在 eBPF 的实现中，诸如内核跟踪（kprobe）、用户跟踪（uprobe）等的事件绑定，都是通过  <code>perf_event_open()</code>  来完成的。</p>
<p>为什么这么说呢？我们再用  <code>strace</code>  来确认一下。把前面  <code>strace</code>  命令中的  <code>-ebpf</code>  参数去掉，重新执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo strace -v -f python3 ./hello.py</span><br></pre></td></tr></table></figure>

<p>忽略无关的输出后，会发现如下的系统调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">/* 1) 加载BPF程序 */</span><br><span class="line">bpf(BPF_PROG_LOAD,...) = 4</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* 2）查询事件类型 */</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/bus/event_source/devices/kprobe/type&quot;</span>, O_RDONLY) = 5</span><br><span class="line"><span class="built_in">read</span>(5, <span class="string">&quot;6\n&quot;</span>, 4096)                    = 2</span><br><span class="line">close(5)                                = 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* 3）创建性能监控事件 */</span><br><span class="line">perf_event_open(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">type</span>=0x6 /* PERF_TYPE_??? */,</span><br><span class="line">        size=PERF_ATTR_SIZE_VER7,</span><br><span class="line">        ...</span><br><span class="line">        wakeup_events=1,</span><br><span class="line">        config1=0x7f275d195c50,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    -1,</span><br><span class="line">    0,</span><br><span class="line">    -1,</span><br><span class="line">    PERF_FLAG_FD_CLOEXEC) = 5</span><br><span class="line"></span><br><span class="line">/* 4）绑定 BPF 到 kprobe 事件 */</span><br><span class="line">ioctl(5, PERF_EVENT_IOC_SET_BPF, 4)     = 0</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从输出中，我们可以看出 BPF 与性能事件的绑定过程分为以下几步：</p>
<ul>
<li>首先，借助 bpf 系统调用，加载 BPF 程序，并记住返回的文件描述符；</li>
<li>然后，查询 kprobe 类型的事件编号。BCC 实际上是通过  <code>/sys/bus/event_source/devices/kprobe/type</code> 来查询的；</li>
<li>接着，调用  <code>perf_event_open</code>  创建性能监控事件。比如，事件类型（type 是上一步查询到的 6）、事件的参数（ config1 包含了内核函数 <code>do_sys_openat2</code> ）等；</li>
<li>最后，再通过 <code>ioctl</code> 的 <code>PERF_EVENT_IOC_SET_BPF</code> 命令，将 BPF 程序绑定到性能监控事件。</li>
</ul>
<h3 id="小结-eBPF-虚拟机工作原理"><a href="#小结-eBPF-虚拟机工作原理" class="headerlink" title="小结 eBPF 虚拟机工作原理"></a>小结 eBPF 虚拟机工作原理</h3><p>梳理 eBPF 在内核中的实现原理，并以上一讲的 Hello World 程序为例，借助 bpftool、strace 等工具，观察了 BPF 指令的具体格式。</p>
<p>然后，我们从 BCC 执行 eBPF 程序的过程入手，一起看了 BPF 指令的加载和执行过程。用高级语言开发的 eBPF 程序，需要首先编译为 BPF 字节码（即 BPF 指令），然后借助  bpf  系统调用加载到内核中，最后再通过性能监控等接口，与具体的内核事件进行绑定。这样，内核的性能监控模块才会在内核事件发生时，自动执行我们开发的 eBPF 程序。</p>
<h2 id="eBPF-程序是怎么跟内核进行交互的"><a href="#eBPF-程序是怎么跟内核进行交互的" class="headerlink" title="eBPF 程序是怎么跟内核进行交互的"></a>eBPF 程序是怎么跟内核进行交互的</h2><p>eBPF 程序到底是如何跟内核事件进行绑定的？又该如何跟内核中的其他模块进行交互呢？今天，一起看看 eBPF 程序的编程接口。</p>
<p>如下图（图片来自 brendangregg.com）所示，一个完整的 eBPF 程序通常包含用户态和内核态两部分。其中，用户态负责 eBPF 程序的加载、事件绑定以及 eBPF 程序运行结果的汇总输出；内核态运行在 eBPF 虚拟机中，负责定制和控制系统的运行状态。</p>
<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/CompleteProgram.png" class>

<p>对于用户态程序来说，我想你已经了解，<strong>它们与内核进行交互时必须要通过系统调用来完成</strong>。而对应到 eBPF 程序中，我们最常用到的就是 <a class="link" target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/bpf.2.html">bpf 系统调用<i class="fas fa-external-link-alt"></i></a>。</p>
<p>在命令行中输入 man bpf ，就可以查询到 BPF 系统调用的调用格式（虽然前面已经看过了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf</span><span class="params">(<span class="type">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>BPF 系统调用接受三个参数：</p>
<ul>
<li>第一个，cmd ，代表操作命令，比如上一讲中我们看到的 <code>BPF_PROG_LOAD</code> 就是加载 eBPF 程序；</li>
<li>第二个，attr，代表 <code>bpf_attr</code> 类型的 eBPF 属性指针，不同类型的操作命令需要传入不同的属性参数；</li>
<li>第三个，size ，代表属性的大小。</li>
</ul>
<p>注意，不同版本的内核所支持的 BPF 命令是不同的，具体支持的命令列表可以参考内核头文件 <code>include/uapi/linux/bpf.h</code> 中  <code>bpf_cmd</code> 的定义。比如，v5.13 内核已经支持 36 个 BPF 命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_cmd</span> &#123;</span></span><br><span class="line">  BPF_MAP_CREATE,</span><br><span class="line">  BPF_MAP_LOOKUP_ELEM,</span><br><span class="line">  BPF_MAP_UPDATE_ELEM,</span><br><span class="line">  BPF_MAP_DELETE_ELEM,</span><br><span class="line">  BPF_MAP_GET_NEXT_KEY,</span><br><span class="line">  BPF_PROG_LOAD,</span><br><span class="line">  BPF_OBJ_PIN,</span><br><span class="line">  BPF_OBJ_GET,</span><br><span class="line">  BPF_PROG_ATTACH,</span><br><span class="line">  BPF_PROG_DETACH,</span><br><span class="line">  BPF_PROG_TEST_RUN,</span><br><span class="line">  BPF_PROG_GET_NEXT_ID,</span><br><span class="line">  BPF_MAP_GET_NEXT_ID,</span><br><span class="line">  BPF_PROG_GET_FD_BY_ID,</span><br><span class="line">  BPF_MAP_GET_FD_BY_ID,</span><br><span class="line">  BPF_OBJ_GET_INFO_BY_FD,</span><br><span class="line">  BPF_PROG_QUERY,</span><br><span class="line">  BPF_RAW_TRACEPOINT_OPEN,</span><br><span class="line">  BPF_BTF_LOAD,</span><br><span class="line">  BPF_BTF_GET_FD_BY_ID,</span><br><span class="line">  BPF_TASK_FD_QUERY,</span><br><span class="line">  BPF_MAP_LOOKUP_AND_DELETE_ELEM,</span><br><span class="line">  BPF_MAP_FREEZE,</span><br><span class="line">  BPF_BTF_GET_NEXT_ID,</span><br><span class="line">  BPF_MAP_LOOKUP_BATCH,</span><br><span class="line">  BPF_MAP_LOOKUP_AND_DELETE_BATCH,</span><br><span class="line">  BPF_MAP_UPDATE_BATCH,</span><br><span class="line">  BPF_MAP_DELETE_BATCH,</span><br><span class="line">  BPF_LINK_CREATE,</span><br><span class="line">  BPF_LINK_UPDATE,</span><br><span class="line">  BPF_LINK_GET_FD_BY_ID,</span><br><span class="line">  BPF_LINK_GET_NEXT_ID,</span><br><span class="line">  BPF_ENABLE_STATS,</span><br><span class="line">  BPF_ITER_CREATE,</span><br><span class="line">  BPF_LINK_DETACH,</span><br><span class="line">  BPF_PROG_BIND_MAP,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>命令对应的表格</p>
<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/CompleteProgram.png" class>

<h3 id="BPF-辅助函数"><a href="#BPF-辅助函数" class="headerlink" title="BPF 辅助函数"></a>BPF 辅助函数</h3><p>说完用户态程序的 bpf 系统调用格式，我们再来看看内核态的 eBPF 程序。</p>
<p>eBPF 程序并不能随意调用内核函数，因此，内核定义了一系列的辅助函数，用于 eBPF 程序与内核其他模块进行交互，这一个实现方式其实是通过 eBPF helpers 来做的。</p>
<p>比如，上一讲的 Hello World 示例中使用的 <code>bpf_trace_printk()</code> 就是最常用的一个辅助函数，用于向调试文件系统（<code>/sys/kernel/debug/tracing/trace_pipe</code>）写入调试信息。</p>
<p>这里补充一个知识点：从内核 5.13 版本开始，部分内核函数（如  <code>tcp_slow_start()</code>、<code>tcp_reno_ssthresh()</code>  等）也可以被 BPF 程序直接调用了，具体你可以查看<a class="link" target="_blank" rel="noopener" href="https://lwn.net/Articles/856005/">这个链接<i class="fas fa-external-link-alt"></i></a>。 不过，这些函数只能在 TCP 拥塞控制算法的 BPF 程序中调用，此处不再做过多的介绍。</p>
<p>需要注意的是，并不是所有的辅助函数都可以在 eBPF 程序中随意使用，不同类型的 eBPF 程序所支持的辅助函数是不同的。比如，对于 Hello World 示例这类内核探针（kprobe）类型的 eBPF 程序，你可以在命令行中执行  <code>bpftool feature probe</code> ，来查询当前系统支持的辅助函数列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ bpftool feature probe</span><br><span class="line">...</span><br><span class="line">eBPF helpers supported <span class="keyword">for</span> program <span class="built_in">type</span> kprobe:</span><br><span class="line">  - bpf_map_lookup_elem</span><br><span class="line">  - bpf_map_update_elem</span><br><span class="line">  - bpf_map_delete_elem</span><br><span class="line">  - bpf_probe_read</span><br><span class="line">  - bpf_ktime_get_ns</span><br><span class="line">  - bpf_get_prandom_u32</span><br><span class="line">  - bpf_get_smp_processor_id</span><br><span class="line">  - bpf_tail_call</span><br><span class="line">  - bpf_get_current_pid_tgid</span><br><span class="line">  - bpf_get_current_uid_gid</span><br><span class="line">  - bpf_get_current_comm</span><br><span class="line">  - bpf_perf_event_read</span><br><span class="line">  - bpf_perf_event_output</span><br><span class="line">  - bpf_get_stackid</span><br><span class="line">  - bpf_get_current_task</span><br><span class="line">  - bpf_current_task_under_cgroup</span><br><span class="line">  - bpf_get_numa_node_id</span><br><span class="line">  - bpf_probe_read_str</span><br><span class="line">  - bpf_perf_event_read_value</span><br><span class="line">  - bpf_override_return</span><br><span class="line">  - bpf_get_stack</span><br><span class="line">  - bpf_get_current_cgroup_id</span><br><span class="line">  - bpf_map_push_elem</span><br><span class="line">  - bpf_map_pop_elem</span><br><span class="line">  - bpf_map_peek_elem</span><br><span class="line">  - bpf_send_signal</span><br><span class="line">  - bpf_probe_read_user</span><br><span class="line">  - bpf_probe_read_kernel</span><br><span class="line">  - bpf_probe_read_user_str</span><br><span class="line">  - bpf_probe_read_kernel_str</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于这些辅助函数的详细定义，你可以在命令行中执行  man bpf-helpers ，或者参考内核头文件  <a class="link" target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L1463">bpf.h - include&#x2F;uapi&#x2F;linux&#x2F;bpf.h<i class="fas fa-external-link-alt"></i></a>，来查看它们的详细定义和使用说明。为了方便掌握，我把常用的辅助函数整理成了一个表格，可以在需要时参考：</p>
<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/bpfHelpersExcel.png" class>

<p>这其中，需要你特别注意的是以 <code>bpf_probe_read</code>  开头的一系列函数。在上一讲中已经提到，eBPF 内部的内存空间只有寄存器和栈。所以，要访问其他的内核空间或用户空间地址，就需要借助  <code>bpf_probe_read</code>  这一系列的辅助函数。这些函数会进行安全性检查，并禁止缺页中断的发生。</p>
<p>而在 eBPF 程序需要大块存储时，就不能像常规的内核代码那样去直接分配内存了，而是必须通过 BPF 映射（BPF Map）来完成。接下来，我带你看看 BPF 映射的具体原理。</p>
<h3 id="BPF-映射"><a href="#BPF-映射" class="headerlink" title="BPF 映射"></a>BPF 映射</h3><p>BPF 映射用于提供大块的键值存储，这些存储可被用户空间程序访问，进而获取 eBPF 程序的运行状态。eBPF 程序最多可以访问 64 个不同的 BPF 映射，并且不同的 eBPF 程序也可以通过相同的 BPF 映射来共享它们的状态。下图（图片来自docs.cilium.io）展示了  BPF 映射的基本使用方法。</p>
<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/UsageOfBPFMap.png" class>

<p>在前面的 BPF 系统调用和辅助函数小节中，你也看到，有很多系统调用命令和辅助函数都是用来访问 BPF 映射的。我相信细心的你已经发现了：BPF 辅助函数中并没有 BPF 映射的创建函数，BPF 映射只能通过用户态程序的系统调用来创建。比如，你可以通过下面的示例代码来创建一个 BPF 映射，并返回映射的文件描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> key_size,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> value_size, <span class="type">unsigned</span> <span class="type">int</span> max_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">    .map_type = map_type,</span><br><span class="line">    .key_size = key_size,</span><br><span class="line">    .value_size = value_size,</span><br><span class="line">    .max_entries = max_entries</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中，最关键的是设置映射的类型。内核头文件 <code>include/uapi/linux/bpf.h</code> 中的  <code>bpf_map_type</code> 定义了所有支持的映射类型，你可以使用如下的 bpftool 命令，来查询当前系统支持哪些映射类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ bpftool feature probe | grep map_type</span><br><span class="line">eBPF map_type <span class="built_in">hash</span> is available</span><br><span class="line">eBPF map_type array is available</span><br><span class="line">eBPF map_type prog_array is available</span><br><span class="line">eBPF map_type perf_event_array is available</span><br><span class="line">eBPF map_type percpu_hash is available</span><br><span class="line">eBPF map_type percpu_array is available</span><br><span class="line">eBPF map_type stack_trace is available</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在下面的表格中，整理了几种最常用的映射类型及其功能和使用场景：</p>
<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/UsualMapSecne.png" class>

<p>如果你的 eBPF 程序使用了 BCC 库，你还可以使用预定义的宏来简化 BPF 映射的创建过程。比如，对哈希表映射来说，BCC 定义了  <code>BPF_HASH(name, key_type=u64, leaf_type=u64, size=10240)</code>，因此，你就可以通过下面的几种方法来创建一个哈希表映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认参数 key_type=u64, leaf_type=u64, size=10240</span></span><br><span class="line">BPF_HASH(stats);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义key类型，保持默认 leaf_type=u64, size=10240</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_t</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> c[<span class="number">80</span>];</span><br><span class="line">&#125;;</span><br><span class="line">BPF_HASH(counts, <span class="keyword">struct</span> <span class="type">key_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义所有参数</span></span><br><span class="line">BPF_HASH(cpu_time, <span class="type">uint64_t</span>, <span class="type">uint64_t</span>, <span class="number">4096</span>);</span><br></pre></td></tr></table></figure>

<p>除了创建之外，映射的删除也需要你特别注意。BPF 系统调用中并没有删除映射的命令，这是因为 <strong>BPF 映射会在用户态程序关闭文件描述符的时候自动删除（即close(fd) ）</strong>。 如果你想在程序退出后还保留映射，就需要调用  <code>BPF_OBJ_PIN</code> 命令，将映射挂载到 <code>/sys/fs/bpf</code> 中。</p>
<p>在调试 BPF 映射相关的问题时，你还可以通过 bpftool 来查看或操作映射的具体内容。比如，你可以通过下面这些命令创建、更新、输出以及删除映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个哈希表映射，并挂载到/sys/fs/bpf/stats_map(Key和Value的大小都是2字节)</span></span><br><span class="line">bpftool <span class="built_in">map</span> create /sys/fs/bpf/stats_map type hash key <span class="number">2</span> value <span class="number">2</span> entries <span class="number">8</span> name stats_map</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询系统中的所有映射</span></span><br><span class="line">bpftool <span class="built_in">map</span></span><br><span class="line"><span class="comment">//示例输出</span></span><br><span class="line"><span class="comment">//340: hash  name stats_map  flags 0x0</span></span><br><span class="line"><span class="comment">//        key 2B  value 2B  max_entries 8  memlock 4096B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向哈希表映射中插入数据</span></span><br><span class="line">bpftool <span class="built_in">map</span> update name stats_map key <span class="number">0xc1</span> <span class="number">0xc2</span> value <span class="number">0xa1</span> <span class="number">0xa2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询哈希表映射中的所有数据</span></span><br><span class="line"> </span><br><span class="line">bpftool <span class="built_in">map</span> dump name stats_map</span><br><span class="line"><span class="comment">//示例输出</span></span><br><span class="line"><span class="comment">//key: c1 c2  value: a1 a2</span></span><br><span class="line"><span class="comment">//Found 1 element</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除哈希表映射</span></span><br><span class="line">rm /sys/fs/bpf/stats_map</span><br></pre></td></tr></table></figure>

<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/MapBasicUse.png" class>

<h3 id="BPF-类型格式（BTF）"><a href="#BPF-类型格式（BTF）" class="headerlink" title="BPF 类型格式（BTF）"></a>BPF 类型格式（BTF）</h3><p>了解过 BPF 辅助函数和映射之后，我们再来看一个开发 eBPF 程序时最常碰到的问题：内核数据结构的定义。</p>
<p>在安装 BCC 工具的时候，你可能就注意到了，内核头文件 <code>linux-headers-$(uname -r)</code> 也是必须要安装的一个依赖项。这是因为 BCC 在编译 eBPF 程序时，需要从内核头文件中找到相应的内核数据结构定义。这样，你在调用 <code>bpf_probe_read</code> 时，才能从内存地址中提取到正确的数据类型。</p>
<p>但是，编译时依赖内核头文件也会带来很多问题。主要有这三个方面：</p>
<ul>
<li>首先，在开发 eBPF 程序时，为了获得内核数据结构的定义，就需要引入一大堆的内核头文件；</li>
<li>其次，内核头文件的路径和数据结构定义在不同内核版本中很可能不同。因此，你在升级内核版本时，就会遇到找不到头文件和数据结构定义错误的问题；</li>
<li>最后，在很多生产环境的机器中，出于安全考虑，并不允许安装内核头文件，这时就无法得到内核数据结构的定义。<strong>在程序中重定义数据结构</strong>虽然可以暂时解决这个问题，但也很容易把使用着错误数据结构的 eBPF 程序带入新版本内核中运行。</li>
</ul>
<p>那么，这么多的问题该怎么解决呢？不用担心，BPF 类型格式（BPF Type Format, BTF）的诞生正是为了解决这些问题。</p>
<p>从内核 5.2 开始，只要开启了 <code>CONFIG_DEBUG_INFO_BTF</code>，在编译内核时，内核数据结构的定义就会自动内嵌在内核二进制文件 vmlinux 中。并且，你还可以借助下面的命令，把这些数据结构的定义导出到一个头文件中（通常命名为 <code>vmlinux.h</code>）:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</span><br></pre></td></tr></table></figure>

<p>如下图（图片来自 GRANT SELTZER 博客）所示，有了内核数据结构的定义，你在开发 eBPF 程序时只需要引入一个 <code>vmlinux.h</code> 即可，不用再引入一大堆的内核头文件了。</p>
<img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/vmlinuxH.png" class>

<p>同时，借助 BTF、bpftool 等工具，我们也可以更好地了解 BPF 程序的内部信息，这也会让调试变得更加方便。比如，在查看 BPF 映射的内容时，你可以直接看到结构化的数据，而不只是十六进制数值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bpftool map dump id 386</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>: 0,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;eth0&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;value&quot;</span>: 0,</span><br><span class="line">              <span class="string">&quot;ifindex&quot;</span>: 0,</span><br><span class="line">              <span class="string">&quot;mac&quot;</span>: []</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解决了内核数据结构的定义问题，接下来的问题就是，<strong>如何让 eBPF 程序在内核升级之后，不需要重新编译就可以直接运行</strong>。eBPF 的一次编译到处执行（Compile Once Run Everywhere，简称 CO-RE）项目借助了 BTF 提供的调试信息，再通过下面的两个步骤，使得 eBPF 程序可以适配不同版本的内核：</p>
<ul>
<li>第一，通过对 BPF 代码中的访问偏移量进行重写，解决了不同内核版本中数据结构偏移量不同的问题；</li>
<li>第二，在 libbpf 中预定义不同内核版本中的数据结构的修改，解决了不同内核中数据结构不兼容的问题。</li>
</ul>
<p>BTF 和一次编译到处执行带来了很多的好处，但你也需要注意这一点：它们都要求比较新的内核版本（&gt;&#x3D;5.2），并且需要非常新的发行版（如 Ubuntu 20.10+、RHEL 8.2+ 等）才会默认打开内核配置 <code>CONFIG_DEBUG_INFO_BTF</code>。对于旧版本的内核，虽然它们不会再去内置 BTF 的支持，但开源社区正在尝试通过 BTFHub 等方法，为它们提供 BTF 调试信息。</p>
<h3 id="小结-eBPF-程序是怎么跟进程进行交互的"><a href="#小结-eBPF-程序是怎么跟进程进行交互的" class="headerlink" title="小结 eBPF 程序是怎么跟进程进行交互的"></a>小结 eBPF 程序是怎么跟进程进行交互的</h3><p>一个完整的 eBPF 程序，通常包含用户态和内核态两部分：用户态程序需要通过 BPF 系统调用跟内核进行交互，进而完成 eBPF 程序加载、事件挂载以及映射创建和更新等任务；而在内核态中，eBPF 程序也不能任意调用内核函数，而是需要通过 BPF 辅助函数完成所需的任务。尤其是在访问内存地址的时候，必须要借助  <code>bpf_probe_read</code> 系列函数读取内存数据，以确保内存的安全和高效访问。</p>
<p>在 eBPF 程序需要大块存储时，我们还需要根据应用场景，引入特定类型的 BPF 映射，并借助它向用户空间的程序提供运行状态的数据。</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>极客时间 eBPF 核心技术与实战</p>

            </div>

            
                <div class="post-copyright-info">
                    
<div class="article-copyright-info-container">
    <ul class="copyright-info-content">
        <li class="post-title">
            <span class="type">本文标题</span>：<span class="content">eBPF 运行原理</span>
        </li>
        <li class="post-author">
            <span class="type">本文作者</span>：<span class="content">Drunkbaby</span>
        </li>
        <li class="post-time">
            <span class="type">创建时间</span>：<span class="content">2023-08-03 22:48:30</span>
        </li>
        <li class="post-link">
            <span class="type">本文链接</span>：<span class="content">2023/08/03/eBPF-运行原理/</span>
        </li>
        <li class="post-license">
            <span class="type">版权声明</span>：<span class="content">本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</span>
        </li>
    </ul>
    <div class="copy-copyright-info flex-center tooltip" data-content="复制版权信息" data-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/eBPF/"><i class="icon fas fa-hashtag"></i>eBPF</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                               rel="prev"
                               href="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"
                            >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                                <span class="title flex-center">
                                <span class="post-nav-title-item text-ellipsis">eBPF 程序的触发机制及其应用场景</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                               rel="next"
                               href="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/"
                            >
                            <span class="title flex-center">
                                <span class="post-nav-title-item text-ellipsis">2023 DASCTF 七月赛&amp;0x401 WP</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                                <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                            </a>
                        </div>
                    
                </div>
            

            
                


    <div class="comments-container">
        <div id="comments-anchor"></div>
        <div class="comment-area-title">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        
            .valine-container {

  #vcomments {

    .vwrap {

      border 0.1rem solid var(--text-color-4)

      .vheader {

        .vinput {

          color var(--text-color-3)
          border-color var(--text-color-4)

          &:focus {
            border-bottom 0.1rem dashed var(--primary-color) !important
          }
        }
      }


      .vedit {

        .veditor {
          color var(--text-color-3)
        }

        .vctrl {

          .vicon {

            fill var(--text-color-3)

            &.actived {
              fill var(--primary-color)
            }
          }
        }
      }


      button.vsubmit {
        color var(--text-color-3) !important
        background transparent !important
        border 0.1rem solid var(--text-color-3) !important

        &:hover {
          color var(--primary-color) !important
          border 0.1rem solid var(--primary-color) !important
        }
      }
    }


    .vcount {
      color var(--text-color-3)

      .vnum {
        color var(--text-color-2)
      }
    }


    .vcard {

      .vnick {
        .author {
          margin-left 0.15rem
          padding 0.15rem
          color #fff
          font-weight 450
          font-size 0.9rem
          background -webkit-linear-gradient(45deg, #e3565e, #ee854b, #f6c258, #90c68a, #5fb3b3, #6699cc, #c594c5)
          background linear-gradient(45deg, #e3565e, #ee854b, #f6c258, #90c68a, #5fb3b3, #6699cc, #c594c5)
          border-radius 0.15rem
        }
      }


      .vhead {

        .vnick {
          color var(--primary-color)
        }

        .vsys {
          color var(--text-color-3)
          background var(--background-color-2) !important
        }
      }


      .vcontent {
        P {
          color var(--text-color-3)

          code {
            color var(--code-foreground)
            background var(--code-background)
          }
        }
      }


      .vh {
        border-bottom-color var(--border-color)
      }

      .vquote {
        border-left-color var(--border-color)
      }
    }


    .vcopy {
      color var(--text-color-4)
    }


    .vpage {

      .vmore {
        color var(--text-color-2)
        border 0.1rem solid var(--border-color)
      }
    }
  }
}

        
    </div>





            
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AF%87"><span class="nav-text">eBPF 运行原理篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#eBPF-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="nav-text">eBPF 虚拟机是如何工作的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-%E7%9A%84%E4%BA%94%E4%B8%AA%E6%A8%A1%E5%9D%97"><span class="nav-text">eBPF 的五个模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-%E6%8C%87%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-text">BPF 指令是什么样的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="nav-text">eBPF 程序是什么时候执行的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-eBPF-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">小结 eBPF 虚拟机工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eBPF-%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%9F%E5%86%85%E6%A0%B8%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E7%9A%84"><span class="nav-text">eBPF 程序是怎么跟内核进行交互的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-text">BPF 辅助函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-%E6%98%A0%E5%B0%84"><span class="nav-text">BPF 映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-%E7%B1%BB%E5%9E%8B%E6%A0%BC%E5%BC%8F%EF%BC%88BTF%EF%BC%89"><span class="nav-text">BPF 类型格式（BTF）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-eBPF-%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%9F%E8%BF%9B%E7%A8%8B%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E7%9A%84"><span class="nav-text">小结 eBPF 程序是怎么跟进程进行交互的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ref"><span class="nav-text">Ref</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2021</span>&nbsp;-&nbsp;2024
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Drunkbaby</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.7.3</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">访问人数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-box border-box pv">
                    <span class="item-type border-box">总访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E7%AF%87"><span class="nav-text">eBPF 运行原理篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#eBPF-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="nav-text">eBPF 虚拟机是如何工作的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-%E7%9A%84%E4%BA%94%E4%B8%AA%E6%A8%A1%E5%9D%97"><span class="nav-text">eBPF 的五个模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-%E6%8C%87%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-text">BPF 指令是什么样的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="nav-text">eBPF 程序是什么时候执行的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-eBPF-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">小结 eBPF 虚拟机工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eBPF-%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%9F%E5%86%85%E6%A0%B8%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E7%9A%84"><span class="nav-text">eBPF 程序是怎么跟内核进行交互的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-text">BPF 辅助函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-%E6%98%A0%E5%B0%84"><span class="nav-text">BPF 映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF-%E7%B1%BB%E5%9E%8B%E6%A0%BC%E5%BC%8F%EF%BC%88BTF%EF%BC%89"><span class="nav-text">BPF 类型格式（BTF）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-eBPF-%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%9F%E8%BF%9B%E7%A8%8B%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E7%9A%84"><span class="nav-text">小结 eBPF 程序是怎么跟进程进行交互的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ref"><span class="nav-text">Ref</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/dark-light-toggle.js"></script>




    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/code-block.js"></script>




<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/post-helper.js"></script>
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/libs/anime.min.js"></script>
        
        
            <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/toc.js"></script>
        
    
    
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.7.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>




</body>
</html>
